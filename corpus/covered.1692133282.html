<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 | *   | <span class='executed'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 | *   | <span class='executed'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 | *   | <span class='executed'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 283 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 |     | <span class='unexecuted'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 327 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Extension of {ERC20} that allows token holders to destroy both their own</span>
 11 |     | <span class='neutral'> * tokens and those that they have an allowance for, in a way that can be</span>
 12 |     | <span class='neutral'> * recognized off-chain (via event analysis).</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC20Burnable is Context, ERC20 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from the caller.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * See {ERC20-_burn}.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function burn(uint256 amount) public virtual {</span>
 21 |     | <span class='unexecuted'>        _burn(_msgSender(), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, deducting from the caller&#39;s</span>
 26 |     | <span class='neutral'>     * allowance.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * See {ERC20-_burn} and {ERC20-allowance}.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * Requirements:</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * - the caller must have allowance for ``accounts``&#39;s tokens of at least</span>
 33 |     | <span class='neutral'>     * `amount`.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function burnFrom(address account, uint256 amount) public virtual {</span>
 36 |     | <span class='unexecuted'>        _spendAllowance(account, _msgSender(), amount);</span>
 37 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='neutral'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/EchidnaPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// import &#39;./interfaces/ILimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>// import &#39;./interfaces/ILimitPoolManager.sol&#39;;</span>
   6 |     | <span class='neutral'>// import &#39;./interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>// import &#39;./base/storage/LimitPoolStorage.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./LimitPoolFactory.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./utils/LimitPoolManager.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./test/Token20.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/utils/SafeTransfers.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./utils/RangePoolERC1155.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./base/structs/PoolsharkStructs.sol&#39;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>// Fuzz LimitPool functionality</span>
  19 | *r  | <span class='executed'>contract EchidnaPool {</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    event Address(address a);</span>
  22 |     | <span class='neutral'>    event Price(uint160 price);</span>
  23 |     | <span class='neutral'>    event Prices(uint160 price0, uint160 price1);</span>
  24 |     | <span class='neutral'>    event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);</span>
  25 |     | <span class='neutral'>    event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);</span>
  26 |     | <span class='neutral'>    event LiquidityDelta(int128 liqLowerBefore, int128 liqUpperBefore, int128 liqLowerAfter, int128 liqUperAfter);</span>
  27 |     | <span class='neutral'>    event Amount(uint256 amt);</span>
  28 |     | <span class='neutral'>    event PassedMint();</span>
  29 |     | <span class='neutral'>    event PassedBurn();</span>
  30 |     | <span class='neutral'>    event PositionTicks(int24 lower, int24 upper);</span>
  31 |     | <span class='neutral'>    event BurnTicks(int24 lower, int24 upper, bool positionExists);</span>
  32 |     | <span class='neutral'>    event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);</span>
  33 |     | <span class='neutral'>    event PositionCreated(bool isCreated);</span>
  34 |     | <span class='neutral'>    event liquidityDeltaAfterUndercut(bool zeroForOne, int128 liquidityDeltaBefore, int128 liquidityDeltaAfter);</span>
  35 |     | <span class='neutral'>    event AssertFailTest(string message, uint160 priceAfter, uint160 priceBefore);</span>
  36 |     | <span class='neutral'>    event LiquidityAbsolute(uint128 beforeAbs, uint128 afterAbs);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    LimitPoolFactory private factory;</span>
  39 |     | <span class='neutral'>    address private implementation;</span>
  40 |     | <span class='neutral'>    LimitPoolManager private manager;</span>
  41 |     | <span class='neutral'>    RangePoolERC1155 private rangePool;</span>
  42 |     | <span class='neutral'>    LimitPool private pool;</span>
  43 |     | <span class='neutral'>    Token20 private tokenIn;</span>
  44 |     | <span class='neutral'>    Token20 private tokenOut;</span>
  45 |     | <span class='neutral'>    Position[] private positions;</span>
  46 |     | <span class='neutral'>    int16 tickSpacing;</span>
  47 |     | <span class='neutral'>    uint16 swapFee;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct LiquidityDeltaValues {</span>
  50 |     | <span class='neutral'>        int128 liquidityDeltaLowerBefore;</span>
  51 |     | <span class='neutral'>        int128 liquidityDeltaUpperBefore;</span>
  52 |     | <span class='neutral'>        int128 liquidityDeltaLowerAfter;</span>
  53 |     | <span class='neutral'>        int128 liquidityDeltaUpperAfter;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct PoolValues {</span>
  57 |     | <span class='neutral'>        uint160 price0Before;</span>
  58 |     | <span class='neutral'>        uint128 liquidity0Before;</span>
  59 |     | <span class='neutral'>        uint160 price1Before;</span>
  60 |     | <span class='neutral'>        // uint128 liquidityGlobal1Before;</span>
  61 |     | <span class='neutral'>        uint128 liquidity1Before;</span>
  62 |     | <span class='neutral'>        uint160 price0After;</span>
  63 |     | <span class='neutral'>        uint128 liquidity0After;</span>
  64 |     | <span class='neutral'>        uint160 price1After;</span>
  65 |     | <span class='neutral'>        uint128 liquidity1After;</span>
  66 |     | <span class='neutral'>        // uint128 liquidityGlobal1After;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        uint128 liquidityGlobalBefore;</span>
  69 |     | <span class='neutral'>        uint128 liquidityGlobalAfter;</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        uint128 liquidityAbsoluteUpperBefore;</span>
  72 |     | <span class='neutral'>        uint128 liquidityAbsoluteLowerBefore;</span>
  73 |     | <span class='neutral'>        uint128 liquidityAbsoluteUpperAfter;</span>
  74 |     | <span class='neutral'>        uint128 liquidityAbsoluteLowerAfter;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // int128 liquidityDeltaAtPrice0Before;</span>
  77 |     | <span class='neutral'>        // int128 liquidityDeltaAtPrice1Before;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        // int128 liquidityDeltaAtPrice0After;</span>
  80 |     | <span class='neutral'>        // int128 liquidityDeltaAtPrice1After;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        uint160 price0;</span>
  83 |     | <span class='neutral'>        uint160 price1;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  87 |     | <span class='neutral'>        address sender;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    struct Position {</span>
  91 |     | <span class='neutral'>        address owner;</span>
  92 |     | <span class='neutral'>        int24 lower;</span>
  93 |     | <span class='neutral'>        int24 upper;</span>
  94 |     | <span class='neutral'>        bool zeroForOne;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    struct PoolStructs {</span>
  98 |     | <span class='neutral'>        PoolsharkStructs.LimitTick lower;</span>
  99 |     | <span class='neutral'>        PoolsharkStructs.LimitTick upper;</span>
 100 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool0;</span>
 101 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool1;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    modifier tickPreconditions(int24 lower, int24 upper) {</span>
 105 | *r  | <span class='executed'>        require(lower &lt; upper);</span>
 106 | *r  | <span class='executed'>        require(upper &lt; 887272);</span>
 107 | *r  | <span class='executed'>        require(lower &gt; -887272);</span>
 108 | *r  | <span class='executed'>        require(lower % tickSpacing == 0);</span>
 109 | *r  | <span class='executed'>        require(upper % tickSpacing == 0);</span>
 110 |     | <span class='neutral'>        _;</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='unexecuted'>    constructor() {</span>
 113 |     | <span class='unexecuted'>        manager = new LimitPoolManager();</span>
 114 |     | <span class='unexecuted'>        factory = new LimitPoolFactory(address(manager));</span>
 115 |     | <span class='unexecuted'>        implementation = address(new LimitPool(address(factory)));</span>
 116 |     | <span class='unexecuted'>        rangePool = new RangePoolERC1155(address(factory));</span>
 117 |     | <span class='neutral'>        </span>
 118 |     | <span class='unexecuted'>        manager.enableImplementation(bytes32(0x0), address(implementation), address(rangePool));</span>
 119 |     | <span class='unexecuted'>        tickSpacing = 10;</span>
 120 |     | <span class='neutral'>        // manager.enableTickSpacing(tickSpacing,500);</span>
 121 |     | <span class='unexecuted'>        tokenIn = new Token20(&quot;IN&quot;, &quot;IN&quot;, 18);</span>
 122 |     | <span class='unexecuted'>        tokenOut = new Token20(&quot;OUT&quot;, &quot;OUT&quot;, 18);</span>
 123 |     | <span class='unexecuted'>        (address poolAddr,) = factory.createLimitPool(bytes32(0x0), address(tokenIn), address(tokenOut), 500, 79228162514264337593543950336);</span>
 124 |     | <span class='unexecuted'>        pool = LimitPool(poolAddr);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'></span>
 128 | *   | <span class='executed'>    function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 129 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 130 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 131 | *   | <span class='executed'>        mintAndApprove();</span>
 132 | *   | <span class='executed'>        amount = amount + 1;</span>
 133 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 134 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>        (,poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalBefore,,) = pool.globalState();</span>
 137 | *   | <span class='executed'>        poolValues.price0Before = poolStructs.pool0.price;</span>
 138 | *   | <span class='executed'>        poolValues.liquidity0Before = poolStructs.pool0.liquidity;</span>
 139 | *   | <span class='executed'>        poolValues.price1Before = poolStructs.pool1.price;</span>
 140 | *   | <span class='executed'>        poolValues.liquidity1Before = poolStructs.pool1.liquidity;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        // LiquidityDeltaValues memory values;</span>
 143 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 144 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 147 |     | <span class='neutral'>        // values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 148 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = poolStructs.lower.liquidityAbsolute;</span>
 149 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = poolStructs.upper.liquidityAbsolute;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'></span>
 152 | *   | <span class='executed'>        ILimitPoolStructs.MintLimitParams memory params;</span>
 153 | *   | <span class='executed'>        params.to = msg.sender;</span>
 154 | *   | <span class='executed'>        params.amount = amount;</span>
 155 | *   | <span class='executed'>        params.mintPercent = 0;</span>
 156 | *   | <span class='executed'>        params.lower = lower;</span>
 157 | *   | <span class='executed'>        params.upper = upper;</span>
 158 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 161 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 162 |     | <span class='neutral'>        bool posCreated;</span>
 163 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 164 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
 165 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>        // ACTION </span>
 168 | *r  | <span class='executed'>        pool.mintLimit(params);</span>
 169 | *   | <span class='executed'>        if (posCreated) positions.push(Position(msg.sender, lower, upper, zeroForOne));</span>
 170 |     | <span class='neutral'></span>
 171 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 172 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 175 |     | <span class='neutral'>        // values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 176 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = poolStructs.lower.liquidityAbsolute;</span>
 177 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = poolStructs.upper.liquidityAbsolute;</span>
 178 |     | <span class='neutral'></span>
 179 | *   | <span class='executed'>        (, poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 180 | *   | <span class='executed'>        poolValues.price0After = poolStructs.pool0.price;</span>
 181 | *   | <span class='executed'>        poolValues.liquidity0After = poolStructs.pool0.liquidity;</span>
 182 | *   | <span class='executed'>        poolValues.price1After = poolStructs.pool1.price;</span>
 183 | *   | <span class='executed'>        poolValues.liquidity1After = poolStructs.pool1.liquidity;</span>
 184 | *   | <span class='executed'>        poolValues.price0 = poolStructs.pool0.price;</span>
 185 | *   | <span class='executed'>        poolValues.price1 = poolStructs.pool1.price;</span>
 186 | *   | <span class='executed'>        emit Prices(poolValues.price0, poolValues.price1);</span>
 187 | *   | <span class='executed'>        assert(poolValues.price0 &gt;= poolValues.price1);</span>
 188 | *   | <span class='executed'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // POST CONDITIONS</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>        // TODO: Create an invariant that combines liquidity delta and liquidity absolute</span>
 193 |     | <span class='neutral'>        </span>
 194 |     | <span class='neutral'>        // Ensure that liquidityAbsolute is incremented when not undercutting</span>
 195 | *   | <span class='executed'>        if(zeroForOne){</span>
 196 | *   | <span class='executed'>            if(poolValues.price0After &gt;= poolValues.price0Before){</span>
 197 | *   | <span class='executed'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 198 | *   | <span class='executed'>                assert(poolValues.liquidityAbsoluteUpperAfter &gt;= poolValues.liquidityAbsoluteUpperBefore);</span>
 199 |     | <span class='neutral'>            }</span>
 200 |     | <span class='neutral'>        } else {</span>
 201 | *   | <span class='executed'>            if(poolValues.price1Before &gt;= poolValues.price1After){</span>
 202 | *   | <span class='executed'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 203 | *   | <span class='executed'>                assert(poolValues.liquidityAbsoluteLowerAfter &gt;= poolValues.liquidityAbsoluteLowerBefore);</span>
 204 |     | <span class='neutral'>            }</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'>        // Check that liqudityAbsolute is decremented on undercut</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>        // if(zeroForOne){</span>
 209 |     | <span class='neutral'>        //     if(poolValues.price0After &lt; poolValues.price0Before){</span>
 210 |     | <span class='neutral'>        //         emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 211 |     | <span class='neutral'>        //         assert(poolValues.liquidityAbsoluteUpperAfter &lt; poolValues.liquidityAbsoluteUpperBefore);</span>
 212 |     | <span class='neutral'>        //     }</span>
 213 |     | <span class='neutral'>        // } else {</span>
 214 |     | <span class='neutral'>        //     if(poolValues.price1Before &lt; poolValues.price1After){</span>
 215 |     | <span class='neutral'>        //         emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 216 |     | <span class='neutral'>        //         assert(poolValues.liquidityAbsoluteLowerAfter &lt; poolValues.liquidityAbsoluteLowerBefore);</span>
 217 |     | <span class='neutral'>        //     }</span>
 218 |     | <span class='neutral'>        // }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 221 | *   | <span class='executed'>        assert(poolValues.price0After &gt;= poolValues.price1After);</span>
 222 | *   | <span class='executed'>        if (posCreated) {</span>
 223 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 224 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
 225 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 226 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>        </span>
 229 | *   | <span class='executed'>        emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 230 | *   | <span class='executed'>        emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 231 |     | <span class='neutral'>        // emit LiquidityDelta(values.liquidityDeltaLowerBefore, values.liquidityDeltaUpperBefore, values.liquidityDeltaLowerAfter, values.liquidityDeltaUpperAfter);</span>
 232 |     | <span class='neutral'>        </span>
 233 |     | <span class='neutral'>        // Ensure pool.liquity is incremented when undercutting</span>
 234 | *   | <span class='executed'>        assert(poolValues.liquidityGlobalAfter &gt;= poolValues.liquidityGlobalBefore);</span>
 235 | *   | <span class='executed'>        if (zeroForOne) {</span>
 236 |     | <span class='neutral'>            // Ensure liquidity does not decrease on mint</span>
 237 | *   | <span class='executed'>            if (poolValues.price0After &lt; poolValues.price0Before) {</span>
 238 | *   | <span class='executed'>                emit AssertFailTest(&quot;poolValues.price0After &lt; poolValues.price0Before&quot;, poolValues.price0After, poolValues.price0Before);</span>
 239 | *   | <span class='executed'>                assert(poolValues.liquidity0After &gt; 0);</span>
 240 |     | <span class='neutral'>            }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>            // Doesn&#39;t hold due to insertSingle stashing pool liquidity on tick to save</span>
 243 |     | <span class='neutral'>            // if (posCreated) {</span>
 244 |     | <span class='neutral'>            //     assert(values.liquidityDeltaLowerAfter &gt;= values.liquidityDeltaLowerBefore);</span>
 245 |     | <span class='neutral'>            //     assert(values.liquidityDeltaUpperAfter &lt;= values.liquidityDeltaUpperBefore);</span>
 246 |     | <span class='neutral'>            // }</span>
 247 |     | <span class='neutral'>        }</span>
 248 |     | <span class='neutral'>        else {</span>
 249 |     | <span class='neutral'>            // Ensure pool.liquity is incremented when undercutting</span>
 250 | *   | <span class='executed'>            if (poolValues.price1After &gt; poolValues.price1Before) {</span>
 251 | *   | <span class='executed'>                emit AssertFailTest(&quot;poolValues.price1After &gt; poolValues.price1Before&quot;, poolValues.price1After, poolValues.price1Before);</span>
 252 | *   | <span class='executed'>                assert(poolValues.liquidity1After &gt; 0);</span>
 253 |     | <span class='neutral'>            }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='neutral'>            // if (posCreated) {</span>
 256 |     | <span class='neutral'>            //     assert(values.liquidityDeltaUpperAfter &gt;= values.liquidityDeltaUpperBefore);</span>
 257 |     | <span class='neutral'>            //     assert(values.liquidityDeltaLowerAfter &lt;= values.liquidityDeltaLowerBefore);</span>
 258 |     | <span class='neutral'>            // }</span>
 259 |     | <span class='neutral'>            </span>
 260 |     | <span class='neutral'>        }</span>
 261 |     | <span class='neutral'>    }</span>
 262 |     | <span class='neutral'></span>
 263 | *   | <span class='executed'>    function mintVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
 264 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 265 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 266 | *   | <span class='executed'>        mintAndApprove();</span>
 267 | *   | <span class='executed'>        amount = amount + 1;</span>
 268 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 269 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 270 |     | <span class='neutral'></span>
 271 | *   | <span class='executed'>        (,poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalBefore,,) = pool.globalState();</span>
 272 | *   | <span class='executed'>        poolValues.price0Before = poolStructs.pool0.price;</span>
 273 | *   | <span class='executed'>        poolValues.liquidity0Before = poolStructs.pool0.liquidity;</span>
 274 | *   | <span class='executed'>        poolValues.price1Before = poolStructs.pool1.price;</span>
 275 | *   | <span class='executed'>        poolValues.liquidity1Before = poolStructs.pool1.liquidity;</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='neutral'>        // LiquidityDeltaValues memory values;</span>
 278 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 279 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>        // values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 282 |     | <span class='neutral'>        // values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 283 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = poolStructs.lower.liquidityAbsolute;</span>
 284 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = poolStructs.upper.liquidityAbsolute;</span>
 285 |     | <span class='neutral'></span>
 286 | *   | <span class='executed'>        ILimitPoolStructs.MintLimitParams memory params;</span>
 287 | *   | <span class='executed'>        params.to = msg.sender;</span>
 288 | *   | <span class='executed'>        params.amount = amount;</span>
 289 | *   | <span class='executed'>        params.mintPercent = mintPercent;</span>
 290 | *   | <span class='executed'>        params.lower = lower;</span>
 291 | *   | <span class='executed'>        params.upper = upper;</span>
 292 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 295 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 296 |     | <span class='neutral'>        bool posCreated;</span>
 297 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 298 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
 299 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>        // ACTION </span>
 302 | *r  | <span class='executed'>        pool.mintLimit(params);</span>
 303 | *   | <span class='executed'>        if (posCreated) positions.push(Position(msg.sender, lower, upper, zeroForOne));</span>
 304 |     | <span class='neutral'></span>
 305 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 306 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>        // values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 309 |     | <span class='neutral'>        // values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 310 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = poolStructs.lower.liquidityAbsolute;</span>
 311 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = poolStructs.upper.liquidityAbsolute;</span>
 312 |     | <span class='neutral'></span>
 313 | *   | <span class='executed'>        (, poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 314 | *   | <span class='executed'>        poolValues.price0After = poolStructs.pool0.price;</span>
 315 | *   | <span class='executed'>        poolValues.liquidity0After = poolStructs.pool0.liquidity;</span>
 316 | *   | <span class='executed'>        poolValues.price1After = poolStructs.pool1.price;</span>
 317 | *   | <span class='executed'>        poolValues.liquidity1After = poolStructs.pool1.liquidity;</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        </span>
 320 | *   | <span class='executed'>        poolValues.price0 = poolStructs.pool0.price;</span>
 321 | *   | <span class='executed'>        poolValues.price1 = poolStructs.pool1.price;</span>
 322 | *   | <span class='executed'>        emit Prices(poolValues.price0, poolValues.price1);</span>
 323 | *   | <span class='executed'>        assert(poolValues.price0 &gt;= poolValues.price1);</span>
 324 | *   | <span class='executed'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>        // POST CONDITIONS</span>
 327 |     | <span class='neutral'></span>
 328 | *   | <span class='executed'>        if(zeroForOne){</span>
 329 | *   | <span class='executed'>            if(poolValues.price0After &gt;= poolValues.price0Before){</span>
 330 | *   | <span class='executed'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 331 | *   | <span class='executed'>                assert(poolValues.liquidityAbsoluteUpperAfter &gt; poolValues.liquidityAbsoluteUpperBefore);</span>
 332 |     | <span class='neutral'>            }</span>
 333 |     | <span class='neutral'>        } else {</span>
 334 | *   | <span class='executed'>            if(poolValues.price1Before &gt;= poolValues.price1After){</span>
 335 | *   | <span class='executed'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 336 | *   | <span class='executed'>                assert(poolValues.liquidityAbsoluteLowerAfter &gt; poolValues.liquidityAbsoluteLowerBefore);</span>
 337 |     | <span class='neutral'>            }</span>
 338 |     | <span class='neutral'>        }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 341 | *   | <span class='executed'>        assert(poolValues.price0After &gt;= poolValues.price1After);</span>
 342 | *   | <span class='executed'>        if (posCreated) {</span>
 343 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 344 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
 345 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 346 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'>        </span>
 349 | *   | <span class='executed'>        emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 350 | *   | <span class='executed'>        emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 351 |     | <span class='neutral'>        // emit LiquidityDelta(values.liquidityDeltaLowerBefore, values.liquidityDeltaUpperBefore, values.liquidityDeltaLowerAfter, values.liquidityDeltaUpperAfter);</span>
 352 |     | <span class='neutral'>        </span>
 353 |     | <span class='neutral'>        // Ensure pool.liquity is incremented when undercutting</span>
 354 | *   | <span class='executed'>        assert(poolValues.liquidityGlobalAfter &gt;= poolValues.liquidityGlobalBefore);</span>
 355 | *   | <span class='executed'>        if (zeroForOne) {</span>
 356 |     | <span class='neutral'>            // Ensure liquidity does not decrease on mint</span>
 357 | *   | <span class='executed'>            if (poolValues.price0After &lt; poolValues.price0Before) {</span>
 358 | *   | <span class='executed'>                emit AssertFailTest(&quot;poolValues.price0After &lt; poolValues.price0Before&quot;, poolValues.price0After, poolValues.price0Before);</span>
 359 | *   | <span class='executed'>                assert(poolValues.liquidity0After &gt; 0);</span>
 360 |     | <span class='neutral'>            }</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='neutral'>            // Doesn&#39;t hold due to insertSingle stashing pool liquidity on tick to save</span>
 363 |     | <span class='neutral'>            // if (posCreated) {</span>
 364 |     | <span class='neutral'>            //     assert(values.liquidityDeltaLowerAfter &gt;= values.liquidityDeltaLowerBefore);</span>
 365 |     | <span class='neutral'>            //     assert(values.liquidityDeltaUpperAfter &lt;= values.liquidityDeltaUpperBefore);</span>
 366 |     | <span class='neutral'>            // }</span>
 367 |     | <span class='neutral'>        }</span>
 368 |     | <span class='neutral'>        else {</span>
 369 |     | <span class='neutral'>            // Ensure pool.liquity is incremented when undercutting</span>
 370 | *   | <span class='executed'>            if (poolValues.price1After &gt; poolValues.price1Before) {</span>
 371 | *   | <span class='executed'>                emit AssertFailTest(&quot;poolValues.price1After &gt; poolValues.price1Before&quot;, poolValues.price1After, poolValues.price1Before);</span>
 372 | *   | <span class='executed'>                assert(poolValues.liquidity1After &gt; 0);</span>
 373 |     | <span class='neutral'>            }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>            // if (posCreated) {</span>
 376 |     | <span class='neutral'>            //     assert(values.liquidityDeltaUpperAfter &gt;= values.liquidityDeltaUpperBefore);</span>
 377 |     | <span class='neutral'>            //     assert(values.liquidityDeltaLowerAfter &lt;= values.liquidityDeltaLowerBefore);</span>
 378 |     | <span class='neutral'>            // }</span>
 379 |     | <span class='neutral'>            </span>
 380 |     | <span class='neutral'>        }</span>
 381 |     | <span class='neutral'>    }</span>
 382 |     | <span class='neutral'></span>
 383 | *   | <span class='executed'>    function swap(uint160 priceLimit, uint128 amount, bool exactIn, bool zeroForOne) public {</span>
 384 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 385 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 386 | *   | <span class='executed'>        mintAndApprove();</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>        // TODO: Can do a check for liquidity absolute here probably</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='neutral'>        // ACTION</span>
 391 |     | <span class='neutral'>        ILimitPoolStructs.SwapParams memory params;</span>
 392 | *   | <span class='executed'>        params.to = msg.sender;</span>
 393 | *   | <span class='executed'>        params.priceLimit = priceLimit;</span>
 394 | *   | <span class='executed'>        params.amount = amount;</span>
 395 | *   | <span class='executed'>        params.exactIn = exactIn;</span>
 396 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 397 | *   | <span class='executed'>        params.callbackData = abi.encodePacked(address(this));</span>
 398 |     | <span class='neutral'></span>
 399 | *r  | <span class='executed'>        pool.swap(params);</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>        // POST CONDITIONS</span>
 402 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1,,,) = pool.globalState();</span>
 403 | *   | <span class='executed'>        uint160 price0 = pool0.price;</span>
 404 | *   | <span class='executed'>        uint160 price1 = pool1.price;</span>
 405 | *   | <span class='executed'>        emit Prices(price0, price1);</span>
 406 | *   | <span class='executed'>        assert(price0 &gt;= price1);</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 | *   | <span class='executed'>    function burn(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {</span>
 410 |     | <span class='neutral'>        // PRE CONDITIONS </span>
 411 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 412 | *   | <span class='executed'>        positionIndex = positionIndex % positions.length;</span>
 413 | *   | <span class='executed'>        Position memory pos = positions[positionIndex];</span>
 414 | *r  | <span class='executed'>        require(claimAt &gt;= pos.lower &amp;&amp; claimAt &lt;= pos.upper);</span>
 415 | *r  | <span class='executed'>        require(claimAt % tickSpacing == 0);</span>
 416 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 417 |     | <span class='neutral'></span>
 418 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,) = pool.globalState();</span>
 419 |     | <span class='neutral'></span>
 420 | *   | <span class='executed'>        ILimitPoolStructs.BurnLimitParams memory params;</span>
 421 | *   | <span class='executed'>        params.to = pos.owner;</span>
 422 |     | <span class='neutral'>        // TODO: allow for variable burn percentages</span>
 423 | *   | <span class='executed'>        params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;</span>
 424 | *   | <span class='executed'>        params.lower = pos.lower;</span>
 425 | *   | <span class='executed'>        params.claim = claimAt;</span>
 426 | *   | <span class='executed'>        params.upper = pos.upper;</span>
 427 | *   | <span class='executed'>        params.zeroForOne = pos.zeroForOne;</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='neutral'>        // LiquidityDeltaValues memory values;</span>
 430 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(pos.lower);</span>
 431 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(pos.upper);</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>        // values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 434 |     | <span class='neutral'>        // values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 435 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 436 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 437 |     | <span class='neutral'>        </span>
 438 | *   | <span class='executed'>        emit PositionTicks(pos.lower, pos.upper);</span>
 439 | *r  | <span class='executed'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 440 | *   | <span class='executed'>        emit BurnTicks(lower, upper, positionExists);</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>        // ACTION</span>
 443 | *r  | <span class='executed'>        pool.burnLimit(params);</span>
 444 | *   | <span class='executed'>        if (!positionExists) {</span>
 445 | *   | <span class='executed'>            positions[positionIndex] = positions[positions.length - 1];</span>
 446 | *   | <span class='executed'>            delete positions[positions.length - 1];</span>
 447 |     | <span class='neutral'>        }</span>
 448 |     | <span class='neutral'>        else {</span>
 449 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 450 | *   | <span class='executed'>            positions[positionIndex] = Position(pos.owner, lower, upper, pos.zeroForOne);</span>
 451 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 452 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
 453 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 454 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 455 |     | <span class='neutral'>        }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='neutral'>        // POST CONDITIONS</span>
 458 |     | <span class='neutral'></span>
 459 | *   | <span class='executed'>        (, lowerTick) = pool.ticks(lower);</span>
 460 | *   | <span class='executed'>        (, upperTick) = pool.ticks(upper);</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'>        // values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 463 |     | <span class='neutral'>        // values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 464 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 465 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 466 |     | <span class='neutral'></span>
 467 | *   | <span class='executed'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 468 | *   | <span class='executed'>        uint160 price0 = pool0.price;</span>
 469 | *   | <span class='executed'>        uint160 price1 = pool1.price;</span>
 470 | *   | <span class='executed'>        emit Prices(price0, price1);</span>
 471 | *   | <span class='executed'>        assert(price0 &gt;= price1);</span>
 472 | *   | <span class='executed'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 473 | *   | <span class='executed'>        assert((poolValues.liquidityGlobalAfter &lt;= liquidityGlobalBefore));</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='neutral'>        // TODO: Look into this more</span>
 476 |     | <span class='neutral'>        // emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 477 |     | <span class='neutral'>        // assert(poolValues.liquidityAbsoluteLowerAfter &lt; poolValues.liquidityAbsoluteLowerBefore);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 | *   | <span class='executed'>    function claim(int24 claimAt, uint256 positionIndex) public {</span>
 481 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 482 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 483 | *   | <span class='executed'>        positionIndex = positionIndex % positions.length;</span>
 484 | *   | <span class='executed'>        Position memory pos = positions[positionIndex];</span>
 485 | *   | <span class='executed'>        claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));</span>
 486 | *r  | <span class='executed'>        require(claimAt % tickSpacing == 0);</span>
 487 |     | <span class='neutral'></span>
 488 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 489 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,) = pool.globalState();</span>
 490 |     | <span class='neutral'></span>
 491 | *   | <span class='executed'>        ILimitPoolStructs.BurnLimitParams memory params;</span>
 492 | *   | <span class='executed'>        params.to = pos.owner;</span>
 493 |     | <span class='neutral'>        // TODO: allow for variable burn percentages</span>
 494 | *   | <span class='executed'>        params.burnPercent = 0;</span>
 495 | *   | <span class='executed'>        params.lower = pos.lower;</span>
 496 | *   | <span class='executed'>        params.claim = claimAt;</span>
 497 | *   | <span class='executed'>        params.upper = pos.upper;</span>
 498 | *   | <span class='executed'>        params.zeroForOne = pos.zeroForOne;</span>
 499 |     | <span class='neutral'>        </span>
 500 | *   | <span class='executed'>        emit PositionTicks(pos.lower, pos.upper);</span>
 501 | *   | <span class='executed'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 502 | *   | <span class='executed'>        emit BurnTicks(lower, upper, positionExists);</span>
 503 |     | <span class='neutral'></span>
 504 |     | <span class='neutral'>        // ACTION</span>
 505 | *r  | <span class='executed'>        pool.burnLimit(params);</span>
 506 | *   | <span class='executed'>        if (!positionExists) {</span>
 507 | *   | <span class='executed'>            positions[positionIndex] = positions[positions.length - 1];</span>
 508 | *   | <span class='executed'>            delete positions[positions.length - 1];</span>
 509 |     | <span class='neutral'>        }</span>
 510 |     | <span class='neutral'>        else {</span>
 511 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 512 | *   | <span class='executed'>            positions[positionIndex] = Position(pos.owner, lower, upper, pos.zeroForOne);</span>
 513 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 514 | *   | <span class='executed'>            assert(lower &lt; upper);</span>
 515 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 516 | *   | <span class='executed'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 517 |     | <span class='neutral'>        }</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>        // POST CONDITIONS</span>
 520 | *   | <span class='executed'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 521 | *   | <span class='executed'>        uint160 price0 = pool0.price;</span>
 522 | *   | <span class='executed'>        uint160 price1 = pool1.price;</span>
 523 | *   | <span class='executed'>        emit Prices(price0, price1);</span>
 524 | *   | <span class='executed'>        assert(price0 &gt;= price1);</span>
 525 |     | <span class='neutral'></span>
 526 |     | <span class='neutral'>        // NOTE: INVALID INVARIANTS</span>
 527 |     | <span class='neutral'>        // if(pos.zeroForOne) {</span>
 528 |     | <span class='neutral'>        //     emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);</span>
 529 |     | <span class='neutral'>        //     if (positionExists) {</span>
 530 |     | <span class='neutral'>        //         assert((liquidityGlobal0After == liquidityGlobal0Before));</span>
 531 |     | <span class='neutral'>        //     }</span>
 532 |     | <span class='neutral'>        // }</span>
 533 |     | <span class='neutral'>        // else {</span>
 534 |     | <span class='neutral'>        //     emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);</span>
 535 |     | <span class='neutral'>        //     if (positionExists) {</span>
 536 |     | <span class='neutral'>        //         assert((liquidityGlobal1After == liquidityGlobal1Before));</span>
 537 |     | <span class='neutral'>        //     }</span>
 538 |     | <span class='neutral'>        // }</span>
 539 |     | <span class='neutral'>    }</span>
 540 |     | <span class='neutral'></span>
 541 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
 542 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 543 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 544 | *   | <span class='executed'>        mintAndApprove();</span>
 545 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 546 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,) = pool.globalState();</span>
 547 |     | <span class='neutral'>        // uint160 price0Before = pool0.price;</span>
 548 |     | <span class='neutral'>        // uint160 price1Before = pool1.price;</span>
 549 |     | <span class='neutral'></span>
 550 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 551 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 552 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 553 |     | <span class='neutral'></span>
 554 | *   | <span class='executed'>        values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 555 | *   | <span class='executed'>        values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 556 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 557 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>        // ACTION </span>
 560 | *   | <span class='executed'>        mintVariable(amount, zeroForOne, lower, upper, mintPercent);</span>
 561 | *   | <span class='executed'>        emit PassedMint();</span>
 562 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 563 | *   | <span class='executed'>        emit PassedBurn();</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>        // POST CONDITIONS</span>
 566 | *   | <span class='executed'>        (, lowerTick) = pool.ticks(lower);</span>
 567 | *   | <span class='executed'>        (, upperTick) = pool.ticks(upper);</span>
 568 |     | <span class='neutral'></span>
 569 | *   | <span class='executed'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 570 | *   | <span class='executed'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 571 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 572 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 573 |     | <span class='neutral'>        </span>
 574 | *   | <span class='executed'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 575 | *   | <span class='executed'>        uint160 price0After = pool0.price;</span>
 576 | *   | <span class='executed'>        uint160 price1After = pool1.price;</span>
 577 | *   | <span class='executed'>        emit Prices(price0After, price1After);</span>
 578 | *   | <span class='executed'>        assert(price0After &gt;= price1After);</span>
 579 | *   | <span class='executed'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 580 | *   | <span class='executed'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 581 |     | <span class='neutral'></span>
 582 | *   | <span class='executed'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 583 | *   | <span class='executed'>        assert(poolValues.liquidityAbsoluteLowerAfter == poolValues.liquidityAbsoluteLowerBefore);</span>
 584 | *   | <span class='executed'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 585 | *   | <span class='executed'>        assert(poolValues.liquidityAbsoluteUpperAfter == poolValues.liquidityAbsoluteUpperBefore);</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 589 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 590 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 591 | *   | <span class='executed'>        mintAndApprove();</span>
 592 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 593 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,) = pool.globalState();</span>
 594 |     | <span class='neutral'>        // uint160 price0Before = pool0.price;</span>
 595 |     | <span class='neutral'>        // uint160 price1Before = pool1.price;</span>
 596 |     | <span class='neutral'></span>
 597 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 598 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 599 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 600 |     | <span class='neutral'></span>
 601 | *   | <span class='executed'>        values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 602 | *   | <span class='executed'>        values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 603 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 604 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>        // ACTION </span>
 607 | *   | <span class='executed'>        mint(amount, zeroForOne, lower, upper);</span>
 608 | *   | <span class='executed'>        emit PassedMint();</span>
 609 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 610 | *   | <span class='executed'>        emit PassedBurn();</span>
 611 |     | <span class='neutral'></span>
 612 |     | <span class='neutral'>        // POST CONDITIONS</span>
 613 | *   | <span class='executed'>        (, lowerTick) = pool.ticks(lower);</span>
 614 | *   | <span class='executed'>        (, upperTick) = pool.ticks(upper);</span>
 615 |     | <span class='neutral'></span>
 616 | *   | <span class='executed'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 617 | *   | <span class='executed'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 618 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 619 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 620 |     | <span class='neutral'></span>
 621 |     | <span class='neutral'></span>
 622 | *   | <span class='executed'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 623 | *   | <span class='executed'>        uint160 price0After = pool0.price;</span>
 624 | *   | <span class='executed'>        uint160 price1After = pool1.price;</span>
 625 | *   | <span class='executed'>        emit Prices(price0After, price1After);</span>
 626 | *   | <span class='executed'>        assert(price0After &gt;= price1After);</span>
 627 | *   | <span class='executed'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 628 | *   | <span class='executed'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 629 |     | <span class='neutral'></span>
 630 | *   | <span class='executed'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 631 | *   | <span class='executed'>        assert(poolValues.liquidityAbsoluteLowerAfter == poolValues.liquidityAbsoluteLowerBefore);</span>
 632 | *   | <span class='executed'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 633 | *   | <span class='executed'>        assert(poolValues.liquidityAbsoluteUpperAfter == poolValues.liquidityAbsoluteUpperBefore);</span>
 634 |     | <span class='neutral'>    }</span>
 635 |     | <span class='neutral'></span>
 636 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {</span>
 637 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 638 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 639 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 640 | *   | <span class='executed'>        mintAndApprove();</span>
 641 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 642 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,) = pool.globalState();</span>
 643 |     | <span class='neutral'></span>
 644 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 645 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 646 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 647 |     | <span class='neutral'></span>
 648 | *   | <span class='executed'>        values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 649 | *   | <span class='executed'>        values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 650 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 651 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 652 |     | <span class='neutral'></span>
 653 |     | <span class='neutral'>        // ACTION </span>
 654 | *   | <span class='executed'>        mint(amount, zeroForOne, lower, upper);</span>
 655 | *   | <span class='executed'>        emit PassedMint();</span>
 656 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, percent);</span>
 657 | *   | <span class='executed'>        emit PassedBurn();</span>
 658 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 659 |     | <span class='neutral'>        emit PassedBurn();</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='neutral'>        // POST CONDITIONS</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='neutral'>        (, lowerTick) = pool.ticks(lower);</span>
 664 |     | <span class='neutral'>        (, upperTick) = pool.ticks(upper);</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='neutral'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 667 |     | <span class='neutral'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 668 |     | <span class='neutral'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 669 |     | <span class='neutral'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 672 |     | <span class='neutral'>        uint160 price0After = pool0.price;</span>
 673 |     | <span class='neutral'>        uint160 price1After = pool1.price;</span>
 674 |     | <span class='neutral'>        emit Prices(price0After, price1After);</span>
 675 |     | <span class='neutral'>        assert(price0After &gt;= price1After);</span>
 676 |     | <span class='neutral'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 677 |     | <span class='neutral'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 678 |     | <span class='neutral'></span>
 679 |     | <span class='neutral'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 680 |     | <span class='neutral'>        assert(poolValues.liquidityAbsoluteLowerAfter == poolValues.liquidityAbsoluteLowerBefore);</span>
 681 |     | <span class='neutral'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 682 |     | <span class='neutral'>        assert(poolValues.liquidityAbsoluteUpperAfter == poolValues.liquidityAbsoluteUpperBefore);</span>
 683 |     | <span class='neutral'>    }</span>
 684 |     | <span class='neutral'></span>
 685 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
 686 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 687 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 688 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 689 | *   | <span class='executed'>        mintAndApprove();</span>
 690 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 691 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,) = pool.globalState();</span>
 692 |     | <span class='neutral'></span>
 693 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 694 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 695 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 696 |     | <span class='neutral'></span>
 697 | *   | <span class='executed'>        values.liquidityDeltaLowerBefore = lowerTick.liquidityDelta;</span>
 698 | *   | <span class='executed'>        values.liquidityDeltaUpperBefore = upperTick.liquidityDelta;</span>
 699 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 700 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'></span>
 703 |     | <span class='neutral'>        // ACTION </span>
 704 | *   | <span class='executed'>        mintVariable(amount, zeroForOne, lower, upper, mintPercent);</span>
 705 | *   | <span class='executed'>        emit PassedMint();</span>
 706 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, percent);</span>
 707 | *   | <span class='executed'>        emit PassedBurn();</span>
 708 | *   | <span class='executed'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 709 | *   | <span class='executed'>        emit PassedBurn();</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>        // POST CONDITIONS</span>
 712 | *   | <span class='executed'>        (, lowerTick) = pool.ticks(lower);</span>
 713 | *   | <span class='executed'>        (, upperTick) = pool.ticks(upper);</span>
 714 |     | <span class='neutral'></span>
 715 | *   | <span class='executed'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 716 | *   | <span class='executed'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 717 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 718 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 719 |     | <span class='neutral'></span>
 720 | *   | <span class='executed'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,) = pool.globalState();</span>
 721 | *   | <span class='executed'>        uint160 price0After = pool0.price;</span>
 722 | *   | <span class='executed'>        uint160 price1After = pool1.price;</span>
 723 | *   | <span class='executed'>        emit Prices(price0After, price1After);</span>
 724 | *   | <span class='executed'>        assert(price0After &gt;= price1After);</span>
 725 | *   | <span class='executed'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 726 | *   | <span class='executed'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 727 |     | <span class='neutral'></span>
 728 | *   | <span class='executed'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 729 | *   | <span class='executed'>        assert(poolValues.liquidityAbsoluteLowerAfter == poolValues.liquidityAbsoluteLowerBefore);</span>
 730 | *   | <span class='executed'>        emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 731 | *   | <span class='executed'>        assert(poolValues.liquidityAbsoluteUpperAfter == poolValues.liquidityAbsoluteUpperBefore);</span>
 732 |     | <span class='neutral'>    }</span>
 733 |     | <span class='neutral'></span>
 734 | *   | <span class='executed'>    function poolsharkSwapCallback(</span>
 735 |     | <span class='neutral'>        int256 amount0Delta,</span>
 736 |     | <span class='neutral'>    int256 amount1Delta,</span>
 737 |     | <span class='neutral'>        bytes calldata data</span>
 738 | *   | <span class='executed'>    ) external {</span>
 739 | *   | <span class='executed'>        address token0 = LimitPool(pool).token0();</span>
 740 | *   | <span class='executed'>        address token1 = LimitPool(pool).token1();</span>
 741 |     | <span class='neutral'>        // SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));</span>
 742 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 743 | *   | <span class='executed'>            SafeTransfers.transferInto(token0, address(pool), uint256(-amount0Delta));</span>
 744 |     | <span class='neutral'>        } else {</span>
 745 | *   | <span class='executed'>            SafeTransfers.transferInto(token1, address(pool), uint256(-amount1Delta));</span>
 746 |     | <span class='neutral'>        }</span>
 747 |     | <span class='neutral'>    }</span>
 748 |     | <span class='neutral'></span>
 749 | *   | <span class='executed'>    function mintAndApprove() internal {</span>
 750 |     | <span class='neutral'>        // TODO: can make token mints to be in between some range</span>
 751 | *   | <span class='executed'>        tokenIn.mint(msg.sender, 100000000000 ether);</span>
 752 | *   | <span class='executed'>        tokenOut.mint(msg.sender, 100000000000 ether);</span>
 753 | *   | <span class='executed'>        tokenIn.mint(address(this), 100000000000 ether);</span>
 754 | *   | <span class='executed'>        tokenOut.mint(address(this), 100000000000 ether);</span>
 755 | *   | <span class='executed'>        tokenIn.approve(address(pool), type(uint256).max);</span>
 756 | *   | <span class='executed'>        tokenOut.approve(address(pool), type(uint256).max);</span>
 757 |     | <span class='neutral'>    }</span>
 758 |     | <span class='neutral'></span>
 759 | *   | <span class='executed'>    function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {</span>
 760 | *   | <span class='executed'>        return uint128(low + (val % (high-low +1))); </span>
 761 |     | <span class='neutral'>    }</span>
 762 |     | <span class='neutral'></span>
 763 |     | <span class='neutral'>    function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {</span>
 764 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 765 |     | <span class='neutral'>        amount = amount + 1e5 + 1;</span>
 766 |     | <span class='neutral'>        ILimitPoolStructs.Immutables memory immutables = pool.immutables();</span>
 767 |     | <span class='neutral'>        uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);</span>
 768 |     | <span class='neutral'>        uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);</span>
 769 |     | <span class='neutral'></span>
 770 |     | <span class='neutral'>        uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 771 |     | <span class='neutral'>            priceLower,</span>
 772 |     | <span class='neutral'>            priceUpper,</span>
 773 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 774 |     | <span class='neutral'>            zeroForOne ? 0 : uint256(amount),</span>
 775 |     | <span class='neutral'>            zeroForOne ? uint256(amount) : 0</span>
 776 |     | <span class='neutral'>        );</span>
 777 |     | <span class='neutral'></span>
 778 |     | <span class='neutral'>        (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(</span>
 779 |     | <span class='neutral'>            priceLower,</span>
 780 |     | <span class='neutral'>            priceUpper,</span>
 781 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 782 |     | <span class='neutral'>            liquidityMinted,</span>
 783 |     | <span class='neutral'>            true</span>
 784 |     | <span class='neutral'>        );</span>
 785 |     | <span class='neutral'></span>
 786 |     | <span class='neutral'>        if(zeroForOne) {</span>
 787 |     | <span class='neutral'>            emit LiquidityMinted(amount, token0Amount, zeroForOne);</span>
 788 |     | <span class='neutral'>            assert(isEqualWithinPercentage(amount, token0Amount, 100));</span>
 789 |     | <span class='neutral'>            </span>
 790 |     | <span class='neutral'>        }</span>
 791 |     | <span class='neutral'>        else {</span>
 792 |     | <span class='neutral'>            emit LiquidityMinted(amount, token1Amount, zeroForOne);</span>
 793 |     | <span class='neutral'>            assert(isEqualWithinPercentage(amount, token1Amount, 100));</span>
 794 |     | <span class='neutral'>        }</span>
 795 |     | <span class='neutral'></span>
 796 |     | <span class='neutral'>    }</span>
 797 |     | <span class='neutral'></span>
 798 |     | <span class='neutral'>    function isEqualWithinPercentage(uint256 a, uint256 b, uint256 percentage) internal pure returns (bool) {</span>
 799 |     | <span class='neutral'>        uint256 diff = a &gt; b ? a - b : b - a;</span>
 800 |     | <span class='neutral'>        uint256 maxDiff = a * percentage / 10000; // basis points </span>
 801 |     | <span class='neutral'></span>
 802 |     | <span class='neutral'>        return diff &lt;= maxDiff;</span>
 803 |     | <span class='neutral'>    }</span>
 804 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/EchidnaTickMap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;./LimitPoolFactory.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;./utils/LimitPoolManager.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;./test/Token20.sol&#39;;</span>
  9 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
 10 |     | <span class='neutral'>import &#39;./libraries/utils/SafeTransfers.sol&#39;;</span>
 11 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>// Fuzz TickMap functionality</span>
 15 |     | <span class='unexecuted'>contract EchidnaTickMap {</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event TickResult(int24 inputTick, int24 outputTick);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    ILimitPoolStructs.TickMap public tickMap;</span>
 20 |     | <span class='neutral'>    int16 tickSpacing;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>     constructor() {</span>
 23 |     | <span class='unexecuted'>        tickSpacing = 10;</span>
 24 |     | <span class='unexecuted'>        TickMap.set(tickMap, ConstantProduct.minTick(tickSpacing), tickSpacing);</span>
 25 |     | <span class='unexecuted'>        TickMap.set(tickMap, ConstantProduct.maxTick(tickSpacing), tickSpacing);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function setTickTwice(int24 tick) public {</span>
 30 |     | <span class='unexecuted'>        require(tick &gt; ConstantProduct.minTick(tickSpacing));</span>
 31 |     | <span class='unexecuted'>        require(tick &lt; ConstantProduct.maxTick(tickSpacing));</span>
 32 |     | <span class='unexecuted'>        TickMap.set(tickMap, tick, tickSpacing);</span>
 33 |     | <span class='unexecuted'>        TickMap.set(tickMap, tick, tickSpacing);</span>
 34 |     | <span class='unexecuted'>        bool exists = TickMap.get(tickMap, tick, tickSpacing);</span>
 35 |     | <span class='unexecuted'>        assert(exists);</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function setThenUnsets(int24 tick) public {</span>
 39 |     | <span class='unexecuted'>        require(tick &gt; ConstantProduct.minTick(tickSpacing));</span>
 40 |     | <span class='unexecuted'>        require(tick &lt; ConstantProduct.maxTick(tickSpacing));</span>
 41 |     | <span class='unexecuted'>        TickMap.set(tickMap, tick, tickSpacing);</span>
 42 |     | <span class='unexecuted'>        TickMap.unset(tickMap, tick, tickSpacing);</span>
 43 |     | <span class='neutral'>        bool exists = TickMap.get(tickMap, tick, tickSpacing);</span>
 44 |     | <span class='neutral'>        assert(!exists);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function setTick(int24 tick) public {</span>
 48 |     | <span class='unexecuted'>        require(tick &gt; ConstantProduct.minTick(tickSpacing));</span>
 49 |     | <span class='unexecuted'>        require(tick &lt; ConstantProduct.maxTick(tickSpacing));</span>
 50 |     | <span class='unexecuted'>        TickMap.set(tickMap, tick, tickSpacing);</span>
 51 |     | <span class='neutral'>        bool exists = TickMap.get(tickMap, tick, tickSpacing);</span>
 52 |     | <span class='neutral'>        assert(exists);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function unsetTick(int24 tick) public {</span>
 56 |     | <span class='unexecuted'>        require(tick &gt; ConstantProduct.minTick(tickSpacing));</span>
 57 |     | <span class='unexecuted'>        require(tick &lt; ConstantProduct.maxTick(tickSpacing));</span>
 58 |     | <span class='unexecuted'>        TickMap.unset(tickMap, tick, tickSpacing);</span>
 59 |     | <span class='unexecuted'>        bool exists = TickMap.get(tickMap, tick, tickSpacing);</span>
 60 |     | <span class='unexecuted'>        assert(!exists);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function next(int24 tick, bool inclusive) public {</span>
 64 |     | <span class='unexecuted'>        require(tick % tickSpacing == 0);</span>
 65 |     | <span class='unexecuted'>        require(tick % (tickSpacing/2) == 0);</span>
 66 |     | <span class='unexecuted'>        int24 nextTick = TickMap.next(tickMap, tick, tickSpacing, inclusive);</span>
 67 |     | <span class='unexecuted'>        emit TickResult(tick, nextTick);</span>
 68 |     | <span class='neutral'>        // if (inclusive) {</span>
 69 |     | <span class='neutral'>        //     bool exists = TickMap.get(tickMap, tick, tickSpacing);</span>
 70 |     | <span class='neutral'>        //     if (exists) assert(tick == nextTick);</span>
 71 |     | <span class='neutral'>        // }</span>
 72 |     | <span class='unexecuted'>        assert(nextTick &gt;= tick);</span>
 73 |     | <span class='neutral'>    </span>
 74 |     | <span class='neutral'>    }</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='unexecuted'>    function previous(int24 tick, bool inclusive) public {</span>
 77 |     | <span class='unexecuted'>        require(tick % tickSpacing == 0);</span>
 78 |     | <span class='unexecuted'>        require(tick % (tickSpacing/2) == 0);</span>
 79 |     | <span class='unexecuted'>        int24 previousTick = TickMap.previous(tickMap, tick, tickSpacing, inclusive);</span>
 80 |     | <span class='unexecuted'>        emit TickResult(tick, previousTick);</span>
 81 |     | <span class='unexecuted'>        if (inclusive) {</span>
 82 |     | <span class='unexecuted'>            bool exists = TickMap.get(tickMap, tick, tickSpacing);</span>
 83 |     | <span class='unexecuted'>            if (exists) assert(tick == previousTick);</span>
 84 |     | <span class='neutral'>        }</span>
 85 |     | <span class='unexecuted'>        assert(previousTick &lt;= tick);</span>
 86 |     | <span class='neutral'>    }</span>
 87 |     | <span class='neutral'></span>
 88 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/LimitPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/range/IRangePool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./interfaces/IPool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolStorage.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolImmutables.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./base/structs/LimitPoolFactoryStructs.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./utils/LimitPoolErrors.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/pool/SwapCall.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/pool/QuoteCall.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./libraries/range/pool/MintCall.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./libraries/range/pool/BurnCall.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./libraries/limit/pool/MintLimitCall.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./libraries/limit/pool/BurnLimitCall.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  19 |     | <span class='neutral'>import &#39;./libraries/solady/LibClone.sol&#39;;</span>
  20 |     | <span class='neutral'>import &#39;./external/openzeppelin/security/ReentrancyGuard.sol&#39;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>/// @notice Poolshark Limit Pool Implementation</span>
  24 | *   | <span class='executed'>contract LimitPool is</span>
  25 |     | <span class='neutral'>    ILimitPool,</span>
  26 |     | <span class='neutral'>    IRangePool,</span>
  27 |     | <span class='neutral'>    LimitPoolStorage,</span>
  28 |     | <span class='neutral'>    LimitPoolImmutables,</span>
  29 |     | <span class='neutral'>    LimitPoolFactoryStructs,</span>
  30 |     | <span class='neutral'>    ReentrancyGuard</span>
  31 |     | <span class='neutral'>{</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    event SimulateMint(bytes b);</span>
  34 |     | <span class='neutral'>    event SimulateMint(bytes4 b);</span>
  35 |     | <span class='neutral'>    event SimulateMint(bool b);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    modifier ownerOnly() {</span>
  38 |     | <span class='unexecuted'>        _onlyOwner();</span>
  39 |     | <span class='unexecuted'>        _;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    modifier factoryOnly() {</span>
  43 |     | <span class='unexecuted'>        _onlyFactory();</span>
  44 |     | <span class='neutral'>        _;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    modifier canoncialOnly() {</span>
  48 |     | <span class='unexecuted'>        _onlyCanoncialClones();</span>
  49 |     | <span class='neutral'>        _;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    address public immutable original;</span>
  53 |     | <span class='unexecuted'>    address public immutable factory;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    constructor(</span>
  56 |     | <span class='neutral'>        address factory_</span>
  57 |     | <span class='neutral'>    ) {</span>
  58 |     | <span class='unexecuted'>        original = address(this);</span>
  59 |     | <span class='unexecuted'>        factory = factory_;</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function initialize(</span>
  63 |     | <span class='neutral'>        uint160 startPrice</span>
  64 |     | <span class='neutral'>    ) external override </span>
  65 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
  66 |     | <span class='neutral'>        factoryOnly</span>
  67 |     | <span class='neutral'>        canoncialOnly</span>
  68 |     | <span class='neutral'>    {</span>
  69 |     | <span class='neutral'>        // initialize state</span>
  70 |     | <span class='unexecuted'>        globalState = Ticks.initialize(</span>
  71 |     | <span class='unexecuted'>            rangeTickMap,</span>
  72 |     | <span class='unexecuted'>            limitTickMap,</span>
  73 |     | <span class='unexecuted'>            samples,</span>
  74 |     | <span class='neutral'>            globalState,</span>
  75 |     | <span class='unexecuted'>            immutables(),</span>
  76 |     | <span class='unexecuted'>            startPrice</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function mint(</span>
  81 |     | <span class='neutral'>        MintParams memory params</span>
  82 |     | <span class='neutral'>    ) external override</span>
  83 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
  84 |     | <span class='neutral'>        canoncialOnly</span>
  85 |     | <span class='neutral'>    {</span>
  86 |     | <span class='unexecuted'>        MintCache memory cache = MintCache({</span>
  87 |     | <span class='unexecuted'>            state: globalState,</span>
  88 |     | <span class='unexecuted'>            position: positions[params.lower][params.upper],</span>
  89 |     | <span class='unexecuted'>            constants: immutables(),</span>
  90 |     | <span class='unexecuted'>            liquidityMinted: 0</span>
  91 |     | <span class='neutral'>        });</span>
  92 |     | <span class='unexecuted'>        cache = MintCall.perform(params, cache, rangeTickMap, ticks, samples);</span>
  93 |     | <span class='neutral'>        globalState = cache.state; </span>
  94 |     | <span class='neutral'>        positions[params.lower][params.upper] = cache.position;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function burn(</span>
  98 |     | <span class='neutral'>        BurnParams memory params</span>
  99 |     | <span class='neutral'>    ) external override</span>
 100 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 101 |     | <span class='neutral'>        canoncialOnly</span>
 102 |     | <span class='unexecuted'>    {</span>
 103 |     | <span class='unexecuted'>        BurnCache memory cache = BurnCache({</span>
 104 |     | <span class='unexecuted'>            state: globalState,</span>
 105 |     | <span class='unexecuted'>            position: positions[params.lower][params.upper],</span>
 106 |     | <span class='unexecuted'>            constants: immutables(),</span>
 107 |     | <span class='unexecuted'>            amount0: 0,</span>
 108 |     | <span class='neutral'>            amount1: 0,</span>
 109 |     | <span class='neutral'>            tokenBurned: 0</span>
 110 |     | <span class='neutral'>        });</span>
 111 |     | <span class='unexecuted'>        cache = BurnCall.perform(params, cache, rangeTickMap, ticks, samples);</span>
 112 |     | <span class='unexecuted'>        globalState = cache.state;</span>
 113 |     | <span class='unexecuted'>        positions[params.lower][params.upper] = cache.position;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    //limitSwap</span>
 117 |     | <span class='unexecuted'>    function mintLimit(</span>
 118 |     | <span class='neutral'>        MintLimitParams memory params</span>
 119 |     | <span class='neutral'>    ) external override</span>
 120 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 121 |     | <span class='neutral'>        canoncialOnly</span>
 122 |     | <span class='neutral'>    {</span>
 123 |     | <span class='unexecuted'>        MintLimitCache memory cache;</span>
 124 |     | <span class='neutral'>        {</span>
 125 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 126 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='unexecuted'>        cache = MintLimitCall.perform(</span>
 129 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 130 |     | <span class='unexecuted'>            ticks,</span>
 131 |     | <span class='unexecuted'>            samples,</span>
 132 |     | <span class='unexecuted'>            rangeTickMap,</span>
 133 |     | <span class='unexecuted'>            limitTickMap,</span>
 134 |     | <span class='unexecuted'>            globalState,</span>
 135 |     | <span class='unexecuted'>            params,</span>
 136 |     | <span class='unexecuted'>            cache</span>
 137 |     | <span class='neutral'>        );</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        globalState = cache.state;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function getResizedTicksForMint(</span>
 143 |     | <span class='neutral'>        MintLimitParams memory params</span>
 144 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionCreated){</span>
 145 |     | <span class='unexecuted'>        MintLimitCache memory cache;</span>
 146 |     | <span class='neutral'>        {</span>
 147 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 148 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        try MintLimitCall.getResizedTicks(</span>
 152 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 153 |     | <span class='unexecuted'>            ticks,</span>
 154 |     | <span class='unexecuted'>            samples,</span>
 155 |     | <span class='unexecuted'>            rangeTickMap,</span>
 156 |     | <span class='unexecuted'>            limitTickMap,</span>
 157 |     | <span class='unexecuted'>            globalState,</span>
 158 |     | <span class='unexecuted'>            params,</span>
 159 |     | <span class='unexecuted'>            cache</span>
 160 |     | <span class='neutral'>        ) {</span>
 161 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 162 |     | <span class='unexecuted'>            emit SimulateMint(data);</span>
 163 |     | <span class='neutral'>            bytes4 sig;</span>
 164 |     | <span class='neutral'>            assembly {</span>
 165 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 166 |     | <span class='neutral'>            }</span>
 167 |     | <span class='neutral'>            </span>
 168 |     | <span class='neutral'>            // SimulateMint error</span>
 169 |     | <span class='unexecuted'>            if (sig == hex&quot;5cc1f67b&quot;) {</span>
 170 |     | <span class='unexecuted'>                (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 171 |     | <span class='neutral'>            }</span>
 172 |     | <span class='neutral'>            else {</span>
 173 |     | <span class='unexecuted'>                lower = -8388608;</span>
 174 |     | <span class='unexecuted'>                upper = -8388608;</span>
 175 |     | <span class='unexecuted'>                positionCreated = false;</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    function burnLimit(</span>
 181 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 182 |     | <span class='neutral'>    ) external override</span>
 183 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 184 |     | <span class='neutral'>        canoncialOnly</span>
 185 |     | <span class='neutral'>    {</span>
 186 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
 187 |     | <span class='unexecuted'>        BurnLimitCache memory cache = BurnLimitCache({</span>
 188 |     | <span class='neutral'>            state: globalState,</span>
 189 |     | <span class='unexecuted'>            position: params.zeroForOne ? positions0[params.to][params.lower][params.upper]</span>
 190 |     | <span class='unexecuted'>                                        : positions1[params.to][params.lower][params.upper],</span>
 191 |     | <span class='unexecuted'>            constants: immutables()</span>
 192 |     | <span class='neutral'>        });</span>
 193 |     | <span class='unexecuted'>        cache = BurnLimitCall.perform(</span>
 194 |     | <span class='unexecuted'>            params, </span>
 195 |     | <span class='unexecuted'>            cache, </span>
 196 |     | <span class='unexecuted'>            limitTickMap,</span>
 197 |     | <span class='unexecuted'>            ticks,</span>
 198 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 199 |     | <span class='neutral'>        );</span>
 200 |     | <span class='neutral'>        globalState = cache.state;</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>    function getResizedTicksForBurn(</span>
 204 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 205 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionExists){</span>
 206 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
 207 |     | <span class='unexecuted'>        BurnLimitCache memory cache = BurnLimitCache({</span>
 208 |     | <span class='neutral'>            state: globalState,</span>
 209 |     | <span class='unexecuted'>            position: params.zeroForOne ? positions0[params.to][params.lower][params.upper]</span>
 210 |     | <span class='unexecuted'>                                        : positions1[params.to][params.lower][params.upper],</span>
 211 |     | <span class='unexecuted'>            constants: immutables()</span>
 212 |     | <span class='neutral'>        });</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='unexecuted'>        try BurnLimitCall.getResizedTicks(</span>
 215 |     | <span class='unexecuted'>            params, </span>
 216 |     | <span class='unexecuted'>            cache, </span>
 217 |     | <span class='unexecuted'>            limitTickMap,</span>
 218 |     | <span class='unexecuted'>            ticks,</span>
 219 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1</span>
 220 |     | <span class='neutral'>        ) {</span>
 221 |     | <span class='neutral'>        } catch (bytes memory data) {</span>
 222 |     | <span class='neutral'>            bytes4 sig;</span>
 223 |     | <span class='neutral'>            assembly {</span>
 224 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='neutral'>            // SimulateBurn error</span>
 227 |     | <span class='unexecuted'>            if (sig == hex&quot;97dd6e0a&quot;) {</span>
 228 |     | <span class='unexecuted'>                (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='neutral'>             else {</span>
 231 |     | <span class='neutral'>                lower = -8388608;</span>
 232 |     | <span class='neutral'>                upper = -8388608;</span>
 233 |     | <span class='neutral'>                positionExists = false;</span>
 234 |     | <span class='neutral'>            }</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>    function swap(</span>
 239 |     | <span class='neutral'>        SwapParams memory params</span>
 240 |     | <span class='neutral'>    ) external override</span>
 241 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 242 |     | <span class='neutral'>        canoncialOnly</span>
 243 |     | <span class='neutral'>    returns (</span>
 244 |     | <span class='unexecuted'>        int256,</span>
 245 |     | <span class='unexecuted'>        int256</span>
 246 |     | <span class='neutral'>    ) </span>
 247 |     | <span class='neutral'>    {</span>
 248 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 249 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 250 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>        return SwapCall.perform(</span>
 253 |     | <span class='unexecuted'>            ticks,</span>
 254 |     | <span class='unexecuted'>            globalState,</span>
 255 |     | <span class='unexecuted'>            samples,</span>
 256 |     | <span class='unexecuted'>            rangeTickMap,</span>
 257 |     | <span class='unexecuted'>            limitTickMap,</span>
 258 |     | <span class='unexecuted'>            params,</span>
 259 |     | <span class='neutral'>            cache</span>
 260 |     | <span class='neutral'>        );</span>
 261 |     | <span class='neutral'>    }</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>    function quote(</span>
 264 |     | <span class='neutral'>        QuoteParams memory params</span>
 265 |     | <span class='neutral'>    ) external view override canoncialOnly returns (</span>
 266 |     | <span class='unexecuted'>        uint256,</span>
 267 |     | <span class='unexecuted'>        uint256,</span>
 268 |     | <span class='unexecuted'>        uint160</span>
 269 |     | <span class='neutral'>    ) {</span>
 270 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 271 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 272 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 273 |     | <span class='unexecuted'>        return QuoteCall.perform(</span>
 274 |     | <span class='unexecuted'>            ticks,</span>
 275 |     | <span class='unexecuted'>            rangeTickMap,</span>
 276 |     | <span class='unexecuted'>            limitTickMap,</span>
 277 |     | <span class='unexecuted'>            params,</span>
 278 |     | <span class='neutral'>            cache</span>
 279 |     | <span class='neutral'>        );</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>    function increaseSampleLength(</span>
 283 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
 284 |     | <span class='neutral'>    ) external override</span>
 285 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 286 |     | <span class='neutral'>        canoncialOnly </span>
 287 |     | <span class='neutral'>    {</span>
 288 |     | <span class='unexecuted'>        globalState.pool = Samples.expand(</span>
 289 |     | <span class='unexecuted'>            samples,</span>
 290 |     | <span class='unexecuted'>            globalState.pool,</span>
 291 |     | <span class='unexecuted'>            sampleLengthNext</span>
 292 |     | <span class='neutral'>        );</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>    function fees(</span>
 296 |     | <span class='neutral'>        uint16 protocolFee0,</span>
 297 |     | <span class='neutral'>        uint16 protocolFee1,</span>
 298 |     | <span class='neutral'>        bool setFees</span>
 299 |     | <span class='neutral'>    ) external override</span>
 300 |     | <span class='neutral'>        ownerOnly</span>
 301 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 302 |     | <span class='neutral'>        canoncialOnly </span>
 303 |     | <span class='neutral'>    returns (</span>
 304 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 305 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 306 |     | <span class='unexecuted'>    ) {</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'>        if (setFees) {</span>
 309 |     | <span class='unexecuted'>            if (protocolFee0 &gt; 10000 || protocolFee1 &gt; 10000)</span>
 310 |     | <span class='unexecuted'>                revert ProtocolFeeCeilingExceeded();</span>
 311 |     | <span class='unexecuted'>            globalState.pool1.protocolFee = protocolFee0;</span>
 312 |     | <span class='unexecuted'>            globalState.pool0.protocolFee = protocolFee1;</span>
 313 |     | <span class='neutral'>        }</span>
 314 |     | <span class='unexecuted'>        address feeTo = ILimitPoolManager(owner()).feeTo();</span>
 315 |     | <span class='unexecuted'>        token0Fees = globalState.pool1.protocolFees;</span>
 316 |     | <span class='unexecuted'>        token1Fees = globalState.pool0.protocolFees;</span>
 317 |     | <span class='unexecuted'>        globalState.pool0.protocolFees = 0;</span>
 318 |     | <span class='unexecuted'>        globalState.pool1.protocolFees = 0;</span>
 319 |     | <span class='unexecuted'>        if (token0Fees &gt; 0)</span>
 320 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, token0(), token0Fees);</span>
 321 |     | <span class='unexecuted'>        if (token1Fees &gt; 0)</span>
 322 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, token1(), token1Fees);</span>
 323 |     | <span class='neutral'>    }</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='unexecuted'>    function immutables() public view returns (</span>
 326 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables memory</span>
 327 |     | <span class='neutral'>    ) {</span>
 328 |     | <span class='unexecuted'>        return Immutables(</span>
 329 |     | <span class='unexecuted'>            owner(),</span>
 330 |     | <span class='unexecuted'>            factory,</span>
 331 |     | <span class='unexecuted'>            PriceBounds(minPrice(), maxPrice()),</span>
 332 |     | <span class='unexecuted'>            token0(),</span>
 333 |     | <span class='unexecuted'>            token1(),</span>
 334 |     | <span class='unexecuted'>            poolToken(),</span>
 335 |     | <span class='unexecuted'>            tickSpacing(),</span>
 336 |     | <span class='unexecuted'>            swapFee()</span>
 337 |     | <span class='neutral'>        );</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>    function priceBounds(int16 tickSpacing) external pure returns (uint160, uint160) {</span>
 341 |     | <span class='unexecuted'>        return ConstantProduct.priceBounds(tickSpacing);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='unexecuted'>    function _onlyOwner() private view {</span>
 345 |     | <span class='unexecuted'>        if (msg.sender != owner()) revert OwnerOnly();</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='unexecuted'>    function _onlyCanoncialClones() private view {</span>
 349 |     | <span class='neutral'>        // compute pool key</span>
 350 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(original, token0(), token1(), swapFee()));</span>
 351 |     | <span class='neutral'>        </span>
 352 |     | <span class='neutral'>        // compute canonical pool address</span>
 353 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 354 |     | <span class='unexecuted'>            original,</span>
 355 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 356 |     | <span class='unexecuted'>                owner(),</span>
 357 |     | <span class='unexecuted'>                token0(),</span>
 358 |     | <span class='unexecuted'>                token1(),</span>
 359 |     | <span class='unexecuted'>                poolToken(),</span>
 360 |     | <span class='unexecuted'>                minPrice(),</span>
 361 |     | <span class='unexecuted'>                maxPrice(),</span>
 362 |     | <span class='unexecuted'>                tickSpacing(),</span>
 363 |     | <span class='unexecuted'>                swapFee()</span>
 364 |     | <span class='neutral'>            ),</span>
 365 |     | <span class='unexecuted'>            key,</span>
 366 |     | <span class='unexecuted'>            factory</span>
 367 |     | <span class='neutral'>        );</span>
 368 |     | <span class='neutral'>        // only allow delegateCall from canonical clones</span>
 369 |     | <span class='neutral'>        // if (address(this) != predictedAddress) require(false, &#39;NoDelegateCall()&#39;);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='unexecuted'>    function _onlyFactory() private view {</span>
 373 |     | <span class='unexecuted'>        if (msg.sender != factory) revert FactoryOnly();</span>
 374 |     | <span class='neutral'>    }</span>
 375 |     | <span class='neutral'>}</span>
 376 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/LimitPoolFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./base/events/LimitPoolFactoryEvents.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./base/structs/PoolsharkStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./utils/LimitPoolErrors.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./libraries/solady/LibClone.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract LimitPoolFactory is </span>
  13 |     | <span class='neutral'>    ILimitPoolFactory,</span>
  14 |     | <span class='neutral'>    PoolsharkStructs,</span>
  15 |     | <span class='neutral'>    LimitPoolFactoryEvents,</span>
  16 |     | <span class='neutral'>    LimitPoolFactoryErrors</span>
  17 |     | <span class='neutral'>{</span>
  18 |     | <span class='neutral'>    using LibClone for address;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>event Debug(uint a);</span>
  21 |     | <span class='neutral'>event DebugTick(int24 a);</span>
  22 |     | <span class='unexecuted'>    address immutable public owner;</span>
  23 |     | <span class='unexecuted'>    address immutable public original;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    constructor(</span>
  26 |     | <span class='neutral'>        address owner_</span>
  27 |     | <span class='neutral'>    ) {</span>
  28 |     | <span class='unexecuted'>        owner = owner_;</span>
  29 |     | <span class='unexecuted'>        original = address(this);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>    function createLimitPool(</span>
  33 |     | <span class='neutral'>        bytes32 poolType,</span>
  34 |     | <span class='neutral'>        address tokenIn,</span>
  35 |     | <span class='neutral'>        address tokenOut,</span>
  36 |     | <span class='neutral'>        uint16  swapFee,</span>
  37 |     | <span class='neutral'>        uint160 startPrice</span>
  38 |     | <span class='neutral'>    ) external override returns (</span>
  39 |     | <span class='unexecuted'>        address pool,</span>
  40 |     | <span class='unexecuted'>        address poolToken</span>
  41 |     | <span class='neutral'>    ) {</span>
  42 |     | <span class='unexecuted'>        emit Debug(1);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // validate token pair</span>
  45 |     | <span class='unexecuted'>        if (tokenIn == tokenOut || tokenIn == address(0) || tokenOut == address(0)) {</span>
  46 |     | <span class='unexecuted'>            revert InvalidTokenAddress();</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        // sort tokens by address</span>
  50 |     | <span class='neutral'>        Immutables memory constants;</span>
  51 |     | <span class='unexecuted'>        (constants.token0, constants.token1) = tokenIn &lt; tokenOut ? (tokenIn,  tokenOut) </span>
  52 |     | <span class='unexecuted'>                                                                  : (tokenOut, tokenIn);</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>        // check if tick spacing supported</span>
  55 |     | <span class='unexecuted'>        constants.swapFee = swapFee;</span>
  56 |     | <span class='unexecuted'>        constants.tickSpacing = ILimitPoolManager(owner).feeTiers(swapFee);</span>
  57 |     | <span class='unexecuted'>        emit Debug(21);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        if (constants.tickSpacing == 0) revert FeeTierNotSupported();</span>
  60 |     | <span class='unexecuted'>        emit Debug(11);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // check if pool type supported</span>
  63 |     | <span class='unexecuted'>        (</span>
  64 |     | <span class='unexecuted'>            address poolImpl,</span>
  65 |     | <span class='neutral'>            address tokenImpl</span>
  66 |     | <span class='unexecuted'>         ) = ILimitPoolManager(owner).implementations(poolType);</span>
  67 |     | <span class='unexecuted'>        if (poolImpl == address(0) || tokenImpl == address(0)) revert PoolTypeNotSupported();</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // generate key for pool</span>
  70 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
  71 |     | <span class='unexecuted'>            poolImpl,</span>
  72 |     | <span class='unexecuted'>            constants.token0,</span>
  73 |     | <span class='unexecuted'>            constants.token1,</span>
  74 |     | <span class='unexecuted'>            constants.swapFee</span>
  75 |     | <span class='neutral'>        ));</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // check if pool already exists</span>
  78 |     | <span class='unexecuted'>        if (limitPools[key] != address(0)) revert PoolAlreadyExists();</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        // set immutables</span>
  81 |     | <span class='unexecuted'>        constants.owner = owner;</span>
  82 |     | <span class='unexecuted'>        constants.factory = original;</span>
  83 |     | <span class='unexecuted'>        (</span>
  84 |     | <span class='unexecuted'>            constants.bounds.min,</span>
  85 |     | <span class='unexecuted'>            constants.bounds.max</span>
  86 |     | <span class='unexecuted'>        ) = ILimitPool(poolImpl).priceBounds(constants.tickSpacing);</span>
  87 |     | <span class='unexecuted'>        emit Debug(2);</span>
  88 |     | <span class='neutral'>        // calculate token address</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // pass this address into a clone of RangePoolERC1155</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // take that ERC1155 contract address and pass that into pool</span>
  93 |     | <span class='neutral'>        // launch pool token</span>
  94 |     | <span class='unexecuted'>        constants.poolToken = tokenImpl.cloneDeterministic({</span>
  95 |     | <span class='unexecuted'>            salt: key,</span>
  96 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
  97 |     | <span class='neutral'>                poolImpl</span>
  98 |     | <span class='neutral'>            )</span>
  99 |     | <span class='neutral'>        });</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>        // launch pool</span>
 102 |     | <span class='unexecuted'>        pool = poolImpl.cloneDeterministic({</span>
 103 |     | <span class='unexecuted'>            salt: key,</span>
 104 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
 105 |     | <span class='unexecuted'>                constants.owner,</span>
 106 |     | <span class='unexecuted'>                constants.token0,</span>
 107 |     | <span class='unexecuted'>                constants.token1,</span>
 108 |     | <span class='neutral'>                constants.poolToken,</span>
 109 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 110 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 111 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 112 |     | <span class='unexecuted'>                constants.swapFee</span>
 113 |     | <span class='neutral'>            )</span>
 114 |     | <span class='neutral'>        });</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>        // initialize pool storage</span>
 117 |     | <span class='unexecuted'>        ILimitPool(pool).initialize(startPrice);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        // save pool in mapping</span>
 120 |     | <span class='unexecuted'>        limitPools[key] = pool;</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        emit PoolCreated(</span>
 123 |     | <span class='neutral'>            pool,</span>
 124 |     | <span class='neutral'>            poolToken,</span>
 125 |     | <span class='neutral'>            poolImpl,</span>
 126 |     | <span class='neutral'>            tokenImpl,</span>
 127 |     | <span class='unexecuted'>            constants.token0,</span>
 128 |     | <span class='unexecuted'>            constants.token1,</span>
 129 |     | <span class='unexecuted'>            constants.swapFee,</span>
 130 |     | <span class='unexecuted'>            constants.tickSpacing</span>
 131 |     | <span class='neutral'>        );</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>        return (pool, constants.poolToken);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>    function getLimitPool(</span>
 137 |     | <span class='neutral'>        bytes32 poolType,</span>
 138 |     | <span class='neutral'>        address tokenIn,</span>
 139 |     | <span class='neutral'>        address tokenOut,</span>
 140 |     | <span class='neutral'>        uint16 swapFee</span>
 141 |     | <span class='neutral'>    ) external view override returns (</span>
 142 |     | <span class='unexecuted'>        address pool,</span>
 143 |     | <span class='unexecuted'>        address poolToken</span>
 144 |     | <span class='neutral'>    ) {</span>
 145 |     | <span class='neutral'>        // set lexographical token address ordering</span>
 146 |     | <span class='unexecuted'>        address token0 = tokenIn &lt; tokenOut ? tokenIn : tokenOut;</span>
 147 |     | <span class='unexecuted'>        address token1 = tokenIn &lt; tokenOut ? tokenOut : tokenIn;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>        // check if tick spacing supported</span>
 150 |     | <span class='unexecuted'>        int16 tickSpacing = ILimitPoolManager(owner).feeTiers(swapFee);</span>
 151 |     | <span class='unexecuted'>        if (tickSpacing == 0) revert FeeTierNotSupported();</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>        // check if pool type supported</span>
 154 |     | <span class='unexecuted'>        (</span>
 155 |     | <span class='unexecuted'>            address poolImpl,</span>
 156 |     | <span class='neutral'>            address tokenImpl</span>
 157 |     | <span class='unexecuted'>         ) = ILimitPoolManager(owner).implementations(poolType);</span>
 158 |     | <span class='unexecuted'>        if (poolImpl == address(0) || tokenImpl == address(0)) revert PoolTypeNotSupported();</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // generate key for pool</span>
 161 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 162 |     | <span class='neutral'>            poolImpl,</span>
 163 |     | <span class='neutral'>            token0,</span>
 164 |     | <span class='neutral'>            token1,</span>
 165 |     | <span class='neutral'>            swapFee</span>
 166 |     | <span class='neutral'>        ));</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        pool = limitPools[key];</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        poolToken = LibClone.predictDeterministicAddress(</span>
 171 |     | <span class='unexecuted'>            tokenImpl,</span>
 172 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 173 |     | <span class='neutral'>                poolImpl</span>
 174 |     | <span class='neutral'>            ),</span>
 175 |     | <span class='unexecuted'>            key,</span>
 176 |     | <span class='unexecuted'>            address(this)</span>
 177 |     | <span class='neutral'>        );</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>        return (pool, poolToken);</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'>}</span>
 182 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/events/LimitPoolEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolEvents {</span>
  5 |     | <span class='neutral'>    event Initialize(</span>
  6 |     | <span class='neutral'>        int24 minTick,</span>
  7 |     | <span class='neutral'>        int24 maxTick,</span>
  8 |     | <span class='neutral'>        uint160 startPrice,</span>
  9 |     | <span class='neutral'>        int24 startTick</span>
 10 |     | <span class='neutral'>    );</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    event Sync(</span>
 13 |     | <span class='neutral'>        uint160 price,</span>
 14 |     | <span class='neutral'>        uint128 liquidity</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event MintLimit(</span>
 18 |     | <span class='neutral'>        address indexed to,</span>
 19 |     | <span class='neutral'>        int24 lower,</span>
 20 |     | <span class='neutral'>        int24 upper,</span>
 21 |     | <span class='neutral'>        bool zeroForOne,</span>
 22 |     | <span class='neutral'>        uint32 epochLast,</span>
 23 |     | <span class='neutral'>        uint128 amountIn,</span>
 24 |     | <span class='neutral'>        uint128 amountFilled,</span>
 25 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
 26 |     | <span class='neutral'>        uint128 poolLiquidity,</span>
 27 |     | <span class='neutral'>        uint160 poolPrice</span>
 28 |     | <span class='neutral'>    );</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    event BurnLimit(</span>
 31 |     | <span class='neutral'>        address indexed to,</span>
 32 |     | <span class='neutral'>        int24 lower,</span>
 33 |     | <span class='neutral'>        int24 upper,</span>
 34 |     | <span class='neutral'>        int24 claim,</span>
 35 |     | <span class='neutral'>        bool zeroForOne,</span>
 36 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 37 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
 38 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
 39 |     | <span class='neutral'>    );</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    event Swap(</span>
 42 |     | <span class='neutral'>        address indexed recipient,</span>
 43 |     | <span class='neutral'>        bool zeroForOne,</span>
 44 |     | <span class='neutral'>        uint256 amountIn,</span>
 45 |     | <span class='neutral'>        uint256 amountOut,</span>
 46 |     | <span class='neutral'>        uint160 price,</span>
 47 |     | <span class='neutral'>        uint128 liquidity,</span>
 48 |     | <span class='neutral'>        int24 tickAtPrice</span>
 49 |     | <span class='neutral'>    );</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/events/LimitPoolFactoryEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryEvents {</span>
  5 |     | <span class='neutral'>    event PoolCreated(</span>
  6 |     | <span class='neutral'>        address pool,</span>
  7 |     | <span class='neutral'>        address token,</span>
  8 |     | <span class='neutral'>        address poolImpl,</span>
  9 |     | <span class='neutral'>        address tokenImpl,</span>
 10 |     | <span class='neutral'>        address indexed token0,</span>
 11 |     | <span class='neutral'>        address indexed token1,</span>
 12 |     | <span class='neutral'>        uint16 indexed swapFee,</span>
 13 |     | <span class='neutral'>        int16 tickSpacing</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/events/LimitPoolManagerEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolManagerEvents {</span>
  5 |     | <span class='neutral'>    event FactoryChanged(address indexed previousFactory, address indexed newFactory);</span>
  6 |     | <span class='neutral'>    event ImplementationEnabled(</span>
  7 |     | <span class='neutral'>        bytes32 key,</span>
  8 |     | <span class='neutral'>        address poolImpl,</span>
  9 |     | <span class='neutral'>        address tokenImpl</span>
 10 |     | <span class='neutral'>    );</span>
 11 |     | <span class='neutral'>    event FeeTierEnabled(</span>
 12 |     | <span class='neutral'>        uint16 swapFee,</span>
 13 |     | <span class='neutral'>        int16 tickSpacing</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'>    event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);</span>
 16 |     | <span class='neutral'>    event OwnerTransfer(address indexed previousOwner, address indexed newOwner);</span>
 17 |     | <span class='neutral'>    event ProtocolFeesModified(</span>
 18 |     | <span class='neutral'>        address[] modifyPools,</span>
 19 |     | <span class='neutral'>        uint16[] syncFees,</span>
 20 |     | <span class='neutral'>        uint16[] fillFees,</span>
 21 |     | <span class='neutral'>        bool[] setFees,</span>
 22 |     | <span class='neutral'>        uint128[] token0Fees,</span>
 23 |     | <span class='neutral'>        uint128[] token1Fees</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'>    event ProtocolFeesCollected(</span>
 26 |     | <span class='neutral'>        address[] collectPools,</span>
 27 |     | <span class='neutral'>        uint128[] token0Fees,</span>
 28 |     | <span class='neutral'>        uint128[] token1Fees</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/LimitPoolFactoryStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryStorage {</span>
  5 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; address) public limitPools;</span>
  6 |     | <span class='neutral'>}</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/LimitPoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../libraries/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract LimitPoolImmutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function owner() public pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function token0() public pure returns (address) {</span>
 12 |     | <span class='unexecuted'>        return _getArgAddress(20);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function token1() public pure returns (address) {</span>
 16 |     | <span class='unexecuted'>        return _getArgAddress(40);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function poolToken() public pure returns (address) {</span>
 20 |     | <span class='unexecuted'>        return _getArgAddress(60);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function minPrice() public pure returns (uint160) {</span>
 24 |     | <span class='unexecuted'>        return _getArgUint160(80);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function maxPrice() public pure returns (uint160) {</span>
 28 |     | <span class='unexecuted'>        return _getArgUint160(100);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function tickSpacing() public pure returns (int16) {</span>
 32 |     | <span class='unexecuted'>        return int16(_getArgUint16(120));</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function swapFee() public pure returns (uint16) {</span>
 36 |     | <span class='unexecuted'>        return _getArgUint16(122);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/LimitPoolStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../../utils/LimitPoolErrors.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract LimitPoolStorage is ILimitPoolStructs, IRangePoolStructs, LimitPoolErrors {</span>
 10 |     | <span class='unexecuted'>    GlobalState public globalState;</span>
 11 |     | <span class='unexecuted'>    TickMap public rangeTickMap;</span>
 12 |     | <span class='unexecuted'>    TickMap public limitTickMap;</span>
 13 |     | <span class='unexecuted'>    address public feeTo;</span>
 14 |     | <span class='unexecuted'>    Sample[65535] public samples;</span>
 15 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick) public ticks;</span>
 16 |     | <span class='unexecuted'>    mapping(int24 =&gt; mapping(int24 =&gt; Position)) public positions; /// @dev - positions owned by the pool</span>
 17 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; LimitPosition))) public positions0; //positions with token0 deposited</span>
 18 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; LimitPosition))) public positions1; //positions with token1 deposited</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/RangePoolERC1155Immutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../libraries/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract RangePoolERC1155Immutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function poolImpl() public pure returns (address) {</span>
  8 |     | <span class='neutral'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/structs/LimitPoolFactoryStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryStructs {</span>
  5 |     | <span class='neutral'>    struct LimitPoolParams {</span>
  6 |     | <span class='neutral'>        address owner;</span>
  7 |     | <span class='neutral'>        address token0;</span>
  8 |     | <span class='neutral'>        address token1;</span>
  9 |     | <span class='neutral'>        uint160 minPrice;</span>
 10 |     | <span class='neutral'>        uint160 maxPrice;</span>
 11 |     | <span class='neutral'>        uint160 startPrice;</span>
 12 |     | <span class='neutral'>        int16   tickSpacing;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/structs/PoolsharkStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface PoolsharkStructs {</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>    struct GlobalState {</span>
   7 |     | <span class='neutral'>        RangePoolState pool;</span>
   8 |     | <span class='neutral'>        LimitPoolState pool0;</span>
   9 |     | <span class='neutral'>        LimitPoolState pool1;</span>
  10 |     | <span class='neutral'>        uint128 liquidityGlobal;</span>
  11 |     | <span class='neutral'>        uint32 epoch;</span>
  12 |     | <span class='neutral'>        uint8 unlocked;</span>
  13 |     | <span class='neutral'>    }</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    struct LimitPoolState {</span>
  16 |     | <span class='neutral'>        uint160 price; /// @dev Starting price current</span>
  17 |     | <span class='neutral'>        uint128 liquidity; /// @dev Liquidity currently active</span>
  18 |     | <span class='neutral'>        uint128 protocolFees;</span>
  19 |     | <span class='neutral'>        uint16 protocolFee;</span>
  20 |     | <span class='neutral'>        int24 tickAtPrice;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    struct RangePoolState {</span>
  24 |     | <span class='neutral'>        SampleState  samples;</span>
  25 |     | <span class='neutral'>        uint200 feeGrowthGlobal0;</span>
  26 |     | <span class='neutral'>        uint200 feeGrowthGlobal1;</span>
  27 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  28 |     | <span class='neutral'>        uint160 price;               /// @dev Starting price current</span>
  29 |     | <span class='neutral'>        uint128 liquidity;           /// @dev Liquidity currently active</span>
  30 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
  31 |     | <span class='neutral'>        int24   tickAtPrice;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    struct Tick {</span>
  35 |     | <span class='neutral'>        RangeTick range;</span>
  36 |     | <span class='neutral'>        LimitTick limit;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct LimitTick {</span>
  40 |     | <span class='neutral'>        uint160 priceAt;</span>
  41 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  42 |     | <span class='neutral'>        uint128 liquidityAbsolute;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct RangeTick {</span>
  46 |     | <span class='neutral'>        uint200 feeGrowthOutside0;</span>
  47 |     | <span class='neutral'>        uint200 feeGrowthOutside1;</span>
  48 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumOutside;</span>
  49 |     | <span class='neutral'>        int56 tickSecondsAccumOutside;</span>
  50 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  51 |     | <span class='neutral'>        uint128 liquidityAbsolute;</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    struct Sample {</span>
  55 |     | <span class='neutral'>        uint32  blockTimestamp;</span>
  56 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
  57 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    struct SampleState {</span>
  61 |     | <span class='neutral'>        uint16  index;</span>
  62 |     | <span class='neutral'>        uint16  length;</span>
  63 |     | <span class='neutral'>        uint16  lengthNext;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    struct SwapParams {</span>
  67 |     | <span class='neutral'>        address to;</span>
  68 |     | <span class='neutral'>        uint160 priceLimit;</span>
  69 |     | <span class='neutral'>        uint128  amount;</span>
  70 |     | <span class='neutral'>        bool exactIn;</span>
  71 |     | <span class='neutral'>        bool zeroForOne;</span>
  72 |     | <span class='neutral'>        bytes callbackData;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    struct QuoteParams {</span>
  76 |     | <span class='neutral'>        uint160 priceLimit;</span>
  77 |     | <span class='neutral'>        uint128 amount;</span>
  78 |     | <span class='neutral'>        bool exactIn;</span>
  79 |     | <span class='neutral'>        bool zeroForOne;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'>    </span>
  82 |     | <span class='neutral'>    struct Immutables {</span>
  83 |     | <span class='neutral'>        address owner;</span>
  84 |     | <span class='neutral'>        address factory;</span>
  85 |     | <span class='neutral'>        PriceBounds bounds;</span>
  86 |     | <span class='neutral'>        address token0;</span>
  87 |     | <span class='neutral'>        address token1;</span>
  88 |     | <span class='neutral'>        address poolToken;</span>
  89 |     | <span class='neutral'>        int16 tickSpacing;</span>
  90 |     | <span class='neutral'>        uint16 swapFee;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    struct PriceBounds {</span>
  94 |     | <span class='neutral'>        uint160 min;</span>
  95 |     | <span class='neutral'>        uint160 max;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    struct TickMap {</span>
  99 |     | <span class='neutral'>        uint256 blocks;                     /// @dev - sets of words</span>
 100 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) words;  /// @dev - sets to words</span>
 101 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) ticks;  /// @dev - words to ticks</span>
 102 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs0; /// @dev - ticks to epochs</span>
 103 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs1; /// @dev - ticks to epochs</span>
 104 |     | <span class='neutral'>        //TODO: epochs0 and epochs1; zeroForOne param for EpochMap.get/set</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    struct SwapCache {</span>
 108 |     | <span class='neutral'>        GlobalState state;</span>
 109 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
 110 |     | <span class='neutral'>        uint256 price;</span>
 111 |     | <span class='neutral'>        uint256 liquidity;</span>
 112 |     | <span class='neutral'>        uint256 amountLeft;</span>
 113 |     | <span class='neutral'>        uint256 input;</span>
 114 |     | <span class='neutral'>        uint256 output;</span>
 115 |     | <span class='neutral'>        uint160 crossPrice;</span>
 116 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
 117 |     | <span class='neutral'>        uint128 feeAmount;</span>
 118 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
 119 |     | <span class='neutral'>        int24   crossTick;</span>
 120 |     | <span class='neutral'>        uint8   crossStatus;</span>
 121 |     | <span class='neutral'>        bool    limitActive;</span>
 122 |     | <span class='neutral'>        bool    exactIn;</span>
 123 |     | <span class='neutral'>        bool    cross;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    // struct CrossState {</span>
 127 |     | <span class='neutral'>    //     int24   tickAhead;</span>
 128 |     | <span class='neutral'>    //     bool    limitPoolAhead;</span>
 129 |     | <span class='neutral'>    //     bool    active;</span>
 130 |     | <span class='neutral'>    // }    </span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    enum CrossStatus {</span>
 133 |     | <span class='neutral'>        RANGE,</span>
 134 |     | <span class='neutral'>        LIMIT,</span>
 135 |     | <span class='neutral'>        BOTH</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/external/openzeppelin/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &#39;../../../base/structs/PoolsharkStructs.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 12 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 13 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 16 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 17 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 18 |     | <span class='neutral'> * points to them.</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 21 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 22 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 23 |     | <span class='neutral'> */</span>
 24 |     | <span class='neutral'>abstract contract ReentrancyGuard is PoolsharkStructs {</span>
 25 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 26 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 27 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 28 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 29 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 32 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 33 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 34 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 35 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 36 |     | <span class='neutral'>    uint8 private constant _NOT_ENTERED = 1;</span>
 37 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Unauthorized reentrant call.</span>
 41 |     | <span class='neutral'>     */</span>
 42 |     | <span class='neutral'>    error ReentrancyGuardReentrantCall();</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Reentrant state invalid.</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='neutral'>    error ReentrancyGuardInvalidState();</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 51 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 52 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 53 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 54 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 55 |     | <span class='neutral'>     */</span>
 56 |     | <span class='neutral'>    modifier nonReentrant(GlobalState storage state) {</span>
 57 |     | <span class='unexecuted'>        _nonReentrantBefore(state);</span>
 58 |     | <span class='neutral'>        _;</span>
 59 |     | <span class='unexecuted'>        _nonReentrantAfter(state);</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>    function _nonReentrantBefore(GlobalState storage state) private {</span>
 63 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 64 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED) {</span>
 65 |     | <span class='unexecuted'>            revert ReentrancyGuardReentrantCall();</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 69 |     | <span class='unexecuted'>        state.unlocked = _ENTERED;</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='unexecuted'>    function _nonReentrantAfter(GlobalState storage state) private {</span>
 73 |     | <span class='unexecuted'>        if (state.unlocked != _ENTERED) revert ReentrancyGuardInvalidState();</span>
 74 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 75 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 76 |     | <span class='unexecuted'>        state.unlocked = _NOT_ENTERED;</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 81 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function _reentrancyGuardEntered(GlobalState storage state) internal view returns (bool) {</span>
 84 |     | <span class='neutral'>        return state.unlocked == _ENTERED;</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20Minimal {</span>
  5 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  6 |     | <span class='neutral'>    /// @param account The address for which to look up the balance for</span>
  7 |     | <span class='neutral'>    /// @return amount of tokens held by the account</span>
  8 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/IPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../base/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IPool is PoolsharkStructs {</span>
  7 |     | <span class='neutral'>    function immutables() external view returns (Immutables memory);</span>
  8 |     | <span class='neutral'>    </span>
  9 |     | <span class='neutral'>    function swap(</span>
 10 |     | <span class='neutral'>        SwapParams memory params</span>
 11 |     | <span class='neutral'>    ) external returns (</span>
 12 |     | <span class='neutral'>        int256 amount0,</span>
 13 |     | <span class='neutral'>        int256 amount1</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function quote(</span>
 17 |     | <span class='neutral'>        QuoteParams memory params</span>
 18 |     | <span class='neutral'>    ) external view returns (</span>
 19 |     | <span class='neutral'>        uint256 inAmount,</span>
 20 |     | <span class='neutral'>        uint256 outAmount,</span>
 21 |     | <span class='neutral'>        uint160 priceAfter</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function fees(</span>
 25 |     | <span class='neutral'>        uint16 protocolFee0,</span>
 26 |     | <span class='neutral'>        uint16 protocolFee1,</span>
 27 |     | <span class='neutral'>        bool setFees</span>
 28 |     | <span class='neutral'>    ) external returns (</span>
 29 |     | <span class='neutral'>        uint128 token0Fees,</span>
 30 |     | <span class='neutral'>        uint128 token1Fees</span>
 31 |     | <span class='neutral'>    );</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function globalState() external view returns (</span>
 34 |     | <span class='neutral'>        RangePoolState memory pool,</span>
 35 |     | <span class='neutral'>        LimitPoolState memory pool0,</span>
 36 |     | <span class='neutral'>        LimitPoolState memory pool1,</span>
 37 |     | <span class='neutral'>        uint128 liquidityGlobal,</span>
 38 |     | <span class='neutral'>        uint32 epoch,</span>
 39 |     | <span class='neutral'>        uint8 unlocked</span>
 40 |     | <span class='neutral'>    );</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    function samples(uint256) external view returns (</span>
 43 |     | <span class='neutral'>        uint32,</span>
 44 |     | <span class='neutral'>        int56,</span>
 45 |     | <span class='neutral'>        uint160</span>
 46 |     | <span class='neutral'>    );</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function ticks(int24) external view returns (</span>
 49 |     | <span class='neutral'>        RangeTick memory,</span>
 50 |     | <span class='neutral'>        LimitTick memory</span>
 51 |     | <span class='neutral'>    );</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    function positions(int24, int24) external view returns (</span>
 54 |     | <span class='neutral'>        uint128,</span>
 55 |     | <span class='neutral'>        uint128,</span>
 56 |     | <span class='neutral'>        uint128,</span>
 57 |     | <span class='neutral'>        uint256,</span>
 58 |     | <span class='neutral'>        uint256</span>
 59 |     | <span class='neutral'>    );</span>
 60 |     | <span class='neutral'>}</span>
 61 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/callbacks/IPoolsharkSwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for swaps</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls the `swap` function must implement this interface.</span>
  6 |     | <span class='neutral'>interface IPoolsharkSwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 10 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 11 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 12 |     | <span class='neutral'>    function poolsharkSwapCallback(</span>
 13 |     | <span class='neutral'>        int256 amount0Delta,</span>
 14 |     | <span class='neutral'>        int256 amount1Delta,</span>
 15 |     | <span class='neutral'>        bytes calldata data</span>
 16 |     | <span class='neutral'>    ) external;</span>
 17 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/limit/ILimitPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../base/structs/LimitPoolFactoryStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ILimitPool is ILimitPoolStructs {</span>
  8 |     | <span class='neutral'>    function initialize(</span>
  9 |     | <span class='neutral'>        uint160 startPrice</span>
 10 |     | <span class='neutral'>    ) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function mintLimit(</span>
 13 |     | <span class='neutral'>        MintLimitParams memory params</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function burnLimit(</span>
 17 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 18 |     | <span class='neutral'>    ) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function fees(</span>
 21 |     | <span class='neutral'>        uint16 protocolFee0,</span>
 22 |     | <span class='neutral'>        uint16 protocolFee1,</span>
 23 |     | <span class='neutral'>        bool setFees</span>
 24 |     | <span class='neutral'>    ) external returns (</span>
 25 |     | <span class='neutral'>        uint128 token0Fees,</span>
 26 |     | <span class='neutral'>        uint128 token1Fees</span>
 27 |     | <span class='neutral'>    );</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function priceBounds(</span>
 30 |     | <span class='neutral'>        int16 tickSpacing</span>
 31 |     | <span class='neutral'>    ) external pure returns (</span>
 32 |     | <span class='neutral'>        uint160 minPrice,</span>
 33 |     | <span class='neutral'>        uint160 maxPrice</span>
 34 |     | <span class='neutral'>    );</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/limit/ILimitPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'>import &#39;../../base/storage/LimitPoolFactoryStorage.sol&#39;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>abstract contract ILimitPoolFactory is LimitPoolFactoryStorage {</span>
  6 |     | <span class='neutral'>    function createLimitPool(</span>
  7 |     | <span class='neutral'>        bytes32 poolType,</span>
  8 |     | <span class='neutral'>        address tokenIn,</span>
  9 |     | <span class='neutral'>        address tokenOut,</span>
 10 |     | <span class='neutral'>        uint16  swapFee,</span>
 11 |     | <span class='neutral'>        uint160 startPrice</span>
 12 |     | <span class='neutral'>    ) external virtual returns (</span>
 13 |     | <span class='neutral'>        address pool,</span>
 14 |     | <span class='neutral'>        address poolToken</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function getLimitPool(</span>
 18 |     | <span class='neutral'>        bytes32 poolType,</span>
 19 |     | <span class='neutral'>        address tokenIn,</span>
 20 |     | <span class='neutral'>        address tokenOut,</span>
 21 |     | <span class='neutral'>        uint16  swapFee</span>
 22 |     | <span class='neutral'>    ) external view virtual returns (</span>
 23 |     | <span class='neutral'>        address pool,</span>
 24 |     | <span class='neutral'>        address poolToken</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/limit/ILimitPoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice LimitPoolManager interface</span>
  5 |     | <span class='neutral'>interface ILimitPoolManager {</span>
  6 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  7 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  8 |     | <span class='neutral'>    function implementations(</span>
  9 |     | <span class='neutral'>        bytes32 poolType</span>
 10 |     | <span class='neutral'>    ) external view returns (</span>
 11 |     | <span class='neutral'>        address poolImpl,</span>
 12 |     | <span class='neutral'>        address tokenImpl</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'>    function feeTiers(</span>
 15 |     | <span class='neutral'>        uint16 swapFee</span>
 16 |     | <span class='neutral'>    ) external view returns (</span>
 17 |     | <span class='neutral'>        int16 tickSpacing</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/limit/ILimitPoolStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../base/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface ILimitPoolStructs is PoolsharkStructs {</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    struct LimitPosition {</span>
   9 |     | <span class='neutral'>        uint128 amountIn; // token amount already claimed; balance</span>
  10 |     | <span class='neutral'>        uint128 amountOut; // necessary for non-custodial positions</span>
  11 |     | <span class='neutral'>        uint128 liquidity; // expected amount to be used not actual</span>
  12 |     | <span class='neutral'>        uint32 epochLast;  // epoch when this position was created at</span>
  13 |     | <span class='neutral'>        bool crossedInto; // whether the position was crossed into already</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    struct MintLimitParams {</span>
  17 |     | <span class='neutral'>        address to;</span>
  18 |     | <span class='neutral'>        uint128 amount;</span>
  19 |     | <span class='neutral'>        uint96 mintPercent;</span>
  20 |     | <span class='neutral'>        int24 lower;</span>
  21 |     | <span class='neutral'>        int24 upper;</span>
  22 |     | <span class='neutral'>        bool zeroForOne;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct BurnLimitParams {</span>
  26 |     | <span class='neutral'>        address to;</span>
  27 |     | <span class='neutral'>        uint128 burnPercent;</span>
  28 |     | <span class='neutral'>        int24 lower;</span>
  29 |     | <span class='neutral'>        int24 claim;</span>
  30 |     | <span class='neutral'>        int24 upper;</span>
  31 |     | <span class='neutral'>        bool zeroForOne;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    struct SnapshotLimitParams {</span>
  35 |     | <span class='neutral'>        address owner;</span>
  36 |     | <span class='neutral'>        uint128 burnPercent;</span>
  37 |     | <span class='neutral'>        int24 lower;</span>
  38 |     | <span class='neutral'>        int24 upper;</span>
  39 |     | <span class='neutral'>        int24 claim;</span>
  40 |     | <span class='neutral'>        bool zeroForOne;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct UpdateLimitParams {</span>
  44 |     | <span class='neutral'>        address owner;</span>
  45 |     | <span class='neutral'>        address to;</span>
  46 |     | <span class='neutral'>        uint128 amount;</span>
  47 |     | <span class='neutral'>        int24 lower;</span>
  48 |     | <span class='neutral'>        int24 upper;</span>
  49 |     | <span class='neutral'>        int24 claim;</span>
  50 |     | <span class='neutral'>        bool zeroForOne;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    struct MintLimitCache {</span>
  54 |     | <span class='neutral'>        GlobalState state;</span>
  55 |     | <span class='neutral'>        LimitPosition position;</span>
  56 |     | <span class='neutral'>        Immutables constants;</span>
  57 |     | <span class='neutral'>        LimitPoolState pool;</span>
  58 |     | <span class='neutral'>        SwapCache swapCache;</span>
  59 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
  60 |     | <span class='neutral'>        uint256 mintSize;</span>
  61 |     | <span class='neutral'>        uint256 priceLimit;</span>
  62 |     | <span class='neutral'>        int256 amountIn;</span>
  63 |     | <span class='neutral'>        uint256 amountOut;</span>
  64 |     | <span class='neutral'>        uint256 priceLower;</span>
  65 |     | <span class='neutral'>        uint256 priceUpper;</span>
  66 |     | <span class='neutral'>        int24 tickLimit;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    struct BurnLimitCache {</span>
  70 |     | <span class='neutral'>        GlobalState state;</span>
  71 |     | <span class='neutral'>        LimitPosition position;</span>
  72 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    struct UpdateCache {</span>
  76 |     | <span class='neutral'>        GlobalState state;</span>
  77 |     | <span class='neutral'>        LimitPoolState pool;</span>
  78 |     | <span class='neutral'>        LimitTick claimTick;</span>
  79 |     | <span class='neutral'>        LimitPosition position;</span>
  80 |     | <span class='neutral'>        uint160 priceLower;</span>
  81 |     | <span class='neutral'>        uint160 priceClaim;</span>
  82 |     | <span class='neutral'>        uint160 priceUpper;</span>
  83 |     | <span class='neutral'>        bool earlyReturn;</span>
  84 |     | <span class='neutral'>        bool removeLower;</span>
  85 |     | <span class='neutral'>        bool removeUpper;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    struct InsertSingleLocals {</span>
  89 |     | <span class='neutral'>        int24 previousFullTick;</span>
  90 |     | <span class='neutral'>        int24 nextFullTick;</span>
  91 |     | <span class='neutral'>        uint256 priceNext;</span>
  92 |     | <span class='neutral'>        uint256 pricePrevious;</span>
  93 |     | <span class='neutral'>        uint256 amountInExact;</span>
  94 |     | <span class='neutral'>        uint256 amountOutExact;</span>
  95 |     | <span class='neutral'>        uint256 amountToCross;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    struct GetDeltasLocals {</span>
  99 |     | <span class='neutral'>        int24 previousFullTick;</span>
 100 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 101 |     | <span class='neutral'>        uint256 priceNext;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'>}</span>
 104 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/range/IRangePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./IRangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./IRangePoolManager.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IRangePool is IRangePoolStructs {</span>
  8 |     | <span class='neutral'>    function mint(</span>
  9 |     | <span class='neutral'>        MintParams memory mintParams</span>
 10 |     | <span class='neutral'>    ) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function burn(</span>
 13 |     | <span class='neutral'>        BurnParams memory burnParams</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function swap(</span>
 17 |     | <span class='neutral'>        SwapParams memory params</span>
 18 |     | <span class='neutral'>    ) external returns (</span>
 19 |     | <span class='neutral'>        int256 amount0,</span>
 20 |     | <span class='neutral'>        int256 amount1</span>
 21 |     | <span class='neutral'>    );</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function quote(</span>
 24 |     | <span class='neutral'>        QuoteParams memory params</span>
 25 |     | <span class='neutral'>    ) external view returns (</span>
 26 |     | <span class='neutral'>        uint256 inAmount,</span>
 27 |     | <span class='neutral'>        uint256 outAmount,</span>
 28 |     | <span class='neutral'>        uint160 priceAfter</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function increaseSampleLength(</span>
 32 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
 33 |     | <span class='neutral'>    ) external;</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/range/IRangePoolERC1155.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;../../base/structs/PoolsharkStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IRangePoolERC1155 is IERC165, PoolsharkStructs {</span>
  9 |     | <span class='neutral'>    event TransferSingle(</span>
 10 |     | <span class='neutral'>        address indexed sender,</span>
 11 |     | <span class='neutral'>        address indexed from,</span>
 12 |     | <span class='neutral'>        address indexed to,</span>
 13 |     | <span class='neutral'>        uint256 id,</span>
 14 |     | <span class='neutral'>        uint256 amount</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event TransferBatch(</span>
 18 |     | <span class='neutral'>        address indexed sender,</span>
 19 |     | <span class='neutral'>        address indexed from,</span>
 20 |     | <span class='neutral'>        address indexed to,</span>
 21 |     | <span class='neutral'>        uint256[] ids,</span>
 22 |     | <span class='neutral'>        uint256[] amounts</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    event ApprovalForAll(</span>
 26 |     | <span class='neutral'>        address indexed account,</span>
 27 |     | <span class='neutral'>        address indexed sender,</span>
 28 |     | <span class='neutral'>        bool approve</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) external view returns (uint256);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function balanceOfBatch(</span>
 38 |     | <span class='neutral'>        address[] calldata accounts,</span>
 39 |     | <span class='neutral'>        uint256[] calldata ids</span>
 40 |     | <span class='neutral'>    ) external view returns (</span>
 41 |     | <span class='neutral'>        uint256[] memory batchBalances</span>
 42 |     | <span class='neutral'>    );</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function totalSupply(uint256 id) external view returns (uint256);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function isApprovedForAll(address owner, address spender) external view returns (bool);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function setApprovalForAll(address sender, bool approved) external;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function mintFungible(</span>
 51 |     | <span class='neutral'>        address account,</span>
 52 |     | <span class='neutral'>        uint256 id,</span>
 53 |     | <span class='neutral'>        uint256 amount,</span>
 54 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 55 |     | <span class='neutral'>    ) external;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function burnFungible(</span>
 58 |     | <span class='neutral'>        address account,</span>
 59 |     | <span class='neutral'>        uint256 id,</span>
 60 |     | <span class='neutral'>        uint256 amount,</span>
 61 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 62 |     | <span class='neutral'>    ) external;</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function safeTransferFrom(</span>
 65 |     | <span class='neutral'>        address from,</span>
 66 |     | <span class='neutral'>        address to,</span>
 67 |     | <span class='neutral'>        uint256 id,</span>
 68 |     | <span class='neutral'>        uint256 amount</span>
 69 |     | <span class='neutral'>    ) external;</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 72 |     | <span class='neutral'>        address from,</span>
 73 |     | <span class='neutral'>        address to,</span>
 74 |     | <span class='neutral'>        uint256[] calldata id,</span>
 75 |     | <span class='neutral'>        uint256[] calldata amount</span>
 76 |     | <span class='neutral'>    ) external;</span>
 77 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/range/IRangePoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IRangePoolFactory {</span>
  5 |     | <span class='neutral'>    function createRangePool(</span>
  6 |     | <span class='neutral'>        address fromToken,</span>
  7 |     | <span class='neutral'>        address destToken,</span>
  8 |     | <span class='neutral'>        uint16 fee,</span>
  9 |     | <span class='neutral'>        uint160 startPrice</span>
 10 |     | <span class='neutral'>    ) external returns (address book);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function getRangePool(</span>
 13 |     | <span class='neutral'>        address fromToken,</span>
 14 |     | <span class='neutral'>        address destToken,</span>
 15 |     | <span class='neutral'>        uint256 fee</span>
 16 |     | <span class='neutral'>    ) external view returns (address);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function owner() external view returns(address);</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/range/IRangePoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./IRangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./IRangePoolERC1155.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IRangePoolManager {</span>
  8 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  9 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
 10 |     | <span class='neutral'>    function protocolFees(address pool) external view returns (uint16);</span>
 11 |     | <span class='neutral'>    function feeTiers(uint16 swapFee) external view returns (int24);</span>
 12 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/range/IRangePoolStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./IRangePoolERC1155.sol&quot;;</span>
   5 |     | <span class='neutral'>import &#39;../../base/structs/PoolsharkStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>interface IRangePoolStructs is PoolsharkStructs {</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    struct Position {</span>
  10 |     | <span class='neutral'>        uint256 feeGrowthInside0Last;</span>
  11 |     | <span class='neutral'>        uint256 feeGrowthInside1Last;</span>
  12 |     | <span class='neutral'>        uint128 liquidity;</span>
  13 |     | <span class='neutral'>        uint128 amount0;</span>
  14 |     | <span class='neutral'>        uint128 amount1;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct MintParams {</span>
  18 |     | <span class='neutral'>        address to;</span>
  19 |     | <span class='neutral'>        int24 lower;</span>
  20 |     | <span class='neutral'>        int24 upper;</span>
  21 |     | <span class='neutral'>        uint128 amount0;</span>
  22 |     | <span class='neutral'>        uint128 amount1;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct BurnParams {</span>
  26 |     | <span class='neutral'>        address to;</span>
  27 |     | <span class='neutral'>        int24 lower;</span>
  28 |     | <span class='neutral'>        int24 upper;</span>
  29 |     | <span class='neutral'>        uint128 burnPercent;</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    struct SnapshotParams {</span>
  33 |     | <span class='neutral'>        address owner;</span>
  34 |     | <span class='neutral'>        int24 lower;</span>
  35 |     | <span class='neutral'>        int24 upper;</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    struct CompoundParams {</span>
  39 |     | <span class='neutral'>        int24 lower;</span>
  40 |     | <span class='neutral'>        int24 upper;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct SampleParams {</span>
  44 |     | <span class='neutral'>        uint16 sampleIndex;</span>
  45 |     | <span class='neutral'>        uint16 sampleLength;</span>
  46 |     | <span class='neutral'>        uint32 time;</span>
  47 |     | <span class='neutral'>        uint32[] secondsAgo;</span>
  48 |     | <span class='neutral'>        int24 tick;</span>
  49 |     | <span class='neutral'>        uint128 liquidity;</span>
  50 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    struct AddParams {</span>
  54 |     | <span class='neutral'>        GlobalState state;</span>
  55 |     | <span class='neutral'>        MintParams mint;</span>
  56 |     | <span class='neutral'>        uint128 amount;</span>
  57 |     | <span class='neutral'>        uint128 liquidity;</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    struct RemoveParams {</span>
  61 |     | <span class='neutral'>        uint128 amount0;</span>
  62 |     | <span class='neutral'>        uint128 amount1;</span>
  63 |     | <span class='neutral'>        uint128 tokenBurned;</span>
  64 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    struct UpdateParams {</span>
  68 |     | <span class='neutral'>        int24 lower;</span>
  69 |     | <span class='neutral'>        int24 upper;</span>
  70 |     | <span class='neutral'>        uint128 burnPercent;</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    struct MintCache {</span>
  74 |     | <span class='neutral'>        GlobalState state;</span>
  75 |     | <span class='neutral'>        Position position;</span>
  76 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  77 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    struct BurnCache {</span>
  81 |     | <span class='neutral'>        GlobalState state;</span>
  82 |     | <span class='neutral'>        Position position;</span>
  83 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  84 |     | <span class='neutral'>        uint128 amount0;</span>
  85 |     | <span class='neutral'>        uint128 amount1;</span>
  86 |     | <span class='neutral'>        uint128 tokenBurned;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    struct PositionCache {</span>
  90 |     | <span class='neutral'>        uint160 priceLower;</span>
  91 |     | <span class='neutral'>        uint160 priceUpper;</span>
  92 |     | <span class='neutral'>        uint256 liquidityOnPosition;</span>
  93 |     | <span class='neutral'>        uint256 liquidityAmount;</span>
  94 |     | <span class='neutral'>        uint256 totalSupply;</span>
  95 |     | <span class='neutral'>        uint256 tokenId;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    struct UpdatePositionCache {</span>
  99 |     | <span class='neutral'>        uint256 totalSupply;</span>
 100 |     | <span class='neutral'>        uint256 tokenBurned;</span>
 101 |     | <span class='neutral'>        uint256 rangeFeeGrowth0;</span>
 102 |     | <span class='neutral'>        uint256 rangeFeeGrowth1;</span>
 103 |     | <span class='neutral'>        uint128 amountFees0;</span>
 104 |     | <span class='neutral'>        uint128 amountFees1;</span>
 105 |     | <span class='neutral'>        uint128 feesBurned0;</span>
 106 |     | <span class='neutral'>        uint128 feesBurned1;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    struct SnapshotCache {</span>
 110 |     | <span class='neutral'>        int24   tick;</span>
 111 |     | <span class='neutral'>        uint160 price;</span>
 112 |     | <span class='neutral'>        uint32  blockTimestamp;</span>
 113 |     | <span class='neutral'>        uint32  secondsOutsideLower;</span>
 114 |     | <span class='neutral'>        uint32  secondsOutsideUpper;</span>
 115 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
 116 |     | <span class='neutral'>        int56   tickSecondsAccumLower;</span>
 117 |     | <span class='neutral'>        int56   tickSecondsAccumUpper;</span>
 118 |     | <span class='neutral'>        uint128 liquidity;</span>
 119 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
 120 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumLower;</span>
 121 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumUpper;</span>
 122 |     | <span class='neutral'>        uint256 userBalance;</span>
 123 |     | <span class='neutral'>        uint256 totalSupply;</span>
 124 |     | <span class='neutral'>        Position position;</span>
 125 |     | <span class='neutral'>        SampleState samples;</span>
 126 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'>}</span>
 129 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/EchidnaAssertions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library EchidnaAssertions {</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);</span>
  9 |     | <span class='neutral'>    event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);</span>
 10 |     | <span class='neutral'>    event LiquidityUnlock(int128 liquidity);</span>
 11 |     | <span class='neutral'>    event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);</span>
 12 |     | <span class='neutral'>    event LiquidityDelta(int128 liquidityDelta);</span>
 13 |     | <span class='neutral'>    event WrongTickClaimedAt4(bool zeroForOne, int24 claimTickNext, int24 upper, int24 lower);</span>
 14 |     | <span class='neutral'>    event TickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {</span>
 17 |     | <span class='unexecuted'>        emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);</span>
 18 |     | <span class='neutral'>        assert(liquidityGlobal &gt;= amount);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 22 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 23 |     | <span class='unexecuted'>        assert(liquidity &gt;= amount);</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {</span>
 27 |     | <span class='unexecuted'>        emit LiquidityUnlock(liquidity);</span>
 28 |     | <span class='unexecuted'>        assert(liquidity &gt;= 0);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {</span>
 32 |     | <span class='unexecuted'>        emit PoolBalanceExceeded(poolBalance, outputAmount);</span>
 33 |     | <span class='unexecuted'>        assert(poolBalance &gt;= outputAmount);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>    function assertWrongTickClaimedAt4(bool zeroForOne, int24 claimTickNext, int24 upper, int24 lower) internal {</span>
 37 |     | <span class='unexecuted'>        emit WrongTickClaimedAt4(zeroForOne, claimTickNext, upper, lower);</span>
 38 |     | <span class='unexecuted'>        assert(false);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function assertTickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing) internal {</span>
 42 |     | <span class='unexecuted'>        emit TickAtPriceDivisibleByTickSpacing(tick, priceAt, tickSpacing);</span>
 43 |     | <span class='unexecuted'>        if(tick % tickSpacing == 0) assert(priceAt == 0);</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/TickMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../base/structs/PoolsharkStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library TickMap {</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    error TickIndexOverflow();</span>
  10 |     | <span class='neutral'>    error TickIndexUnderflow();</span>
  11 |     | <span class='neutral'>    error TickIndexBadSpacing();</span>
  12 |     | <span class='neutral'>    error BlockIndexOverflow();</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function get(</span>
  15 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  16 |     | <span class='neutral'>        int24 tick,</span>
  17 |     | <span class='neutral'>        int24 tickSpacing</span>
  18 |     | <span class='neutral'>    ) internal view returns (</span>
  19 |     | <span class='unexecuted'>        bool exists</span>
  20 |     | <span class='neutral'>    ) {</span>
  21 |     | <span class='unexecuted'>        (</span>
  22 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  23 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  24 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // check if bit is already set</span>
  27 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  28 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  29 |     | <span class='unexecuted'>            return true;</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='unexecuted'>        return false;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function set(</span>
  35 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  36 |     | <span class='neutral'>        int24 tick,</span>
  37 |     | <span class='neutral'>        int24 tickSpacing</span>
  38 |     | <span class='neutral'>    ) internal returns (</span>
  39 |     | <span class='unexecuted'>        bool exists</span>
  40 |     | <span class='neutral'>    ) {</span>
  41 |     | <span class='unexecuted'>        (</span>
  42 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  43 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  44 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  45 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // check if bit is already set</span>
  48 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  49 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  50 |     | <span class='unexecuted'>            return true;</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex]     = word; </span>
  54 |     | <span class='unexecuted'>        tickMap.words[blockIndex]   |= 1 &lt;&lt; (wordIndex &amp; 0xFF); // same as modulus 255</span>
  55 |     | <span class='unexecuted'>        tickMap.blocks              |= 1 &lt;&lt; blockIndex;</span>
  56 |     | <span class='neutral'>        return false;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function unset(</span>
  60 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  61 |     | <span class='neutral'>        int24 tick,</span>
  62 |     | <span class='neutral'>        int16 tickSpacing</span>
  63 |     | <span class='unexecuted'>    ) internal {</span>
  64 |     | <span class='unexecuted'>        (</span>
  65 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  66 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  67 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  68 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex] &amp;= ~(1 &lt;&lt; (tickIndex &amp; 0xFF));</span>
  71 |     | <span class='unexecuted'>        if (tickMap.ticks[wordIndex] == 0) {</span>
  72 |     | <span class='unexecuted'>            tickMap.words[blockIndex] &amp;= ~(1 &lt;&lt; (wordIndex &amp; 0xFF));</span>
  73 |     | <span class='unexecuted'>            if (tickMap.words[blockIndex] == 0) {</span>
  74 |     | <span class='unexecuted'>                tickMap.blocks &amp;= ~(1 &lt;&lt; blockIndex);</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function previous(</span>
  80 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  81 |     | <span class='neutral'>        int24 tick,</span>
  82 |     | <span class='neutral'>        int16 tickSpacing,</span>
  83 |     | <span class='neutral'>        bool inclusive</span>
  84 |     | <span class='neutral'>    ) internal view returns (</span>
  85 |     | <span class='unexecuted'>        int24 previousTick</span>
  86 |     | <span class='neutral'>    ) {</span>
  87 |     | <span class='unexecuted'>        unchecked {</span>
  88 |     | <span class='neutral'>            // rounds up to ensure relative position</span>
  89 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0 || inclusive) {</span>
  90 |     | <span class='unexecuted'>                if (tick &lt; (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {</span>
  91 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick &gt;= 0</span>
  92 |     | <span class='unexecuted'>                    if (tick &gt;= 0) {</span>
  93 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  94 |     | <span class='unexecuted'>                    } else if (inclusive &amp;&amp; tick % (tickSpacing / 2) == 0) {</span>
  95 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick == tickAtPrice</span>
  96 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  97 |     | <span class='neutral'>                    }</span>
  98 |     | <span class='neutral'>                }</span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='unexecuted'>            (</span>
 101 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 102 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 103 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 104 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>            uint256 word = tickMap.ticks[wordIndex] &amp; ((1 &lt;&lt; (tickIndex &amp; 0xFF)) - 1);</span>
 107 |     | <span class='unexecuted'>            if (word == 0) {</span>
 108 |     | <span class='unexecuted'>                uint256 block_ = tickMap.words[blockIndex] &amp; ((1 &lt;&lt; (wordIndex &amp; 0xFF)) - 1);</span>
 109 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 110 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ((1 &lt;&lt; blockIndex) - 1);</span>
 111 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>                    blockIndex = _msb(blockMap);</span>
 114 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 115 |     | <span class='neutral'>                }</span>
 116 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _msb(block_);</span>
 117 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='unexecuted'>            previousTick = _tick((wordIndex &lt;&lt; 8) | _msb(word), tickSpacing);</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function next(</span>
 124 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 125 |     | <span class='neutral'>        int24 tick,</span>
 126 |     | <span class='neutral'>        int16 tickSpacing,</span>
 127 |     | <span class='neutral'>        bool inclusive</span>
 128 |     | <span class='neutral'>    ) internal view returns (</span>
 129 |     | <span class='unexecuted'>        int24 nextTick</span>
 130 |     | <span class='neutral'>    ) {</span>
 131 |     | <span class='neutral'>        unchecked {</span>
 132 |     | <span class='neutral'>            /// @dev - handles tickAtPrice being past tickSpacing / 2</span>
 133 |     | <span class='unexecuted'>            if (inclusive &amp;&amp; tick % tickSpacing != 0) {</span>
 134 |     | <span class='unexecuted'>                tick -= 1;</span>
 135 |     | <span class='neutral'>            }</span>
 136 |     | <span class='neutral'>            /// @dev - handles negative ticks rounding up</span>
 137 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) {</span>
 138 |     | <span class='unexecuted'>                if (tick &lt; 0)</span>
 139 |     | <span class='unexecuted'>                    if (tick &gt; (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))</span>
 140 |     | <span class='unexecuted'>                        tick -= tickSpacing / 2;</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='unexecuted'>            (</span>
 143 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 144 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 145 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 146 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 147 |     | <span class='unexecuted'>            uint256 word;</span>
 148 |     | <span class='unexecuted'>            if ((tickIndex &amp; 0xFF) != 255) {</span>
 149 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex] &amp; ~((1 &lt;&lt; ((tickIndex &amp; 0xFF) + 1)) - 1);</span>
 150 |     | <span class='neutral'>            }</span>
 151 |     | <span class='unexecuted'>            if (word == 0) {</span>
 152 |     | <span class='unexecuted'>                uint256 block_;</span>
 153 |     | <span class='unexecuted'>                if ((blockIndex &amp; 0xFF) != 255) {</span>
 154 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex] &amp; ~((1 &lt;&lt; ((wordIndex &amp; 0xFF) + 1)) - 1);</span>
 155 |     | <span class='neutral'>                }</span>
 156 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 157 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ~((1 &lt;&lt; blockIndex + 1) - 1);</span>
 158 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 159 |     | <span class='unexecuted'>                    blockIndex = _lsb(blockMap);</span>
 160 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 161 |     | <span class='neutral'>                }</span>
 162 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _lsb(block_);</span>
 163 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 164 |     | <span class='neutral'>            }</span>
 165 |     | <span class='unexecuted'>            nextTick = _tick((wordIndex &lt;&lt; 8) | _lsb(word), tickSpacing);</span>
 166 |     | <span class='neutral'>        }</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='unexecuted'>    function getIndices(</span>
 170 |     | <span class='neutral'>        int24 tick,</span>
 171 |     | <span class='neutral'>        int24 tickSpacing</span>
 172 |     | <span class='neutral'>    ) public pure returns (</span>
 173 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 174 |     | <span class='neutral'>            uint256 wordIndex,</span>
 175 |     | <span class='neutral'>            uint256 blockIndex</span>
 176 |     | <span class='neutral'>        )</span>
 177 |     | <span class='neutral'>    {</span>
 178 |     | <span class='neutral'>        unchecked {</span>
 179 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.MAX_TICK) require(false, &#39; TickIndexOverflow()&#39;);</span>
 180 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.MIN_TICK) require(false, &#39;TickIndexUnderflow()&#39;);</span>
 181 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) tick = round(tick, tickSpacing / 2);</span>
 182 |     | <span class='unexecuted'>            tickIndex = uint256(int256((round(tick, tickSpacing / 2) </span>
 183 |     | <span class='unexecuted'>                                        - round(ConstantProduct.MIN_TICK, tickSpacing / 2)) </span>
 184 |     | <span class='unexecuted'>                                        / (tickSpacing / 2)));</span>
 185 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 8;   // 2^8 ticks per word</span>
 186 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 16; // 2^8 words per block</span>
 187 |     | <span class='unexecuted'>            if (blockIndex &gt; 255) require(false, &#39;BlockIndexOverflow()&#39;);</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>    function _tick (</span>
 194 |     | <span class='neutral'>        uint256 tickIndex,</span>
 195 |     | <span class='neutral'>        int24 tickSpacing</span>
 196 |     | <span class='neutral'>    ) internal pure returns (</span>
 197 |     | <span class='unexecuted'>        int24 tick</span>
 198 |     | <span class='neutral'>    ) {</span>
 199 |     | <span class='neutral'>        unchecked {</span>
 200 |     | <span class='unexecuted'>            if (tickIndex &gt; uint24(round(ConstantProduct.MAX_TICK, tickSpacing) * 2) * 2) </span>
 201 |     | <span class='unexecuted'>                require(false, &#39;TickIndexOverflow()&#39;);</span>
 202 |     | <span class='unexecuted'>            tick = int24(int256(tickIndex) * (tickSpacing / 2) + round(ConstantProduct.MIN_TICK, tickSpacing / 2));</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function _msb(</span>
 207 |     | <span class='neutral'>        uint256 x</span>
 208 |     | <span class='neutral'>    ) internal pure returns (</span>
 209 |     | <span class='unexecuted'>        uint8 r</span>
 210 |     | <span class='neutral'>    ) {</span>
 211 |     | <span class='neutral'>        unchecked {</span>
 212 |     | <span class='unexecuted'>            assert(x &gt; 0);</span>
 213 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000000000000000000000000000) {</span>
 214 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 215 |     | <span class='unexecuted'>                r += 128;</span>
 216 |     | <span class='neutral'>            }</span>
 217 |     | <span class='unexecuted'>            if (x &gt;= 0x10000000000000000) {</span>
 218 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 219 |     | <span class='unexecuted'>                r += 64;</span>
 220 |     | <span class='neutral'>            }</span>
 221 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000) {</span>
 222 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 223 |     | <span class='unexecuted'>                r += 32;</span>
 224 |     | <span class='neutral'>            }</span>
 225 |     | <span class='unexecuted'>            if (x &gt;= 0x10000) {</span>
 226 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 227 |     | <span class='unexecuted'>                r += 16;</span>
 228 |     | <span class='neutral'>            }</span>
 229 |     | <span class='unexecuted'>            if (x &gt;= 0x100) {</span>
 230 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 231 |     | <span class='unexecuted'>                r += 8;</span>
 232 |     | <span class='neutral'>            }</span>
 233 |     | <span class='unexecuted'>            if (x &gt;= 0x10) {</span>
 234 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 235 |     | <span class='unexecuted'>                r += 4;</span>
 236 |     | <span class='neutral'>            }</span>
 237 |     | <span class='unexecuted'>            if (x &gt;= 0x4) {</span>
 238 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 239 |     | <span class='unexecuted'>                r += 2;</span>
 240 |     | <span class='neutral'>            }</span>
 241 |     | <span class='unexecuted'>            if (x &gt;= 0x2) r += 1;</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>    function _lsb(</span>
 246 |     | <span class='neutral'>        uint256 x</span>
 247 |     | <span class='neutral'>    ) internal pure returns (</span>
 248 |     | <span class='unexecuted'>        uint8 r</span>
 249 |     | <span class='neutral'>    ) {</span>
 250 |     | <span class='neutral'>        unchecked {</span>
 251 |     | <span class='unexecuted'>            assert(x &gt; 0); // if x is 0 return 0</span>
 252 |     | <span class='unexecuted'>            r = 255;</span>
 253 |     | <span class='unexecuted'>            if (x &amp; type(uint128).max &gt; 0) {</span>
 254 |     | <span class='unexecuted'>                r -= 128;</span>
 255 |     | <span class='neutral'>            } else {</span>
 256 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 257 |     | <span class='neutral'>            }</span>
 258 |     | <span class='unexecuted'>            if (x &amp; type(uint64).max &gt; 0) {</span>
 259 |     | <span class='unexecuted'>                r -= 64;</span>
 260 |     | <span class='neutral'>            } else {</span>
 261 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 262 |     | <span class='neutral'>            }</span>
 263 |     | <span class='unexecuted'>            if (x &amp; type(uint32).max &gt; 0) {</span>
 264 |     | <span class='unexecuted'>                r -= 32;</span>
 265 |     | <span class='neutral'>            } else {</span>
 266 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 267 |     | <span class='neutral'>            }</span>
 268 |     | <span class='unexecuted'>            if (x &amp; type(uint16).max &gt; 0) {</span>
 269 |     | <span class='unexecuted'>                r -= 16;</span>
 270 |     | <span class='neutral'>            } else {</span>
 271 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 272 |     | <span class='neutral'>            }</span>
 273 |     | <span class='unexecuted'>            if (x &amp; type(uint8).max &gt; 0) {</span>
 274 |     | <span class='unexecuted'>                r -= 8;</span>
 275 |     | <span class='neutral'>            } else {</span>
 276 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 277 |     | <span class='neutral'>            }</span>
 278 |     | <span class='unexecuted'>            if (x &amp; 0xf &gt; 0) {</span>
 279 |     | <span class='unexecuted'>                r -= 4;</span>
 280 |     | <span class='neutral'>            } else {</span>
 281 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='unexecuted'>            if (x &amp; 0x3 &gt; 0) {</span>
 284 |     | <span class='unexecuted'>                r -= 2;</span>
 285 |     | <span class='neutral'>            } else {</span>
 286 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 287 |     | <span class='neutral'>            }</span>
 288 |     | <span class='unexecuted'>            if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>    function round(</span>
 293 |     | <span class='neutral'>        int24 tick,</span>
 294 |     | <span class='neutral'>        int24 tickSpacing</span>
 295 |     | <span class='neutral'>    ) internal pure returns (</span>
 296 |     | <span class='unexecuted'>        int24 roundedTick</span>
 297 |     | <span class='neutral'>    ) {</span>
 298 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>    function roundHalf(</span>
 302 |     | <span class='neutral'>        int24 tick,</span>
 303 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 304 |     | <span class='neutral'>        uint256 price</span>
 305 |     | <span class='neutral'>    ) internal pure returns (</span>
 306 |     | <span class='unexecuted'>        int24 roundedTick,</span>
 307 |     | <span class='neutral'>        uint160 roundedTickPrice</span>
 308 |     | <span class='neutral'>    ) {</span>
 309 |     | <span class='neutral'>        //pool.tickAtPrice -99.5</span>
 310 |     | <span class='neutral'>        //pool.tickAtPrice -100</span>
 311 |     | <span class='neutral'>        //-105</span>
 312 |     | <span class='neutral'>        //-95</span>
 313 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 314 |     | <span class='unexecuted'>        roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 315 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 316 |     | <span class='unexecuted'>            return (roundedTick, roundedTickPrice);</span>
 317 |     | <span class='unexecuted'>        if (roundedTick &gt; 0) {</span>
 318 |     | <span class='unexecuted'>            roundedTick += constants.tickSpacing / 2;</span>
 319 |     | <span class='unexecuted'>        } else if (roundedTick &lt; 0) {</span>
 320 |     | <span class='unexecuted'>            if (roundedTickPrice &lt; price)</span>
 321 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 322 |     | <span class='neutral'>            else</span>
 323 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 324 |     | <span class='neutral'>        } else {</span>
 325 |     | <span class='unexecuted'>            if (price &gt; roundedTickPrice) {</span>
 326 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 327 |     | <span class='unexecuted'>            } else if (price &lt; roundedTickPrice) {</span>
 328 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 329 |     | <span class='neutral'>            }</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='unexecuted'>    function roundAhead(</span>
 334 |     | <span class='neutral'>        int24 tick,</span>
 335 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 336 |     | <span class='neutral'>        bool zeroForOne,</span>
 337 |     | <span class='neutral'>        uint256 price</span>
 338 |     | <span class='neutral'>    ) internal pure returns (</span>
 339 |     | <span class='unexecuted'>        int24 roundedTick</span>
 340 |     | <span class='unexecuted'>    ) {</span>
 341 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 342 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 343 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 344 |     | <span class='unexecuted'>            return roundedTick;</span>
 345 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 346 |     | <span class='neutral'>            // round up if positive</span>
 347 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 348 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 349 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 350 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 351 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 352 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 353 |     | <span class='neutral'>                }</span>
 354 |     | <span class='neutral'>            }</span>
 355 |     | <span class='neutral'>        } else {</span>
 356 |     | <span class='neutral'>            // round down if negative</span>
 357 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 358 |     | <span class='neutral'>            /// @dev - strictly less due to TickMath always rounding to lesser values</span>
 359 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 360 |     | <span class='neutral'>        }</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='unexecuted'>    function roundBack(</span>
 364 |     | <span class='neutral'>        int24 tick,</span>
 365 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 366 |     | <span class='neutral'>        bool zeroForOne,</span>
 367 |     | <span class='neutral'>        uint256 price</span>
 368 |     | <span class='neutral'>    ) internal pure returns (</span>
 369 |     | <span class='unexecuted'>        int24 roundedTick</span>
 370 |     | <span class='unexecuted'>    ) {</span>
 371 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 372 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 373 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 374 |     | <span class='unexecuted'>            return roundedTick;</span>
 375 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 376 |     | <span class='neutral'>            // round down if negative</span>
 377 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 378 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 379 |     | <span class='neutral'>        } else {</span>
 380 |     | <span class='neutral'>            // round up if positive</span>
 381 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 382 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 383 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 384 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 385 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 386 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 387 |     | <span class='neutral'>                }</span>
 388 |     | <span class='neutral'>            }</span>
 389 |     | <span class='neutral'>        }</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/Ticks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../base/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./range/math/FeeMath.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./range/math/FeeMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./range/Samples.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./limit/EpochMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./limit/TicksLimit.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>library Ticks {</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    // constants for crossing ticks / limit pools</span>
  20 |     | <span class='unexecuted'>    uint8 internal constant RANGE_TICK = 2**0;</span>
  21 |     | <span class='unexecuted'>    uint8 internal constant LIMIT_TICK = 2**1;</span>
  22 |     | <span class='unexecuted'>    uint8 internal constant LIMIT_POOL = 2**2;</span>
  23 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    event Initialize(</span>
  26 |     | <span class='neutral'>        int24 minTick,</span>
  27 |     | <span class='neutral'>        int24 maxTick,</span>
  28 |     | <span class='neutral'>        uint160 startPrice,</span>
  29 |     | <span class='neutral'>        int24 startTick</span>
  30 |     | <span class='neutral'>    );</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    event Swap(</span>
  33 |     | <span class='neutral'>        address indexed recipient,</span>
  34 |     | <span class='neutral'>        bool zeroForOne,</span>
  35 |     | <span class='neutral'>        uint256 amountIn,</span>
  36 |     | <span class='neutral'>        uint256 amountOut,</span>
  37 |     | <span class='neutral'>        uint160 price,</span>
  38 |     | <span class='neutral'>        uint128 liquidity,</span>
  39 |     | <span class='neutral'>        uint128 feeAmount,</span>
  40 |     | <span class='neutral'>        int24 tickAtPrice</span>
  41 |     | <span class='neutral'>    );</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>    function initialize(</span>
  44 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  45 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  46 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  47 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
  48 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
  49 |     | <span class='neutral'>        uint160 startPrice</span>
  50 |     | <span class='neutral'>    ) internal returns (</span>
  51 |     | <span class='unexecuted'>        ILimitPoolStructs.GlobalState memory</span>
  52 |     | <span class='neutral'>    ) {</span>
  53 |     | <span class='neutral'>        // state should only be initialized once</span>
  54 |     | <span class='unexecuted'>        if (state.pool0.price &gt; 0) require (false, &#39;PoolAlreadyInitialized()&#39;);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        // initialize epoch</span>
  57 |     | <span class='unexecuted'>        state.epoch = 1;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // check price bounds</span>
  60 |     | <span class='unexecuted'>        if (startPrice &lt; constants.bounds.min || startPrice &gt;= constants.bounds.max) require(false, &#39;StartPriceInvalid()&#39;);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // initialize range ticks</span>
  63 |     | <span class='unexecuted'>        TickMap.set(rangeTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  64 |     | <span class='unexecuted'>        TickMap.set(rangeTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  65 |     | <span class='neutral'>        </span>
  66 |     | <span class='neutral'>        // initialize limit ticks</span>
  67 |     | <span class='unexecuted'>        TickMap.set(limitTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  68 |     | <span class='unexecuted'>        TickMap.set(limitTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>        // initialize price</span>
  71 |     | <span class='unexecuted'>        state.pool.price = startPrice;</span>
  72 |     | <span class='unexecuted'>        state.pool0.price = startPrice;</span>
  73 |     | <span class='unexecuted'>        state.pool1.price = startPrice;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        int24 startTick = ConstantProduct.getTickAtPrice(startPrice, constants);</span>
  76 |     | <span class='unexecuted'>        state.pool.tickAtPrice = startTick;</span>
  77 |     | <span class='unexecuted'>        state.pool0.tickAtPrice = startTick;</span>
  78 |     | <span class='unexecuted'>        state.pool1.tickAtPrice = startTick;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>        // intialize samples</span>
  81 |     | <span class='unexecuted'>        state.pool = Samples.initialize(samples, state.pool);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // emit event</span>
  84 |     | <span class='unexecuted'>        emit Initialize(</span>
  85 |     | <span class='unexecuted'>            ConstantProduct.minTick(constants.tickSpacing),</span>
  86 |     | <span class='unexecuted'>            ConstantProduct.maxTick(constants.tickSpacing),</span>
  87 |     | <span class='unexecuted'>            state.pool0.price,</span>
  88 |     | <span class='unexecuted'>            state.pool0.tickAtPrice</span>
  89 |     | <span class='neutral'>        );</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>        return state;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'>    </span>
  94 |     | <span class='unexecuted'>    function swap(</span>
  95 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  96 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  97 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  98 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  99 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
 100 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 101 |     | <span class='neutral'>    ) internal returns (</span>
 102 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 103 |     | <span class='neutral'>    )</span>
 104 |     | <span class='neutral'>    {   </span>
 105 |     | <span class='neutral'>        // start with range price</span>
 106 |     | <span class='unexecuted'>        cache.price = cache.state.pool.price;</span>
 107 |     | <span class='unexecuted'>        cache.crossTick = cache.state.pool.tickAtPrice;</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        uint128 startLiquidity = cache.liquidity.toUint128();</span>
 112 |     | <span class='neutral'>        </span>
 113 |     | <span class='neutral'>        // set crossTick/crossPrice based on the best between limit and range</span>
 114 |     | <span class='neutral'>        // grab sample for accumulators</span>
 115 |     | <span class='unexecuted'>        cache = PoolsharkStructs.SwapCache({</span>
 116 |     | <span class='unexecuted'>            state: cache.state,</span>
 117 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 118 |     | <span class='unexecuted'>            price: cache.price,</span>
 119 |     | <span class='unexecuted'>            liquidity: cache.liquidity,</span>
 120 |     | <span class='unexecuted'>            amountLeft: params.amount,</span>
 121 |     | <span class='neutral'>            input:  0,</span>
 122 |     | <span class='neutral'>            output: 0,</span>
 123 |     | <span class='unexecuted'>            crossPrice: cache.crossPrice,</span>
 124 |     | <span class='neutral'>            secondsPerLiquidityAccum: 0,</span>
 125 |     | <span class='neutral'>            feeAmount: 0,</span>
 126 |     | <span class='neutral'>            tickSecondsAccum: 0,</span>
 127 |     | <span class='unexecuted'>            crossTick: cache.crossTick,</span>
 128 |     | <span class='unexecuted'>            crossStatus: cache.crossStatus,</span>
 129 |     | <span class='unexecuted'>            limitActive: cache.limitActive,</span>
 130 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 131 |     | <span class='unexecuted'>            cross: true</span>
 132 |     | <span class='neutral'>        });</span>
 133 |     | <span class='neutral'>        // should be calculated at each step for dynamic fee</span>
 134 |     | <span class='unexecuted'>        if (!cache.exactIn) cache.amountLeft = OverflowMath.mulDivRoundingUp(uint256(params.amount), 1e6, (1e6 - cache.constants.swapFee));</span>
 135 |     | <span class='neutral'>        // grab latest sample and store in cache for _cross</span>
 136 |     | <span class='unexecuted'>        (</span>
 137 |     | <span class='unexecuted'>            cache.tickSecondsAccum,</span>
 138 |     | <span class='unexecuted'>            cache.secondsPerLiquidityAccum</span>
 139 |     | <span class='unexecuted'>        ) = Samples.getSingle(</span>
 140 |     | <span class='unexecuted'>                IPool(address(this)), </span>
 141 |     | <span class='unexecuted'>                IRangePoolStructs.SampleParams(</span>
 142 |     | <span class='unexecuted'>                    cache.state.pool.samples.index,</span>
 143 |     | <span class='unexecuted'>                    cache.state.pool.samples.length,</span>
 144 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 145 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 146 |     | <span class='unexecuted'>                    cache.state.pool.tickAtPrice,</span>
 147 |     | <span class='unexecuted'>                    cache.liquidity.toUint128(),</span>
 148 |     | <span class='unexecuted'>                    cache.constants</span>
 149 |     | <span class='neutral'>                ),</span>
 150 |     | <span class='neutral'>                0</span>
 151 |     | <span class='neutral'>        );</span>
 152 |     | <span class='neutral'>        // increment swap epoch</span>
 153 |     | <span class='unexecuted'>        cache.state.epoch += 1;</span>
 154 |     | <span class='neutral'>        // grab latest sample and store in cache for _cross</span>
 155 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 156 |     | <span class='neutral'>            // handle price being at cross tick</span>
 157 |     | <span class='unexecuted'>            cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);</span>
 158 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 159 |     | <span class='unexecuted'>                cache = _cross(</span>
 160 |     | <span class='unexecuted'>                    ticks,</span>
 161 |     | <span class='unexecuted'>                    rangeTickMap,</span>
 162 |     | <span class='unexecuted'>                    limitTickMap,</span>
 163 |     | <span class='unexecuted'>                    cache,</span>
 164 |     | <span class='unexecuted'>                    params</span>
 165 |     | <span class='neutral'>                );</span>
 166 |     | <span class='neutral'>            }</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        /// @dev - write oracle entry after start of block</span>
 169 |     | <span class='unexecuted'>        (</span>
 170 |     | <span class='unexecuted'>            cache.state.pool.samples.index,</span>
 171 |     | <span class='unexecuted'>            cache.state.pool.samples.length</span>
 172 |     | <span class='unexecuted'>        ) = Samples.save(</span>
 173 |     | <span class='unexecuted'>            samples,</span>
 174 |     | <span class='unexecuted'>            cache.state.pool.samples,</span>
 175 |     | <span class='unexecuted'>            startLiquidity,</span>
 176 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice</span>
 177 |     | <span class='neutral'>        );</span>
 178 |     | <span class='neutral'>        // pool liquidity should be updated along the way</span>
 179 |     | <span class='unexecuted'>        cache.state.pool.price = cache.price.toUint160();</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        if (cache.price != cache.crossPrice) {</span>
 182 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice = ConstantProduct.getTickAtPrice(cache.price.toUint160(), cache.constants);</span>
 183 |     | <span class='neutral'>        } else {</span>
 184 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice = cache.crossTick;</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='unexecuted'>        if (cache.limitActive) {</span>
 187 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 188 |     | <span class='unexecuted'>                cache.state.pool1.price = cache.state.pool.price;</span>
 189 |     | <span class='unexecuted'>                cache.state.pool1.tickAtPrice = cache.state.pool.tickAtPrice;</span>
 190 |     | <span class='neutral'>            } else {</span>
 191 |     | <span class='unexecuted'>                cache.state.pool0.price = cache.state.pool.price;</span>
 192 |     | <span class='unexecuted'>                cache.state.pool0.tickAtPrice = cache.state.pool.tickAtPrice;</span>
 193 |     | <span class='neutral'>            }</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='unexecuted'>        emit Swap(</span>
 196 |     | <span class='unexecuted'>            params.to,</span>
 197 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 198 |     | <span class='unexecuted'>            cache.input,</span>
 199 |     | <span class='unexecuted'>            cache.output,</span>
 200 |     | <span class='unexecuted'>            cache.price.toUint160(),</span>
 201 |     | <span class='unexecuted'>            cache.liquidity.toUint128(),</span>
 202 |     | <span class='unexecuted'>            cache.feeAmount,</span>
 203 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice</span>
 204 |     | <span class='neutral'>        );</span>
 205 |     | <span class='unexecuted'>        return cache;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>    function quote(</span>
 209 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 210 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 211 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 212 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params,</span>
 213 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 214 |     | <span class='neutral'>    ) internal view returns (</span>
 215 |     | <span class='unexecuted'>        uint256,</span>
 216 |     | <span class='neutral'>        uint256,</span>
 217 |     | <span class='neutral'>        uint160</span>
 218 |     | <span class='neutral'>    ) {</span>
 219 |     | <span class='neutral'>        // start with range price</span>
 220 |     | <span class='unexecuted'>        cache.price = cache.state.pool.price;</span>
 221 |     | <span class='unexecuted'>        cache.crossTick = cache.state.pool.tickAtPrice;</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);</span>
 224 |     | <span class='neutral'>        </span>
 225 |     | <span class='neutral'>        // set crossTick/crossPrice based on the best between limit and range</span>
 226 |     | <span class='neutral'>        // grab sample for accumulators</span>
 227 |     | <span class='unexecuted'>        cache = PoolsharkStructs.SwapCache({</span>
 228 |     | <span class='unexecuted'>            state: cache.state,</span>
 229 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 230 |     | <span class='unexecuted'>            price: cache.price,</span>
 231 |     | <span class='unexecuted'>            liquidity: cache.liquidity,</span>
 232 |     | <span class='unexecuted'>            amountLeft: params.amount,</span>
 233 |     | <span class='neutral'>            input:  0,</span>
 234 |     | <span class='neutral'>            output: 0,</span>
 235 |     | <span class='unexecuted'>            crossPrice: cache.crossPrice,</span>
 236 |     | <span class='neutral'>            secondsPerLiquidityAccum: 0,</span>
 237 |     | <span class='neutral'>            feeAmount: 0,</span>
 238 |     | <span class='neutral'>            tickSecondsAccum: 0,</span>
 239 |     | <span class='unexecuted'>            crossTick: cache.crossTick,</span>
 240 |     | <span class='unexecuted'>            crossStatus: cache.crossStatus,</span>
 241 |     | <span class='unexecuted'>            limitActive: cache.limitActive,</span>
 242 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 243 |     | <span class='unexecuted'>            cross: true</span>
 244 |     | <span class='neutral'>        });</span>
 245 |     | <span class='neutral'>        // should be calculated at each step for dynamic fee</span>
 246 |     | <span class='unexecuted'>        if (!cache.exactIn) cache.amountLeft = OverflowMath.mulDivRoundingUp(uint256(params.amount), 1e6, (1e6 - cache.constants.swapFee));</span>
 247 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 248 |     | <span class='unexecuted'>            cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);</span>
 249 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 250 |     | <span class='unexecuted'>                cache = _pass(</span>
 251 |     | <span class='unexecuted'>                    ticks,</span>
 252 |     | <span class='unexecuted'>                    rangeTickMap,</span>
 253 |     | <span class='unexecuted'>                    limitTickMap,</span>
 254 |     | <span class='unexecuted'>                    cache,</span>
 255 |     | <span class='unexecuted'>                    params</span>
 256 |     | <span class='neutral'>                );</span>
 257 |     | <span class='neutral'>            }</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'>        return (</span>
 260 |     | <span class='unexecuted'>            cache.input,</span>
 261 |     | <span class='unexecuted'>            cache.output,</span>
 262 |     | <span class='unexecuted'>            cache.price.toUint160()</span>
 263 |     | <span class='neutral'>        );</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>    function _quoteSingle(</span>
 267 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 268 |     | <span class='neutral'>        uint160 priceLimit,</span>
 269 |     | <span class='neutral'>        bool zeroForOne</span>
 270 |     | <span class='neutral'>    ) internal pure returns (</span>
 271 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 272 |     | <span class='neutral'>    ) {</span>
 273 |     | <span class='unexecuted'>        if ((zeroForOne ? priceLimit &gt;= cache.price</span>
 274 |     | <span class='unexecuted'>                        : priceLimit &lt;= cache.price) ||</span>
 275 |     | <span class='unexecuted'>            (zeroForOne &amp;&amp; cache.price == cache.constants.bounds.min) ||</span>
 276 |     | <span class='unexecuted'>            (!zeroForOne &amp;&amp; cache.price == cache.constants.bounds.max) ||</span>
 277 |     | <span class='unexecuted'>            (cache.amountLeft == 0 &amp;&amp; cache.liquidity &gt; 0))</span>
 278 |     | <span class='neutral'>        {</span>
 279 |     | <span class='unexecuted'>            cache.cross = false;</span>
 280 |     | <span class='unexecuted'>            return cache;</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='unexecuted'>        uint256 nextPrice = cache.crossPrice;</span>
 283 |     | <span class='neutral'>        uint256 amountOut;</span>
 284 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 285 |     | <span class='neutral'>            // Trading token 0 (x) for token 1 (y).</span>
 286 |     | <span class='neutral'>            // price  is decreasing.</span>
 287 |     | <span class='unexecuted'>            if (nextPrice &lt; priceLimit) {</span>
 288 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 289 |     | <span class='neutral'>            }</span>
 290 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)</span>
 291 |     | <span class='unexecuted'>                                              : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 292 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 293 |     | <span class='neutral'>                // We can swap within the current range.</span>
 294 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(cache.liquidity) &lt;&lt; 96;</span>
 295 |     | <span class='neutral'>                // calculate price after swap</span>
 296 |     | <span class='neutral'>                uint256 newPrice;</span>
 297 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 298 |     | <span class='unexecuted'>                    newPrice = OverflowMath.mulDivRoundingUp(</span>
 299 |     | <span class='unexecuted'>                        liquidityPadded,</span>
 300 |     | <span class='unexecuted'>                        cache.price,</span>
 301 |     | <span class='unexecuted'>                        liquidityPadded + uint256(cache.price) * uint256(cache.amountLeft)</span>
 302 |     | <span class='neutral'>                    );</span>
 303 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, newPrice, uint256(cache.price), false);</span>
 304 |     | <span class='unexecuted'>                    cache.input += cache.amountLeft;</span>
 305 |     | <span class='neutral'>                } else {</span>
 306 |     | <span class='unexecuted'>                    newPrice = cache.price - </span>
 307 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(cache.amountLeft &lt;&lt; 96, cache.liquidity);</span>
 308 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 309 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDx(cache.liquidity, newPrice, uint256(cache.price), true);</span>
 310 |     | <span class='neutral'>                }</span>
 311 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 312 |     | <span class='unexecuted'>                cache.cross = false;</span>
 313 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 314 |     | <span class='neutral'>            } else {</span>
 315 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 316 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 317 |     | <span class='unexecuted'>                    cache.input += amountMax;</span>
 318 |     | <span class='neutral'>                } else {</span>
 319 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 320 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true);</span>
 321 |     | <span class='neutral'>                }</span>
 322 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 323 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) cache.cross = true;</span>
 324 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 325 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 326 |     | <span class='neutral'>            }</span>
 327 |     | <span class='unexecuted'>        } else {</span>
 328 |     | <span class='neutral'>            // Price is increasing.</span>
 329 |     | <span class='unexecuted'>            if (nextPrice &gt; priceLimit) {</span>
 330 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)</span>
 333 |     | <span class='unexecuted'>                                              : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);</span>
 334 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 335 |     | <span class='unexecuted'>                uint256 newPrice;</span>
 336 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 337 |     | <span class='unexecuted'>                    newPrice = cache.price +</span>
 338 |     | <span class='unexecuted'>                        OverflowMath.mulDiv(cache.amountLeft, Q96, cache.liquidity);</span>
 339 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);</span>
 340 |     | <span class='unexecuted'>                    cache.input += cache.amountLeft;</span>
 341 |     | <span class='neutral'>                } else {</span>
 342 |     | <span class='unexecuted'>                    uint256 liquidityPadded = uint256(cache.liquidity) &lt;&lt; 96;</span>
 343 |     | <span class='unexecuted'>                    newPrice = OverflowMath.mulDivRoundingUp(</span>
 344 |     | <span class='neutral'>                        liquidityPadded, </span>
 345 |     | <span class='unexecuted'>                        cache.price,</span>
 346 |     | <span class='unexecuted'>                        liquidityPadded - uint256(cache.price) * cache.amountLeft</span>
 347 |     | <span class='neutral'>                    );</span>
 348 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 349 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true);</span>
 350 |     | <span class='neutral'>                }</span>
 351 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 352 |     | <span class='unexecuted'>                cache.cross = false;</span>
 353 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 354 |     | <span class='neutral'>            } else {</span>
 355 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 356 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);</span>
 357 |     | <span class='unexecuted'>                    cache.input += amountMax;</span>
 358 |     | <span class='neutral'>                } else {</span>
 359 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 360 |     | <span class='unexecuted'>                    cache.input += ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true);</span>
 361 |     | <span class='neutral'>                }</span>
 362 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 363 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) cache.cross = true;</span>
 364 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 365 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 366 |     | <span class='neutral'>            }</span>
 367 |     | <span class='neutral'>        }</span>
 368 |     | <span class='unexecuted'>        cache = FeeMath.calculate(cache, amountOut, zeroForOne);</span>
 369 |     | <span class='neutral'>        return cache;</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='unexecuted'>    function _cross(</span>
 373 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 374 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 375 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 376 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 377 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params</span>
 378 |     | <span class='neutral'>    ) internal returns (</span>
 379 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 380 |     | <span class='neutral'>    ) {</span>
 381 |     | <span class='neutral'>        // crossing range ticks</span>
 382 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; RANGE_TICK) &gt; 0) {</span>
 383 |     | <span class='unexecuted'>            PoolsharkStructs.RangeTick memory crossTick = ticks[cache.crossTick].range;</span>
 384 |     | <span class='unexecuted'>            crossTick.feeGrowthOutside0       = cache.state.pool.feeGrowthGlobal0 - crossTick.feeGrowthOutside0;</span>
 385 |     | <span class='unexecuted'>            crossTick.feeGrowthOutside1       = cache.state.pool.feeGrowthGlobal1 - crossTick.feeGrowthOutside1;</span>
 386 |     | <span class='unexecuted'>            crossTick.tickSecondsAccumOutside = cache.tickSecondsAccum - crossTick.tickSecondsAccumOutside;</span>
 387 |     | <span class='unexecuted'>            crossTick.secondsPerLiquidityAccumOutside = cache.secondsPerLiquidityAccum - crossTick.secondsPerLiquidityAccumOutside;</span>
 388 |     | <span class='unexecuted'>            ticks[cache.crossTick].range = crossTick;</span>
 389 |     | <span class='neutral'>            int128 liquidityDelta = crossTick.liquidityDelta;</span>
 390 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 391 |     | <span class='neutral'>                unchecked {</span>
 392 |     | <span class='unexecuted'>                    if (liquidityDelta &gt;= 0){</span>
 393 |     | <span class='unexecuted'>                        cache.state.pool.liquidity -= uint128(liquidityDelta);</span>
 394 |     | <span class='neutral'>                    } else {</span>
 395 |     | <span class='unexecuted'>                        cache.state.pool.liquidity += uint128(-liquidityDelta); </span>
 396 |     | <span class='neutral'>                    }</span>
 397 |     | <span class='neutral'>                }</span>
 398 |     | <span class='neutral'>            } else {</span>
 399 |     | <span class='neutral'>                unchecked {</span>
 400 |     | <span class='unexecuted'>                    if (liquidityDelta &gt;= 0) {</span>
 401 |     | <span class='unexecuted'>                        cache.state.pool.liquidity += uint128(liquidityDelta);</span>
 402 |     | <span class='neutral'>                    } else {</span>
 403 |     | <span class='unexecuted'>                        cache.state.pool.liquidity -= uint128(-liquidityDelta);</span>
 404 |     | <span class='neutral'>                    }</span>
 405 |     | <span class='neutral'>                }</span>
 406 |     | <span class='neutral'>            }</span>
 407 |     | <span class='neutral'>            /// @dev - price and tickAtPrice updated at end of loop</span>
 408 |     | <span class='neutral'>        }</span>
 409 |     | <span class='neutral'>        // crossing limit tick</span>
 410 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_TICK) &gt; 0) {</span>
 411 |     | <span class='neutral'>            // cross limit tick</span>
 412 |     | <span class='unexecuted'>            EpochMap.set(cache.crossTick, !params.zeroForOne, cache.state.epoch, limitTickMap, cache.constants);</span>
 413 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='unexecuted'>            if (liquidityDelta &gt;= 0) {</span>
 416 |     | <span class='unexecuted'>                cache.liquidity += uint128(liquidityDelta);</span>
 417 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity += uint128(liquidityDelta);</span>
 418 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity += uint128(liquidityDelta);</span>
 419 |     | <span class='neutral'>            }</span>
 420 |     | <span class='neutral'>            else {</span>
 421 |     | <span class='unexecuted'>                cache.liquidity -= uint128(-liquidityDelta);</span>
 422 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity -= uint128(-liquidityDelta);</span>
 423 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity -= uint128(-liquidityDelta);</span>
 424 |     | <span class='neutral'>            }</span>
 425 |     | <span class='neutral'>            // zero out liquidityDelta and priceAt</span>
 426 |     | <span class='unexecuted'>            ticks[cache.crossTick].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 427 |     | <span class='unexecuted'>            TicksLimit.clear(ticks, cache.constants, limitTickMap, cache.crossTick);</span>
 428 |     | <span class='neutral'>            /// @dev - price and tickAtPrice updated at end of loop</span>
 429 |     | <span class='neutral'>        }</span>
 430 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_POOL) &gt; 0) {</span>
 431 |     | <span class='neutral'>            // add limit pool</span>
 432 |     | <span class='unexecuted'>            uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity</span>
 433 |     | <span class='unexecuted'>                                                       : cache.state.pool0.liquidity;</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) cache.liquidity += liquidityDelta;</span>
 436 |     | <span class='neutral'>        }</span>
 437 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        return cache;</span>
 440 |     | <span class='neutral'>    }</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='unexecuted'>    function _pass(</span>
 443 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 444 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 445 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 446 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 447 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params</span>
 448 |     | <span class='neutral'>    ) internal view returns (</span>
 449 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 450 |     | <span class='neutral'>    ) {</span>
 451 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; RANGE_TICK) &gt; 0) {</span>
 452 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].range.liquidityDelta;</span>
 453 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 454 |     | <span class='neutral'>                unchecked {</span>
 455 |     | <span class='unexecuted'>                    if (liquidityDelta &gt;= 0){</span>
 456 |     | <span class='unexecuted'>                        cache.state.pool.liquidity -= uint128(liquidityDelta);</span>
 457 |     | <span class='neutral'>                    } else {</span>
 458 |     | <span class='unexecuted'>                        cache.state.pool.liquidity += uint128(-liquidityDelta);</span>
 459 |     | <span class='neutral'>                    }</span>
 460 |     | <span class='neutral'>                }</span>
 461 |     | <span class='neutral'>            } else {</span>
 462 |     | <span class='neutral'>                unchecked {</span>
 463 |     | <span class='unexecuted'>                    if (liquidityDelta &gt;= 0) {</span>
 464 |     | <span class='unexecuted'>                        cache.state.pool.liquidity += uint128(liquidityDelta);</span>
 465 |     | <span class='neutral'>                    } else {</span>
 466 |     | <span class='unexecuted'>                        cache.state.pool.liquidity -= uint128(-liquidityDelta);</span>
 467 |     | <span class='neutral'>                    }</span>
 468 |     | <span class='neutral'>                }</span>
 469 |     | <span class='neutral'>            }</span>
 470 |     | <span class='neutral'>        }</span>
 471 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_TICK) &gt; 0) {</span>
 472 |     | <span class='neutral'>            // cross limit tick</span>
 473 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;</span>
 474 |     | <span class='neutral'></span>
 475 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) {</span>
 476 |     | <span class='unexecuted'>                cache.liquidity += uint128(liquidityDelta);</span>
 477 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity += uint128(liquidityDelta);</span>
 478 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity += uint128(liquidityDelta);</span>
 479 |     | <span class='neutral'>            } </span>
 480 |     | <span class='neutral'>            else {</span>
 481 |     | <span class='unexecuted'>                cache.liquidity -= uint128(-liquidityDelta);</span>
 482 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 483 |     | <span class='unexecuted'>                    cache.state.pool1.liquidity -= uint128(-liquidityDelta);</span>
 484 |     | <span class='neutral'>                } else {</span>
 485 |     | <span class='unexecuted'>                    cache.state.pool0.liquidity -= uint128(-liquidityDelta);</span>
 486 |     | <span class='neutral'>                }</span>
 487 |     | <span class='neutral'>            }</span>
 488 |     | <span class='neutral'>        }</span>
 489 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_POOL) &gt; 0) {</span>
 490 |     | <span class='neutral'>            // add limit pool</span>
 491 |     | <span class='unexecuted'>            uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity</span>
 492 |     | <span class='unexecuted'>                                                       : cache.state.pool0.liquidity;</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) {</span>
 495 |     | <span class='unexecuted'>                cache.liquidity += liquidityDelta;</span>
 496 |     | <span class='neutral'>            }</span>
 497 |     | <span class='neutral'>        }</span>
 498 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>        return cache;</span>
 501 |     | <span class='neutral'>    }</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='unexecuted'>    function _iterate(</span>
 504 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 505 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 506 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 507 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 508 |     | <span class='neutral'>        bool zeroForOne,</span>
 509 |     | <span class='neutral'>        bool inclusive</span>
 510 |     | <span class='neutral'>    ) internal view returns (</span>
 511 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory </span>
 512 |     | <span class='neutral'>    )    </span>
 513 |     | <span class='neutral'>    {</span>
 514 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 515 |     | <span class='unexecuted'>            if (cache.price &gt; cache.state.pool1.price) {</span>
 516 |     | <span class='neutral'>                // load range pool</span>
 517 |     | <span class='unexecuted'>                cache.limitActive = false;</span>
 518 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity;</span>
 519 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 520 |     | <span class='neutral'>                // next range tick vs. limit pool price</span>
 521 |     | <span class='unexecuted'>                cache.crossTick = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 522 |     | <span class='unexecuted'>                cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 523 |     | <span class='unexecuted'>                if (cache.state.pool1.price &gt;= cache.crossPrice) {</span>
 524 |     | <span class='neutral'>                    // cross into limit pool</span>
 525 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_POOL;</span>
 526 |     | <span class='unexecuted'>                    if (cache.state.pool1.price == cache.crossPrice)</span>
 527 |     | <span class='neutral'>                        // also cross range tick</span>
 528 |     | <span class='unexecuted'>                        cache.crossStatus |= RANGE_TICK;</span>
 529 |     | <span class='neutral'>                    else {</span>
 530 |     | <span class='unexecuted'>                        cache.crossTick = cache.state.pool1.tickAtPrice;</span>
 531 |     | <span class='unexecuted'>                        cache.crossPrice = cache.state.pool1.price;</span>
 532 |     | <span class='neutral'>                    }</span>
 533 |     | <span class='neutral'>                }</span>
 534 |     | <span class='neutral'>                else {</span>
 535 |     | <span class='neutral'>                    // cross only range tick</span>
 536 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 537 |     | <span class='neutral'>                }</span>
 538 |     | <span class='unexecuted'>            } else {</span>
 539 |     | <span class='neutral'>                // load range and limit pools</span>
 540 |     | <span class='unexecuted'>                cache.limitActive = true;</span>
 541 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity + cache.state.pool1.liquidity;</span>
 542 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 543 |     | <span class='neutral'>                // next range tick vs. next limit tick</span>
 544 |     | <span class='unexecuted'>                int24 rangeTickAhead = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 545 |     | <span class='unexecuted'>                int24 limitTickAhead = TickMap.previous(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 546 |     | <span class='unexecuted'>                if (rangeTickAhead &gt;= limitTickAhead) {</span>
 547 |     | <span class='unexecuted'>                    cache.crossTick = rangeTickAhead;</span>
 548 |     | <span class='neutral'>                    // cross range tick</span>
 549 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 550 |     | <span class='unexecuted'>                    if (rangeTickAhead == limitTickAhead)</span>
 551 |     | <span class='neutral'>                        // also cross limit tick</span>
 552 |     | <span class='unexecuted'>                        cache.crossStatus |= LIMIT_TICK;</span>
 553 |     | <span class='unexecuted'>                    cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 554 |     | <span class='neutral'>                } else {</span>
 555 |     | <span class='neutral'>                    // only cross limit tick</span>
 556 |     | <span class='unexecuted'>                    cache.crossTick = limitTickAhead;</span>
 557 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_TICK;</span>
 558 |     | <span class='unexecuted'>                    cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 559 |     | <span class='unexecuted'>                                                                                 : ticks[cache.crossTick].limit.priceAt;</span>
 560 |     | <span class='neutral'>                }</span>
 561 |     | <span class='neutral'>            }</span>
 562 |     | <span class='neutral'>        } else {</span>
 563 |     | <span class='unexecuted'>            if (cache.price &lt; cache.state.pool0.price) {</span>
 564 |     | <span class='neutral'>                // load range pool</span>
 565 |     | <span class='unexecuted'>                cache.limitActive = false;</span>
 566 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity;</span>
 567 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 568 |     | <span class='neutral'>                // next range tick vs. limit pool price</span>
 569 |     | <span class='unexecuted'>                cache.crossTick = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 570 |     | <span class='unexecuted'>                cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 571 |     | <span class='unexecuted'>                if (cache.state.pool0.price &lt;= cache.crossPrice) {</span>
 572 |     | <span class='neutral'>                    // cross into limit pool</span>
 573 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_POOL;</span>
 574 |     | <span class='unexecuted'>                    if (cache.state.pool0.price == cache.crossPrice)</span>
 575 |     | <span class='neutral'>                        // also cross range tick</span>
 576 |     | <span class='unexecuted'>                        cache.crossStatus |= RANGE_TICK;</span>
 577 |     | <span class='neutral'>                    else {</span>
 578 |     | <span class='unexecuted'>                        cache.crossTick = cache.state.pool0.tickAtPrice;</span>
 579 |     | <span class='unexecuted'>                        cache.crossPrice = cache.state.pool0.price;</span>
 580 |     | <span class='neutral'>                    }</span>
 581 |     | <span class='neutral'>                }</span>
 582 |     | <span class='neutral'>                else {</span>
 583 |     | <span class='neutral'>                    // cross only range tick</span>
 584 |     | <span class='neutral'>                    cache.crossStatus = RANGE_TICK;</span>
 585 |     | <span class='neutral'>                }</span>
 586 |     | <span class='unexecuted'>            } else {</span>
 587 |     | <span class='neutral'>                // load range and limit pools</span>
 588 |     | <span class='unexecuted'>                cache.limitActive = true;</span>
 589 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity + cache.state.pool0.liquidity;</span>
 590 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 591 |     | <span class='neutral'>                // next range tick vs. next limit tick</span>
 592 |     | <span class='unexecuted'>                int24 rangeTickAhead = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 593 |     | <span class='unexecuted'>                int24 limitTickAhead = TickMap.next(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 594 |     | <span class='unexecuted'>                if (rangeTickAhead &lt;= limitTickAhead) {</span>
 595 |     | <span class='unexecuted'>                    cache.crossTick = rangeTickAhead;</span>
 596 |     | <span class='neutral'>                    // cross range tick</span>
 597 |     | <span class='unexecuted'>                    cache.crossStatus |= RANGE_TICK;</span>
 598 |     | <span class='unexecuted'>                    if (rangeTickAhead == limitTickAhead)</span>
 599 |     | <span class='neutral'>                        // also cross limit tick</span>
 600 |     | <span class='unexecuted'>                        cache.crossStatus |= LIMIT_TICK;</span>
 601 |     | <span class='unexecuted'>                    cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 602 |     | <span class='neutral'>                } else {</span>
 603 |     | <span class='neutral'>                    // only cross limit tick</span>
 604 |     | <span class='unexecuted'>                    cache.crossTick = limitTickAhead;</span>
 605 |     | <span class='unexecuted'>                    cache.crossStatus |= LIMIT_TICK;</span>
 606 |     | <span class='unexecuted'>                    cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 607 |     | <span class='unexecuted'>                                                                                 : ticks[cache.crossTick].limit.priceAt;</span>
 608 |     | <span class='neutral'>                }</span>
 609 |     | <span class='neutral'>            }</span>
 610 |     | <span class='neutral'>        }</span>
 611 |     | <span class='unexecuted'>        return cache;</span>
 612 |     | <span class='neutral'>    }</span>
 613 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/limit/Claims.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../utils/String.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../EchidnaAssertions.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library Claims {</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    function validate(</span>
  16 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
  17 |     | <span class='neutral'>            storage positions,</span>
  18 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  19 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  20 |     | <span class='neutral'>        ILimitPoolStructs.LimitPoolState memory pool,</span>
  21 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
  22 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache,</span>
  23 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  24 |     | <span class='neutral'>    ) internal returns (</span>
  25 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory,</span>
  26 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory</span>
  27 |     | <span class='neutral'>    ) {</span>
  28 |     | <span class='neutral'>        // validate position liquidity</span>
  29 |     | <span class='unexecuted'>        if (params.amount &gt; cache.position.liquidity) require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
  30 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
  31 |     | <span class='unexecuted'>            require(false, &#39;NoPositionLiquidityFound()&#39;);</span>
  32 |     | <span class='neutral'>        }</span>
  33 |     | <span class='neutral'>        </span>
  34 |     | <span class='unexecuted'>        if (params.claim &lt; params.lower || params.claim &gt; params.upper) require (false, &#39;InvalidClaimTick()&#39;);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='unexecuted'>        uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, constants);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        if (params.zeroForOne){</span>
  39 |     | <span class='unexecuted'>            if (pool.price &gt;= cache.priceClaim) {</span>
  40 |     | <span class='unexecuted'>                if (pool.price &lt;= cache.priceUpper) {</span>
  41 |     | <span class='unexecuted'>                    cache.priceClaim = pool.price;</span>
  42 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(pool.tickAtPrice, constants, params.zeroForOne, cache.priceClaim);</span>
  43 |     | <span class='unexecuted'>                    claimTickEpoch = cache.state.epoch;</span>
  44 |     | <span class='neutral'>                } else {</span>
  45 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  46 |     | <span class='unexecuted'>                    params.claim = params.upper;</span>
  47 |     | <span class='unexecuted'>                    cache.claimTick = ticks[params.upper].limit;</span>
  48 |     | <span class='neutral'>                }</span>
  49 |     | <span class='unexecuted'>                claimTickEpoch = cache.state.epoch;</span>
  50 |     | <span class='unexecuted'>            } else if (params.claim % constants.tickSpacing != 0) {</span>
  51 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  52 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt1()&#39;);</span>
  53 |     | <span class='neutral'>                }</span>
  54 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  55 |     | <span class='neutral'>            }</span>
  56 |     | <span class='neutral'>        } else {</span>
  57 |     | <span class='unexecuted'>            if (pool.price &lt;= cache.priceClaim) {</span>
  58 |     | <span class='unexecuted'>                if (pool.price &gt;= cache.priceLower) {</span>
  59 |     | <span class='unexecuted'>                    cache.priceClaim = pool.price;</span>
  60 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(pool.tickAtPrice, constants, params.zeroForOne, cache.priceClaim);</span>
  61 |     | <span class='neutral'>                    claimTickEpoch = cache.state.epoch;</span>
  62 |     | <span class='neutral'>                } else {</span>
  63 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
  64 |     | <span class='unexecuted'>                    params.claim = params.lower;</span>
  65 |     | <span class='unexecuted'>                    cache.claimTick = ticks[params.upper].limit;</span>
  66 |     | <span class='neutral'>                }</span>
  67 |     | <span class='unexecuted'>                claimTickEpoch = cache.state.epoch;</span>
  68 |     | <span class='unexecuted'>            } else if (params.claim % constants.tickSpacing != 0) {</span>
  69 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  70 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt2()&#39;);</span>
  71 |     | <span class='neutral'>                }</span>
  72 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  73 |     | <span class='neutral'>            }</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // validate claim tick</span>
  77 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {</span>
  78 |     | <span class='unexecuted'>             if (claimTickEpoch &lt;= cache.position.epochLast)</span>
  79 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt3()&#39;);</span>
  80 |     | <span class='unexecuted'>        } else if (params.amount &gt; 0) {</span>
  81 |     | <span class='neutral'>            /// @dev - partway claim is valid as long as liquidity is not being removed</span>
  82 |     | <span class='unexecuted'>            int24 claimTickNext = params.zeroForOne</span>
  83 |     | <span class='unexecuted'>                ? TickMap.next(tickMap, params.claim, constants.tickSpacing, false)</span>
  84 |     | <span class='unexecuted'>                : TickMap.previous(tickMap, params.claim, constants.tickSpacing, false);</span>
  85 |     | <span class='neutral'>            // if we cleared the final tick of their position, this is the wrong claim tick</span>
  86 |     | <span class='unexecuted'>            if (params.zeroForOne ? claimTickNext &gt; params.upper</span>
  87 |     | <span class='unexecuted'>                                  : claimTickNext &lt; params.lower) {</span>
  88 |     | <span class='unexecuted'>                EchidnaAssertions.assertWrongTickClaimedAt4(params.zeroForOne, claimTickNext, params.upper, params.lower);</span>
  89 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt4()&#39;);</span>
  90 |     | <span class='neutral'>            }</span>
  91 |     | <span class='neutral'>            // zero fill or partial fill</span>
  92 |     | <span class='neutral'>            /// @dev - if the next tick was crossed after position creation, the claim tick is incorrect</span>
  93 |     | <span class='neutral'>            /// @dev - we can cycle to find the right claim tick for the user</span>
  94 |     | <span class='unexecuted'>            uint32 claimTickNextAccumEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, constants);</span>
  95 |     | <span class='neutral'>            ///@dev - next swapEpoch should not be greater</span>
  96 |     | <span class='unexecuted'>            if (claimTickNextAccumEpoch &gt; cache.position.epochLast) {</span>
  97 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt5()&#39;);</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 100 |     | <span class='unexecuted'>                uint32 endTickAccumEpoch = EpochMap.get(params.upper, params.zeroForOne, tickMap, constants);</span>
 101 |     | <span class='unexecuted'>                if (endTickAccumEpoch &gt; cache.position.epochLast) {</span>
 102 |     | <span class='unexecuted'>                    params.claim = params.upper;</span>
 103 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
 104 |     | <span class='unexecuted'>                    cache.claimTick = ticks[params.upper].limit;</span>
 105 |     | <span class='neutral'>                }</span>
 106 |     | <span class='unexecuted'>            } else {</span>
 107 |     | <span class='unexecuted'>                uint32 endTickAccumEpoch = EpochMap.get(params.lower, params.zeroForOne, tickMap, constants);</span>
 108 |     | <span class='unexecuted'>                if (endTickAccumEpoch &gt; cache.position.epochLast) {</span>
 109 |     | <span class='unexecuted'>                    params.claim = params.lower;</span>
 110 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
 111 |     | <span class='unexecuted'>                    cache.claimTick = ticks[params.lower].limit;</span>
 112 |     | <span class='neutral'>                }</span>
 113 |     | <span class='neutral'>            }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>        /// @dev - start tick does not overwrite position and final tick clears position</span>
 117 |     | <span class='unexecuted'>        if (params.claim != params.upper &amp;&amp; params.claim != params.lower) {</span>
 118 |     | <span class='neutral'>            // check epochLast on claim tick</span>
 119 |     | <span class='unexecuted'>            if (claimTickEpoch &lt;= cache.position.epochLast)</span>
 120 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt7()&#39;);</span>
 121 |     | <span class='neutral'>            // prevent position overwriting at claim tick</span>
 122 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 123 |     | <span class='unexecuted'>                if (positions[params.owner][params.claim][params.upper].liquidity &gt; 0) {</span>
 124 |     | <span class='unexecuted'>                    require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.claim), &#39;, &#39;, String.from(params.upper), &#39;)&#39;));</span>
 125 |     | <span class='neutral'>                }</span>
 126 |     | <span class='neutral'>            } else {</span>
 127 |     | <span class='unexecuted'>                if (positions[params.owner][params.lower][params.claim].liquidity &gt; 0) {</span>
 128 |     | <span class='unexecuted'>                    require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.lower), &#39;, &#39;, String.from(params.claim), &#39;)&#39;));</span>
 129 |     | <span class='neutral'>                }</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>        // early return if no update and amount burned is 0</span>
 134 |     | <span class='neutral'>        //TODO: after we&#39;ve cycled through claim ticks and there are no position updates just revert - DONE</span>
 135 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == params.lower</span>
 136 |     | <span class='unexecuted'>                              : params.claim == params.upper) {</span>
 137 |     | <span class='unexecuted'>            if (params.amount == 0)</span>
 138 |     | <span class='unexecuted'>                require(false, &#39;NoPositionUpdates()&#39;);</span>
 139 |     | <span class='neutral'>        }</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        return (params, cache);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function getDeltas(</span>
 145 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache,</span>
 146 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
 147 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 148 |     | <span class='neutral'>    ) internal pure returns (</span>
 149 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory</span>
 150 |     | <span class='neutral'>    ) {</span>
 151 |     | <span class='neutral'>        // if half tick priceAt &gt; 0 add amountOut to amountOutClaimed</span>
 152 |     | <span class='neutral'>        // set claimPriceLast if zero</span>
 153 |     | <span class='unexecuted'>        if (!cache.position.crossedInto) {</span>
 154 |     | <span class='unexecuted'>            cache.position.crossedInto = true;</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='unexecuted'>        ILimitPoolStructs.GetDeltasLocals memory locals;</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>        if (params.claim % constants.tickSpacing != 0)</span>
 159 |     | <span class='neutral'>        // this should pass price at the claim tick</span>
 160 |     | <span class='unexecuted'>            locals.previousFullTick = TickMap.roundBack(params.claim, constants, params.zeroForOne, ConstantProduct.getPriceAtTick(params.claim, constants));</span>
 161 |     | <span class='neutral'>        else</span>
 162 |     | <span class='unexecuted'>            locals.previousFullTick = params.claim;</span>
 163 |     | <span class='unexecuted'>        locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 164 |     | <span class='unexecuted'>        if (params.zeroForOne ? locals.previousFullTick &gt; params.lower</span>
 165 |     | <span class='unexecuted'>                              : locals.previousFullTick &lt; params.upper) {</span>
 166 |     | <span class='neutral'>            </span>
 167 |     | <span class='neutral'>            // claim amounts up to latest full tick crossed</span>
 168 |     | <span class='unexecuted'>            cache.position.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.position.liquidity, cache.priceLower, locals.pricePrevious, false)</span>
 169 |     | <span class='unexecuted'>                                                                 : ConstantProduct.getDx(cache.position.liquidity, locals.pricePrevious, cache.priceUpper, false));</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 172 |     | <span class='neutral'>           // if tick hasn&#39;t been set back calculate amountIn</span>
 173 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &gt; locals.pricePrevious</span>
 174 |     | <span class='unexecuted'>                                  : cache.priceClaim &lt; locals.pricePrevious) {</span>
 175 |     | <span class='neutral'>                // allow partial tick claim if removing liquidity</span>
 176 |     | <span class='unexecuted'>                cache.position.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(params.amount, locals.pricePrevious, cache.priceClaim, false)</span>
 177 |     | <span class='unexecuted'>                                                                     : ConstantProduct.getDx(params.amount, cache.priceClaim, locals.pricePrevious, false));</span>
 178 |     | <span class='neutral'>            }</span>
 179 |     | <span class='neutral'>            // use priceClaim if tick hasn&#39;t been set back</span>
 180 |     | <span class='neutral'>            // else use claimPriceLast to calculate amountOut</span>
 181 |     | <span class='unexecuted'>            if (params.claim != (params.zeroForOne ? params.upper : params.lower)) {</span>
 182 |     | <span class='unexecuted'>                cache.position.amountOut += uint128(params.zeroForOne ? ConstantProduct.getDx(params.amount, cache.priceClaim, cache.priceUpper, false)</span>
 183 |     | <span class='unexecuted'>                                                                      : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceClaim, false));</span>
 184 |     | <span class='neutral'>            }</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'>        // take protocol fee if needed</span>
 187 |     | <span class='unexecuted'>        if (cache.pool.protocolFee &gt; 0 &amp;&amp; cache.position.amountIn &gt; 0) {</span>
 188 |     | <span class='unexecuted'>            uint128 protocolFeeAmount = cache.position.amountIn * cache.pool.protocolFee / 1e6;</span>
 189 |     | <span class='unexecuted'>            cache.position.amountIn -= protocolFeeAmount;</span>
 190 |     | <span class='unexecuted'>            cache.pool.protocolFees += protocolFeeAmount;</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        return cache;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/limit/EpochMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library EpochMap {</span>
   8 |     | <span class='unexecuted'>    function set(</span>
   9 |     | <span class='neutral'>        int24  tick,</span>
  10 |     | <span class='neutral'>        bool zeroForOne,</span>
  11 |     | <span class='neutral'>        uint256 epoch,</span>
  12 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  13 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  14 |     | <span class='unexecuted'>    ) internal {</span>
  15 |     | <span class='unexecuted'>        (</span>
  16 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  17 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  18 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  19 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  20 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  21 |     | <span class='neutral'>        // assert epoch isn&#39;t bigger than max uint32</span>
  22 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
  23 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
  24 |     | <span class='neutral'>        // clear previous value</span>
  25 |     | <span class='unexecuted'>        epochValue &amp;=  ~(((1 &lt;&lt; 9) - 1) &lt;&lt; ((tickIndex &amp; 0x7) * 32));</span>
  26 |     | <span class='neutral'>        // add new value to word</span>
  27 |     | <span class='unexecuted'>        epochValue |= epoch &lt;&lt; ((tickIndex &amp; 0x7) * 32);</span>
  28 |     | <span class='neutral'>        // store word in map</span>
  29 |     | <span class='unexecuted'>        zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue</span>
  30 |     | <span class='unexecuted'>                   : tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
  31 |     | <span class='neutral'>    }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    function get(</span>
  34 |     | <span class='neutral'>        int24 tick,</span>
  35 |     | <span class='neutral'>        bool zeroForOne,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  38 |     | <span class='neutral'>    ) internal view returns (</span>
  39 |     | <span class='unexecuted'>        uint32 epoch</span>
  40 |     | <span class='neutral'>    ) {</span>
  41 |     | <span class='unexecuted'>        (</span>
  42 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  43 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  44 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  45 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  46 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
  49 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
  50 |     | <span class='neutral'>        // right shift so first 8 bits are epoch value</span>
  51 |     | <span class='unexecuted'>        epochValue &gt;&gt;= ((tickIndex &amp; 0x7) * 32);</span>
  52 |     | <span class='neutral'>        // clear other bits</span>
  53 |     | <span class='unexecuted'>        epochValue &amp;= ((1 &lt;&lt; 32) - 1);</span>
  54 |     | <span class='neutral'>        return uint32(epochValue);</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function getIndices(</span>
  58 |     | <span class='neutral'>        int24 tick,</span>
  59 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  60 |     | <span class='neutral'>    ) internal pure returns (</span>
  61 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  62 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  63 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  64 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  65 |     | <span class='neutral'>        )</span>
  66 |     | <span class='neutral'>    {</span>
  67 |     | <span class='neutral'>        unchecked {</span>
  68 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.maxTick(constants.tickSpacing)) require (false, &#39;TickIndexOverflow()&#39;);</span>
  69 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.minTick(constants.tickSpacing)) require (false, &#39;TickIndexUnderflow()&#39;);</span>
  70 |     | <span class='unexecuted'>            if (tick % (constants.tickSpacing / 2) != 0) {</span>
  71 |     | <span class='unexecuted'>                require (false, &#39;TickIndexInvalid()&#39;);</span>
  72 |     | <span class='neutral'>            } </span>
  73 |     | <span class='unexecuted'>            tickIndex = uint256(int256((_round(tick, constants.tickSpacing / 2) </span>
  74 |     | <span class='unexecuted'>                                        - _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2)) </span>
  75 |     | <span class='unexecuted'>                                        / (constants.tickSpacing / 2)));</span>
  76 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 3;        // 2^3 epochs per word</span>
  77 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 11;      // 2^8 words per block</span>
  78 |     | <span class='unexecuted'>            volumeIndex = tickIndex &gt;&gt; 19;     // 2^8 blocks per volume</span>
  79 |     | <span class='unexecuted'>            if (blockIndex &gt; 2046) require (false, &#39;BlockIndexOverflow()&#39;);</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function _tick (</span>
  84 |     | <span class='neutral'>        uint256 tickIndex,</span>
  85 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  86 |     | <span class='neutral'>    ) internal pure returns (</span>
  87 |     | <span class='neutral'>        int24 tick</span>
  88 |     | <span class='neutral'>    ) {</span>
  89 |     | <span class='neutral'>        unchecked {</span>
  90 |     | <span class='neutral'>            if (tickIndex &gt; uint24(_round(ConstantProduct.MAX_TICK, constants.tickSpacing) * 2) * 2) </span>
  91 |     | <span class='neutral'>                require(false, &#39;TickIndexOverflow()&#39;);</span>
  92 |     | <span class='neutral'>            tick = int24(int256(tickIndex) * (constants.tickSpacing / 2) + _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2));</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>    function _round(</span>
  97 |     | <span class='neutral'>        int24 tick,</span>
  98 |     | <span class='neutral'>        int24 tickSpacing</span>
  99 |     | <span class='neutral'>    ) internal pure returns (</span>
 100 |     | <span class='unexecuted'>        int24 roundedTick</span>
 101 |     | <span class='neutral'>    ) {</span>
 102 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'>}</span>
 105 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/limit/PositionsLimit.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./TicksLimit.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./Claims.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  14 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  15 |     | <span class='unexecuted'>library PositionsLimit {</span>
  16 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    event BurnLimit(</span>
  19 |     | <span class='neutral'>        address indexed to,</span>
  20 |     | <span class='neutral'>        int24 lower,</span>
  21 |     | <span class='neutral'>        int24 upper,</span>
  22 |     | <span class='neutral'>        int24 claim,</span>
  23 |     | <span class='neutral'>        bool zeroForOne,</span>
  24 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  25 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  26 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  27 |     | <span class='neutral'>    );</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    function resize(</span>
  30 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  31 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  32 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  33 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  34 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory params,</span>
  35 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache</span>
  36 |     | <span class='neutral'>    ) internal returns (</span>
  37 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory,</span>
  38 |     | <span class='unexecuted'>        ILimitPoolStructs.MintLimitCache memory</span>
  39 |     | <span class='neutral'>    )</span>
  40 |     | <span class='neutral'>    {</span>
  41 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
  44 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // cannot mint empty position</span>
  47 |     | <span class='unexecuted'>        if (params.amount == 0) require (false, &#39;PositionAmountZero()&#39;);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>        cache.mintSize = uint256(params.mintPercent) * uint256(params.amount) / 1e28;</span>
  50 |     | <span class='neutral'>        // calculate L constant</span>
  51 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  52 |     | <span class='unexecuted'>            cache.priceLower,</span>
  53 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  54 |     | <span class='unexecuted'>            params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
  55 |     | <span class='unexecuted'>            params.zeroForOne ? 0 : uint256(params.amount),</span>
  56 |     | <span class='unexecuted'>            params.zeroForOne ? uint256(params.amount) : 0</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) require (false, &#39;PositionLiquidityZero()&#39;);</span>
  60 |     | <span class='neutral'>        // calculate price limit by using half of input</span>
  61 |     | <span class='neutral'>        {</span>
  62 |     | <span class='unexecuted'>            cache.priceLimit = params.zeroForOne ? ConstantProduct.getNewPrice(cache.priceUpper, cache.liquidityMinted, params.amount / 2, true, true)</span>
  63 |     | <span class='unexecuted'>                                                 : ConstantProduct.getNewPrice(cache.priceLower, cache.liquidityMinted, params.amount / 2, false, true);</span>
  64 |     | <span class='unexecuted'>            if (cache.priceLimit == 0) require (false, &#39;PriceLimitZero()&#39;);</span>
  65 |     | <span class='neutral'>            // get tick at price</span>
  66 |     | <span class='unexecuted'>            cache.tickLimit = ConstantProduct.getTickAtPrice(cache.priceLimit.toUint160(), cache.constants);</span>
  67 |     | <span class='neutral'>            // round to nearest tick spacing</span>
  68 |     | <span class='unexecuted'>            cache.priceLimit = ConstantProduct.getPriceAtTick(cache.tickLimit, cache.constants);</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory swapCache;</span>
  72 |     | <span class='unexecuted'>        swapCache.state = cache.state;</span>
  73 |     | <span class='unexecuted'>        swapCache.constants = cache.constants;</span>
  74 |     | <span class='unexecuted'>        swapCache.price = cache.state.pool.price;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // swap zero if no liquidity near market price</span>
  77 |     | <span class='unexecuted'>        if (cache.state.pool.liquidity == 0 &amp;&amp; </span>
  78 |     | <span class='unexecuted'>            (params.zeroForOne ? swapCache.price &gt; cache.priceLower</span>
  79 |     | <span class='unexecuted'>                               : swapCache.price &lt; cache.priceUpper)) {</span>
  80 |     | <span class='unexecuted'>            swapCache = Ticks.swap(</span>
  81 |     | <span class='unexecuted'>                ticks,</span>
  82 |     | <span class='unexecuted'>                samples,</span>
  83 |     | <span class='unexecuted'>                rangeTickMap,</span>
  84 |     | <span class='unexecuted'>                limitTickMap,</span>
  85 |     | <span class='unexecuted'>                PoolsharkStructs.SwapParams({</span>
  86 |     | <span class='unexecuted'>                    to: params.to,</span>
  87 |     | <span class='unexecuted'>                    priceLimit: (params.zeroForOne ? cache.priceLower </span>
  88 |     | <span class='unexecuted'>                                                   : cache.priceUpper).toUint160(),</span>
  89 |     | <span class='unexecuted'>                    amount: 0,</span>
  90 |     | <span class='neutral'>                    //TODO: handle exactOut</span>
  91 |     | <span class='unexecuted'>                    exactIn: true,</span>
  92 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
  93 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
  94 |     | <span class='neutral'>                }),</span>
  95 |     | <span class='unexecuted'>                swapCache</span>
  96 |     | <span class='neutral'>            );</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        // only swap if priceLimit is beyond current pool price</span>
 100 |     | <span class='unexecuted'>        if (params.zeroForOne ? cache.priceLimit &lt; swapCache.price</span>
 101 |     | <span class='unexecuted'>                              : cache.priceLimit &gt; swapCache.price) {</span>
 102 |     | <span class='neutral'>            // swap and save the pool state</span>
 103 |     | <span class='unexecuted'>            swapCache = Ticks.swap(</span>
 104 |     | <span class='unexecuted'>                ticks,</span>
 105 |     | <span class='unexecuted'>                samples,</span>
 106 |     | <span class='unexecuted'>                rangeTickMap,</span>
 107 |     | <span class='unexecuted'>                limitTickMap,</span>
 108 |     | <span class='unexecuted'>                PoolsharkStructs.SwapParams({</span>
 109 |     | <span class='unexecuted'>                    to: params.to,</span>
 110 |     | <span class='unexecuted'>                    priceLimit: cache.priceLimit.toUint160(),</span>
 111 |     | <span class='unexecuted'>                    amount: params.amount,</span>
 112 |     | <span class='neutral'>                    //TODO: handle exactOut</span>
 113 |     | <span class='unexecuted'>                    exactIn: true,</span>
 114 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
 115 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
 116 |     | <span class='neutral'>                }),</span>
 117 |     | <span class='neutral'>                swapCache</span>
 118 |     | <span class='neutral'>            );</span>
 119 |     | <span class='neutral'>            // subtract from remaining input amount</span>
 120 |     | <span class='unexecuted'>            params.amount -= uint128(swapCache.input);</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        }</span>
 123 |     | <span class='neutral'>        // save to cache</span>
 124 |     | <span class='unexecuted'>        cache.swapCache = swapCache;</span>
 125 |     | <span class='unexecuted'>        cache.state = swapCache.state;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        if (params.amount &lt; cache.mintSize) params.amount = 0;</span>
 128 |     | <span class='neutral'>        // move start tick based on amount filled in swap</span>
 129 |     | <span class='unexecuted'>        if ((params.amount &gt; 0 &amp;&amp; swapCache.input &gt; 0) ||</span>
 130 |     | <span class='unexecuted'>            (params.zeroForOne ? cache.priceLower &lt; swapCache.price</span>
 131 |     | <span class='unexecuted'>                               : cache.priceUpper &gt; swapCache.price)</span>
 132 |     | <span class='neutral'>        ) {</span>
 133 |     | <span class='neutral'>            // move the tick limit based on pool.tickAtPrice</span>
 134 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceLower &lt; swapCache.price</span>
 135 |     | <span class='unexecuted'>                                  : cache.priceUpper &gt; swapCache.price) {</span>
 136 |     | <span class='unexecuted'>                cache.tickLimit = swapCache.state.pool.tickAtPrice;</span>
 137 |     | <span class='neutral'>            }</span>
 138 |     | <span class='neutral'>            // round ahead tickLimit to avoid crossing epochs</span>
 139 |     | <span class='unexecuted'>            cache.tickLimit = TickMap.roundAhead(cache.tickLimit, cache.constants, params.zeroForOne, swapCache.price);</span>
 140 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 141 |     | <span class='unexecuted'>                if (cache.priceLower &lt; swapCache.price) {</span>
 142 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 143 |     | <span class='neutral'>                    /// @dev - if swap didn&#39;t go to limit user would be 100% filled</span>
 144 |     | <span class='unexecuted'>                    params.lower = cache.tickLimit;</span>
 145 |     | <span class='unexecuted'>                    cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 146 |     | <span class='neutral'>                }</span>
 147 |     | <span class='unexecuted'>                if (params.lower &gt;= params.upper &amp;&amp; </span>
 148 |     | <span class='unexecuted'>                    params.lower &lt; ConstantProduct.maxTick(cache.constants.tickSpacing) - cache.constants.tickSpacing</span>
 149 |     | <span class='neutral'>                ) {</span>
 150 |     | <span class='unexecuted'>                    params.upper = params.lower + cache.constants.tickSpacing;</span>
 151 |     | <span class='neutral'>                }</span>
 152 |     | <span class='unexecuted'>                cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 153 |     | <span class='neutral'>            } else {</span>
 154 |     | <span class='unexecuted'>                if (cache.priceUpper &gt; swapCache.price) {</span>
 155 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 156 |     | <span class='unexecuted'>                    params.upper = cache.tickLimit;</span>
 157 |     | <span class='unexecuted'>                    cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 158 |     | <span class='neutral'>                }</span>
 159 |     | <span class='unexecuted'>                if (params.upper &lt;= params.lower &amp;&amp; </span>
 160 |     | <span class='unexecuted'>                    params.lower &gt; ConstantProduct.minTick(cache.constants.tickSpacing) + cache.constants.tickSpacing</span>
 161 |     | <span class='neutral'>                ) {</span>
 162 |     | <span class='unexecuted'>                    params.lower = params.upper - cache.constants.tickSpacing;</span>
 163 |     | <span class='neutral'>                }</span>
 164 |     | <span class='unexecuted'>                cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 165 |     | <span class='neutral'>            }</span>
 166 |     | <span class='unexecuted'>            if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper)</span>
 167 |     | <span class='unexecuted'>                cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 168 |     | <span class='unexecuted'>                    cache.priceLower,</span>
 169 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
 170 |     | <span class='unexecuted'>                    params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
 171 |     | <span class='unexecuted'>                    params.zeroForOne ? 0 : uint256(params.amount),</span>
 172 |     | <span class='unexecuted'>                    params.zeroForOne ? uint256(params.amount) : 0</span>
 173 |     | <span class='neutral'>                );</span>
 174 |     | <span class='neutral'>            else</span>
 175 |     | <span class='neutral'>                /// @auditor unnecessary since params.amount is 0</span>
 176 |     | <span class='unexecuted'>                cache.liquidityMinted = 0;</span>
 177 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
 178 |     | <span class='neutral'>        }</span>
 179 |     | <span class='neutral'>        // console.log(&#39;position bounds end&#39;, uint24(-params.lower), uint24(params.upper), uint24(cache.state.pool.tickAtPrice));</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        if (params.lower &gt;= params.upper) {</span>
 182 |     | <span class='unexecuted'>            params.amount = 0;</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>        return (</span>
 186 |     | <span class='unexecuted'>            params,</span>
 187 |     | <span class='unexecuted'>            cache</span>
 188 |     | <span class='neutral'>        );</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function add(</span>
 192 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache,</span>
 193 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 194 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 195 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory params</span>
 196 |     | <span class='neutral'>    ) internal returns (</span>
 197 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory,</span>
 198 |     | <span class='unexecuted'>        ILimitPoolStructs.LimitPosition memory</span>
 199 |     | <span class='neutral'>    ) {</span>
 200 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) return (cache.pool, cache.position);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 203 |     | <span class='unexecuted'>            cache.position.epochLast = cache.state.epoch;</span>
 204 |     | <span class='neutral'>        } else {</span>
 205 |     | <span class='neutral'>            // safety check in case we somehow get here</span>
 206 |     | <span class='unexecuted'>            if (</span>
 207 |     | <span class='unexecuted'>                params.zeroForOne</span>
 208 |     | <span class='unexecuted'>                    ? EpochMap.get(params.lower, params.zeroForOne, tickMap, cache.constants)</span>
 209 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 210 |     | <span class='unexecuted'>                    : EpochMap.get(params.upper, params.zeroForOne, tickMap, cache.constants)</span>
 211 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 212 |     | <span class='neutral'>            ) {</span>
 213 |     | <span class='unexecuted'>                require (false, string.concat(&#39;UpdatePositionFirstAt(&#39;, String.from(params.lower), &#39;, &#39;, String.from(params.upper), &#39;)&#39;));</span>
 214 |     | <span class='neutral'>            }</span>
 215 |     | <span class='neutral'>            /// @auditor maybe this shouldn&#39;t be a revert but rather just not mint the position?</span>
 216 |     | <span class='neutral'>        }</span>
 217 |     | <span class='neutral'>        </span>
 218 |     | <span class='neutral'>        // add liquidity to ticks</span>
 219 |     | <span class='unexecuted'>        TicksLimit.insert(</span>
 220 |     | <span class='unexecuted'>            ticks,</span>
 221 |     | <span class='unexecuted'>            tickMap,</span>
 222 |     | <span class='unexecuted'>            cache,</span>
 223 |     | <span class='unexecuted'>            params</span>
 224 |     | <span class='neutral'>        );</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        // update liquidity global</span>
 227 |     | <span class='unexecuted'>        cache.state.liquidityGlobal += uint128(cache.liquidityMinted);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(cache.liquidityMinted);</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>        return (cache.pool, cache.position);</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    //Limitxxx would be easier</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>    function remove(</span>
 237 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
 238 |     | <span class='neutral'>            storage positions,</span>
 239 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 240 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 241 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 242 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
 243 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 244 |     | <span class='neutral'>    ) internal returns (</span>
 245 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory,</span>
 246 |     | <span class='unexecuted'>        ILimitPoolStructs.LimitPosition memory</span>
 247 |     | <span class='neutral'>    ) {</span>
 248 |     | <span class='neutral'>        // initialize cache</span>
 249 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache;</span>
 250 |     | <span class='unexecuted'>        cache.position = positions[params.to][params.lower][params.upper];</span>
 251 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, constants);</span>
 252 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, constants);</span>
 253 |     | <span class='unexecuted'>        cache.removeLower = true; cache.removeUpper = true;</span>
 254 |     | <span class='unexecuted'>        cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 257 |     | <span class='unexecuted'>        params.amount = _convert(cache.position.liquidity, params.amount);</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>        // early return if no liquidity to remove</span>
 260 |     | <span class='unexecuted'>        if (params.amount == 0) return (state, cache.position);</span>
 261 |     | <span class='unexecuted'>        if (params.amount &gt; cache.position.liquidity) {</span>
 262 |     | <span class='unexecuted'>            require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>        /// @dev - validate position has not been crossed into</span>
 265 |     | <span class='unexecuted'>        if (params.zeroForOne) {</span>
 266 |     | <span class='unexecuted'>            if (EpochMap.get(params.lower, params.zeroForOne, tickMap, constants)</span>
 267 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 268 |     | <span class='unexecuted'>                int24 nextTick = TickMap.next(tickMap, params.lower, constants.tickSpacing, false);</span>
 269 |     | <span class='unexecuted'>                if (cache.pool.price &gt; cache.priceLower ||</span>
 270 |     | <span class='unexecuted'>                    EpochMap.get(nextTick, params.zeroForOne, tickMap, constants)</span>
 271 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 272 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt7()&#39;);            </span>
 273 |     | <span class='neutral'>                }</span>
 274 |     | <span class='unexecuted'>                if (cache.pool.price == cache.priceLower) {</span>
 275 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(cache.pool.liquidity, params.amount, &quot;PLU-1&quot;);</span>
 276 |     | <span class='unexecuted'>                    cache.pool.liquidity -= params.amount;</span>
 277 |     | <span class='neutral'>                }</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='neutral'>            // if pool price is further along</span>
 280 |     | <span class='neutral'>            // OR next tick has a greater epoch</span>
 281 |     | <span class='neutral'>        } else {</span>
 282 |     | <span class='unexecuted'>            if (EpochMap.get(params.upper, params.zeroForOne, tickMap, constants)</span>
 283 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 284 |     | <span class='unexecuted'>                int24 previousTick = TickMap.previous(tickMap, params.upper, constants.tickSpacing, false);</span>
 285 |     | <span class='unexecuted'>                if (cache.pool.price &lt; cache.priceUpper ||</span>
 286 |     | <span class='unexecuted'>                    EpochMap.get(previousTick, params.zeroForOne, tickMap, constants)</span>
 287 |     | <span class='unexecuted'>                        &gt; cache.position.epochLast) {</span>
 288 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt8()&#39;);            </span>
 289 |     | <span class='neutral'>                }</span>
 290 |     | <span class='unexecuted'>                if (cache.pool.price == cache.priceUpper) {</span>
 291 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(cache.pool.liquidity, params.amount, &quot;PLU-2&quot;);</span>
 292 |     | <span class='unexecuted'>                    cache.pool.liquidity -= params.amount;</span>
 293 |     | <span class='neutral'>                }</span>
 294 |     | <span class='neutral'>            }</span>
 295 |     | <span class='neutral'>        }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        TicksLimit.remove(</span>
 298 |     | <span class='unexecuted'>            ticks,</span>
 299 |     | <span class='unexecuted'>            tickMap,</span>
 300 |     | <span class='unexecuted'>            cache,</span>
 301 |     | <span class='unexecuted'>            params,</span>
 302 |     | <span class='unexecuted'>            constants</span>
 303 |     | <span class='neutral'>        );</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        // update liquidity global</span>
 306 |     | <span class='unexecuted'>        EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, params.amount, &quot;LGU-1&quot;);</span>
 307 |     | <span class='unexecuted'>        state.liquidityGlobal -= params.amount;</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='unexecuted'>        cache.position.amountOut += uint128(</span>
 310 |     | <span class='unexecuted'>            params.zeroForOne</span>
 311 |     | <span class='unexecuted'>                ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 312 |     | <span class='unexecuted'>                : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)</span>
 313 |     | <span class='neutral'>        );</span>
 314 |     | <span class='neutral'></span>
 315 |     | <span class='unexecuted'>        cache.position.liquidity -= uint128(params.amount);</span>
 316 |     | <span class='unexecuted'>        positions[params.to][params.lower][params.upper] = cache.position;</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 319 |     | <span class='unexecuted'>            emit BurnLimit(</span>
 320 |     | <span class='unexecuted'>                    params.to,</span>
 321 |     | <span class='unexecuted'>                    params.lower,</span>
 322 |     | <span class='unexecuted'>                    params.upper,</span>
 323 |     | <span class='unexecuted'>                    params.zeroForOne ? params.lower : params.upper,</span>
 324 |     | <span class='unexecuted'>                    params.zeroForOne,</span>
 325 |     | <span class='unexecuted'>                    params.amount,</span>
 326 |     | <span class='unexecuted'>                    0,</span>
 327 |     | <span class='unexecuted'>                    cache.position.amountOut</span>
 328 |     | <span class='neutral'>            );</span>
 329 |     | <span class='neutral'>        }</span>
 330 |     | <span class='neutral'>        // save pool state to memory</span>
 331 |     | <span class='unexecuted'>        if (params.zeroForOne) cache.state.pool0 = cache.pool;</span>
 332 |     | <span class='unexecuted'>        else cache.state.pool1 = cache.pool;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>        return (state, cache.position);</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>    function update(</span>
 338 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
 339 |     | <span class='neutral'>            storage positions,</span>
 340 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 341 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 342 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
 343 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
 344 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 345 |     | <span class='neutral'>    ) internal returns (</span>
 346 |     | <span class='unexecuted'>        ILimitPoolStructs.GlobalState memory,</span>
 347 |     | <span class='unexecuted'>        ILimitPoolStructs.LimitPosition memory,</span>
 348 |     | <span class='unexecuted'>        int24</span>
 349 |     | <span class='neutral'>    )</span>
 350 |     | <span class='neutral'>    {</span>
 351 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache;</span>
 352 |     | <span class='unexecuted'>        (</span>
 353 |     | <span class='neutral'>            params,</span>
 354 |     | <span class='neutral'>            cache,</span>
 355 |     | <span class='neutral'>            state</span>
 356 |     | <span class='unexecuted'>        ) = _deltas(</span>
 357 |     | <span class='unexecuted'>            positions,</span>
 358 |     | <span class='unexecuted'>            ticks,</span>
 359 |     | <span class='unexecuted'>            tickMap,</span>
 360 |     | <span class='unexecuted'>            state,</span>
 361 |     | <span class='unexecuted'>            params,</span>
 362 |     | <span class='unexecuted'>            constants</span>
 363 |     | <span class='neutral'>        );</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>        if (cache.earlyReturn)</span>
 366 |     | <span class='unexecuted'>            return (state, cache.position, params.claim);</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>        // update pool liquidity</span>
 369 |     | <span class='unexecuted'>        if (cache.priceClaim == cache.pool.price &amp;&amp; params.amount &gt; 0) {</span>
 370 |     | <span class='neutral'>            // handle pool.price at edge of range</span>
 371 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &lt; cache.priceUpper</span>
 372 |     | <span class='unexecuted'>                                  : cache.priceClaim &gt; cache.priceLower){</span>
 373 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityUnderflows(cache.pool.liquidity, params.amount, &quot;PLU-3&quot;);</span>
 374 |     | <span class='unexecuted'>                cache.pool.liquidity -= params.amount;</span>
 375 |     | <span class='neutral'>            }</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='unexecuted'>        if (params.amount &gt; 0) {</span>
 380 |     | <span class='unexecuted'>            if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {</span>
 381 |     | <span class='neutral'>                // only remove once if final tick of position</span>
 382 |     | <span class='unexecuted'>                cache.removeLower = false;</span>
 383 |     | <span class='unexecuted'>                cache.removeUpper = false;</span>
 384 |     | <span class='neutral'>            } else {</span>
 385 |     | <span class='unexecuted'>                params.zeroForOne ? cache.removeUpper = true </span>
 386 |     | <span class='unexecuted'>                                  : cache.removeLower = true;</span>
 387 |     | <span class='neutral'>            }</span>
 388 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 389 |     | <span class='unexecuted'>                if (params.claim == params.lower &amp;&amp; </span>
 390 |     | <span class='unexecuted'>                    cache.pool.price &lt; cache.priceLower</span>
 391 |     | <span class='neutral'>                ) {</span>
 392 |     | <span class='unexecuted'>                    cache.removeLower = true;</span>
 393 |     | <span class='unexecuted'>                } else if (params.claim % constants.tickSpacing != 0 &amp;&amp; </span>
 394 |     | <span class='unexecuted'>                    cache.pool.price &lt; cache.priceClaim)</span>
 395 |     | <span class='unexecuted'>                    cache.removeLower = true;</span>
 396 |     | <span class='neutral'>            } else {</span>
 397 |     | <span class='unexecuted'>                if (params.claim == params.upper &amp;&amp;</span>
 398 |     | <span class='unexecuted'>                    cache.pool.price &gt; cache.priceUpper</span>
 399 |     | <span class='neutral'>                )</span>
 400 |     | <span class='unexecuted'>                    cache.removeUpper = true;</span>
 401 |     | <span class='unexecuted'>                else if (params.claim % constants.tickSpacing != 0 &amp;&amp;</span>
 402 |     | <span class='unexecuted'>                            cache.pool.price &gt; cache.priceClaim)</span>
 403 |     | <span class='unexecuted'>                    cache.removeUpper = true;</span>
 404 |     | <span class='neutral'>            }</span>
 405 |     | <span class='unexecuted'>            TicksLimit.remove(</span>
 406 |     | <span class='unexecuted'>                ticks,</span>
 407 |     | <span class='unexecuted'>                tickMap,</span>
 408 |     | <span class='unexecuted'>                cache,</span>
 409 |     | <span class='unexecuted'>                params,</span>
 410 |     | <span class='unexecuted'>                constants</span>
 411 |     | <span class='neutral'>            );</span>
 412 |     | <span class='neutral'>            // update position liquidity</span>
 413 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(params.amount);</span>
 414 |     | <span class='neutral'>            // update global liquidity</span>
 415 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, params.amount, &quot;LGU-2&quot;);</span>
 416 |     | <span class='unexecuted'>            state.liquidityGlobal -= params.amount;</span>
 417 |     | <span class='neutral'>        }</span>
 418 |     | <span class='neutral'>        //TODO: set params.amount = 0 if end tick so correct value is emitted for event</span>
 419 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == params.upper</span>
 420 |     | <span class='unexecuted'>                              : params.claim == params.lower) {</span>
 421 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, cache.position.liquidity, &quot;LGU-3&quot;);</span>
 422 |     | <span class='unexecuted'>            state.liquidityGlobal -= cache.position.liquidity;</span>
 423 |     | <span class='neutral'>            // set params.amount for BurnLimit event</span>
 424 |     | <span class='unexecuted'>            params.amount = cache.position.liquidity;</span>
 425 |     | <span class='unexecuted'>            cache.position.liquidity = 0;</span>
 426 |     | <span class='neutral'>        }</span>
 427 |     | <span class='neutral'>        // clear out old position</span>
 428 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim != params.lower </span>
 429 |     | <span class='unexecuted'>                              : params.claim != params.upper) {</span>
 430 |     | <span class='neutral'>            </span>
 431 |     | <span class='neutral'>            /// @dev - this also clears out position end claims</span>
 432 |     | <span class='unexecuted'>            if (params.zeroForOne ? params.claim == params.lower </span>
 433 |     | <span class='unexecuted'>                                  : params.claim == params.upper) {</span>
 434 |     | <span class='neutral'>                // subtract remaining position liquidity out from global</span>
 435 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, cache.position.liquidity, &quot;LGU-4&quot;);</span>
 436 |     | <span class='unexecuted'>                state.liquidityGlobal -= cache.position.liquidity;</span>
 437 |     | <span class='neutral'>            }</span>
 438 |     | <span class='unexecuted'>            delete positions[params.to][params.lower][params.upper];</span>
 439 |     | <span class='neutral'>        }</span>
 440 |     | <span class='neutral'>        // clear position if empty</span>
 441 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 442 |     | <span class='unexecuted'>            cache.position.epochLast = 0;</span>
 443 |     | <span class='unexecuted'>            cache.position.crossedInto = false;</span>
 444 |     | <span class='neutral'>        }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>        // round back claim tick for storage</span>
 447 |     | <span class='unexecuted'>        if (params.claim % constants.tickSpacing != 0)</span>
 448 |     | <span class='unexecuted'>            params.claim = TickMap.roundBack(params.claim, constants, params.zeroForOne, cache.priceClaim);</span>
 449 |     | <span class='neutral'>        </span>
 450 |     | <span class='unexecuted'>        emit BurnLimit(</span>
 451 |     | <span class='unexecuted'>            params.to,</span>
 452 |     | <span class='unexecuted'>            params.lower,</span>
 453 |     | <span class='unexecuted'>            params.upper,</span>
 454 |     | <span class='unexecuted'>            params.claim,</span>
 455 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 456 |     | <span class='unexecuted'>            params.amount,</span>
 457 |     | <span class='unexecuted'>            cache.position.amountIn,</span>
 458 |     | <span class='unexecuted'>            cache.position.amountOut</span>
 459 |     | <span class='neutral'>        );</span>
 460 |     | <span class='neutral'>        // save pool to globalState</span>
 461 |     | <span class='unexecuted'>        if (params.zeroForOne) state.pool0 = cache.pool;</span>
 462 |     | <span class='unexecuted'>        else state.pool1 = cache.pool;</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>        // return cached position in memory and transfer out</span>
 465 |     | <span class='unexecuted'>        return (state, cache.position, params.claim);</span>
 466 |     | <span class='neutral'>    }</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>    function snapshot(</span>
 469 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
 470 |     | <span class='neutral'>            storage positions,</span>
 471 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 472 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 473 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
 474 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
 475 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 476 |     | <span class='neutral'>    ) internal returns (</span>
 477 |     | <span class='neutral'>        ILimitPoolStructs.LimitPosition memory</span>
 478 |     | <span class='neutral'>    ) {</span>
 479 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache;</span>
 480 |     | <span class='neutral'>        (</span>
 481 |     | <span class='neutral'>            params,</span>
 482 |     | <span class='neutral'>            cache,</span>
 483 |     | <span class='neutral'>            state</span>
 484 |     | <span class='neutral'>        ) = _deltas(</span>
 485 |     | <span class='neutral'>            positions,</span>
 486 |     | <span class='neutral'>            ticks,</span>
 487 |     | <span class='neutral'>            tickMap,</span>
 488 |     | <span class='neutral'>            state,</span>
 489 |     | <span class='neutral'>            params,</span>
 490 |     | <span class='neutral'>            constants</span>
 491 |     | <span class='neutral'>        );</span>
 492 |     | <span class='neutral'></span>
 493 |     | <span class='neutral'>        if (cache.earlyReturn)</span>
 494 |     | <span class='neutral'>            return (cache.position);</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>        if (params.amount &gt; 0) {</span>
 497 |     | <span class='neutral'>            cache.position.liquidity -= uint128(params.amount);</span>
 498 |     | <span class='neutral'>        }</span>
 499 |     | <span class='neutral'>        </span>
 500 |     | <span class='neutral'>        // clear position values if empty</span>
 501 |     | <span class='neutral'>        if (cache.position.liquidity == 0) {</span>
 502 |     | <span class='neutral'>            cache.position.epochLast = 0;</span>
 503 |     | <span class='neutral'>            cache.position.crossedInto = false;</span>
 504 |     | <span class='neutral'>        }    </span>
 505 |     | <span class='neutral'>        return cache.position;</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='unexecuted'>    function _convert(</span>
 509 |     | <span class='neutral'>        uint128 liquidity,</span>
 510 |     | <span class='neutral'>        uint128 percent</span>
 511 |     | <span class='neutral'>    ) internal pure returns (</span>
 512 |     | <span class='unexecuted'>        uint128</span>
 513 |     | <span class='neutral'>    ) {</span>
 514 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 515 |     | <span class='unexecuted'>        if (percent &gt; 1e38) percent = 1e38;</span>
 516 |     | <span class='unexecuted'>        if (liquidity == 0 &amp;&amp; percent &gt; 0) require (false, &#39;PositionNotFound()&#39;);</span>
 517 |     | <span class='unexecuted'>        return uint128(uint256(liquidity) * uint256(percent) / 1e38);</span>
 518 |     | <span class='neutral'>    }</span>
 519 |     | <span class='neutral'></span>
 520 |     | <span class='unexecuted'>    function _deltas(</span>
 521 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
 522 |     | <span class='neutral'>            storage positions,</span>
 523 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 524 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 525 |     | <span class='neutral'>        ILimitPoolStructs.GlobalState memory state,</span>
 526 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
 527 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 528 |     | <span class='neutral'>    ) internal returns (</span>
 529 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory,</span>
 530 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory,</span>
 531 |     | <span class='unexecuted'>        ILimitPoolStructs.GlobalState memory</span>
 532 |     | <span class='neutral'>    ) {</span>
 533 |     | <span class='unexecuted'>        ILimitPoolStructs.UpdateCache memory cache = ILimitPoolStructs.UpdateCache({</span>
 534 |     | <span class='unexecuted'>            state: state,</span>
 535 |     | <span class='unexecuted'>            position: positions[params.owner][params.lower][params.upper],</span>
 536 |     | <span class='unexecuted'>            pool: params.zeroForOne ? state.pool0 : state.pool1,</span>
 537 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
 538 |     | <span class='unexecuted'>            priceClaim: ticks[params.claim].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(params.claim, constants)</span>
 539 |     | <span class='unexecuted'>                                                               : ticks[params.claim].limit.priceAt,</span>
 540 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
 541 |     | <span class='unexecuted'>            claimTick: ticks[params.claim].limit,</span>
 542 |     | <span class='unexecuted'>            earlyReturn: false,</span>
 543 |     | <span class='unexecuted'>            removeLower: false,</span>
 544 |     | <span class='unexecuted'>            removeUpper: false</span>
 545 |     | <span class='neutral'>        });</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='unexecuted'>        params.amount = _convert(cache.position.liquidity, params.amount);</span>
 548 |     | <span class='neutral'></span>
 549 |     | <span class='neutral'>        // check claim is valid</span>
 550 |     | <span class='unexecuted'>        (params, cache) = Claims.validate(</span>
 551 |     | <span class='unexecuted'>            positions,</span>
 552 |     | <span class='unexecuted'>            ticks,</span>
 553 |     | <span class='unexecuted'>            tickMap,</span>
 554 |     | <span class='unexecuted'>            cache.pool,</span>
 555 |     | <span class='neutral'>            params,</span>
 556 |     | <span class='neutral'>            cache,</span>
 557 |     | <span class='unexecuted'>            constants</span>
 558 |     | <span class='neutral'>        );</span>
 559 |     | <span class='unexecuted'>        if (cache.earlyReturn) {</span>
 560 |     | <span class='unexecuted'>            return (params, cache, state);</span>
 561 |     | <span class='neutral'>        }</span>
 562 |     | <span class='neutral'>        // calculate position deltas</span>
 563 |     | <span class='unexecuted'>        cache = Claims.getDeltas(cache, params, constants);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'></span>
 567 |     | <span class='unexecuted'>        return (params, cache, state);</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/limit/TicksLimit.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../base/structs/LimitPoolFactoryStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./PositionsLimit.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../range/Samples.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/// @notice Tick management library for limit pools</span>
  17 |     | <span class='unexecuted'>library TicksLimit {</span>
  18 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  19 |     | <span class='neutral'>    error LiquidityUnderflow();</span>
  20 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  21 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  22 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  23 |     | <span class='neutral'>    error InvalidPositionBounds();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    function validate(</span>
  30 |     | <span class='neutral'>        int24 lower,</span>
  31 |     | <span class='neutral'>        int24 upper,</span>
  32 |     | <span class='neutral'>        int24 tickSpacing</span>
  33 |     | <span class='neutral'>    ) internal pure {</span>
  34 |     | <span class='neutral'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  35 |     | <span class='neutral'>        if (lower &lt;= ConstantProduct.MIN_TICK) require(false, &#39;InvalidLowerTick()&#39;);</span>
  36 |     | <span class='neutral'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  37 |     | <span class='neutral'>        if (upper &gt;= ConstantProduct.MAX_TICK) require(false, &#39;InvalidUpperTick()&#39;);</span>
  38 |     | <span class='neutral'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function insert(</span>
  42 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  43 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  44 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache,</span>
  45 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory params</span>
  46 |     | <span class='neutral'>    ) internal {</span>
  47 |     | <span class='neutral'>        /// @auditor - validation of ticks is in Positions.validate</span>
  48 |     | <span class='unexecuted'>        if (cache.liquidityMinted &gt; (uint128(type(int128).max) - cache.state.liquidityGlobal) )</span>
  49 |     | <span class='unexecuted'>            require (false, &#39;LiquidityOverflow()&#39;);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>        int256 liquidityMinted = int256(cache.liquidityMinted);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>        // check if adding liquidity necessary</span>
  54 |     | <span class='unexecuted'>        if (!params.zeroForOne || cache.priceLower &gt; cache.pool.price) {</span>
  55 |     | <span class='neutral'>            // sets bit in map</span>
  56 |     | <span class='unexecuted'>            if(!TickMap.set(tickMap, params.lower, cache.constants.tickSpacing)){</span>
  57 |     | <span class='neutral'>                // inherit epoch </span>
  58 |     | <span class='unexecuted'>                int24 tickAhead;</span>
  59 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  60 |     | <span class='unexecuted'>                    tickAhead  = TickMap.next(tickMap, params.lower, cache.constants.tickSpacing, false);</span>
  61 |     | <span class='neutral'>                } else {</span>
  62 |     | <span class='unexecuted'>                    tickAhead  = TickMap.previous(tickMap, params.lower, cache.constants.tickSpacing, false);</span>
  63 |     | <span class='neutral'>                }</span>
  64 |     | <span class='unexecuted'>                uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);</span>
  65 |     | <span class='unexecuted'>                EpochMap.set(params.lower, params.zeroForOne, epochAhead, tickMap, cache.constants);</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickLower = ticks[params.lower].limit;</span>
  68 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  69 |     | <span class='unexecuted'>                tickLower.liquidityDelta += int128(liquidityMinted);</span>
  70 |     | <span class='neutral'>            } else {</span>
  71 |     | <span class='unexecuted'>                tickLower.liquidityDelta -= int128(liquidityMinted);</span>
  72 |     | <span class='neutral'>            }</span>
  73 |     | <span class='unexecuted'>            tickLower.liquidityAbsolute += cache.liquidityMinted.toUint128();</span>
  74 |     | <span class='unexecuted'>            ticks[params.lower].limit = tickLower;</span>
  75 |     | <span class='neutral'>        } else {</span>
  76 |     | <span class='neutral'>            /// @dev - i.e. if zeroForOne &amp;&amp; cache.priceLower &lt;= cache.pool.price</span>
  77 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
  78 |     | <span class='neutral'>            // mark epoch on undercut tick</span>
  79 |     | <span class='unexecuted'>            EpochMap.set(params.lower, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        if (params.zeroForOne || cache.priceUpper &lt; cache.pool.price) {</span>
  83 |     | <span class='unexecuted'>            if(!TickMap.set(tickMap, params.upper, cache.constants.tickSpacing)) {</span>
  84 |     | <span class='unexecuted'>                int24 tickAhead;</span>
  85 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  86 |     | <span class='unexecuted'>                    tickAhead  = TickMap.next(tickMap, params.upper, cache.constants.tickSpacing, false);</span>
  87 |     | <span class='neutral'>                } else {</span>
  88 |     | <span class='unexecuted'>                    tickAhead  = TickMap.previous(tickMap, params.upper, cache.constants.tickSpacing, false);</span>
  89 |     | <span class='neutral'>                }</span>
  90 |     | <span class='unexecuted'>                uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);</span>
  91 |     | <span class='unexecuted'>                EpochMap.set(params.upper, params.zeroForOne, epochAhead, tickMap, cache.constants);</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickUpper = ticks[params.upper].limit;</span>
  94 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  95 |     | <span class='unexecuted'>                tickUpper.liquidityDelta -= int128(liquidityMinted);</span>
  96 |     | <span class='neutral'>            } else {</span>
  97 |     | <span class='unexecuted'>                tickUpper.liquidityDelta += int128(liquidityMinted);</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='unexecuted'>            tickUpper.liquidityAbsolute += cache.liquidityMinted.toUint128();</span>
 100 |     | <span class='unexecuted'>            ticks[params.upper].limit = tickUpper;</span>
 101 |     | <span class='neutral'>        } else {</span>
 102 |     | <span class='neutral'>            /// @dev - i.e. if !zeroForOne &amp;&amp; cache.priceUpper &gt;= cache.pool.price</span>
 103 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
 104 |     | <span class='neutral'>            // mark epoch on undercut tick</span>
 105 |     | <span class='unexecuted'>            EpochMap.set(params.upper, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>    function insertSingle(</span>
 110 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory params,</span>
 111 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 112 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 113 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache,</span>
 114 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState memory pool,</span>
 115 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 116 |     | <span class='neutral'>    ) internal returns (</span>
 117 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory</span>
 118 |     | <span class='neutral'>    ){</span>
 119 |     | <span class='neutral'>        /// @auditor - would be smart to protect against the case of epochs crossing</span>
 120 |     | <span class='unexecuted'>        (</span>
 121 |     | <span class='unexecuted'>            int24 tickToSave,</span>
 122 |     | <span class='unexecuted'>            uint160 roundedPrice</span>
 123 |     | <span class='unexecuted'>        ) = TickMap.roundHalf(pool.tickAtPrice, constants, pool.price);</span>
 124 |     | <span class='neutral'>        // update tick to save</span>
 125 |     | <span class='unexecuted'>        ILimitPoolStructs.LimitTick memory tick = ticks[tickToSave].limit;</span>
 126 |     | <span class='neutral'>        /// @auditor - tick.priceAt will be zero for tick % tickSpacing == 0</span>
 127 |     | <span class='unexecuted'>        if (tick.priceAt == 0) {</span>
 128 |     | <span class='unexecuted'>            if (pool.price != (params.zeroForOne ? cache.priceLower : cache.priceUpper)) {</span>
 129 |     | <span class='unexecuted'>                TickMap.set(tickMap, tickToSave, constants.tickSpacing);</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='unexecuted'>            EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 132 |     | <span class='neutral'>        }</span>
 133 |     | <span class='neutral'>        // skip if we are at the nearest full tick</span>
 134 |     | <span class='unexecuted'>        if(pool.price != roundedPrice) {</span>
 135 |     | <span class='neutral'>            // if empty just save the pool price</span>
 136 |     | <span class='unexecuted'>            if (tick.priceAt == 0) {</span>
 137 |     | <span class='unexecuted'>                tick.priceAt = pool.price;</span>
 138 |     | <span class='unexecuted'>                EchidnaAssertions.assertTickAtPriceDivisibleByTickSpacing(tickToSave, ticks[tickToSave].limit.priceAt, constants.tickSpacing);</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='unexecuted'>            else {</span>
 141 |     | <span class='neutral'>                // we need to blend the two partial fills into a single tick</span>
 142 |     | <span class='unexecuted'>                ILimitPoolStructs.InsertSingleLocals memory locals;</span>
 143 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 144 |     | <span class='neutral'>                    // 0 -&gt; 1 positions price moves up so nextFullTick is greater</span>
 145 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave - constants.tickSpacing / 2;</span>
 146 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 147 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 148 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDy(pool.liquidity, locals.pricePrevious, pool.price, false);</span>
 149 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDy(uint128(tick.liquidityDelta), locals.pricePrevious, tick.priceAt, false);</span>
 150 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 151 |     | <span class='neutral'>                    /// @auditor - the opposing amount calculated is off by 1/100 millionth</span>
 152 |     | <span class='neutral'>                    ///            (i.e. since we&#39;re using exactOut we lose precision on exactInput amount)</span>
 153 |     | <span class='neutral'>                    ///            the expected dy to the next tick is either exact or slightly more</span>
 154 |     | <span class='neutral'>                    ///            the expected dx to the next tick is 1/100 millionth less after the blend</span>
 155 |     | <span class='neutral'>                    // advance price past closest full tick using amountOut filled</span>
 156 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, false, true).toUint160();</span>
 157 |     | <span class='neutral'>                    // dx to the next tick is less than before the tick blend</span>
 158 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 159 |     | <span class='unexecuted'>                } else {</span>
 160 |     | <span class='neutral'>                    // 0 -&gt; 1 positions price moves up so nextFullTick is lesser</span>
 161 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave + constants.tickSpacing / 2;</span>
 162 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 163 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 164 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDx(pool.liquidity, pool.price, locals.pricePrevious, false);</span>
 165 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDx(uint128(tick.liquidityDelta), tick.priceAt, locals.pricePrevious, false);</span>
 166 |     | <span class='neutral'>                    // add current pool liquidity to partial tick</span>
 167 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 168 |     | <span class='neutral'>                    // advance price past closest full tick using amountOut filled</span>
 169 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, true, true).toUint160();</span>
 170 |     | <span class='neutral'>                    // mark epoch for second partial fill positions</span>
 171 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 172 |     | <span class='neutral'>                }</span>
 173 |     | <span class='neutral'>            }</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>        // invariant =&gt; if we save liquidity to tick clear pool liquidity</span>
 176 |     | <span class='unexecuted'>        if ((tickToSave != (params.zeroForOne ? params.lower : params.upper))) {</span>
 177 |     | <span class='unexecuted'>            tick.liquidityDelta += int128(pool.liquidity);</span>
 178 |     | <span class='unexecuted'>            tick.liquidityAbsolute += pool.liquidity;</span>
 179 |     | <span class='unexecuted'>            pool.liquidity = 0;</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='unexecuted'>        ticks[tickToSave].limit = tick;</span>
 182 |     | <span class='unexecuted'>        return pool;</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>    function remove(</span>
 186 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 187 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 188 |     | <span class='neutral'>        ILimitPoolStructs.UpdateCache memory cache,</span>
 189 |     | <span class='neutral'>        ILimitPoolStructs.UpdateLimitParams memory params,</span>
 190 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 191 |     | <span class='unexecuted'>    ) internal {</span>
 192 |     | <span class='neutral'>        // set ticks based on claim and zeroForOne</span>
 193 |     | <span class='unexecuted'>        int24 lower = params.zeroForOne ? params.claim : params.lower;</span>
 194 |     | <span class='unexecuted'>        int24 upper = params.zeroForOne ? params.upper : params.claim;</span>
 195 |     | <span class='neutral'>        {    </span>
 196 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickLower = ticks[lower].limit;</span>
 197 |     | <span class='neutral'>            </span>
 198 |     | <span class='unexecuted'>            if (cache.removeLower) {</span>
 199 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 200 |     | <span class='unexecuted'>                    tickLower.liquidityDelta -= int128(params.amount);</span>
 201 |     | <span class='neutral'>                } else {</span>
 202 |     | <span class='unexecuted'>                    tickLower.liquidityDelta += int128(params.amount);</span>
 203 |     | <span class='neutral'>                }</span>
 204 |     | <span class='unexecuted'>                tickLower.liquidityAbsolute -= params.amount;</span>
 205 |     | <span class='unexecuted'>                ticks[lower].limit = tickLower;</span>
 206 |     | <span class='unexecuted'>                clear(ticks, constants, tickMap, lower);</span>
 207 |     | <span class='neutral'>            }</span>
 208 |     | <span class='neutral'>        }</span>
 209 |     | <span class='unexecuted'>        {</span>
 210 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickUpper = ticks[upper].limit;</span>
 211 |     | <span class='unexecuted'>            if (cache.removeUpper) {</span>
 212 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 213 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta += int128(params.amount);</span>
 214 |     | <span class='neutral'>                } else {</span>
 215 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta -= int128(params.amount);</span>
 216 |     | <span class='neutral'>                }</span>
 217 |     | <span class='unexecuted'>                tickUpper.liquidityAbsolute -= params.amount;</span>
 218 |     | <span class='unexecuted'>                ticks[upper].limit = tickUpper;</span>
 219 |     | <span class='unexecuted'>                clear(ticks, constants, tickMap, upper);</span>
 220 |     | <span class='neutral'>            }</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>     function unlock(</span>
 225 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache,</span>
 226 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState memory pool,</span>
 227 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 228 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 229 |     | <span class='neutral'>        bool zeroForOne</span>
 230 |     | <span class='neutral'>    ) internal returns (</span>
 231 |     | <span class='unexecuted'>        ILimitPoolStructs.MintLimitCache memory,</span>
 232 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory</span>
 233 |     | <span class='neutral'>    )</span>
 234 |     | <span class='neutral'>    {</span>
 235 |     | <span class='unexecuted'>        if (pool.liquidity &gt; 0) return (cache, pool);</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>        (int24 startTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 240 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.next(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 241 |     | <span class='unexecuted'>            if (pool.tickAtPrice &lt; ConstantProduct.maxTick(cache.constants.tickSpacing)) {</span>
 242 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 243 |     | <span class='neutral'>            }</span>
 244 |     | <span class='neutral'>        } else {</span>
 245 |     | <span class='neutral'>            /// @dev - roundedUp true since liquidity could be equal to the current pool tickAtPrice</span>
 246 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.previous(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 247 |     | <span class='unexecuted'>            if (pool.tickAtPrice &gt; ConstantProduct.minTick(cache.constants.tickSpacing)) {</span>
 248 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 249 |     | <span class='neutral'>            }</span>
 250 |     | <span class='neutral'>        }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>        // increment pool liquidity</span>
 253 |     | <span class='unexecuted'>        EchidnaAssertions.assertPositiveLiquidityOnUnlock(ticks[pool.tickAtPrice].limit.liquidityDelta);</span>
 254 |     | <span class='unexecuted'>        pool.liquidity += uint128(ticks[pool.tickAtPrice].limit.liquidityDelta);</span>
 255 |     | <span class='unexecuted'>        int24 tickToClear = pool.tickAtPrice;</span>
 256 |     | <span class='unexecuted'>        uint160 tickPriceAt = ticks[pool.tickAtPrice].limit.priceAt;</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>        if (tickPriceAt == 0) {</span>
 259 |     | <span class='neutral'>            // if full tick crossed</span>
 260 |     | <span class='unexecuted'>            pool.price = ConstantProduct.getPriceAtTick(pool.tickAtPrice, cache.constants);</span>
 261 |     | <span class='neutral'>        } else {</span>
 262 |     | <span class='neutral'>            // if half tick crossed</span>
 263 |     | <span class='unexecuted'>            pool.price = tickPriceAt;</span>
 264 |     | <span class='unexecuted'>            pool.tickAtPrice = ConstantProduct.getTickAtPrice(tickPriceAt, cache.constants);</span>
 265 |     | <span class='neutral'>        }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>        // zero out tick</span>
 268 |     | <span class='unexecuted'>        ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 269 |     | <span class='unexecuted'>        clear(ticks, cache.constants, tickMap, tickToClear);</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='unexecuted'>        return (cache, pool);</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>    function clear(</span>
 275 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 276 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 277 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 278 |     | <span class='neutral'>        int24 tickToClear</span>
 279 |     | <span class='neutral'>    ) internal {</span>
 280 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 281 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 282 |     | <span class='unexecuted'>                tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 283 |     | <span class='unexecuted'>                ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 284 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 285 |     | <span class='neutral'>            }</span>
 286 |     | <span class='neutral'>        }</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='unexecuted'>    function _empty(</span>
 290 |     | <span class='neutral'>        ILimitPoolStructs.Tick memory tick</span>
 291 |     | <span class='neutral'>    ) internal pure returns (</span>
 292 |     | <span class='unexecuted'>        bool</span>
 293 |     | <span class='neutral'>    ) {</span>
 294 |     | <span class='unexecuted'>        if (tick.limit.liquidityAbsolute != 0) {</span>
 295 |     | <span class='unexecuted'>            return false;</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='unexecuted'>        return true;</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>}</span>
 300 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/limit/pool/BurnLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../PositionsLimit.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 | *   | <span class='executed'>library BurnLimitCall {</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    error SimulateBurn(int24 lower, int24 upper, bool positionExists);</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    event BurnLimit(</span>
  13 |     | <span class='neutral'>        address indexed to,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        int24 claim,</span>
  17 |     | <span class='neutral'>        bool zeroForOne,</span>
  18 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  19 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  20 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function perform(</span>
  24 |     | <span class='neutral'>        ILimitPoolStructs.BurnLimitParams memory params,</span>
  25 |     | <span class='neutral'>        ILimitPoolStructs.BurnLimitCache memory cache,</span>
  26 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  27 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  28 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
  29 |     | <span class='neutral'>            storage positions</span>
  30 |     | <span class='unexecuted'>    ) internal returns (ILimitPoolStructs.BurnLimitCache memory) {</span>
  31 |     | <span class='unexecuted'>        if (params.lower &gt;= params.upper) require (false, &#39;InvalidPositionBounds()&#39;);</span>
  32 |     | <span class='unexecuted'>        if (cache.position.epochLast == 0) require(false, &#39;PositionNotFound()&#39;);</span>
  33 |     | <span class='unexecuted'>        if (cache.position.crossedInto</span>
  34 |     | <span class='unexecuted'>            || params.claim != (params.zeroForOne ? params.lower : params.upper)</span>
  35 |     | <span class='unexecuted'>            || cache.position.epochLast &lt; (params.zeroForOne ? EpochMap.get(params.lower, params.zeroForOne, tickMap, cache.constants)</span>
  36 |     | <span class='unexecuted'>                                                             : EpochMap.get(params.upper, params.zeroForOne, tickMap, cache.constants)))</span>
  37 |     | <span class='neutral'>        {</span>
  38 |     | <span class='neutral'>            // position has been crossed into</span>
  39 |     | <span class='unexecuted'>            (</span>
  40 |     | <span class='neutral'>                cache.state,</span>
  41 |     | <span class='unexecuted'>                cache.position,</span>
  42 |     | <span class='unexecuted'>                params.claim</span>
  43 |     | <span class='unexecuted'>            ) = PositionsLimit.update(</span>
  44 |     | <span class='unexecuted'>                positions,</span>
  45 |     | <span class='unexecuted'>                ticks,</span>
  46 |     | <span class='unexecuted'>                tickMap,</span>
  47 |     | <span class='unexecuted'>                cache.state,</span>
  48 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateLimitParams(</span>
  49 |     | <span class='unexecuted'>                    params.to,</span>
  50 |     | <span class='unexecuted'>                    params.to,</span>
  51 |     | <span class='unexecuted'>                    params.burnPercent,</span>
  52 |     | <span class='unexecuted'>                    params.lower,</span>
  53 |     | <span class='unexecuted'>                    params.upper,</span>
  54 |     | <span class='unexecuted'>                    params.claim,</span>
  55 |     | <span class='unexecuted'>                    params.zeroForOne</span>
  56 |     | <span class='neutral'>                ),</span>
  57 |     | <span class='unexecuted'>                cache.constants</span>
  58 |     | <span class='neutral'>            );</span>
  59 |     | <span class='neutral'>        } else {</span>
  60 |     | <span class='neutral'>            // position has not been crossed into</span>
  61 |     | <span class='unexecuted'>            (cache.state, cache.position) = PositionsLimit.remove(</span>
  62 |     | <span class='unexecuted'>                positions,</span>
  63 |     | <span class='unexecuted'>                ticks,</span>
  64 |     | <span class='unexecuted'>                tickMap,</span>
  65 |     | <span class='unexecuted'>                cache.state,</span>
  66 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateLimitParams(</span>
  67 |     | <span class='unexecuted'>                    params.to,</span>
  68 |     | <span class='unexecuted'>                    params.to,</span>
  69 |     | <span class='unexecuted'>                    params.burnPercent,</span>
  70 |     | <span class='unexecuted'>                    params.lower,</span>
  71 |     | <span class='unexecuted'>                    params.upper,</span>
  72 |     | <span class='unexecuted'>                    params.zeroForOne ? params.lower : params.upper,</span>
  73 |     | <span class='unexecuted'>                    params.zeroForOne</span>
  74 |     | <span class='neutral'>                ),</span>
  75 |     | <span class='unexecuted'>                cache.constants</span>
  76 |     | <span class='neutral'>            );</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='unexecuted'>        cache = Collect.burnLimit(</span>
  79 |     | <span class='unexecuted'>            cache,</span>
  80 |     | <span class='unexecuted'>            params</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != params.upper</span>
  83 |     | <span class='unexecuted'>                               : params.claim != params.lower))</span>
  84 |     | <span class='unexecuted'>            params.zeroForOne</span>
  85 |     | <span class='unexecuted'>                ? positions[params.to][params.claim][params.upper] = cache.position</span>
  86 |     | <span class='unexecuted'>                : positions[params.to][params.lower][params.claim] = cache.position;</span>
  87 |     | <span class='unexecuted'>        return cache;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    // Echidna funcs</span>
  91 | *   | <span class='executed'>    function getResizedTicks(</span>
  92 |     | <span class='neutral'>        ILimitPoolStructs.BurnLimitParams memory params,</span>
  93 |     | <span class='neutral'>        ILimitPoolStructs.BurnLimitCache memory cache,</span>
  94 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  95 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  96 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
  97 |     | <span class='neutral'>            storage positions</span>
  98 |     | <span class='neutral'>    ) external {</span>
  99 | *   | <span class='executed'>        if (params.lower &gt;= params.upper) require (false, &#39;InvalidPositionBounds()&#39;);</span>
 100 | *   | <span class='executed'>        if (cache.position.epochLast == 0) require(false, &#39;PositionNotFound()&#39;);</span>
 101 |     | <span class='unexecuted'>        if (cache.position.crossedInto</span>
 102 |     | <span class='unexecuted'>            || params.claim != (params.zeroForOne ? params.lower : params.upper)</span>
 103 |     | <span class='unexecuted'>            || cache.position.epochLast &lt; (params.zeroForOne ? EpochMap.get(params.lower, params.zeroForOne, tickMap, cache.constants)</span>
 104 |     | <span class='unexecuted'>                                                             : EpochMap.get(params.upper, params.zeroForOne, tickMap, cache.constants)))</span>
 105 |     | <span class='neutral'>        {</span>
 106 |     | <span class='neutral'>            // position has been crossed into</span>
 107 |     | <span class='unexecuted'>            (</span>
 108 |     | <span class='neutral'>                cache.state,</span>
 109 |     | <span class='unexecuted'>                cache.position,</span>
 110 |     | <span class='unexecuted'>                params.claim</span>
 111 |     | <span class='unexecuted'>            ) = PositionsLimit.update(</span>
 112 |     | <span class='unexecuted'>                positions,</span>
 113 |     | <span class='unexecuted'>                ticks,</span>
 114 |     | <span class='unexecuted'>                tickMap,</span>
 115 |     | <span class='unexecuted'>                cache.state,</span>
 116 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateLimitParams(</span>
 117 |     | <span class='unexecuted'>                    params.to,</span>
 118 |     | <span class='unexecuted'>                    params.to,</span>
 119 |     | <span class='unexecuted'>                    params.burnPercent,</span>
 120 |     | <span class='unexecuted'>                    params.lower,</span>
 121 |     | <span class='unexecuted'>                    params.upper,</span>
 122 |     | <span class='unexecuted'>                    params.claim,</span>
 123 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 124 |     | <span class='neutral'>                ),</span>
 125 |     | <span class='unexecuted'>                cache.constants</span>
 126 |     | <span class='neutral'>            );</span>
 127 |     | <span class='neutral'>        } else {</span>
 128 |     | <span class='neutral'>            // position has not been crossed into</span>
 129 |     | <span class='unexecuted'>            (cache.state, cache.position) = PositionsLimit.remove(</span>
 130 |     | <span class='unexecuted'>                positions,</span>
 131 |     | <span class='unexecuted'>                ticks,</span>
 132 |     | <span class='unexecuted'>                tickMap,</span>
 133 |     | <span class='unexecuted'>                cache.state,</span>
 134 |     | <span class='unexecuted'>                ILimitPoolStructs.UpdateLimitParams(</span>
 135 |     | <span class='unexecuted'>                    params.to,</span>
 136 |     | <span class='unexecuted'>                    params.to,</span>
 137 |     | <span class='unexecuted'>                    params.burnPercent,</span>
 138 |     | <span class='unexecuted'>                    params.lower,</span>
 139 |     | <span class='unexecuted'>                    params.upper,</span>
 140 |     | <span class='unexecuted'>                    params.zeroForOne ? params.lower : params.upper,</span>
 141 |     | <span class='unexecuted'>                    params.zeroForOne</span>
 142 |     | <span class='neutral'>                ),</span>
 143 |     | <span class='unexecuted'>                cache.constants</span>
 144 |     | <span class='neutral'>            );</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='unexecuted'>        cache = Collect.burnLimit(</span>
 147 |     | <span class='unexecuted'>            cache,</span>
 148 |     | <span class='unexecuted'>            params</span>
 149 |     | <span class='neutral'>        );</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>        bool positionExists = cache.position.epochLast != 0;</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != params.upper</span>
 154 |     | <span class='unexecuted'>                               : params.claim != params.lower)) {</span>
 155 |     | <span class='unexecuted'>            params.zeroForOne</span>
 156 |     | <span class='unexecuted'>                ? positions[params.to][params.claim][params.upper] = cache.position</span>
 157 |     | <span class='unexecuted'>                : positions[params.to][params.lower][params.claim] = cache.position;</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 160 |     | <span class='unexecuted'>                revert SimulateBurn(params.claim, params.upper, positionExists);</span>
 161 |     | <span class='neutral'>            }</span>
 162 |     | <span class='neutral'>            else {</span>
 163 |     | <span class='unexecuted'>                revert SimulateBurn(params.lower, params.claim, positionExists);</span>
 164 |     | <span class='neutral'>            }</span>
 165 |     | <span class='neutral'>        }</span>
 166 |     | <span class='neutral'>        </span>
 167 |     | <span class='unexecuted'>        revert SimulateBurn(params.lower, params.upper, positionExists);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'>}</span>
 170 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/limit/pool/MintLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../PositionsLimit.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../EchidnaAssertions.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../../interfaces/IERC20Minimal.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 | *   | <span class='executed'>library MintLimitCall {</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    error SimulateMint(int24 lower, int24 upper, bool positionCreated);</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    event MintLimit(</span>
  15 |     | <span class='neutral'>        address indexed to,</span>
  16 |     | <span class='neutral'>        int24 lower,</span>
  17 |     | <span class='neutral'>        int24 upper,</span>
  18 |     | <span class='neutral'>        bool zeroForOne,</span>
  19 |     | <span class='neutral'>        uint32 epochLast,</span>
  20 |     | <span class='neutral'>        uint128 amountIn,</span>
  21 |     | <span class='neutral'>        uint128 amountFilled,</span>
  22 |     | <span class='neutral'>        uint128 liquidityMinted</span>
  23 |     | <span class='neutral'>    );</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    event Sync(</span>
  26 |     | <span class='neutral'>        uint160 price,</span>
  27 |     | <span class='neutral'>        uint128 liquidity</span>
  28 |     | <span class='neutral'>    );</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function perform(</span>
  31 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
  32 |     | <span class='neutral'>            storage positions,</span>
  33 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  34 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  35 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  38 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory params,</span>
  39 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache</span>
  40 |     | <span class='unexecuted'>    ) internal returns (ILimitPoolStructs.MintLimitCache memory) {</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // resize position if necessary</span>
  43 |     | <span class='unexecuted'>        (params, cache) = PositionsLimit.resize(</span>
  44 |     | <span class='unexecuted'>            ticks,</span>
  45 |     | <span class='unexecuted'>            samples,</span>
  46 |     | <span class='unexecuted'>            rangeTickMap,</span>
  47 |     | <span class='unexecuted'>            limitTickMap,</span>
  48 |     | <span class='unexecuted'>            params,</span>
  49 |     | <span class='unexecuted'>            cache</span>
  50 |     | <span class='neutral'>        );</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // save state for reentrancy safety</span>
  53 |     | <span class='unexecuted'>        save(cache, globalState, !params.zeroForOne);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        // transfer in token amount</span>
  56 |     | <span class='unexecuted'>        SafeTransfers.transferIn(</span>
  57 |     | <span class='unexecuted'>                                 params.zeroForOne ? cache.constants.token0 </span>
  58 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
  59 |     | <span class='unexecuted'>                                 params.amount + cache.swapCache.input</span>
  60 |     | <span class='neutral'>                                );</span>
  61 |     | <span class='neutral'>        // transfer out if swap output </span>
  62 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  63 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  64 |     | <span class='unexecuted'>            cache.swapCache.output</span>
  65 |     | <span class='neutral'>        );</span>
  66 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0)</span>
  67 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
  68 |     | <span class='unexecuted'>                params.to,</span>
  69 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
  70 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
  71 |     | <span class='unexecuted'>                cache.swapCache.output</span>
  72 |     | <span class='neutral'>            );</span>
  73 |     | <span class='neutral'>        // mint position if amount is left</span>
  74 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
  75 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
  76 |     | <span class='neutral'>            // load position given params</span>
  77 |     | <span class='unexecuted'>            cache.position = positions[params.to][params.lower][params.upper];</span>
  78 |     | <span class='neutral'>            </span>
  79 |     | <span class='neutral'>            // bump to the next tick if there is no liquidity</span>
  80 |     | <span class='unexecuted'>            if (cache.pool.liquidity == 0) {</span>
  81 |     | <span class='neutral'>                /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
  82 |     | <span class='unexecuted'>                (cache, cache.pool) = TicksLimit.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);</span>
  83 |     | <span class='neutral'>            }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  86 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
  87 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
  88 |     | <span class='neutral'>                    // save liquidity if active</span>
  89 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
  90 |     | <span class='unexecuted'>                        cache.pool = TicksLimit.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
  91 |     | <span class='neutral'>                    }</span>
  92 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
  93 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
  94 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
  95 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
  96 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
  97 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
  98 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
  99 |     | <span class='unexecuted'>                    emit Sync(cache.pool.price, cache.pool.liquidity);</span>
 100 |     | <span class='neutral'>                }</span>
 101 |     | <span class='unexecuted'>            } else {</span>
 102 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 103 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 104 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 105 |     | <span class='unexecuted'>                        cache.pool = TicksLimit.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 106 |     | <span class='neutral'>                    }</span>
 107 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 108 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 109 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 110 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 111 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 112 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 113 |     | <span class='unexecuted'>                    emit Sync(cache.pool.price, cache.pool.liquidity);</span>
 114 |     | <span class='neutral'>                }</span>
 115 |     | <span class='neutral'>            }</span>
 116 |     | <span class='unexecuted'>            (cache.pool, cache.position) = PositionsLimit.add(</span>
 117 |     | <span class='unexecuted'>                cache,</span>
 118 |     | <span class='unexecuted'>                ticks,</span>
 119 |     | <span class='unexecuted'>                limitTickMap,</span>
 120 |     | <span class='unexecuted'>                params</span>
 121 |     | <span class='neutral'>            );</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>            // save position to storage</span>
 124 |     | <span class='unexecuted'>            positions[params.to][params.lower][params.upper] = cache.position;</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>            params.zeroForOne ? cache.state.pool0 = cache.pool : cache.state.pool1 = cache.pool;</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>            emit MintLimit(</span>
 129 |     | <span class='unexecuted'>                params.to,</span>
 130 |     | <span class='unexecuted'>                params.lower,</span>
 131 |     | <span class='unexecuted'>                params.upper,</span>
 132 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 133 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 134 |     | <span class='unexecuted'>                uint128(params.amount + cache.swapCache.input),</span>
 135 |     | <span class='unexecuted'>                uint128(cache.swapCache.output),</span>
 136 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 137 |     | <span class='neutral'>            );</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        require(cache.position.liquidity != 0, &quot;Minting with 0 liquidity&quot;);</span>
 141 |     | <span class='neutral'>        // save lp side for safe reentrancy</span>
 142 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
 143 |     | <span class='unexecuted'>        return cache;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function save(</span>
 147 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache,</span>
 148 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 149 |     | <span class='neutral'>        bool zeroForOne</span>
 150 |     | <span class='neutral'>    ) internal {</span>
 151 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
 152 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 153 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 154 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
 155 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
 156 |     | <span class='neutral'>        } else {</span>
 157 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
 158 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    // Echidna funcs</span>
 163 | *   | <span class='executed'>    function getResizedTicks(</span>
 164 |     | <span class='neutral'>        mapping(address =&gt; mapping(int24 =&gt; mapping(int24 =&gt; ILimitPoolStructs.LimitPosition)))</span>
 165 |     | <span class='neutral'>            storage positions,</span>
 166 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 167 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
 168 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 169 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 170 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 171 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitParams memory params,</span>
 172 |     | <span class='neutral'>        ILimitPoolStructs.MintLimitCache memory cache</span>
 173 |     | <span class='neutral'>    ) external {</span>
 174 | *   | <span class='executed'>        bool positionCreated = false;</span>
 175 |     | <span class='neutral'>        // resize position if necessary</span>
 176 | *   | <span class='executed'>        (params, cache) = PositionsLimit.resize(</span>
 177 | *   | <span class='executed'>            ticks,</span>
 178 | *   | <span class='executed'>            samples,</span>
 179 | *   | <span class='executed'>            rangeTickMap,</span>
 180 | *   | <span class='executed'>            limitTickMap,</span>
 181 | *   | <span class='executed'>            params,</span>
 182 | *   | <span class='executed'>            cache</span>
 183 |     | <span class='neutral'>        );</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        // save state for reentrancy safety</span>
 186 | *   | <span class='executed'>        save(cache, globalState, !params.zeroForOne);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        // transfer in token amount</span>
 189 | *   | <span class='executed'>        SafeTransfers.transferIn(</span>
 190 | *   | <span class='executed'>                                 params.zeroForOne ? cache.constants.token0 </span>
 191 | *   | <span class='executed'>                                                   : cache.constants.token1,</span>
 192 | *   | <span class='executed'>                                 params.amount + cache.swapCache.input</span>
 193 |     | <span class='neutral'>                                );</span>
 194 |     | <span class='neutral'>        // transfer out if swap output </span>
 195 | *   | <span class='executed'>        if (cache.swapCache.output &gt; 0)</span>
 196 | *   | <span class='executed'>            SafeTransfers.transferOut(</span>
 197 |     | <span class='unexecuted'>                params.to,</span>
 198 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
 199 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
 200 |     | <span class='unexecuted'>                cache.swapCache.output</span>
 201 |     | <span class='neutral'>            );</span>
 202 |     | <span class='neutral'>        // mint position if amount is left</span>
 203 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
 204 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
 205 |     | <span class='neutral'>            // load position given params</span>
 206 |     | <span class='unexecuted'>            cache.position = positions[params.to][params.lower][params.upper];</span>
 207 |     | <span class='neutral'>            </span>
 208 |     | <span class='neutral'>            // bump to the next tick if there is no liquidity</span>
 209 |     | <span class='unexecuted'>            if (cache.pool.liquidity == 0) {</span>
 210 |     | <span class='neutral'>                /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
 211 |     | <span class='unexecuted'>                (cache, cache.pool) = TicksLimit.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 215 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 216 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
 217 |     | <span class='neutral'>                    // save liquidity if active</span>
 218 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 219 |     | <span class='unexecuted'>                        cache.pool = TicksLimit.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 220 |     | <span class='neutral'>                    }</span>
 221 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
 222 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
 223 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
 224 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 225 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 226 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 227 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 228 |     | <span class='unexecuted'>                    emit Sync(cache.pool.price, cache.pool.liquidity);</span>
 229 |     | <span class='neutral'>                }</span>
 230 |     | <span class='unexecuted'>            } else {</span>
 231 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 232 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 233 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 234 |     | <span class='unexecuted'>                        cache.pool = TicksLimit.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 235 |     | <span class='neutral'>                    }</span>
 236 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 237 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 238 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 239 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 240 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 241 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 242 |     | <span class='unexecuted'>                    emit Sync(cache.pool.price, cache.pool.liquidity);</span>
 243 |     | <span class='neutral'>                }</span>
 244 |     | <span class='neutral'>            }</span>
 245 |     | <span class='unexecuted'>            (cache.pool, cache.position) = PositionsLimit.add(</span>
 246 |     | <span class='unexecuted'>                cache,</span>
 247 |     | <span class='unexecuted'>                ticks,</span>
 248 |     | <span class='unexecuted'>                limitTickMap,</span>
 249 |     | <span class='unexecuted'>                params</span>
 250 |     | <span class='neutral'>            );</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>            positionCreated = true;</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>            // save position to storage</span>
 255 |     | <span class='unexecuted'>            positions[params.to][params.lower][params.upper] = cache.position;</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='unexecuted'>            params.zeroForOne ? cache.state.pool0 = cache.pool : cache.state.pool1 = cache.pool;</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>            emit MintLimit(</span>
 260 |     | <span class='unexecuted'>                params.to,</span>
 261 |     | <span class='unexecuted'>                params.lower,</span>
 262 |     | <span class='unexecuted'>                params.upper,</span>
 263 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 264 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 265 |     | <span class='unexecuted'>                uint128(params.amount + cache.swapCache.input),</span>
 266 |     | <span class='unexecuted'>                uint128(cache.swapCache.output),</span>
 267 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 268 |     | <span class='neutral'>            );</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'></span>
 271 |     | <span class='neutral'>        // save lp side for safe reentrancy</span>
 272 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
 273 |     | <span class='neutral'>    </span>
 274 |     | <span class='unexecuted'>        revert SimulateMint(params.lower, params.upper, positionCreated);</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function balance(</span>
 278 |     | <span class='neutral'>        address token</span>
 279 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 280 |     | <span class='unexecuted'>        (</span>
 281 |     | <span class='neutral'>            bool success,</span>
 282 |     | <span class='neutral'>            bytes memory data</span>
 283 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 284 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 285 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 286 |     | <span class='unexecuted'>                                        address(this)</span>
 287 |     | <span class='neutral'>                                    )</span>
 288 |     | <span class='neutral'>                                );</span>
 289 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 290 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'>}</span>
 293 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/math/ConstantProduct.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./OverflowMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../base/structs/PoolsharkStructs.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Math library that facilitates ranged liquidity calculations.</span>
   9 |     | <span class='unexecuted'>library ConstantProduct {</span>
  10 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct PriceBounds {</span>
  13 |     | <span class='neutral'>        uint160 min;</span>
  14 |     | <span class='neutral'>        uint160 max;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>    ///////////////////////// DYDX MATH /////////////////////////</span>
  19 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function getDy(</span>
  22 |     | <span class='neutral'>        uint256 liquidity,</span>
  23 |     | <span class='neutral'>        uint256 priceLower,</span>
  24 |     | <span class='neutral'>        uint256 priceUpper,</span>
  25 |     | <span class='neutral'>        bool roundUp</span>
  26 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  27 |     | <span class='unexecuted'>        return _getDy(liquidity, priceLower, priceUpper, roundUp);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function getDx(</span>
  31 |     | <span class='neutral'>        uint256 liquidity,</span>
  32 |     | <span class='neutral'>        uint256 priceLower,</span>
  33 |     | <span class='neutral'>        uint256 priceUpper,</span>
  34 |     | <span class='neutral'>        bool roundUp</span>
  35 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  36 |     | <span class='unexecuted'>        return _getDx(liquidity, priceLower, priceUpper, roundUp);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function _getDy(</span>
  40 |     | <span class='neutral'>        uint256 liquidity,</span>
  41 |     | <span class='neutral'>        uint256 priceLower,</span>
  42 |     | <span class='neutral'>        uint256 priceUpper,</span>
  43 |     | <span class='neutral'>        bool roundUp</span>
  44 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  45 |     | <span class='neutral'>        unchecked {</span>
  46 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  47 |     | <span class='unexecuted'>            if (roundUp) {</span>
  48 |     | <span class='unexecuted'>                dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);</span>
  49 |     | <span class='neutral'>            } else {</span>
  50 |     | <span class='unexecuted'>                dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);</span>
  51 |     | <span class='neutral'>            }</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function _getDx(</span>
  56 |     | <span class='neutral'>        uint256 liquidity,</span>
  57 |     | <span class='neutral'>        uint256 priceLower,</span>
  58 |     | <span class='neutral'>        uint256 priceUpper,</span>
  59 |     | <span class='neutral'>        bool roundUp</span>
  60 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  61 |     | <span class='neutral'>        unchecked {</span>
  62 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  63 |     | <span class='unexecuted'>            if (roundUp) {</span>
  64 |     | <span class='unexecuted'>                dx = OverflowMath.divRoundingUp(</span>
  65 |     | <span class='unexecuted'>                        OverflowMath.mulDivRoundingUp(</span>
  66 |     | <span class='unexecuted'>                            liquidity &lt;&lt; 96, </span>
  67 |     | <span class='unexecuted'>                            priceUpper - priceLower,</span>
  68 |     | <span class='unexecuted'>                            priceUpper</span>
  69 |     | <span class='neutral'>                        ),</span>
  70 |     | <span class='unexecuted'>                        priceLower</span>
  71 |     | <span class='neutral'>                );</span>
  72 |     | <span class='neutral'>            } else {</span>
  73 |     | <span class='unexecuted'>                dx = OverflowMath.mulDiv(</span>
  74 |     | <span class='unexecuted'>                        liquidity &lt;&lt; 96,</span>
  75 |     | <span class='unexecuted'>                        priceUpper - priceLower,</span>
  76 |     | <span class='unexecuted'>                        priceUpper</span>
  77 |     | <span class='unexecuted'>                ) / priceLower;</span>
  78 |     | <span class='neutral'>            }</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  83 |     | <span class='neutral'>        uint256 priceLower,</span>
  84 |     | <span class='neutral'>        uint256 priceUpper,</span>
  85 |     | <span class='neutral'>        uint256 currentPrice,</span>
  86 |     | <span class='neutral'>        uint256 dy,</span>
  87 |     | <span class='neutral'>        uint256 dx</span>
  88 |     | <span class='unexecuted'>    ) internal pure returns (uint256 liquidity) {</span>
  89 |     | <span class='neutral'>        unchecked {</span>
  90 |     | <span class='unexecuted'>            if (priceUpper &lt;= currentPrice) {</span>
  91 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);</span>
  92 |     | <span class='unexecuted'>            } else if (currentPrice &lt;= priceLower) {</span>
  93 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(</span>
  94 |     | <span class='unexecuted'>                    dx,</span>
  95 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceLower, priceUpper, Q96),</span>
  96 |     | <span class='unexecuted'>                    priceUpper - priceLower</span>
  97 |     | <span class='neutral'>                );</span>
  98 |     | <span class='unexecuted'>            } else {</span>
  99 |     | <span class='unexecuted'>                uint256 liquidity0 = OverflowMath.mulDiv(</span>
 100 |     | <span class='unexecuted'>                    dx,</span>
 101 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceUpper, currentPrice, Q96),</span>
 102 |     | <span class='unexecuted'>                    priceUpper - currentPrice</span>
 103 |     | <span class='neutral'>                );</span>
 104 |     | <span class='unexecuted'>                uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);</span>
 105 |     | <span class='unexecuted'>                liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
 106 |     | <span class='neutral'>            }</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
 111 |     | <span class='neutral'>        uint256 priceLower,</span>
 112 |     | <span class='neutral'>        uint256 priceUpper,</span>
 113 |     | <span class='neutral'>        uint256 currentPrice,</span>
 114 |     | <span class='neutral'>        uint256 liquidityAmount,</span>
 115 |     | <span class='neutral'>        bool roundUp</span>
 116 |     | <span class='unexecuted'>    ) internal pure returns (uint128 token0amount, uint128 token1amount) {</span>
 117 |     | <span class='unexecuted'>        if (priceUpper &lt;= currentPrice) {</span>
 118 |     | <span class='unexecuted'>            token1amount = uint128(_getDy(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 119 |     | <span class='unexecuted'>        } else if (currentPrice &lt;= priceLower) {</span>
 120 |     | <span class='unexecuted'>            token0amount = uint128(_getDx(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 121 |     | <span class='neutral'>        } else {</span>
 122 |     | <span class='unexecuted'>            token0amount = uint128(_getDx(liquidityAmount, currentPrice, priceUpper, roundUp));</span>
 123 |     | <span class='unexecuted'>            token1amount = uint128(_getDy(liquidityAmount, priceLower, currentPrice, roundUp));</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='unexecuted'>        if (token0amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 126 |     | <span class='unexecuted'>        if (token1amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function getNewPrice(</span>
 130 |     | <span class='neutral'>        uint256 price,</span>
 131 |     | <span class='neutral'>        uint256 liquidity,</span>
 132 |     | <span class='neutral'>        uint256 amount,</span>
 133 |     | <span class='neutral'>        bool zeroForOne,</span>
 134 |     | <span class='neutral'>        bool exactIn</span>
 135 |     | <span class='neutral'>    ) internal pure returns (</span>
 136 |     | <span class='unexecuted'>        uint256 newPrice</span>
 137 |     | <span class='neutral'>    ) {</span>
 138 |     | <span class='unexecuted'>        if (exactIn) {</span>
 139 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 140 |     | <span class='unexecuted'>                uint256 liquidityPadded = liquidity &lt;&lt; 96;</span>
 141 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 142 |     | <span class='neutral'>                                liquidityPadded,</span>
 143 |     | <span class='unexecuted'>                                price,</span>
 144 |     | <span class='unexecuted'>                                liquidityPadded + price * amount</span>
 145 |     | <span class='neutral'>                    );</span>
 146 |     | <span class='neutral'>            } else {</span>
 147 |     | <span class='unexecuted'>                newPrice = price + (amount &lt;&lt; 96) / liquidity;</span>
 148 |     | <span class='neutral'>            }</span>
 149 |     | <span class='neutral'>        } else {</span>
 150 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 151 |     | <span class='unexecuted'>                newPrice = price - </span>
 152 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(amount &lt;&lt; 96, liquidity);</span>
 153 |     | <span class='neutral'>            } else {</span>
 154 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(liquidity) &lt;&lt; 96;</span>
 155 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 156 |     | <span class='neutral'>                        liquidityPadded, </span>
 157 |     | <span class='unexecuted'>                        price,</span>
 158 |     | <span class='unexecuted'>                        liquidityPadded - uint256(price) * amount</span>
 159 |     | <span class='neutral'>                );</span>
 160 |     | <span class='neutral'>            }</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 165 |     | <span class='neutral'>    ///////////////////////// TICK MATH /////////////////////////</span>
 166 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128</span>
 169 |     | <span class='unexecuted'>    int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function minTick(</span>
 172 |     | <span class='neutral'>        int16 tickSpacing</span>
 173 |     | <span class='neutral'>    ) internal pure returns (</span>
 174 |     | <span class='unexecuted'>        int24 tick</span>
 175 |     | <span class='neutral'>    ) {</span>
 176 |     | <span class='unexecuted'>        return MIN_TICK / tickSpacing * tickSpacing;</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>    function maxTick(</span>
 180 |     | <span class='neutral'>        int16 tickSpacing</span>
 181 |     | <span class='neutral'>    ) internal pure returns (</span>
 182 |     | <span class='unexecuted'>        int24 tick</span>
 183 |     | <span class='neutral'>    ) {</span>
 184 |     | <span class='unexecuted'>        return MAX_TICK / tickSpacing * tickSpacing;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    function priceBounds(</span>
 188 |     | <span class='neutral'>        int16 tickSpacing</span>
 189 |     | <span class='neutral'>    ) internal pure returns (</span>
 190 |     | <span class='unexecuted'>        uint160,</span>
 191 |     | <span class='unexecuted'>        uint160</span>
 192 |     | <span class='neutral'>    ) {</span>
 193 |     | <span class='unexecuted'>        return (minPrice(tickSpacing), maxPrice(tickSpacing));</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>    function minPrice(</span>
 197 |     | <span class='neutral'>        int16 tickSpacing</span>
 198 |     | <span class='neutral'>    ) internal pure returns (</span>
 199 |     | <span class='unexecuted'>        uint160 price</span>
 200 |     | <span class='neutral'>    ) {</span>
 201 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables  memory constants;</span>
 202 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 203 |     | <span class='unexecuted'>        return getPriceAtTick(minTick(tickSpacing), constants);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function maxPrice(</span>
 207 |     | <span class='neutral'>        int16 tickSpacing</span>
 208 |     | <span class='neutral'>    ) internal pure returns (</span>
 209 |     | <span class='unexecuted'>        uint160 price</span>
 210 |     | <span class='neutral'>    ) {</span>
 211 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables  memory constants;</span>
 212 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 213 |     | <span class='unexecuted'>        return getPriceAtTick(maxTick(tickSpacing), constants);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'>    </span>
 216 |     | <span class='unexecuted'>    function checkTicks(</span>
 217 |     | <span class='neutral'>        int24 lower,</span>
 218 |     | <span class='neutral'>        int24 upper,</span>
 219 |     | <span class='neutral'>        int16 tickSpacing</span>
 220 |     | <span class='neutral'>    ) internal pure</span>
 221 |     | <span class='neutral'>    {</span>
 222 |     | <span class='unexecuted'>        if (lower &lt;= minTick(tickSpacing)) require (false, &#39;LowerTickOutOfBounds()&#39;);</span>
 223 |     | <span class='unexecuted'>        if (upper &gt;= maxTick(tickSpacing)) require (false, &#39;UpperTickOutOfBounds()&#39;);</span>
 224 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require (false, &#39;LowerTickOutsideTickSpacing()&#39;);</span>
 225 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require (false, &#39;UpperTickOutsideTickSpacing()&#39;);</span>
 226 |     | <span class='unexecuted'>        if (lower &gt;= upper) require (false, &#39;LowerUpperTickOrderInvalid()&#39;);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    function checkPrice(</span>
 230 |     | <span class='neutral'>        uint160 price,</span>
 231 |     | <span class='neutral'>        PriceBounds memory bounds</span>
 232 |     | <span class='neutral'>    ) internal pure {</span>
 233 |     | <span class='neutral'>        if (price &lt; bounds.min || price &gt;= bounds.max) require (false, &#39;PriceOutOfBounds()&#39;);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96.</span>
 237 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick.</span>
 238 |     | <span class='neutral'>    /// @param tick The input tick for the above formula.</span>
 239 |     | <span class='neutral'>    /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
 240 |     | <span class='neutral'>    /// at the given tick.</span>
 241 |     | <span class='unexecuted'>    function getPriceAtTick(</span>
 242 |     | <span class='neutral'>        int24 tick,</span>
 243 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 244 |     | <span class='neutral'>    ) internal pure returns (</span>
 245 |     | <span class='unexecuted'>        uint160 price</span>
 246 |     | <span class='unexecuted'>    ) {</span>
 247 |     | <span class='unexecuted'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
 248 |     | <span class='unexecuted'>        if (absTick &gt; uint256(uint24(maxTick(constants.tickSpacing)))) require (false, &#39;TickOutOfBounds()&#39;);</span>
 249 |     | <span class='unexecuted'>        unchecked {</span>
 250 |     | <span class='unexecuted'>            uint256 ratio = absTick &amp; 0x1 != 0</span>
 251 |     | <span class='unexecuted'>                ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
 252 |     | <span class='neutral'>                : 0x100000000000000000000000000000000;</span>
 253 |     | <span class='unexecuted'>            if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
 254 |     | <span class='unexecuted'>            if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
 255 |     | <span class='unexecuted'>            if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
 256 |     | <span class='unexecuted'>            if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
 257 |     | <span class='unexecuted'>            if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
 258 |     | <span class='unexecuted'>            if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
 259 |     | <span class='unexecuted'>            if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
 260 |     | <span class='unexecuted'>            if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
 261 |     | <span class='unexecuted'>            if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
 262 |     | <span class='unexecuted'>            if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 263 |     | <span class='unexecuted'>            if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 264 |     | <span class='unexecuted'>            if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 265 |     | <span class='unexecuted'>            if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 266 |     | <span class='unexecuted'>            if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 267 |     | <span class='unexecuted'>            if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 268 |     | <span class='unexecuted'>            if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 269 |     | <span class='unexecuted'>            if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 270 |     | <span class='unexecuted'>            if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 271 |     | <span class='unexecuted'>            if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>            if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 274 |     | <span class='neutral'>            // This divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 275 |     | <span class='neutral'>            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.</span>
 276 |     | <span class='neutral'>            // We round up in the division so getTickAtPrice of the output price is always consistent.</span>
 277 |     | <span class='unexecuted'>            price = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio.</span>
 282 |     | <span class='neutral'>    /// @param price The sqrt ratio for which to compute the tick as a Q64.96.</span>
 283 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.</span>
 284 |     | <span class='unexecuted'>    function getTickAtPrice(</span>
 285 |     | <span class='neutral'>        uint160 price,</span>
 286 |     | <span class='neutral'>        PoolsharkStructs.Immutables  memory constants</span>
 287 |     | <span class='unexecuted'>    ) internal pure returns (int24 tick) {</span>
 288 |     | <span class='neutral'>        // Second inequality must be &lt; because the price can never reach the price at the max tick.</span>
 289 |     | <span class='unexecuted'>        if (price &lt; constants.bounds.min || price &gt;= constants.bounds.max)</span>
 290 |     | <span class='unexecuted'>            require (false, &#39;PriceOutOfBounds()&#39;);</span>
 291 |     | <span class='unexecuted'>        uint256 ratio = uint256(price) &lt;&lt; 32;</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>        uint256 r = ratio;</span>
 294 |     | <span class='neutral'>        uint256 msb = 0;</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>        assembly {</span>
 297 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 298 |     | <span class='neutral'>            msb := or(msb, f)</span>
 299 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'>        assembly {</span>
 302 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 303 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 304 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 305 |     | <span class='neutral'>        }</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='unexecuted'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 308 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 309 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        assembly {</span>
 312 |     | <span class='unexecuted'>            let f := shl(4, gt(r, 0xFFFF))</span>
 313 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 314 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 315 |     | <span class='neutral'>        }</span>
 316 |     | <span class='neutral'>        assembly {</span>
 317 |     | <span class='unexecuted'>            let f := shl(3, gt(r, 0xFF))</span>
 318 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 319 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'>        assembly {</span>
 322 |     | <span class='unexecuted'>            let f := shl(2, gt(r, 0xF))</span>
 323 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 324 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'>        assembly {</span>
 327 |     | <span class='unexecuted'>            let f := shl(1, gt(r, 0x3))</span>
 328 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 329 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>        assembly {</span>
 332 |     | <span class='unexecuted'>            let f := gt(r, 0x1)</span>
 333 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 337 |     | <span class='unexecuted'>        else r = ratio &lt;&lt; (127 - msb);</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='unexecuted'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>        assembly {</span>
 342 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 343 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 344 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(63, f))</span>
 345 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 346 |     | <span class='neutral'>        }</span>
 347 |     | <span class='neutral'>        assembly {</span>
 348 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 349 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 350 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(62, f))</span>
 351 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 352 |     | <span class='neutral'>        }</span>
 353 |     | <span class='neutral'>        assembly {</span>
 354 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 355 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 356 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(61, f))</span>
 357 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 358 |     | <span class='neutral'>        }</span>
 359 |     | <span class='neutral'>        assembly {</span>
 360 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 361 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 362 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(60, f))</span>
 363 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 364 |     | <span class='neutral'>        }</span>
 365 |     | <span class='neutral'>        assembly {</span>
 366 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 367 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 368 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(59, f))</span>
 369 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>        assembly {</span>
 372 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 373 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 374 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(58, f))</span>
 375 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'>        assembly {</span>
 378 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 379 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 380 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(57, f))</span>
 381 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 382 |     | <span class='neutral'>        }</span>
 383 |     | <span class='neutral'>        assembly {</span>
 384 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 385 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 386 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(56, f))</span>
 387 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 388 |     | <span class='neutral'>        }</span>
 389 |     | <span class='neutral'>        assembly {</span>
 390 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 391 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 392 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(55, f))</span>
 393 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 394 |     | <span class='neutral'>        }</span>
 395 |     | <span class='neutral'>        assembly {</span>
 396 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 397 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 398 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(54, f))</span>
 399 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 400 |     | <span class='neutral'>        }</span>
 401 |     | <span class='neutral'>        assembly {</span>
 402 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 403 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 404 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(53, f))</span>
 405 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>        assembly {</span>
 408 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 409 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 410 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(52, f))</span>
 411 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 412 |     | <span class='neutral'>        }</span>
 413 |     | <span class='neutral'>        assembly {</span>
 414 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 415 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 416 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(51, f))</span>
 417 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 418 |     | <span class='neutral'>        }</span>
 419 |     | <span class='neutral'>        assembly {</span>
 420 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 421 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 422 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(50, f))</span>
 423 |     | <span class='neutral'>        }</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='unexecuted'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='unexecuted'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 428 |     | <span class='unexecuted'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='unexecuted'>        tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) &lt;= price</span>
 431 |     | <span class='unexecuted'>            ? tickHi</span>
 432 |     | <span class='unexecuted'>            : tickLow;</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/math/OverflowMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.</span>
   5 |     | <span class='unexecuted'>library OverflowMath {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    // @dev no underflow or overflow checks</span>
   8 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   9 |     | <span class='neutral'>        assembly {</span>
  10 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
  11 |     | <span class='neutral'>        }</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
  15 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
  16 |     | <span class='neutral'>    /// @param b The multiplier.</span>
  17 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
  18 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
  19 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.</span>
  20 |     | <span class='unexecuted'>    function mulDiv(</span>
  21 |     | <span class='neutral'>        uint256 a,</span>
  22 |     | <span class='neutral'>        uint256 b,</span>
  23 |     | <span class='neutral'>        uint256 denominator</span>
  24 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  25 |     | <span class='neutral'>        unchecked {</span>
  26 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = a * b.</span>
  27 |     | <span class='neutral'>            // Compute the product mod 2**256 and mod 2**256 - 1,</span>
  28 |     | <span class='neutral'>            // then use the Chinese Remainder Theorem to reconstruct</span>
  29 |     | <span class='neutral'>            // the 512 bit result. The result is stored in two 256</span>
  30 |     | <span class='neutral'>            // variables such that product = prod1 * 2**256 + prod0.</span>
  31 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product.</span>
  32 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product.</span>
  33 |     | <span class='neutral'>            assembly {</span>
  34 |     | <span class='unexecuted'>                let mm := mulmod(a, b, not(0))</span>
  35 |     | <span class='unexecuted'>                prod0 := mul(a, b)</span>
  36 |     | <span class='unexecuted'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  39 |     | <span class='unexecuted'>            if (prod1 == 0) {</span>
  40 |     | <span class='unexecuted'>                require(denominator &gt; 0);</span>
  41 |     | <span class='neutral'>                assembly {</span>
  42 |     | <span class='unexecuted'>                    result := div(prod0, denominator)</span>
  43 |     | <span class='neutral'>                }</span>
  44 |     | <span class='unexecuted'>                return result;</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'>            // Make sure the result is less than 2**256 -</span>
  47 |     | <span class='neutral'>            // also prevents denominator == 0.</span>
  48 |     | <span class='unexecuted'>            require(denominator &gt; prod1);</span>
  49 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  50 |     | <span class='neutral'>            // 512 by 256 division.</span>
  51 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0] -</span>
  53 |     | <span class='neutral'>            // compute remainder using mulmod.</span>
  54 |     | <span class='unexecuted'>            uint256 remainder;</span>
  55 |     | <span class='neutral'>            assembly {</span>
  56 |     | <span class='unexecuted'>                remainder := mulmod(a, b, denominator)</span>
  57 |     | <span class='neutral'>            }</span>
  58 |     | <span class='neutral'>            // Subtract 256 bit number from 512 bit number.</span>
  59 |     | <span class='neutral'>            assembly {</span>
  60 |     | <span class='unexecuted'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  61 |     | <span class='unexecuted'>                prod0 := sub(prod0, remainder)</span>
  62 |     | <span class='neutral'>            }</span>
  63 |     | <span class='neutral'>            // Factor powers of two out of denominator -</span>
  64 |     | <span class='neutral'>            // compute largest power of two divisor of denominator</span>
  65 |     | <span class='neutral'>            // (always &gt;= 1).</span>
  66 |     | <span class='unexecuted'>            uint256 twos = uint256(-int256(denominator)) &amp; denominator;</span>
  67 |     | <span class='neutral'>            // Divide denominator by power of two.</span>
  68 |     | <span class='neutral'>            assembly {</span>
  69 |     | <span class='unexecuted'>                denominator := div(denominator, twos)</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>            // Divide [prod1 prod0] by the factors of two.</span>
  72 |     | <span class='neutral'>            assembly {</span>
  73 |     | <span class='unexecuted'>                prod0 := div(prod0, twos)</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0. For this we need</span>
  76 |     | <span class='neutral'>            // to flip `twos` such that it is 2**256 / twos -</span>
  77 |     | <span class='neutral'>            // if twos is zero, then it becomes one.</span>
  78 |     | <span class='neutral'>            assembly {</span>
  79 |     | <span class='unexecuted'>                twos := add(div(sub(0, twos), twos), 1)</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='unexecuted'>            prod0 |= prod1 * twos;</span>
  82 |     | <span class='neutral'>            // Invert denominator mod 2**256 -</span>
  83 |     | <span class='neutral'>            // now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>            // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>            // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>            // for four bits. That is, denominator * inv = 1 mod 2**4.</span>
  87 |     | <span class='unexecuted'>            uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>            // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>            // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>            // arithmetic, doubling the correct bits in each step.</span>
  91 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**8.</span>
  92 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**16.</span>
  93 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**32.</span>
  94 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**64.</span>
  95 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**128.</span>
  96 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**256.</span>
  97 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying</span>
  98 |     | <span class='neutral'>            // with the modular inverse of denominator. This will give us the</span>
  99 |     | <span class='neutral'>            // correct result modulo 2**256. Since the precoditions guarantee</span>
 100 |     | <span class='neutral'>            // that the outcome is less than 2**256, this is the final result.</span>
 101 |     | <span class='neutral'>            // We don&#39;t need to compute the high bits of the result and prod1</span>
 102 |     | <span class='neutral'>            // is no longer required.</span>
 103 |     | <span class='unexecuted'>            result = prod0 * inv;</span>
 104 |     | <span class='neutral'>            return result;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier.</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
 113 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 118 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 119 |     | <span class='neutral'>        unchecked {</span>
 120 |     | <span class='unexecuted'>            if (mulmod(a, b, denominator) != 0) {</span>
 121 |     | <span class='unexecuted'>                if (result &gt;= type(uint256).max) require (false, &#39;MaxUintExceeded()&#39;);</span>
 122 |     | <span class='unexecuted'>                result++;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/QuoteCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library QuoteCall {</span>
  8 |     | <span class='neutral'>    event Swap(</span>
  9 |     | <span class='neutral'>        address indexed recipient,</span>
 10 |     | <span class='neutral'>        bool zeroForOne,</span>
 11 |     | <span class='neutral'>        uint256 amountIn,</span>
 12 |     | <span class='neutral'>        uint256 amountOut,</span>
 13 |     | <span class='neutral'>        uint160 price,</span>
 14 |     | <span class='neutral'>        uint128 liquidity,</span>
 15 |     | <span class='neutral'>        int24 tickAtPrice</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function perform(</span>
 19 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
 20 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 21 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 22 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params,</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 24 |     | <span class='neutral'>    ) internal view returns (</span>
 25 |     | <span class='unexecuted'>        uint256,</span>
 26 |     | <span class='unexecuted'>        uint256,</span>
 27 |     | <span class='unexecuted'>        uint160</span>
 28 |     | <span class='neutral'>    ) {</span>
 29 |     | <span class='unexecuted'>        return Ticks.quote(</span>
 30 |     | <span class='unexecuted'>            ticks,</span>
 31 |     | <span class='unexecuted'>            rangeTickMap,</span>
 32 |     | <span class='unexecuted'>            limitTickMap,</span>
 33 |     | <span class='unexecuted'>            params,</span>
 34 |     | <span class='unexecuted'>            cache</span>
 35 |     | <span class='neutral'>        );</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/SampleCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../range/Samples.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library SampleCall {</span>
  8 |     | <span class='neutral'>    event Swap(</span>
  9 |     | <span class='neutral'>        address indexed recipient,</span>
 10 |     | <span class='neutral'>        bool zeroForOne,</span>
 11 |     | <span class='neutral'>        uint256 amountIn,</span>
 12 |     | <span class='neutral'>        uint256 amountOut,</span>
 13 |     | <span class='neutral'>        uint160 price,</span>
 14 |     | <span class='neutral'>        uint128 liquidity,</span>
 15 |     | <span class='neutral'>        int24 tickAtPrice</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function perform(</span>
 19 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 20 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 21 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 22 |     | <span class='neutral'>    ) internal view returns (</span>
 23 |     | <span class='neutral'>        int56[]   memory tickSecondsAccum,</span>
 24 |     | <span class='neutral'>        uint160[] memory secondsPerLiquidityAccum,</span>
 25 |     | <span class='neutral'>        uint160 averagePrice,</span>
 26 |     | <span class='neutral'>        uint128 averageLiquidity,</span>
 27 |     | <span class='neutral'>        int24 averageTick</span>
 28 |     | <span class='neutral'>    ) {</span>
 29 |     | <span class='neutral'>        return Samples.get(</span>
 30 |     | <span class='neutral'>            address(this),</span>
 31 |     | <span class='neutral'>            IRangePoolStructs.SampleParams(</span>
 32 |     | <span class='neutral'>                state.pool.samples.index,</span>
 33 |     | <span class='neutral'>                state.pool.samples.length,</span>
 34 |     | <span class='neutral'>                uint32(block.timestamp),</span>
 35 |     | <span class='neutral'>                secondsAgo,</span>
 36 |     | <span class='neutral'>                state.pool.tickAtPrice,</span>
 37 |     | <span class='neutral'>                state.pool.liquidity,</span>
 38 |     | <span class='neutral'>                constants</span>
 39 |     | <span class='neutral'>            )</span>
 40 |     | <span class='neutral'>        );</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>
 43 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/SwapCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/callbacks/IPoolsharkSwapCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library SwapCall {</span>
  12 |     | <span class='neutral'>    event SwapPool0(</span>
  13 |     | <span class='neutral'>        address indexed recipient,</span>
  14 |     | <span class='neutral'>        uint128 amountIn,</span>
  15 |     | <span class='neutral'>        uint128 amountOut,</span>
  16 |     | <span class='neutral'>        uint160 priceLimit,</span>
  17 |     | <span class='neutral'>        uint160 newPrice</span>
  18 |     | <span class='neutral'>    );</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event SwapPool1(</span>
  21 |     | <span class='neutral'>        address indexed recipient,</span>
  22 |     | <span class='neutral'>        uint128 amountIn,</span>
  23 |     | <span class='neutral'>        uint128 amountOut,</span>
  24 |     | <span class='neutral'>        uint160 priceLimit,</span>
  25 |     | <span class='neutral'>        uint160 newPrice</span>
  26 |     | <span class='neutral'>    );</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function perform(</span>
  29 |     | <span class='neutral'>        mapping(int24 =&gt; ILimitPoolStructs.Tick) storage ticks,</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  31 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  32 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  33 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  34 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
  35 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
  36 |     | <span class='neutral'>    ) internal returns (</span>
  37 |     | <span class='unexecuted'>        int256,</span>
  38 |     | <span class='unexecuted'>        int256</span>
  39 |     | <span class='neutral'>    ) {</span>
  40 |     | <span class='unexecuted'>        cache = Ticks.swap(</span>
  41 |     | <span class='unexecuted'>            ticks,</span>
  42 |     | <span class='unexecuted'>            samples,</span>
  43 |     | <span class='unexecuted'>            rangeTickMap,</span>
  44 |     | <span class='unexecuted'>            limitTickMap,</span>
  45 |     | <span class='unexecuted'>            params,</span>
  46 |     | <span class='unexecuted'>            cache</span>
  47 |     | <span class='neutral'>        );</span>
  48 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
  49 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  50 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  51 |     | <span class='unexecuted'>            cache.output</span>
  52 |     | <span class='neutral'>        );</span>
  53 |     | <span class='neutral'>        // transfer output amount</span>
  54 |     | <span class='unexecuted'>        SafeTransfers.transferOut(</span>
  55 |     | <span class='unexecuted'>            params.to, </span>
  56 |     | <span class='unexecuted'>            params.zeroForOne ? cache.constants.token1</span>
  57 |     | <span class='unexecuted'>                              : cache.constants.token0,</span>
  58 |     | <span class='unexecuted'>            cache.output</span>
  59 |     | <span class='neutral'>        );</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>        // check balance and execute callback</span>
  62 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
  63 |     | <span class='unexecuted'>        IPoolsharkSwapCallback(msg.sender).poolsharkSwapCallback(</span>
  64 |     | <span class='unexecuted'>            params.zeroForOne ? -int256(cache.input) : int256(cache.output),</span>
  65 |     | <span class='unexecuted'>            params.zeroForOne ? int256(cache.output) : -int256(cache.input),</span>
  66 |     | <span class='unexecuted'>            params.callbackData</span>
  67 |     | <span class='neutral'>        );</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // check balance requirements after callback</span>
  70 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + cache.input)</span>
  71 |     | <span class='unexecuted'>            require(false, &#39;SwapInputAmountTooLow()&#39;);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        return (</span>
  74 |     | <span class='unexecuted'>            params.zeroForOne ? </span>
  75 |     | <span class='neutral'>                (</span>
  76 |     | <span class='unexecuted'>                    -int256(cache.input),</span>
  77 |     | <span class='unexecuted'>                     int256(cache.output)</span>
  78 |     | <span class='neutral'>                )</span>
  79 |     | <span class='neutral'>              : (</span>
  80 |     | <span class='unexecuted'>                     int256(cache.output),</span>
  81 |     | <span class='unexecuted'>                    -int256(cache.input)</span>
  82 |     | <span class='neutral'>                )</span>
  83 |     | <span class='neutral'>        );</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function save(</span>
  87 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
  88 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  89 |     | <span class='neutral'>        bool zeroForOne</span>
  90 |     | <span class='neutral'>    ) internal {</span>
  91 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  92 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
  93 |     | <span class='unexecuted'>        if (zeroForOne)</span>
  94 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
  95 |     | <span class='neutral'>        else</span>
  96 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function balance(</span>
 100 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
 101 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 102 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 103 |     | <span class='unexecuted'>        (</span>
 104 |     | <span class='unexecuted'>            bool success,</span>
 105 |     | <span class='unexecuted'>            bytes memory data</span>
 106 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 107 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
 108 |     | <span class='neutral'>                               .staticcall(</span>
 109 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 110 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 111 |     | <span class='unexecuted'>                                        address(this)</span>
 112 |     | <span class='neutral'>                                    )</span>
 113 |     | <span class='neutral'>                                );</span>
 114 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 115 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function balance(</span>
 119 |     | <span class='neutral'>        address token</span>
 120 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 121 |     | <span class='neutral'>        (</span>
 122 |     | <span class='neutral'>            bool success,</span>
 123 |     | <span class='neutral'>            bytes memory data</span>
 124 |     | <span class='neutral'>        ) = token.staticcall(</span>
 125 |     | <span class='neutral'>                                    abi.encodeWithSelector(</span>
 126 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
 127 |     | <span class='neutral'>                                        address(this)</span>
 128 |     | <span class='neutral'>                                    )</span>
 129 |     | <span class='neutral'>                                );</span>
 130 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 131 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'>}</span>
 134 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/Positions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./math/FeeMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./TicksRange.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./Tokens.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./Samples.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  14 |     | <span class='unexecuted'>library Positions {</span>
  15 |     | <span class='neutral'>    error NotEnoughPositionLiquidity();</span>
  16 |     | <span class='neutral'>    error InvalidClaimTick();</span>
  17 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  18 |     | <span class='neutral'>    error WrongTickClaimedAt();</span>
  19 |     | <span class='neutral'>    error NoLiquidityBeingAdded();</span>
  20 |     | <span class='neutral'>    error PositionNotUpdated();</span>
  21 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  22 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  23 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  24 |     | <span class='neutral'>    error InvalidPositionBoundsOrder();</span>
  25 |     | <span class='neutral'>    error NotImplementedYet();</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event Mint(</span>
  30 |     | <span class='neutral'>        address indexed recipient,</span>
  31 |     | <span class='neutral'>        int24 lower,</span>
  32 |     | <span class='neutral'>        int24 upper,</span>
  33 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
  34 |     | <span class='neutral'>        uint128 tokenMinted,</span>
  35 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
  36 |     | <span class='neutral'>        uint128 amount0,</span>
  37 |     | <span class='neutral'>        uint128 amount1</span>
  38 |     | <span class='neutral'>    );</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    event Burn(</span>
  41 |     | <span class='neutral'>        address indexed recipient,</span>
  42 |     | <span class='neutral'>        int24 lower,</span>
  43 |     | <span class='neutral'>        int24 upper,</span>
  44 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
  45 |     | <span class='neutral'>        uint128 tokenBurned,</span>
  46 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  47 |     | <span class='neutral'>        uint128 amount0,</span>
  48 |     | <span class='neutral'>        uint128 amount1</span>
  49 |     | <span class='neutral'>    );</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    event Compound(</span>
  52 |     | <span class='neutral'>        int24 indexed lower,</span>
  53 |     | <span class='neutral'>        int24 indexed upper,</span>
  54 |     | <span class='neutral'>        uint128 liquidityCompounded,</span>
  55 |     | <span class='neutral'>        uint128 positionAmount0,</span>
  56 |     | <span class='neutral'>        uint128 positionAmount1</span>
  57 |     | <span class='neutral'>    );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function validate(</span>
  60 |     | <span class='neutral'>        IRangePoolStructs.MintParams memory params,</span>
  61 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
  62 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  63 |     | <span class='unexecuted'>    ) internal pure returns (IRangePoolStructs.MintParams memory, uint256 liquidityMinted) {</span>
  64 |     | <span class='unexecuted'>        TicksRange.validate(params.lower, params.upper, constants.tickSpacing);</span>
  65 |     | <span class='neutral'>        </span>
  66 |     | <span class='unexecuted'>        uint256 priceLower = uint256(ConstantProduct.getPriceAtTick(params.lower, constants));</span>
  67 |     | <span class='unexecuted'>        uint256 priceUpper = uint256(ConstantProduct.getPriceAtTick(params.upper, constants));</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  70 |     | <span class='unexecuted'>            priceLower,</span>
  71 |     | <span class='unexecuted'>            priceUpper,</span>
  72 |     | <span class='unexecuted'>            state.pool.price,</span>
  73 |     | <span class='unexecuted'>            params.amount1,</span>
  74 |     | <span class='unexecuted'>            params.amount0</span>
  75 |     | <span class='neutral'>        );</span>
  76 |     | <span class='unexecuted'>        if (liquidityMinted == 0) require(false, &#39;NoLiquidityBeingAdded()&#39;);</span>
  77 |     | <span class='unexecuted'>        (params.amount0, params.amount1) = ConstantProduct.getAmountsForLiquidity(</span>
  78 |     | <span class='unexecuted'>            priceLower,</span>
  79 |     | <span class='unexecuted'>            priceUpper,</span>
  80 |     | <span class='unexecuted'>            state.pool.price,</span>
  81 |     | <span class='unexecuted'>            liquidityMinted,</span>
  82 |     | <span class='unexecuted'>            true</span>
  83 |     | <span class='neutral'>        );</span>
  84 |     | <span class='unexecuted'>        if (liquidityMinted &gt; uint128(type(int128).max)) require(false, &#39;LiquidityOverflow()&#39;);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        return (params, liquidityMinted);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function add(</span>
  90 |     | <span class='neutral'>        IRangePoolStructs.Position memory position,</span>
  91 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  92 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  93 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  94 |     | <span class='neutral'>        IRangePoolStructs.AddParams memory params,</span>
  95 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  96 |     | <span class='neutral'>    ) internal returns (</span>
  97 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory,</span>
  98 |     | <span class='unexecuted'>        IRangePoolStructs.Position memory,</span>
  99 |     | <span class='unexecuted'>        uint128</span>
 100 |     | <span class='neutral'>    ) {</span>
 101 |     | <span class='unexecuted'>        if (params.mint.amount0 == 0 &amp;&amp; params.mint.amount1 == 0) return (params.state, position, 0);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>        IRangePoolStructs.PositionCache memory cache = IRangePoolStructs.PositionCache({</span>
 104 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.mint.lower, constants),</span>
 105 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.mint.upper, constants),</span>
 106 |     | <span class='unexecuted'>            liquidityOnPosition: 0,</span>
 107 |     | <span class='unexecuted'>            liquidityAmount: 0,</span>
 108 |     | <span class='unexecuted'>            totalSupply: Tokens.totalSupply(constants.poolToken, params.mint.lower, params.mint.upper),</span>
 109 |     | <span class='unexecuted'>            tokenId: Tokens.id(params.mint.lower, params.mint.upper)</span>
 110 |     | <span class='neutral'>        });</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        params.state = TicksRange.insert(</span>
 113 |     | <span class='unexecuted'>            ticks,</span>
 114 |     | <span class='unexecuted'>            samples,</span>
 115 |     | <span class='unexecuted'>            tickMap,</span>
 116 |     | <span class='unexecuted'>            params.state,</span>
 117 |     | <span class='unexecuted'>            constants,</span>
 118 |     | <span class='unexecuted'>            params.mint.lower,</span>
 119 |     | <span class='unexecuted'>            params.mint.upper,</span>
 120 |     | <span class='unexecuted'>            params.amount</span>
 121 |     | <span class='neutral'>        );</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>        (</span>
 124 |     | <span class='neutral'>            position.feeGrowthInside0Last,</span>
 125 |     | <span class='unexecuted'>            position.feeGrowthInside1Last</span>
 126 |     | <span class='unexecuted'>        ) = rangeFeeGrowth(</span>
 127 |     | <span class='unexecuted'>            ticks[params.mint.lower].range,</span>
 128 |     | <span class='unexecuted'>            ticks[params.mint.upper].range,</span>
 129 |     | <span class='unexecuted'>            params.state,</span>
 130 |     | <span class='unexecuted'>            params.mint.lower,</span>
 131 |     | <span class='unexecuted'>            params.mint.upper</span>
 132 |     | <span class='neutral'>        );</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>        position.liquidity += uint128(params.amount);</span>
 135 |     | <span class='neutral'>        </span>
 136 |     | <span class='neutral'>        // modify liquidity minted to account for fees accrued</span>
 137 |     | <span class='unexecuted'>        if (position.amount0 &gt; 0 || position.amount1 &gt; 0</span>
 138 |     | <span class='unexecuted'>            || (position.liquidity - params.amount) &gt; cache.totalSupply) {</span>
 139 |     | <span class='neutral'>            // modify amount based on autocompounded fees</span>
 140 |     | <span class='unexecuted'>            if (cache.totalSupply &gt; 0) {</span>
 141 |     | <span class='unexecuted'>                cache.liquidityOnPosition = ConstantProduct.getLiquidityForAmounts(</span>
 142 |     | <span class='unexecuted'>                                                cache.priceLower,</span>
 143 |     | <span class='unexecuted'>                                                cache.priceUpper,</span>
 144 |     | <span class='unexecuted'>                                                position.amount0 &gt; 0 ? cache.priceLower : cache.priceUpper,</span>
 145 |     | <span class='unexecuted'>                                                position.amount1,</span>
 146 |     | <span class='unexecuted'>                                                position.amount0</span>
 147 |     | <span class='neutral'>                                            );</span>
 148 |     | <span class='unexecuted'>                params.amount = uint128(uint256(params.amount) * cache.totalSupply /</span>
 149 |     | <span class='unexecuted'>                        (uint256(position.liquidity - params.amount) + cache.liquidityOnPosition));</span>
 150 |     | <span class='neutral'>            } /// @dev - if there are fees on the position we mint less positionToken</span>
 151 |     | <span class='neutral'>        }</span>
 152 |     | <span class='unexecuted'>        IRangePoolERC1155(constants.poolToken).mintFungible(params.mint.to, cache.tokenId, params.amount, constants);</span>
 153 |     | <span class='unexecuted'>        emit Mint(</span>
 154 |     | <span class='unexecuted'>            params.mint.to,</span>
 155 |     | <span class='unexecuted'>            params.mint.lower,</span>
 156 |     | <span class='unexecuted'>            params.mint.upper,</span>
 157 |     | <span class='unexecuted'>            cache.tokenId,</span>
 158 |     | <span class='unexecuted'>            params.amount,</span>
 159 |     | <span class='unexecuted'>            params.liquidity,</span>
 160 |     | <span class='unexecuted'>            params.mint.amount0,</span>
 161 |     | <span class='unexecuted'>            params.mint.amount1</span>
 162 |     | <span class='neutral'>        );</span>
 163 |     | <span class='unexecuted'>        return (params.state, position, params.amount);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function remove(</span>
 167 |     | <span class='neutral'>        IRangePoolStructs.Position memory position,</span>
 168 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 169 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
 170 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 171 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 172 |     | <span class='neutral'>        IRangePoolStructs.BurnParams memory params,</span>
 173 |     | <span class='neutral'>        IRangePoolStructs.RemoveParams memory removeParams</span>
 174 |     | <span class='neutral'>    ) internal returns (</span>
 175 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory,</span>
 176 |     | <span class='unexecuted'>        IRangePoolStructs.Position memory,</span>
 177 |     | <span class='unexecuted'>        uint128,</span>
 178 |     | <span class='unexecuted'>        uint128</span>
 179 |     | <span class='neutral'>    ) {</span>
 180 |     | <span class='unexecuted'>        IRangePoolStructs.PositionCache memory cache = IRangePoolStructs.PositionCache({</span>
 181 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, removeParams.constants),</span>
 182 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, removeParams.constants),</span>
 183 |     | <span class='unexecuted'>            liquidityOnPosition: 0,</span>
 184 |     | <span class='unexecuted'>            liquidityAmount: 0,</span>
 185 |     | <span class='unexecuted'>            totalSupply: 0,</span>
 186 |     | <span class='unexecuted'>            tokenId: Tokens.id(params.lower, params.upper)</span>
 187 |     | <span class='neutral'>        });</span>
 188 |     | <span class='unexecuted'>        cache.totalSupply = Tokens.totalSupplyById(removeParams.constants.poolToken, cache.tokenId);</span>
 189 |     | <span class='unexecuted'>        cache.liquidityAmount = params.burnPercent &gt; 0 ? removeParams.tokenBurned * uint256(position.liquidity) </span>
 190 |     | <span class='unexecuted'>                                                                       / (cache.totalSupply + removeParams.tokenBurned)</span>
 191 |     | <span class='unexecuted'>                                                                     : 0;</span>
 192 |     | <span class='unexecuted'>        if (removeParams.tokenBurned == 0) {</span>
 193 |     | <span class='unexecuted'>            return (state, position, removeParams.amount0, removeParams.amount1);</span>
 194 |     | <span class='neutral'>        } </span>
 195 |     | <span class='unexecuted'>        if (cache.liquidityAmount &gt; position.liquidity) require(false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 196 |     | <span class='unexecuted'>        {</span>
 197 |     | <span class='unexecuted'>            uint128 amount0Removed; uint128 amount1Removed;</span>
 198 |     | <span class='unexecuted'>            (amount0Removed, amount1Removed) = ConstantProduct.getAmountsForLiquidity(</span>
 199 |     | <span class='unexecuted'>                cache.priceLower,</span>
 200 |     | <span class='unexecuted'>                cache.priceUpper,</span>
 201 |     | <span class='unexecuted'>                state.pool.price,</span>
 202 |     | <span class='unexecuted'>                cache.liquidityAmount,</span>
 203 |     | <span class='unexecuted'>                false</span>
 204 |     | <span class='neutral'>            );</span>
 205 |     | <span class='unexecuted'>            removeParams.amount0 += amount0Removed;</span>
 206 |     | <span class='unexecuted'>            removeParams.amount1 += amount1Removed;</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='unexecuted'>            position.amount0 += amount0Removed;</span>
 209 |     | <span class='unexecuted'>            position.amount1 += amount1Removed;</span>
 210 |     | <span class='unexecuted'>            position.liquidity -= uint128(cache.liquidityAmount);</span>
 211 |     | <span class='neutral'>        }</span>
 212 |     | <span class='unexecuted'>        if (position.liquidity == 0) {</span>
 213 |     | <span class='unexecuted'>            position.feeGrowthInside0Last = 0;</span>
 214 |     | <span class='unexecuted'>            position.feeGrowthInside1Last = 0;</span>
 215 |     | <span class='neutral'>        }</span>
 216 |     | <span class='unexecuted'>        state = TicksRange.remove(</span>
 217 |     | <span class='unexecuted'>            ticks,</span>
 218 |     | <span class='unexecuted'>            samples,</span>
 219 |     | <span class='unexecuted'>            tickMap,</span>
 220 |     | <span class='unexecuted'>            state,</span>
 221 |     | <span class='unexecuted'>            removeParams.constants,</span>
 222 |     | <span class='unexecuted'>            params.lower,</span>
 223 |     | <span class='unexecuted'>            params.upper,</span>
 224 |     | <span class='unexecuted'>            uint128(cache.liquidityAmount)</span>
 225 |     | <span class='neutral'>        );</span>
 226 |     | <span class='unexecuted'>        emit Burn(</span>
 227 |     | <span class='unexecuted'>            params.to,</span>
 228 |     | <span class='unexecuted'>            params.lower,</span>
 229 |     | <span class='unexecuted'>            params.upper,</span>
 230 |     | <span class='unexecuted'>            cache.tokenId,</span>
 231 |     | <span class='unexecuted'>            removeParams.tokenBurned,</span>
 232 |     | <span class='unexecuted'>            uint128(cache.liquidityAmount),</span>
 233 |     | <span class='unexecuted'>            removeParams.amount0,</span>
 234 |     | <span class='unexecuted'>            removeParams.amount1</span>
 235 |     | <span class='neutral'>        );</span>
 236 |     | <span class='unexecuted'>        return (state, position, removeParams.amount0, removeParams.amount1);</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>    function compound(</span>
 240 |     | <span class='neutral'>        IRangePoolStructs.Position memory position,</span>
 241 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 242 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
 243 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 244 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 245 |     | <span class='neutral'>        IRangePoolStructs.CompoundParams memory params,</span>
 246 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 247 |     | <span class='unexecuted'>    ) internal returns (IRangePoolStructs.Position memory, PoolsharkStructs.GlobalState memory) {</span>
 248 |     | <span class='unexecuted'>        IRangePoolStructs.PositionCache memory cache = IRangePoolStructs.PositionCache({</span>
 249 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),</span>
 250 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),</span>
 251 |     | <span class='unexecuted'>            liquidityOnPosition: 0,</span>
 252 |     | <span class='unexecuted'>            liquidityAmount: 0,</span>
 253 |     | <span class='unexecuted'>            totalSupply: 0,</span>
 254 |     | <span class='unexecuted'>            tokenId: 0</span>
 255 |     | <span class='neutral'>        });</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>        // price tells you the ratio so you need to swap into the correct ratio and add liquidity</span>
 258 |     | <span class='unexecuted'>        cache.liquidityAmount = ConstantProduct.getLiquidityForAmounts(</span>
 259 |     | <span class='unexecuted'>            cache.priceLower,</span>
 260 |     | <span class='unexecuted'>            cache.priceUpper,</span>
 261 |     | <span class='unexecuted'>            state.pool.price,</span>
 262 |     | <span class='unexecuted'>            position.amount1,</span>
 263 |     | <span class='unexecuted'>            position.amount0</span>
 264 |     | <span class='neutral'>        );</span>
 265 |     | <span class='unexecuted'>        if (cache.liquidityAmount &gt; 0) {</span>
 266 |     | <span class='unexecuted'>            state = TicksRange.insert(</span>
 267 |     | <span class='unexecuted'>                ticks,</span>
 268 |     | <span class='unexecuted'>                samples,</span>
 269 |     | <span class='unexecuted'>                tickMap,</span>
 270 |     | <span class='unexecuted'>                state,</span>
 271 |     | <span class='unexecuted'>                constants,</span>
 272 |     | <span class='unexecuted'>                params.lower,</span>
 273 |     | <span class='unexecuted'>                params.upper,</span>
 274 |     | <span class='unexecuted'>                uint128(cache.liquidityAmount)</span>
 275 |     | <span class='neutral'>            );</span>
 276 |     | <span class='unexecuted'>            uint256 amount0; uint256 amount1;</span>
 277 |     | <span class='unexecuted'>            (amount0, amount1) = ConstantProduct.getAmountsForLiquidity(</span>
 278 |     | <span class='unexecuted'>                cache.priceLower,</span>
 279 |     | <span class='unexecuted'>                cache.priceUpper,</span>
 280 |     | <span class='unexecuted'>                state.pool.price,</span>
 281 |     | <span class='unexecuted'>                cache.liquidityAmount,</span>
 282 |     | <span class='unexecuted'>                true</span>
 283 |     | <span class='neutral'>            );</span>
 284 |     | <span class='unexecuted'>            position.amount0 -= (amount0 &lt;= position.amount0) ? uint128(amount0) : position.amount0;</span>
 285 |     | <span class='unexecuted'>            position.amount1 -= (amount1 &lt;= position.amount1) ? uint128(amount1) : position.amount1;</span>
 286 |     | <span class='unexecuted'>            position.liquidity += uint128(cache.liquidityAmount);</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='unexecuted'>        emit Compound(</span>
 289 |     | <span class='unexecuted'>            params.lower,</span>
 290 |     | <span class='unexecuted'>            params.upper,</span>
 291 |     | <span class='unexecuted'>            uint128(cache.liquidityAmount),</span>
 292 |     | <span class='unexecuted'>            position.amount0,</span>
 293 |     | <span class='unexecuted'>            position.amount1</span>
 294 |     | <span class='neutral'>        );</span>
 295 |     | <span class='unexecuted'>        return (position, state);</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='unexecuted'>    function update(</span>
 299 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 300 |     | <span class='neutral'>        IRangePoolStructs.Position memory position,</span>
 301 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 302 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 303 |     | <span class='neutral'>        IRangePoolStructs.UpdateParams memory params</span>
 304 |     | <span class='neutral'>    ) internal returns (</span>
 305 |     | <span class='unexecuted'>        IRangePoolStructs.Position memory,</span>
 306 |     | <span class='unexecuted'>        uint128, </span>
 307 |     | <span class='neutral'>        uint128,</span>
 308 |     | <span class='neutral'>        uint128</span>
 309 |     | <span class='neutral'>    ) {</span>
 310 |     | <span class='neutral'>        IRangePoolStructs.UpdatePositionCache memory cache;</span>
 311 |     | <span class='unexecuted'>        cache.totalSupply = Tokens.totalSupply(constants.poolToken, params.lower, params.upper);</span>
 312 |     | <span class='neutral'>        /// @dev - only true if burn call</span>
 313 |     | <span class='unexecuted'>        if (params.burnPercent &gt; 0) {</span>
 314 |     | <span class='unexecuted'>            uint256 tokenId = Tokens.id(params.lower, params.upper);</span>
 315 |     | <span class='unexecuted'>            cache.tokenBurned = params.burnPercent * Tokens.balanceOf(constants.poolToken, msg.sender, params.lower, params.upper) / 1e38;</span>
 316 |     | <span class='unexecuted'>            IRangePoolERC1155(constants.poolToken).burnFungible(msg.sender, tokenId, cache.tokenBurned, constants);</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>        </span>
 319 |     | <span class='unexecuted'>        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(</span>
 320 |     | <span class='unexecuted'>            ticks[params.lower].range,</span>
 321 |     | <span class='unexecuted'>            ticks[params.upper].range,</span>
 322 |     | <span class='unexecuted'>            state,</span>
 323 |     | <span class='unexecuted'>            params.lower,</span>
 324 |     | <span class='unexecuted'>            params.upper</span>
 325 |     | <span class='neutral'>        );</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>        uint128 amount0Fees = uint128(</span>
 328 |     | <span class='unexecuted'>            OverflowMath.mulDiv(</span>
 329 |     | <span class='unexecuted'>                rangeFeeGrowth0 - position.feeGrowthInside0Last,</span>
 330 |     | <span class='unexecuted'>                uint256(position.liquidity),</span>
 331 |     | <span class='neutral'>                Q128</span>
 332 |     | <span class='neutral'>            )</span>
 333 |     | <span class='neutral'>        );</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>        uint128 amount1Fees = uint128(</span>
 336 |     | <span class='unexecuted'>            OverflowMath.mulDiv(</span>
 337 |     | <span class='unexecuted'>                rangeFeeGrowth1 - position.feeGrowthInside1Last,</span>
 338 |     | <span class='unexecuted'>                position.liquidity,</span>
 339 |     | <span class='neutral'>                Q128</span>
 340 |     | <span class='neutral'>            )</span>
 341 |     | <span class='neutral'>        );</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>        position.feeGrowthInside0Last = rangeFeeGrowth0;</span>
 344 |     | <span class='unexecuted'>        position.feeGrowthInside1Last = rangeFeeGrowth1;</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='unexecuted'>        position.amount0 += amount0Fees;</span>
 347 |     | <span class='unexecuted'>        position.amount1 += amount1Fees;</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='unexecuted'>        if (params.burnPercent &gt; 0) {</span>
 350 |     | <span class='unexecuted'>            cache.feesBurned0 = uint128(</span>
 351 |     | <span class='unexecuted'>                (uint256(position.amount0) * uint256(cache.tokenBurned)) / (cache.totalSupply)</span>
 352 |     | <span class='neutral'>            );</span>
 353 |     | <span class='unexecuted'>            cache.feesBurned1 = uint128(</span>
 354 |     | <span class='unexecuted'>                (uint256(position.amount1) * uint256(cache.tokenBurned)) / (cache.totalSupply)</span>
 355 |     | <span class='neutral'>            );</span>
 356 |     | <span class='neutral'>        }</span>
 357 |     | <span class='unexecuted'>        return (position, cache.feesBurned0, cache.feesBurned1, uint128(cache.tokenBurned));</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>    function rangeFeeGrowth(</span>
 361 |     | <span class='neutral'>        PoolsharkStructs.RangeTick memory lowerTick,</span>
 362 |     | <span class='neutral'>        PoolsharkStructs.RangeTick memory upperTick,</span>
 363 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 364 |     | <span class='neutral'>        int24 lower,</span>
 365 |     | <span class='neutral'>        int24 upper</span>
 366 |     | <span class='unexecuted'>    ) internal pure returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='unexecuted'>        uint256 feeGrowthGlobal0 = state.pool.feeGrowthGlobal0;</span>
 369 |     | <span class='unexecuted'>        uint256 feeGrowthGlobal1 = state.pool.feeGrowthGlobal1;</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>        uint256 feeGrowthBelow0;</span>
 372 |     | <span class='neutral'>        uint256 feeGrowthBelow1;</span>
 373 |     | <span class='unexecuted'>        if (state.pool.tickAtPrice &gt;= lower) {</span>
 374 |     | <span class='unexecuted'>            feeGrowthBelow0 = lowerTick.feeGrowthOutside0;</span>
 375 |     | <span class='unexecuted'>            feeGrowthBelow1 = lowerTick.feeGrowthOutside1;</span>
 376 |     | <span class='neutral'>        } else {</span>
 377 |     | <span class='unexecuted'>            feeGrowthBelow0 = feeGrowthGlobal0 - lowerTick.feeGrowthOutside0;</span>
 378 |     | <span class='unexecuted'>            feeGrowthBelow1 = feeGrowthGlobal1 - lowerTick.feeGrowthOutside1;</span>
 379 |     | <span class='neutral'>        }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='unexecuted'>        uint256 feeGrowthAbove0;</span>
 382 |     | <span class='unexecuted'>        uint256 feeGrowthAbove1;</span>
 383 |     | <span class='unexecuted'>        if (state.pool.tickAtPrice &lt; upper) {</span>
 384 |     | <span class='unexecuted'>            feeGrowthAbove0 = upperTick.feeGrowthOutside0;</span>
 385 |     | <span class='unexecuted'>            feeGrowthAbove1 = upperTick.feeGrowthOutside1;</span>
 386 |     | <span class='neutral'>        } else {</span>
 387 |     | <span class='unexecuted'>            feeGrowthAbove0 = feeGrowthGlobal0 - upperTick.feeGrowthOutside0;</span>
 388 |     | <span class='unexecuted'>            feeGrowthAbove1 = feeGrowthGlobal1 - upperTick.feeGrowthOutside1;</span>
 389 |     | <span class='neutral'>        }</span>
 390 |     | <span class='unexecuted'>        feeGrowthInside0 = feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;</span>
 391 |     | <span class='unexecuted'>        feeGrowthInside1 = feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;</span>
 392 |     | <span class='neutral'>    }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='unexecuted'>    function rangeFeeGrowth(</span>
 395 |     | <span class='neutral'>        address pool,</span>
 396 |     | <span class='neutral'>        int24 lower,</span>
 397 |     | <span class='neutral'>        int24 upper</span>
 398 |     | <span class='neutral'>    ) public view returns (</span>
 399 |     | <span class='unexecuted'>        uint256 feeGrowthInside0,</span>
 400 |     | <span class='unexecuted'>        uint256 feeGrowthInside1</span>
 401 |     | <span class='unexecuted'>    ) {</span>
 402 |     | <span class='unexecuted'>        TicksRange.validate(lower, upper, (IPool(pool).immutables()).tickSpacing);</span>
 403 |     | <span class='unexecuted'>        (</span>
 404 |     | <span class='unexecuted'>            PoolsharkStructs.RangePoolState memory poolState,</span>
 405 |     | <span class='neutral'>            ,,,,</span>
 406 |     | <span class='unexecuted'>        ) = IPool(pool).globalState();</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='unexecuted'>        (</span>
 409 |     | <span class='unexecuted'>            PoolsharkStructs.RangeTick memory tickLower</span>
 410 |     | <span class='neutral'>            ,</span>
 411 |     | <span class='neutral'>        )</span>
 412 |     | <span class='unexecuted'>            = IPool(pool).ticks(lower);</span>
 413 |     | <span class='unexecuted'>        (</span>
 414 |     | <span class='unexecuted'>            PoolsharkStructs.RangeTick memory tickUpper</span>
 415 |     | <span class='neutral'>            ,</span>
 416 |     | <span class='neutral'>        )</span>
 417 |     | <span class='unexecuted'>            = IPool(pool).ticks(upper);</span>
 418 |     | <span class='neutral'></span>
 419 |     | <span class='unexecuted'>        uint256 feeGrowthBelow0;</span>
 420 |     | <span class='unexecuted'>        uint256 feeGrowthBelow1;</span>
 421 |     | <span class='unexecuted'>        uint256 feeGrowthAbove0;</span>
 422 |     | <span class='unexecuted'>        uint256 feeGrowthAbove1;</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='unexecuted'>        if (lower &lt;= poolState.tickAtPrice) {</span>
 425 |     | <span class='unexecuted'>            feeGrowthBelow0 = tickLower.feeGrowthOutside0;</span>
 426 |     | <span class='unexecuted'>            feeGrowthBelow1 = tickLower.feeGrowthOutside1;</span>
 427 |     | <span class='neutral'>        } else {</span>
 428 |     | <span class='unexecuted'>            feeGrowthBelow0 = poolState.feeGrowthGlobal0 - tickLower.feeGrowthOutside0;</span>
 429 |     | <span class='unexecuted'>            feeGrowthBelow1 = poolState.feeGrowthGlobal1 - tickLower.feeGrowthOutside1;</span>
 430 |     | <span class='neutral'>        }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='unexecuted'>        if (poolState.tickAtPrice &lt; upper) {</span>
 433 |     | <span class='unexecuted'>            feeGrowthAbove0 = tickUpper.feeGrowthOutside0;</span>
 434 |     | <span class='unexecuted'>            feeGrowthAbove1 = tickUpper.feeGrowthOutside1;</span>
 435 |     | <span class='neutral'>        } else {</span>
 436 |     | <span class='unexecuted'>            feeGrowthAbove0 = poolState.feeGrowthGlobal0 - tickUpper.feeGrowthOutside0;</span>
 437 |     | <span class='unexecuted'>            feeGrowthAbove1 = poolState.feeGrowthGlobal1 - tickUpper.feeGrowthOutside1;</span>
 438 |     | <span class='neutral'>        }</span>
 439 |     | <span class='unexecuted'>        feeGrowthInside0 = poolState.feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;</span>
 440 |     | <span class='unexecuted'>        feeGrowthInside1 = poolState.feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;</span>
 441 |     | <span class='neutral'>    }</span>
 442 |     | <span class='neutral'></span>
 443 |     | <span class='neutral'>    function snapshot(</span>
 444 |     | <span class='neutral'>        address pool,</span>
 445 |     | <span class='neutral'>        address owner,</span>
 446 |     | <span class='neutral'>        int24 lower,</span>
 447 |     | <span class='neutral'>        int24 upper</span>
 448 |     | <span class='neutral'>    ) internal view returns (</span>
 449 |     | <span class='neutral'>        int56   tickSecondsAccum,</span>
 450 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum,</span>
 451 |     | <span class='neutral'>        uint128 feesOwed0,</span>
 452 |     | <span class='neutral'>        uint128 feesOwed1</span>
 453 |     | <span class='neutral'>    ) {</span>
 454 |     | <span class='neutral'>        TicksRange.validate(lower, upper, (IPool(pool).immutables()).tickSpacing);</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>        IRangePoolStructs.SnapshotCache memory cache;</span>
 457 |     | <span class='neutral'>        (</span>
 458 |     | <span class='neutral'>            PoolsharkStructs.RangePoolState memory poolState,</span>
 459 |     | <span class='neutral'>            ,,,,</span>
 460 |     | <span class='neutral'>        ) = IPool(pool).globalState();</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'></span>
 463 |     | <span class='neutral'>        cache.price = poolState.price;</span>
 464 |     | <span class='neutral'>        cache.liquidity = poolState.liquidity;</span>
 465 |     | <span class='neutral'>        cache.samples = poolState.samples;</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>        (</span>
 468 |     | <span class='neutral'>            PoolsharkStructs.RangeTick memory tickLower</span>
 469 |     | <span class='neutral'>            ,</span>
 470 |     | <span class='neutral'>        )</span>
 471 |     | <span class='neutral'>            = IPool(pool).ticks(lower);</span>
 472 |     | <span class='neutral'>        (</span>
 473 |     | <span class='neutral'>            PoolsharkStructs.RangeTick memory tickUpper</span>
 474 |     | <span class='neutral'>            ,</span>
 475 |     | <span class='neutral'>        )</span>
 476 |     | <span class='neutral'>            = IPool(pool).ticks(upper);</span>
 477 |     | <span class='neutral'></span>
 478 |     | <span class='neutral'>        cache.tickSecondsAccumLower =  tickLower.tickSecondsAccumOutside;</span>
 479 |     | <span class='neutral'>        cache.secondsPerLiquidityAccumLower = tickLower.secondsPerLiquidityAccumOutside;</span>
 480 |     | <span class='neutral'></span>
 481 |     | <span class='neutral'>        // if both have never been crossed into return 0</span>
 482 |     | <span class='neutral'>        cache.tickSecondsAccumUpper = tickUpper.tickSecondsAccumOutside;</span>
 483 |     | <span class='neutral'>        cache.secondsPerLiquidityAccumUpper = tickUpper.secondsPerLiquidityAccumOutside;</span>
 484 |     | <span class='neutral'></span>
 485 |     | <span class='neutral'>        (</span>
 486 |     | <span class='neutral'>            cache.position.liquidity,</span>
 487 |     | <span class='neutral'>            cache.position.amount0,</span>
 488 |     | <span class='neutral'>            cache.position.amount1,</span>
 489 |     | <span class='neutral'>            cache.position.feeGrowthInside0Last,</span>
 490 |     | <span class='neutral'>            cache.position.feeGrowthInside1Last</span>
 491 |     | <span class='neutral'>        )</span>
 492 |     | <span class='neutral'>            = IPool(pool).positions(lower, upper);</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='neutral'>        cache.constants = IPool(pool).immutables();</span>
 495 |     | <span class='neutral'>        </span>
 496 |     | <span class='neutral'>        cache.userBalance = Tokens.balanceOf(pool, owner, lower, upper);</span>
 497 |     | <span class='neutral'>        cache.totalSupply = Tokens.totalSupply(pool, lower, upper);</span>
 498 |     | <span class='neutral'></span>
 499 |     | <span class='neutral'>        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(</span>
 500 |     | <span class='neutral'>            pool,</span>
 501 |     | <span class='neutral'>            lower,</span>
 502 |     | <span class='neutral'>            upper</span>
 503 |     | <span class='neutral'>        );</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='neutral'>        cache.position.amount0 += uint128(</span>
 506 |     | <span class='neutral'>            OverflowMath.mulDiv(</span>
 507 |     | <span class='neutral'>                rangeFeeGrowth0 - cache.position.feeGrowthInside0Last,</span>
 508 |     | <span class='neutral'>                uint256(cache.position.liquidity),</span>
 509 |     | <span class='neutral'>                Q128</span>
 510 |     | <span class='neutral'>            )</span>
 511 |     | <span class='neutral'>        );</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>        cache.position.amount1 += uint128(</span>
 514 |     | <span class='neutral'>            OverflowMath.mulDiv(</span>
 515 |     | <span class='neutral'>                rangeFeeGrowth1 - cache.position.feeGrowthInside1Last,</span>
 516 |     | <span class='neutral'>                cache.position.liquidity,</span>
 517 |     | <span class='neutral'>                Q128</span>
 518 |     | <span class='neutral'>            )</span>
 519 |     | <span class='neutral'>        );</span>
 520 |     | <span class='neutral'></span>
 521 |     | <span class='neutral'>        if (cache.totalSupply &gt; 0) {</span>
 522 |     | <span class='neutral'>            cache.position.amount0 = uint128(cache.position.amount0 * cache.userBalance / cache.totalSupply);</span>
 523 |     | <span class='neutral'>            cache.position.amount1 = uint128(cache.position.amount1 * cache.userBalance / cache.totalSupply);</span>
 524 |     | <span class='neutral'>        }</span>
 525 |     | <span class='neutral'>        </span>
 526 |     | <span class='neutral'>        cache.tick = ConstantProduct.getTickAtPrice(cache.price, cache.constants);</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>        if (lower &gt;= cache.tick) {</span>
 529 |     | <span class='neutral'>            return (</span>
 530 |     | <span class='neutral'>                cache.tickSecondsAccumLower - cache.tickSecondsAccumUpper,</span>
 531 |     | <span class='neutral'>                cache.secondsPerLiquidityAccumLower - cache.secondsPerLiquidityAccumUpper,</span>
 532 |     | <span class='neutral'>                cache.position.amount0,</span>
 533 |     | <span class='neutral'>                cache.position.amount1</span>
 534 |     | <span class='neutral'>            );</span>
 535 |     | <span class='neutral'>        } else if (upper &gt;= cache.tick) {</span>
 536 |     | <span class='neutral'>            cache.blockTimestamp = uint32(block.timestamp);</span>
 537 |     | <span class='neutral'>            (</span>
 538 |     | <span class='neutral'>                cache.tickSecondsAccum,</span>
 539 |     | <span class='neutral'>                cache.secondsPerLiquidityAccum</span>
 540 |     | <span class='neutral'>            ) = Samples.getSingle(</span>
 541 |     | <span class='neutral'>                IPool(address(this)), </span>
 542 |     | <span class='neutral'>                IRangePoolStructs.SampleParams(</span>
 543 |     | <span class='neutral'>                    cache.samples.index,</span>
 544 |     | <span class='neutral'>                    cache.samples.length,</span>
 545 |     | <span class='neutral'>                    uint32(block.timestamp),</span>
 546 |     | <span class='neutral'>                    new uint32[](2),</span>
 547 |     | <span class='neutral'>                    cache.tick,</span>
 548 |     | <span class='neutral'>                    cache.liquidity,</span>
 549 |     | <span class='neutral'>                    cache.constants</span>
 550 |     | <span class='neutral'>                ),</span>
 551 |     | <span class='neutral'>                0</span>
 552 |     | <span class='neutral'>            );</span>
 553 |     | <span class='neutral'>            return (</span>
 554 |     | <span class='neutral'>                cache.tickSecondsAccum </span>
 555 |     | <span class='neutral'>                  - cache.tickSecondsAccumLower </span>
 556 |     | <span class='neutral'>                  - cache.tickSecondsAccumUpper,</span>
 557 |     | <span class='neutral'>                cache.secondsPerLiquidityAccum</span>
 558 |     | <span class='neutral'>                  - cache.secondsPerLiquidityAccumLower</span>
 559 |     | <span class='neutral'>                  - cache.secondsPerLiquidityAccumUpper,</span>
 560 |     | <span class='neutral'>                cache.position.amount0,</span>
 561 |     | <span class='neutral'>                cache.position.amount1</span>
 562 |     | <span class='neutral'>            );</span>
 563 |     | <span class='neutral'>        }</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='unexecuted'>    function id(int24 lower, int24 upper) public pure returns (uint256) {</span>
 567 |     | <span class='unexecuted'>        return Tokens.id(lower, upper);</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'>}</span>
 570 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/Samples.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>library Samples {</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    error InvalidSampleLength();</span>
  12 |     | <span class='neutral'>    error SampleArrayUninitialized();</span>
  13 |     | <span class='neutral'>    error SampleLengthNotAvailable();</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event SampleRecorded(</span>
  16 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
  17 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
  18 |     | <span class='neutral'>    );</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event SampleLengthIncreased(</span>
  21 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function initialize(</span>
  25 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  26 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState memory state</span>
  27 |     | <span class='neutral'>    ) internal returns (</span>
  28 |     | <span class='unexecuted'>        PoolsharkStructs.RangePoolState memory</span>
  29 |     | <span class='neutral'>    )</span>
  30 |     | <span class='neutral'>    {</span>
  31 |     | <span class='unexecuted'>        samples[0] = PoolsharkStructs.Sample({</span>
  32 |     | <span class='unexecuted'>            blockTimestamp: uint32(block.timestamp),</span>
  33 |     | <span class='neutral'>            tickSecondsAccum: 0,</span>
  34 |     | <span class='neutral'>            secondsPerLiquidityAccum: 0</span>
  35 |     | <span class='neutral'>        });</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>        state.samples.length = 1;</span>
  38 |     | <span class='unexecuted'>        state.samples.lengthNext = 5;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>        return state;</span>
  41 |     | <span class='neutral'>        /// @dev - TWAP length of 5 is safer for oracle manipulation</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function save(</span>
  45 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  46 |     | <span class='neutral'>        PoolsharkStructs.SampleState memory sampleState,</span>
  47 |     | <span class='neutral'>        uint128 startLiquidity, /// @dev - liquidity from start of block</span>
  48 |     | <span class='neutral'>        int24  tick</span>
  49 |     | <span class='neutral'>    ) internal returns (</span>
  50 |     | <span class='unexecuted'>        uint16 sampleIndexNew,</span>
  51 |     | <span class='unexecuted'>        uint16 sampleLengthNew</span>
  52 |     | <span class='unexecuted'>    ) {</span>
  53 |     | <span class='neutral'>        // grab the latest sample</span>
  54 |     | <span class='unexecuted'>        IRangePoolStructs.Sample memory newSample = samples[sampleState.index];</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        // early return if timestamp has not advanced 2 seconds</span>
  57 |     | <span class='unexecuted'>        if (newSample.blockTimestamp + 2 &gt; uint32(block.timestamp))</span>
  58 |     | <span class='unexecuted'>            return (sampleState.index, sampleState.length);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        if (sampleState.lengthNext &gt; sampleState.length</span>
  61 |     | <span class='unexecuted'>            &amp;&amp; sampleState.index == (sampleState.length - 1)) {</span>
  62 |     | <span class='neutral'>            // increase sampleLengthNew if old size exceeded</span>
  63 |     | <span class='unexecuted'>            sampleLengthNew = sampleState.lengthNext;</span>
  64 |     | <span class='neutral'>        } else {</span>
  65 |     | <span class='unexecuted'>            sampleLengthNew = sampleState.length;</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='unexecuted'>        sampleIndexNew = (sampleState.index + 1) % sampleLengthNew;</span>
  68 |     | <span class='unexecuted'>        samples[sampleIndexNew] = _build(newSample, uint32(block.timestamp), tick, startLiquidity);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        emit SampleRecorded(</span>
  71 |     | <span class='unexecuted'>            samples[sampleIndexNew].tickSecondsAccum,</span>
  72 |     | <span class='unexecuted'>            samples[sampleIndexNew].secondsPerLiquidityAccum</span>
  73 |     | <span class='neutral'>        );</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function expand(</span>
  77 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  78 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState memory state,</span>
  79 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
  80 |     | <span class='neutral'>    ) internal returns (</span>
  81 |     | <span class='unexecuted'>        PoolsharkStructs.RangePoolState memory</span>
  82 |     | <span class='neutral'>    ) {</span>
  83 |     | <span class='unexecuted'>        if (sampleLengthNext &lt;= state.samples.lengthNext) return state;</span>
  84 |     | <span class='unexecuted'>        for (uint16 i = state.samples.lengthNext; i &lt; sampleLengthNext; i++) {</span>
  85 |     | <span class='unexecuted'>            samples[i].blockTimestamp = 1;</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='unexecuted'>        state.samples.lengthNext = sampleLengthNext;</span>
  88 |     | <span class='unexecuted'>        emit SampleLengthIncreased(sampleLengthNext);</span>
  89 |     | <span class='unexecuted'>        return state;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function get(</span>
  93 |     | <span class='neutral'>        address pool,</span>
  94 |     | <span class='neutral'>        IRangePoolStructs.SampleParams memory params</span>
  95 |     | <span class='neutral'>    ) internal view returns (</span>
  96 |     | <span class='neutral'>        int56[]   memory tickSecondsAccum,</span>
  97 |     | <span class='neutral'>        uint160[] memory secondsPerLiquidityAccum,</span>
  98 |     | <span class='neutral'>        uint160 averagePrice,</span>
  99 |     | <span class='neutral'>        uint128 averageLiquidity,</span>
 100 |     | <span class='neutral'>        int24 averageTick</span>
 101 |     | <span class='neutral'>    ) {</span>
 102 |     | <span class='neutral'>        if (params.sampleLength == 0) require(false, &#39;InvalidSampleLength()&#39;);</span>
 103 |     | <span class='neutral'>        if (params.secondsAgo.length == 0) require(false, &#39;SecondsAgoArrayEmpty()&#39;);</span>
 104 |     | <span class='neutral'>        uint256 size = params.secondsAgo.length &gt; 1 ? params.secondsAgo.length : 2;</span>
 105 |     | <span class='neutral'>        uint32[] memory secondsAgo = new uint32[](size);</span>
 106 |     | <span class='neutral'>        if (params.secondsAgo.length == 1) {</span>
 107 |     | <span class='neutral'>            secondsAgo = new uint32[](2);</span>
 108 |     | <span class='neutral'>            secondsAgo[0] = params.secondsAgo[0];</span>
 109 |     | <span class='neutral'>            secondsAgo[1] = params.secondsAgo[0] + 2;</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>        else secondsAgo = params.secondsAgo;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>        if (secondsAgo[0] == secondsAgo[secondsAgo.length - 1]) require(false, &#39;SecondsAgoArrayValuesEqual()&#39;);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        tickSecondsAccum = new int56[](secondsAgo.length);</span>
 116 |     | <span class='neutral'>        secondsPerLiquidityAccum = new uint160[](secondsAgo.length);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; secondsAgo.length; i++) {</span>
 119 |     | <span class='neutral'>            (</span>
 120 |     | <span class='neutral'>                tickSecondsAccum[i],</span>
 121 |     | <span class='neutral'>                secondsPerLiquidityAccum[i]</span>
 122 |     | <span class='neutral'>            ) = getSingle(</span>
 123 |     | <span class='neutral'>                IPool(pool),</span>
 124 |     | <span class='neutral'>                params,</span>
 125 |     | <span class='neutral'>                secondsAgo[i]</span>
 126 |     | <span class='neutral'>            );</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'>        if (secondsAgo[secondsAgo.length - 1] &gt; secondsAgo[0]) {</span>
 129 |     | <span class='neutral'>            averageTick = int24((tickSecondsAccum[0] - tickSecondsAccum[secondsAgo.length - 1]) </span>
 130 |     | <span class='neutral'>                                / int32(secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));</span>
 131 |     | <span class='neutral'>            averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);</span>
 132 |     | <span class='neutral'>            averageLiquidity = uint128((secondsPerLiquidityAccum[0] - secondsPerLiquidityAccum[secondsAgo.length - 1]) </span>
 133 |     | <span class='neutral'>                                    * (secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));</span>
 134 |     | <span class='neutral'>        } else {</span>
 135 |     | <span class='neutral'>            averageTick = int24((tickSecondsAccum[secondsAgo.length - 1] - tickSecondsAccum[0]) </span>
 136 |     | <span class='neutral'>                                / int32(secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));</span>
 137 |     | <span class='neutral'>            averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);</span>
 138 |     | <span class='neutral'>            averageLiquidity = uint128((secondsPerLiquidityAccum[secondsAgo.length - 1] - secondsPerLiquidityAccum[0]) </span>
 139 |     | <span class='neutral'>                                    * (secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='unexecuted'>    function _poolSample(</span>
 143 |     | <span class='neutral'>        IPool pool,</span>
 144 |     | <span class='neutral'>        uint256 sampleIndex</span>
 145 |     | <span class='neutral'>    ) internal view returns (</span>
 146 |     | <span class='neutral'>        IRangePoolStructs.Sample memory</span>
 147 |     | <span class='neutral'>    ) {</span>
 148 |     | <span class='neutral'>        (</span>
 149 |     | <span class='unexecuted'>            uint32 blockTimestamp,</span>
 150 |     | <span class='unexecuted'>            int56 tickSecondsAccum,</span>
 151 |     | <span class='unexecuted'>            uint160 liquidityPerSecondsAccum</span>
 152 |     | <span class='unexecuted'>        ) = pool.samples(sampleIndex);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        return PoolsharkStructs.Sample(</span>
 155 |     | <span class='neutral'>            blockTimestamp,</span>
 156 |     | <span class='neutral'>            tickSecondsAccum,</span>
 157 |     | <span class='neutral'>            liquidityPerSecondsAccum</span>
 158 |     | <span class='neutral'>        );</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function getSingle(</span>
 162 |     | <span class='neutral'>        IPool pool,</span>
 163 |     | <span class='neutral'>        IRangePoolStructs.SampleParams memory params,</span>
 164 |     | <span class='neutral'>        uint32 secondsAgo</span>
 165 |     | <span class='neutral'>    ) internal view returns (</span>
 166 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 167 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum</span>
 168 |     | <span class='neutral'>    ) {</span>
 169 |     | <span class='unexecuted'>        IRangePoolStructs.Sample memory latest = _poolSample(pool, params.sampleIndex);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        if (secondsAgo == 0) {</span>
 172 |     | <span class='unexecuted'>            if (latest.blockTimestamp != uint32(block.timestamp)) {</span>
 173 |     | <span class='unexecuted'>                latest = _build(</span>
 174 |     | <span class='unexecuted'>                    latest,</span>
 175 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 176 |     | <span class='unexecuted'>                    params.tick,</span>
 177 |     | <span class='unexecuted'>                    params.liquidity</span>
 178 |     | <span class='neutral'>                );</span>
 179 |     | <span class='neutral'>            } </span>
 180 |     | <span class='unexecuted'>            return (</span>
 181 |     | <span class='unexecuted'>                latest.tickSecondsAccum,</span>
 182 |     | <span class='unexecuted'>                latest.secondsPerLiquidityAccum</span>
 183 |     | <span class='neutral'>            );</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>        uint32 targetTime = uint32(block.timestamp) - secondsAgo;</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        (</span>
 189 |     | <span class='unexecuted'>            IRangePoolStructs.Sample memory firstSample,</span>
 190 |     | <span class='unexecuted'>            IRangePoolStructs.Sample memory secondSample</span>
 191 |     | <span class='unexecuted'>        ) = _getAdjacentSamples(</span>
 192 |     | <span class='unexecuted'>                pool,</span>
 193 |     | <span class='unexecuted'>                latest,</span>
 194 |     | <span class='unexecuted'>                params,</span>
 195 |     | <span class='unexecuted'>                targetTime</span>
 196 |     | <span class='neutral'>        );</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>        if (targetTime == firstSample.blockTimestamp) {</span>
 199 |     | <span class='neutral'>            // first sample</span>
 200 |     | <span class='unexecuted'>            return (</span>
 201 |     | <span class='unexecuted'>                firstSample.tickSecondsAccum,</span>
 202 |     | <span class='unexecuted'>                firstSample.secondsPerLiquidityAccum</span>
 203 |     | <span class='neutral'>            );</span>
 204 |     | <span class='unexecuted'>        } else if (targetTime == secondSample.blockTimestamp) {</span>
 205 |     | <span class='neutral'>            // second sample</span>
 206 |     | <span class='unexecuted'>            return (</span>
 207 |     | <span class='unexecuted'>                secondSample.tickSecondsAccum,</span>
 208 |     | <span class='unexecuted'>                secondSample.secondsPerLiquidityAccum</span>
 209 |     | <span class='neutral'>            );</span>
 210 |     | <span class='neutral'>        } else {</span>
 211 |     | <span class='neutral'>            // average two samples</span>
 212 |     | <span class='unexecuted'>            int32 sampleTimeDelta = int32(secondSample.blockTimestamp - firstSample.blockTimestamp);</span>
 213 |     | <span class='unexecuted'>            int56 targetDelta = int56(int32(targetTime - firstSample.blockTimestamp));</span>
 214 |     | <span class='unexecuted'>            return (</span>
 215 |     | <span class='unexecuted'>                firstSample.tickSecondsAccum +</span>
 216 |     | <span class='unexecuted'>                    ((secondSample.tickSecondsAccum - firstSample.tickSecondsAccum) </span>
 217 |     | <span class='unexecuted'>                    / sampleTimeDelta)</span>
 218 |     | <span class='unexecuted'>                    * targetDelta,</span>
 219 |     | <span class='unexecuted'>                firstSample.secondsPerLiquidityAccum +</span>
 220 |     | <span class='neutral'>                    uint160(</span>
 221 |     | <span class='unexecuted'>                        (uint256(</span>
 222 |     | <span class='unexecuted'>                            secondSample.secondsPerLiquidityAccum - firstSample.secondsPerLiquidityAccum</span>
 223 |     | <span class='neutral'>                        ) </span>
 224 |     | <span class='unexecuted'>                        * uint256(uint56(targetDelta))) </span>
 225 |     | <span class='unexecuted'>                        / uint32(sampleTimeDelta)</span>
 226 |     | <span class='neutral'>                    )</span>
 227 |     | <span class='neutral'>            );</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>    function _lte(</span>
 232 |     | <span class='neutral'>        uint32 timeA,</span>
 233 |     | <span class='neutral'>        uint32 timeB</span>
 234 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 235 |     | <span class='unexecuted'>        uint32 currentTime = uint32(block.timestamp);</span>
 236 |     | <span class='unexecuted'>        if (timeA &lt;= currentTime &amp;&amp; timeB &lt;= currentTime) return timeA &lt;= timeB;</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>        uint256 timeAOverflow = timeA;</span>
 239 |     | <span class='unexecuted'>        uint256 timeBOverflow = timeB;</span>
 240 |     | <span class='neutral'></span>
 241 |     | <span class='unexecuted'>        if (timeA &lt;= currentTime) {</span>
 242 |     | <span class='unexecuted'>            timeAOverflow = timeA + 2**32;</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='unexecuted'>        if (timeB &lt;= currentTime) {</span>
 245 |     | <span class='unexecuted'>            timeBOverflow = timeB + 2**32;</span>
 246 |     | <span class='neutral'>        }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='unexecuted'>        return timeAOverflow &lt;= timeBOverflow;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function _build(</span>
 252 |     | <span class='neutral'>        IRangePoolStructs.Sample memory newSample,</span>
 253 |     | <span class='neutral'>        uint32  blockTimestamp,</span>
 254 |     | <span class='neutral'>        int24   tick,</span>
 255 |     | <span class='neutral'>        uint128 liquidity</span>
 256 |     | <span class='neutral'>    ) internal pure returns (</span>
 257 |     | <span class='neutral'>         IRangePoolStructs.Sample memory</span>
 258 |     | <span class='neutral'>    ) {</span>
 259 |     | <span class='unexecuted'>        int56 timeDelta = int56(uint56(blockTimestamp - newSample.blockTimestamp));</span>
 260 |     | <span class='unexecuted'>        return</span>
 261 |     | <span class='unexecuted'>            PoolsharkStructs.Sample({</span>
 262 |     | <span class='unexecuted'>                blockTimestamp: blockTimestamp,</span>
 263 |     | <span class='unexecuted'>                tickSecondsAccum: newSample.tickSecondsAccum + int56(tick) * int32(timeDelta),</span>
 264 |     | <span class='unexecuted'>                secondsPerLiquidityAccum: newSample.secondsPerLiquidityAccum +</span>
 265 |     | <span class='unexecuted'>                    ((uint160(uint56(timeDelta)) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1))</span>
 266 |     | <span class='neutral'>            });</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>    function _binarySearch(</span>
 270 |     | <span class='neutral'>        IPool pool,</span>
 271 |     | <span class='neutral'>        uint32 targetTime,</span>
 272 |     | <span class='neutral'>        uint16 sampleIndex,</span>
 273 |     | <span class='neutral'>        uint16 sampleLength</span>
 274 |     | <span class='neutral'>    ) private view returns (</span>
 275 |     | <span class='neutral'>        IRangePoolStructs.Sample memory firstSample,</span>
 276 |     | <span class='neutral'>        IRangePoolStructs.Sample memory secondSample</span>
 277 |     | <span class='unexecuted'>    ) {</span>
 278 |     | <span class='unexecuted'>        uint256 oldIndex = (sampleIndex + 1) % sampleLength;</span>
 279 |     | <span class='unexecuted'>        uint256 newIndex = oldIndex + sampleLength - 1;             </span>
 280 |     | <span class='unexecuted'>        uint256 index;</span>
 281 |     | <span class='unexecuted'>        while (true) {</span>
 282 |     | <span class='neutral'>            // start in the middle</span>
 283 |     | <span class='unexecuted'>            index = (oldIndex + newIndex) / 2;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>            // get the first sample</span>
 286 |     | <span class='unexecuted'>            firstSample = _poolSample(pool, index % sampleLength);</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>            // if sample is uninitialized</span>
 289 |     | <span class='unexecuted'>            if (firstSample.blockTimestamp == 0) {</span>
 290 |     | <span class='neutral'>                // skip this index and continue</span>
 291 |     | <span class='unexecuted'>                oldIndex = index + 1;</span>
 292 |     | <span class='unexecuted'>                continue;</span>
 293 |     | <span class='neutral'>            }</span>
 294 |     | <span class='neutral'>            // else grab second sample</span>
 295 |     | <span class='unexecuted'>            secondSample = _poolSample(pool, (index + 1) % sampleLength);</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>            // check if target time within first and second sample</span>
 298 |     | <span class='unexecuted'>            bool targetAfterFirst   = _lte(firstSample.blockTimestamp, targetTime);</span>
 299 |     | <span class='unexecuted'>            bool targetBeforeSecond = _lte(targetTime, secondSample.blockTimestamp);</span>
 300 |     | <span class='unexecuted'>            if (targetAfterFirst &amp;&amp; targetBeforeSecond) break;</span>
 301 |     | <span class='unexecuted'>            if (!targetAfterFirst) newIndex = index - 1;</span>
 302 |     | <span class='unexecuted'>            else oldIndex = index + 1;</span>
 303 |     | <span class='neutral'>        }</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>    function _getAdjacentSamples(</span>
 307 |     | <span class='neutral'>        IPool pool,</span>
 308 |     | <span class='neutral'>        IRangePoolStructs.Sample memory firstSample,</span>
 309 |     | <span class='neutral'>        IRangePoolStructs.SampleParams memory params,</span>
 310 |     | <span class='neutral'>        uint32 targetTime</span>
 311 |     | <span class='neutral'>    ) private view returns (</span>
 312 |     | <span class='neutral'>        IRangePoolStructs.Sample memory,</span>
 313 |     | <span class='neutral'>        IRangePoolStructs.Sample memory</span>
 314 |     | <span class='neutral'>    ) {</span>
 315 |     | <span class='unexecuted'>        if (_lte(firstSample.blockTimestamp, targetTime)) {</span>
 316 |     | <span class='unexecuted'>            if (firstSample.blockTimestamp == targetTime) {</span>
 317 |     | <span class='unexecuted'>                return (firstSample, PoolsharkStructs.Sample(0,0,0));</span>
 318 |     | <span class='neutral'>            } else {</span>
 319 |     | <span class='unexecuted'>                return (firstSample, _build(firstSample, targetTime, params.tick, params.liquidity));</span>
 320 |     | <span class='neutral'>            }</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='unexecuted'>        firstSample = _poolSample(pool, (params.sampleIndex + 1) % params.sampleLength);</span>
 323 |     | <span class='unexecuted'>        if (firstSample.blockTimestamp == 0) {</span>
 324 |     | <span class='unexecuted'>            firstSample = _poolSample(pool, 0);</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='unexecuted'>        if(!_lte(firstSample.blockTimestamp, targetTime)) require(false, &#39;SampleLengthNotAvailable()&#39;);</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='unexecuted'>        return _binarySearch(</span>
 329 |     | <span class='unexecuted'>            pool,</span>
 330 |     | <span class='unexecuted'>            targetTime,</span>
 331 |     | <span class='unexecuted'>            params.sampleIndex,</span>
 332 |     | <span class='unexecuted'>            params.sampleLength</span>
 333 |     | <span class='neutral'>        );</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/TicksRange.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../base/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/FeeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./Positions.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./Samples.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @notice Tick management library for range pools</span>
  16 |     | <span class='unexecuted'>library TicksRange {</span>
  17 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  18 |     | <span class='neutral'>    error LiquidityUnderflow();</span>
  19 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  20 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  21 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  22 |     | <span class='neutral'>    error InvalidPositionBounds();</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event Initialize(</span>
  25 |     | <span class='neutral'>        uint160 startPrice,</span>
  26 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  27 |     | <span class='neutral'>        int24 minTick,</span>
  28 |     | <span class='neutral'>        int24 maxTick</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  32 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function validate(</span>
  35 |     | <span class='neutral'>        int24 lower,</span>
  36 |     | <span class='neutral'>        int24 upper,</span>
  37 |     | <span class='neutral'>        int16 tickSpacing</span>
  38 |     | <span class='neutral'>    ) internal pure {</span>
  39 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  40 |     | <span class='unexecuted'>        if (lower &lt;= ConstantProduct.minTick(tickSpacing)) require(false, &#39;InvalidLowerTick()&#39;);</span>
  41 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  42 |     | <span class='unexecuted'>        if (upper &gt;= ConstantProduct.maxTick(tickSpacing)) require(false, &#39;InvalidUpperTick()&#39;);</span>
  43 |     | <span class='unexecuted'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    function insert(</span>
  47 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  48 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
  49 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  50 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
  51 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
  52 |     | <span class='neutral'>        int24 lower,</span>
  53 |     | <span class='neutral'>        int24 upper,</span>
  54 |     | <span class='neutral'>        uint128 amount</span>
  55 |     | <span class='unexecuted'>    ) internal returns (PoolsharkStructs.GlobalState memory) {</span>
  56 |     | <span class='unexecuted'>        validate(lower, upper, constants.tickSpacing);</span>
  57 |     | <span class='neutral'>        // check for amount to overflow liquidity delta &amp; global</span>
  58 |     | <span class='unexecuted'>        if (amount == 0) return state;</span>
  59 |     | <span class='unexecuted'>        if (amount &gt; uint128(type(int128).max)) require(false, &#39;LiquidityOverflow()&#39;);</span>
  60 |     | <span class='unexecuted'>        if (type(uint128).max - state.liquidityGlobal &lt; amount) require(false, &#39;LiquidityOverflow()&#39;);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // get tick at price</span>
  63 |     | <span class='unexecuted'>        int24 tickAtPrice = state.pool.tickAtPrice;</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>        if(TickMap.set(tickMap, lower, constants.tickSpacing)) {</span>
  66 |     | <span class='unexecuted'>            ticks[lower].range.liquidityDelta += int128(amount);</span>
  67 |     | <span class='unexecuted'>            ticks[lower].range.liquidityAbsolute += amount;</span>
  68 |     | <span class='neutral'>        } else {</span>
  69 |     | <span class='unexecuted'>            if (lower &lt;= tickAtPrice) {</span>
  70 |     | <span class='unexecuted'>                (</span>
  71 |     | <span class='unexecuted'>                    int56 tickSecondsAccum,</span>
  72 |     | <span class='neutral'>                    uint160 secondsPerLiquidityAccum</span>
  73 |     | <span class='unexecuted'>                ) = Samples.getSingle(</span>
  74 |     | <span class='unexecuted'>                        IPool(address(this)), </span>
  75 |     | <span class='unexecuted'>                        IRangePoolStructs.SampleParams(</span>
  76 |     | <span class='unexecuted'>                            state.pool.samples.index,</span>
  77 |     | <span class='unexecuted'>                            state.pool.samples.length,</span>
  78 |     | <span class='unexecuted'>                            uint32(block.timestamp),</span>
  79 |     | <span class='unexecuted'>                            new uint32[](2),</span>
  80 |     | <span class='unexecuted'>                            state.pool.tickAtPrice,</span>
  81 |     | <span class='unexecuted'>                            state.pool.liquidity,</span>
  82 |     | <span class='neutral'>                            constants</span>
  83 |     | <span class='neutral'>                        ),</span>
  84 |     | <span class='neutral'>                        0</span>
  85 |     | <span class='neutral'>                );</span>
  86 |     | <span class='unexecuted'>                ticks[lower].range = PoolsharkStructs.RangeTick(</span>
  87 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
  88 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
  89 |     | <span class='unexecuted'>                    secondsPerLiquidityAccum,</span>
  90 |     | <span class='unexecuted'>                    tickSecondsAccum,</span>
  91 |     | <span class='unexecuted'>                    int128(amount),             // liquidityDelta</span>
  92 |     | <span class='unexecuted'>                    amount                      // liquidityAbsolute</span>
  93 |     | <span class='neutral'>                );</span>
  94 |     | <span class='neutral'>            } else {</span>
  95 |     | <span class='unexecuted'>                ticks[lower].range.liquidityDelta = int128(amount);</span>
  96 |     | <span class='neutral'>                // INVARIANT: assert(ticks[lower].range.liquidityAbsolute == 0)</span>
  97 |     | <span class='unexecuted'>                ticks[lower].range.liquidityAbsolute += amount;</span>
  98 |     | <span class='neutral'>                </span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        if(TickMap.set(tickMap, upper, constants.tickSpacing)) {</span>
 103 |     | <span class='unexecuted'>            ticks[upper].range.liquidityDelta -= int128(amount);</span>
 104 |     | <span class='unexecuted'>            ticks[upper].range.liquidityAbsolute += amount;</span>
 105 |     | <span class='neutral'>        } else {</span>
 106 |     | <span class='unexecuted'>            if (upper &lt;= tickAtPrice) {</span>
 107 |     | <span class='unexecuted'>                (</span>
 108 |     | <span class='unexecuted'>                    int56 tickSecondsAccum,</span>
 109 |     | <span class='neutral'>                    uint160 secondsPerLiquidityAccum</span>
 110 |     | <span class='unexecuted'>                ) = Samples.getSingle(</span>
 111 |     | <span class='unexecuted'>                        IPool(address(this)), </span>
 112 |     | <span class='unexecuted'>                        IRangePoolStructs.SampleParams(</span>
 113 |     | <span class='unexecuted'>                            state.pool.samples.index,</span>
 114 |     | <span class='unexecuted'>                            state.pool.samples.length,</span>
 115 |     | <span class='unexecuted'>                            uint32(block.timestamp),</span>
 116 |     | <span class='unexecuted'>                            new uint32[](2),</span>
 117 |     | <span class='neutral'>                            state.pool.tickAtPrice,</span>
 118 |     | <span class='neutral'>                            state.pool.liquidity,</span>
 119 |     | <span class='neutral'>                            constants</span>
 120 |     | <span class='neutral'>                        ),</span>
 121 |     | <span class='neutral'>                        0</span>
 122 |     | <span class='neutral'>                );</span>
 123 |     | <span class='unexecuted'>                ticks[upper].range = PoolsharkStructs.RangeTick(</span>
 124 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
 125 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
 126 |     | <span class='unexecuted'>                    secondsPerLiquidityAccum,</span>
 127 |     | <span class='unexecuted'>                    tickSecondsAccum,</span>
 128 |     | <span class='unexecuted'>                    -int128(amount),</span>
 129 |     | <span class='unexecuted'>                    amount</span>
 130 |     | <span class='neutral'>                );</span>
 131 |     | <span class='neutral'>            } else {</span>
 132 |     | <span class='unexecuted'>                ticks[upper].range.liquidityDelta = -int128(amount);</span>
 133 |     | <span class='unexecuted'>                ticks[upper].range.liquidityAbsolute = amount;</span>
 134 |     | <span class='neutral'>                //assert(ticks[lower].range.feeGrowthOutside0 == 0])</span>
 135 |     | <span class='neutral'>                //assert(ticks[lower].range.feeGrowthOutside1 == 0])</span>
 136 |     | <span class='neutral'>            }</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='unexecuted'>        if (tickAtPrice &gt;= lower &amp;&amp; tickAtPrice &lt; upper) {</span>
 139 |     | <span class='neutral'>            // write an oracle entry</span>
 140 |     | <span class='unexecuted'>            (state.pool.samples.index, state.pool.samples.length) = Samples.save(</span>
 141 |     | <span class='unexecuted'>                samples,</span>
 142 |     | <span class='unexecuted'>                state.pool.samples,</span>
 143 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 144 |     | <span class='unexecuted'>                state.pool.tickAtPrice</span>
 145 |     | <span class='neutral'>            );</span>
 146 |     | <span class='neutral'>            // update pool liquidity</span>
 147 |     | <span class='unexecuted'>            state.pool.liquidity += amount;</span>
 148 |     | <span class='neutral'>        }</span>
 149 |     | <span class='neutral'>        // update global liquidity</span>
 150 |     | <span class='unexecuted'>        state.liquidityGlobal += amount;</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='unexecuted'>        return state;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function remove(</span>
 156 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 157 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples,</span>
 158 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 159 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 160 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants, </span>
 161 |     | <span class='neutral'>        int24 lower,</span>
 162 |     | <span class='neutral'>        int24 upper,</span>
 163 |     | <span class='neutral'>        uint128 amount</span>
 164 |     | <span class='unexecuted'>    ) internal returns (PoolsharkStructs.GlobalState memory) {</span>
 165 |     | <span class='unexecuted'>        validate(lower, upper, constants.tickSpacing);</span>
 166 |     | <span class='neutral'>        //check for amount to overflow liquidity delta &amp; global</span>
 167 |     | <span class='unexecuted'>        if (amount == 0) return state;</span>
 168 |     | <span class='unexecuted'>        if (amount &gt; uint128(type(int128).max)) require(false, &#39;LiquidityUnderflow()&#39;);</span>
 169 |     | <span class='unexecuted'>        if (amount &gt; state.liquidityGlobal) require(false, &#39;LiquidityUnderflow()&#39;);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>        // get pool tick at price</span>
 172 |     | <span class='unexecuted'>        int24 tickAtPrice = state.pool.tickAtPrice;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        // update lower liquidity values</span>
 175 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickLower = ticks[lower].range;</span>
 176 |     | <span class='neutral'>        unchecked {</span>
 177 |     | <span class='unexecuted'>            tickLower.liquidityDelta -= int128(amount);</span>
 178 |     | <span class='unexecuted'>            tickLower.liquidityAbsolute -= amount;</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='unexecuted'>        ticks[lower].range = tickLower;</span>
 181 |     | <span class='neutral'>        // try to clear tick if possible</span>
 182 |     | <span class='unexecuted'>        clear(ticks, constants, tickMap, lower);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // update upper liquidity values</span>
 185 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickUpper = ticks[upper].range;</span>
 186 |     | <span class='neutral'>        unchecked {</span>
 187 |     | <span class='unexecuted'>            tickUpper.liquidityDelta += int128(amount);</span>
 188 |     | <span class='unexecuted'>            tickUpper.liquidityAbsolute -= amount;</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='unexecuted'>        ticks[upper].range = tickUpper;</span>
 191 |     | <span class='neutral'>        // try to clear tick if possible</span>
 192 |     | <span class='unexecuted'>        clear(ticks, constants, tickMap, lower);</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='unexecuted'>        if (tickAtPrice &gt;= lower &amp;&amp; tickAtPrice &lt; upper) {</span>
 195 |     | <span class='neutral'>            // write an oracle entry</span>
 196 |     | <span class='unexecuted'>            (state.pool.samples.index, state.pool.samples.length) = Samples.save(</span>
 197 |     | <span class='unexecuted'>                samples,</span>
 198 |     | <span class='unexecuted'>                state.pool.samples,</span>
 199 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 200 |     | <span class='unexecuted'>                tickAtPrice</span>
 201 |     | <span class='neutral'>            );</span>
 202 |     | <span class='unexecuted'>            state.pool.liquidity -= amount;  </span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='unexecuted'>        state.liquidityGlobal -= amount;</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        return state;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>    function clear(</span>
 210 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 211 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 212 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 213 |     | <span class='neutral'>        int24 tickToClear</span>
 214 |     | <span class='neutral'>    ) internal {</span>
 215 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 216 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 217 |     | <span class='unexecuted'>                    tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 218 |     | <span class='unexecuted'>                ticks[tickToClear].range = PoolsharkStructs.RangeTick(0,0,0,0,0,0);</span>
 219 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 220 |     | <span class='neutral'>            }</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>    function _empty(</span>
 225 |     | <span class='neutral'>        ILimitPoolStructs.Tick memory tick</span>
 226 |     | <span class='neutral'>    ) internal pure returns (</span>
 227 |     | <span class='unexecuted'>        bool</span>
 228 |     | <span class='neutral'>    ) {</span>
 229 |     | <span class='unexecuted'>        if (tick.range.liquidityAbsolute != 0) {</span>
 230 |     | <span class='unexecuted'>            return false;</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>        return true;</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'>}</span>
 235 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/Tokens.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../math/OverflowMath.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../../interfaces/range/IRangePoolFactory.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;../../interfaces/range/IRangePoolStructs.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @notice Token library for ERC-1155 calls.</span>
  9 |     | <span class='unexecuted'>library Tokens {</span>
 10 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>    function id(</span>
 13 |     | <span class='neutral'>        int24 lower,</span>
 14 |     | <span class='neutral'>        int24 upper</span>
 15 |     | <span class='neutral'>    ) internal pure returns (</span>
 16 |     | <span class='unexecuted'>        uint256</span>
 17 |     | <span class='neutral'>    )</span>
 18 |     | <span class='neutral'>    {</span>
 19 |     | <span class='unexecuted'>        return uint256(keccak256(abi.encode(lower, upper)));</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function balanceOf(</span>
 23 |     | <span class='neutral'>        address tokens,</span>
 24 |     | <span class='neutral'>        address owner,</span>
 25 |     | <span class='neutral'>        int24 lower,</span>
 26 |     | <span class='neutral'>        int24 upper</span>
 27 |     | <span class='neutral'>    ) internal view returns (</span>
 28 |     | <span class='unexecuted'>        uint256</span>
 29 |     | <span class='neutral'>    )</span>
 30 |     | <span class='neutral'>    {</span>
 31 |     | <span class='unexecuted'>        return IRangePoolERC1155(tokens).balanceOf(owner, id(lower, upper));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    function totalSupply(</span>
 35 |     | <span class='neutral'>        address tokens,</span>
 36 |     | <span class='neutral'>        int24 lower,</span>
 37 |     | <span class='neutral'>        int24 upper</span>
 38 |     | <span class='neutral'>    ) internal view returns (</span>
 39 |     | <span class='unexecuted'>        uint256</span>
 40 |     | <span class='neutral'>    )</span>
 41 |     | <span class='neutral'>    {</span>
 42 |     | <span class='unexecuted'>        return IRangePoolERC1155(tokens).totalSupply(id(lower, upper));</span>
 43 |     | <span class='neutral'>    }</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='unexecuted'>    function totalSupplyById(</span>
 46 |     | <span class='neutral'>        address tokens,</span>
 47 |     | <span class='neutral'>        uint256 _id</span>
 48 |     | <span class='neutral'>    ) internal view returns (</span>
 49 |     | <span class='unexecuted'>        uint256</span>
 50 |     | <span class='neutral'>    )</span>
 51 |     | <span class='neutral'>    {</span>
 52 |     | <span class='unexecuted'>        return IRangePoolERC1155(tokens).totalSupply(_id);</span>
 53 |     | <span class='neutral'>    } </span>
 54 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/math/FeeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../utils/SafeCast.sol&#39;;</span>
  5 |     | <span class='neutral'>import &quot;../../math/OverflowMath.sol&quot;;</span>
  6 |     | <span class='neutral'>import &#39;../../../base/structs/PoolsharkStructs.sol&#39;;</span>
  7 |     | <span class='neutral'>import &quot;../../../interfaces/range/IRangePoolStructs.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @notice Math library that facilitates fee handling.</span>
 10 |     | <span class='unexecuted'>library FeeMath {</span>
 11 |     | <span class='neutral'>    using SafeCast for uint256;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    struct CalculateLocals {</span>
 16 |     | <span class='neutral'>        uint256 feeAmount;</span>
 17 |     | <span class='neutral'>        uint256 protocolFee;</span>
 18 |     | <span class='neutral'>        uint256 protocolFeesAccrued;</span>
 19 |     | <span class='neutral'>        uint256 amountOutRange;</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function calculate(</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 24 |     | <span class='neutral'>        uint256 amountOut,</span>
 25 |     | <span class='neutral'>        bool zeroForOne</span>
 26 |     | <span class='neutral'>    ) internal pure returns (</span>
 27 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 28 |     | <span class='neutral'>    )</span>
 29 |     | <span class='neutral'>    {</span>
 30 |     | <span class='unexecuted'>        if (cache.state.pool.liquidity != 0) {</span>
 31 |     | <span class='unexecuted'>            CalculateLocals memory locals;</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>            // calculate output from range liquidity</span>
 34 |     | <span class='unexecuted'>            locals.amountOutRange = OverflowMath.mulDiv(amountOut, cache.state.pool.liquidity, cache.liquidity);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>            // take enough fees to cover fee growth</span>
 37 |     | <span class='unexecuted'>            locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountOutRange, cache.constants.swapFee, 1e6);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>            // load protocol fee from cache</span>
 40 |     | <span class='unexecuted'>            locals.protocolFee = zeroForOne ? cache.state.pool0.protocolFee : cache.state.pool1.protocolFee;</span>
 41 |     | <span class='neutral'>            // calculate fee</span>
 42 |     | <span class='unexecuted'>            locals.protocolFeesAccrued = OverflowMath.mulDivRoundingUp(locals.feeAmount, locals.protocolFee, 1e6);</span>
 43 |     | <span class='unexecuted'>            amountOut -= locals.feeAmount;</span>
 44 |     | <span class='neutral'>            // fees for this swap step</span>
 45 |     | <span class='unexecuted'>            locals.feeAmount -= locals.protocolFeesAccrued;</span>
 46 |     | <span class='neutral'>            // add to total fees paid for swap</span>
 47 |     | <span class='unexecuted'>            cache.feeAmount += locals.feeAmount.toUint128();</span>
 48 |     | <span class='neutral'>            </span>
 49 |     | <span class='neutral'>            // save fee growth and protocol fees</span>
 50 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 51 |     | <span class='unexecuted'>                cache.state.pool0.protocolFees += uint128(locals.protocolFeesAccrued);</span>
 52 |     | <span class='unexecuted'>                cache.state.pool.feeGrowthGlobal1 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));</span>
 53 |     | <span class='neutral'>            } else {</span>
 54 |     | <span class='unexecuted'>                cache.state.pool1.protocolFees += uint128(locals.protocolFeesAccrued);</span>
 55 |     | <span class='unexecuted'>                cache.state.pool.feeGrowthGlobal0 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));</span>
 56 |     | <span class='neutral'>            }</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='unexecuted'>        cache.output += amountOut;</span>
 59 |     | <span class='unexecuted'>        return cache;</span>
 60 |     | <span class='neutral'>    }</span>
 61 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/pool/BurnCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../utils/SafeTransfers.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library BurnCall {</span>
  9 |     | <span class='neutral'>    event Burn(</span>
 10 |     | <span class='neutral'>        address indexed recipient,</span>
 11 |     | <span class='neutral'>        int24 lower,</span>
 12 |     | <span class='neutral'>        int24 upper,</span>
 13 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
 14 |     | <span class='neutral'>        uint128 tokenBurned,</span>
 15 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 16 |     | <span class='neutral'>        uint128 amount0,</span>
 17 |     | <span class='neutral'>        uint128 amount1</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function perform(</span>
 21 |     | <span class='neutral'>        IRangePoolStructs.BurnParams memory params,</span>
 22 |     | <span class='neutral'>        IRangePoolStructs.BurnCache memory cache,</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 24 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 25 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples</span>
 26 |     | <span class='unexecuted'>    ) internal returns (IRangePoolStructs.BurnCache memory) {</span>
 27 |     | <span class='unexecuted'>        if (params.burnPercent &gt; 1e38) params.burnPercent = 1e38;</span>
 28 |     | <span class='unexecuted'>        (</span>
 29 |     | <span class='unexecuted'>            cache.position,</span>
 30 |     | <span class='unexecuted'>            cache.amount0,</span>
 31 |     | <span class='unexecuted'>            cache.amount1,</span>
 32 |     | <span class='unexecuted'>            cache.tokenBurned</span>
 33 |     | <span class='unexecuted'>        ) = Positions.update(</span>
 34 |     | <span class='unexecuted'>                ticks,</span>
 35 |     | <span class='unexecuted'>                cache.position,</span>
 36 |     | <span class='unexecuted'>                cache.state,</span>
 37 |     | <span class='unexecuted'>                cache.constants,</span>
 38 |     | <span class='unexecuted'>                IRangePoolStructs.UpdateParams(</span>
 39 |     | <span class='unexecuted'>                    params.lower,</span>
 40 |     | <span class='unexecuted'>                    params.upper,</span>
 41 |     | <span class='unexecuted'>                    params.burnPercent</span>
 42 |     | <span class='neutral'>                )</span>
 43 |     | <span class='neutral'>        );</span>
 44 |     | <span class='unexecuted'>        (</span>
 45 |     | <span class='neutral'>            cache.state,</span>
 46 |     | <span class='unexecuted'>            cache.position,</span>
 47 |     | <span class='unexecuted'>            cache.amount0,</span>
 48 |     | <span class='unexecuted'>            cache.amount1</span>
 49 |     | <span class='unexecuted'>        ) = Positions.remove(</span>
 50 |     | <span class='neutral'>            cache.position,</span>
 51 |     | <span class='unexecuted'>            ticks,</span>
 52 |     | <span class='unexecuted'>            samples,</span>
 53 |     | <span class='unexecuted'>            tickMap,</span>
 54 |     | <span class='unexecuted'>            cache.state,</span>
 55 |     | <span class='unexecuted'>            params,</span>
 56 |     | <span class='unexecuted'>            IRangePoolStructs.RemoveParams(</span>
 57 |     | <span class='unexecuted'>                cache.amount0,</span>
 58 |     | <span class='unexecuted'>                cache.amount1,</span>
 59 |     | <span class='unexecuted'>                cache.tokenBurned,</span>
 60 |     | <span class='unexecuted'>                cache.constants</span>
 61 |     | <span class='neutral'>            )</span>
 62 |     | <span class='neutral'>        );</span>
 63 |     | <span class='unexecuted'>        cache.position.amount0 -= cache.amount0;</span>
 64 |     | <span class='unexecuted'>        cache.position.amount1 -= cache.amount1;</span>
 65 |     | <span class='unexecuted'>        if (cache.position.amount0 &gt; 0 || cache.position.amount1 &gt; 0) {</span>
 66 |     | <span class='unexecuted'>            (cache.position, cache.state) = Positions.compound(</span>
 67 |     | <span class='unexecuted'>                cache.position,</span>
 68 |     | <span class='unexecuted'>                ticks,</span>
 69 |     | <span class='unexecuted'>                samples,</span>
 70 |     | <span class='unexecuted'>                tickMap,</span>
 71 |     | <span class='unexecuted'>                cache.state,</span>
 72 |     | <span class='unexecuted'>                IRangePoolStructs.CompoundParams(</span>
 73 |     | <span class='unexecuted'>                    params.lower,</span>
 74 |     | <span class='unexecuted'>                    params.upper</span>
 75 |     | <span class='neutral'>                ),</span>
 76 |     | <span class='unexecuted'>                cache.constants</span>
 77 |     | <span class='neutral'>            );</span>
 78 |     | <span class='neutral'>        }</span>
 79 |     | <span class='unexecuted'>        if (cache.amount0 &gt; 0) SafeTransfers.transferOut(params.to, cache.constants.token0, cache.amount0);</span>
 80 |     | <span class='unexecuted'>        if (cache.amount1 &gt; 0) SafeTransfers.transferOut(params.to, cache.constants.token1, cache.amount1);</span>
 81 |     | <span class='unexecuted'>        return cache;</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/range/pool/MintCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/range/IRangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../utils/SafeTransfers.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../Positions.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library MintCall {</span>
  9 |     | <span class='neutral'>    event Mint(</span>
 10 |     | <span class='neutral'>        address indexed recipient,</span>
 11 |     | <span class='neutral'>        int24 lower,</span>
 12 |     | <span class='neutral'>        int24 upper,</span>
 13 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
 14 |     | <span class='neutral'>        uint128 tokenMinted,</span>
 15 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
 16 |     | <span class='neutral'>        uint128 amount0,</span>
 17 |     | <span class='neutral'>        uint128 amount1</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function perform(</span>
 21 |     | <span class='neutral'>        IRangePoolStructs.MintParams memory params,</span>
 22 |     | <span class='neutral'>        IRangePoolStructs.MintCache memory cache,</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 24 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 25 |     | <span class='neutral'>        IRangePoolStructs.Sample[65535] storage samples</span>
 26 |     | <span class='unexecuted'>    ) internal returns (IRangePoolStructs.MintCache memory) {</span>
 27 |     | <span class='unexecuted'>        (</span>
 28 |     | <span class='unexecuted'>            cache.position,</span>
 29 |     | <span class='neutral'>            ,,</span>
 30 |     | <span class='unexecuted'>        ) = Positions.update(</span>
 31 |     | <span class='unexecuted'>                ticks,</span>
 32 |     | <span class='unexecuted'>                cache.position,</span>
 33 |     | <span class='unexecuted'>                cache.state,</span>
 34 |     | <span class='unexecuted'>                cache.constants,</span>
 35 |     | <span class='unexecuted'>                IRangePoolStructs.UpdateParams(</span>
 36 |     | <span class='unexecuted'>                    params.lower,</span>
 37 |     | <span class='unexecuted'>                    params.upper,</span>
 38 |     | <span class='unexecuted'>                    0</span>
 39 |     | <span class='neutral'>                )</span>
 40 |     | <span class='neutral'>        );</span>
 41 |     | <span class='unexecuted'>        (params, cache.liquidityMinted) = Positions.validate(params, cache.state, cache.constants);</span>
 42 |     | <span class='unexecuted'>        if (params.amount0 &gt; 0) SafeTransfers.transferIn(cache.constants.token0, params.amount0);</span>
 43 |     | <span class='unexecuted'>        if (params.amount1 &gt; 0) SafeTransfers.transferIn(cache.constants.token1, params.amount1);</span>
 44 |     | <span class='unexecuted'>        if (cache.position.amount0 &gt; 0 || cache.position.amount1 &gt; 0) {</span>
 45 |     | <span class='unexecuted'>            (cache.position, cache.state) = Positions.compound(</span>
 46 |     | <span class='unexecuted'>                cache.position,</span>
 47 |     | <span class='unexecuted'>                ticks,</span>
 48 |     | <span class='unexecuted'>                samples,</span>
 49 |     | <span class='unexecuted'>                tickMap,</span>
 50 |     | <span class='unexecuted'>                cache.state,</span>
 51 |     | <span class='unexecuted'>                IRangePoolStructs.CompoundParams( </span>
 52 |     | <span class='unexecuted'>                    params.lower,</span>
 53 |     | <span class='unexecuted'>                    params.upper</span>
 54 |     | <span class='neutral'>                ),</span>
 55 |     | <span class='unexecuted'>                cache.constants</span>
 56 |     | <span class='neutral'>            );</span>
 57 |     | <span class='neutral'>        }</span>
 58 |     | <span class='neutral'>        // update position with latest fees accrued</span>
 59 |     | <span class='unexecuted'>        (cache.state, cache.position, cache.liquidityMinted) = Positions.add(</span>
 60 |     | <span class='unexecuted'>            cache.position,</span>
 61 |     | <span class='unexecuted'>            ticks,</span>
 62 |     | <span class='unexecuted'>            samples,</span>
 63 |     | <span class='unexecuted'>            tickMap,</span>
 64 |     | <span class='unexecuted'>            IRangePoolStructs.AddParams(</span>
 65 |     | <span class='unexecuted'>                cache.state, </span>
 66 |     | <span class='unexecuted'>                params,</span>
 67 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted),</span>
 68 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 69 |     | <span class='neutral'>            ),</span>
 70 |     | <span class='unexecuted'>            cache.constants</span>
 71 |     | <span class='neutral'>        );</span>
 72 |     | <span class='neutral'>        return cache;</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/solady/Clone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Class with helper read functions for clone with immutable args.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)</span>
   6 |     | <span class='neutral'>/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon &amp; Natalie</span>
   7 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   8 |     | <span class='neutral'>abstract contract Clone {</span>
   9 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes.</span>
  10 |     | <span class='neutral'>    function _getArgBytes(uint256 argOffset, uint256 length)</span>
  11 |     | <span class='neutral'>        internal</span>
  12 |     | <span class='neutral'>        pure</span>
  13 |     | <span class='neutral'>        returns (bytes memory arg)</span>
  14 |     | <span class='neutral'>    {</span>
  15 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  16 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  17 |     | <span class='neutral'>        assembly {</span>
  18 |     | <span class='neutral'>            arg := mload(0x40)</span>
  19 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  20 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)</span>
  21 |     | <span class='neutral'>            let o := add(add(arg, 0x20), length)</span>
  22 |     | <span class='neutral'>            mstore(o, 0) // Zeroize the slot after the bytes.</span>
  23 |     | <span class='neutral'>            mstore(0x40, add(o, 0x20)) // Allocate the memory.</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type address.</span>
  28 |     | <span class='unexecuted'>    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {</span>
  29 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  30 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  31 |     | <span class='neutral'>        assembly {</span>
  32 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev Reads a uint256 array stored in the immutable args.</span>
  37 |     | <span class='neutral'>    function _getArgUint256Array(uint256 argOffset, uint256 length)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='neutral'>        pure</span>
  40 |     | <span class='neutral'>        returns (uint256[] memory arg)</span>
  41 |     | <span class='neutral'>    {</span>
  42 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  43 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  44 |     | <span class='neutral'>        assembly {</span>
  45 |     | <span class='neutral'>            arg := mload(0x40)</span>
  46 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  47 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  48 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @dev Reads a bytes32 array stored in the immutable args.</span>
  53 |     | <span class='neutral'>    function _getArgBytes32Array(uint256 argOffset, uint256 length)</span>
  54 |     | <span class='neutral'>        internal</span>
  55 |     | <span class='neutral'>        pure</span>
  56 |     | <span class='neutral'>        returns (bytes32[] memory arg)</span>
  57 |     | <span class='neutral'>    {</span>
  58 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  59 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  60 |     | <span class='neutral'>        assembly {</span>
  61 |     | <span class='neutral'>            arg := mload(0x40)</span>
  62 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  63 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  64 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes32.</span>
  69 |     | <span class='neutral'>    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {</span>
  70 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  71 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint256.</span>
  78 |     | <span class='neutral'>    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {</span>
  79 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  80 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint248.</span>
  87 |     | <span class='neutral'>    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {</span>
  88 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  89 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  90 |     | <span class='neutral'>        assembly {</span>
  91 |     | <span class='neutral'>            arg := shr(8, calldataload(add(offset, argOffset)))</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint240.</span>
  96 |     | <span class='neutral'>    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {</span>
  97 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  98 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 |     | <span class='neutral'>            arg := shr(16, calldataload(add(offset, argOffset)))</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint232.</span>
 105 |     | <span class='neutral'>    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {</span>
 106 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 107 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 108 |     | <span class='neutral'>        assembly {</span>
 109 |     | <span class='neutral'>            arg := shr(24, calldataload(add(offset, argOffset)))</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint224.</span>
 114 |     | <span class='neutral'>    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {</span>
 115 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 116 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 117 |     | <span class='neutral'>        assembly {</span>
 118 |     | <span class='neutral'>            arg := shr(0x20, calldataload(add(offset, argOffset)))</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint216.</span>
 123 |     | <span class='neutral'>    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {</span>
 124 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='neutral'>            arg := shr(40, calldataload(add(offset, argOffset)))</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint208.</span>
 132 |     | <span class='neutral'>    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {</span>
 133 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 134 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 135 |     | <span class='neutral'>        assembly {</span>
 136 |     | <span class='neutral'>            arg := shr(48, calldataload(add(offset, argOffset)))</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint200.</span>
 141 |     | <span class='neutral'>    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {</span>
 142 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 |     | <span class='neutral'>            arg := shr(56, calldataload(add(offset, argOffset)))</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint192.</span>
 150 |     | <span class='neutral'>    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {</span>
 151 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 152 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            arg := shr(64, calldataload(add(offset, argOffset)))</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint184.</span>
 159 |     | <span class='neutral'>    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {</span>
 160 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='neutral'>            arg := shr(72, calldataload(add(offset, argOffset)))</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint176.</span>
 168 |     | <span class='neutral'>    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {</span>
 169 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            arg := shr(80, calldataload(add(offset, argOffset)))</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint168.</span>
 177 |     | <span class='neutral'>    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {</span>
 178 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 179 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='neutral'>            arg := shr(88, calldataload(add(offset, argOffset)))</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint160.</span>
 186 |     | <span class='neutral'>    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {</span>
 187 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 189 |     | <span class='neutral'>        assembly {</span>
 190 |     | <span class='neutral'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint152.</span>
 195 |     | <span class='neutral'>    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {</span>
 196 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 197 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 198 |     | <span class='neutral'>        assembly {</span>
 199 |     | <span class='neutral'>            arg := shr(104, calldataload(add(offset, argOffset)))</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint144.</span>
 204 |     | <span class='neutral'>    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {</span>
 205 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 207 |     | <span class='neutral'>        assembly {</span>
 208 |     | <span class='neutral'>            arg := shr(112, calldataload(add(offset, argOffset)))</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint136.</span>
 213 |     | <span class='neutral'>    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {</span>
 214 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 216 |     | <span class='neutral'>        assembly {</span>
 217 |     | <span class='neutral'>            arg := shr(120, calldataload(add(offset, argOffset)))</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint128.</span>
 222 |     | <span class='neutral'>    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {</span>
 223 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='neutral'>            arg := shr(128, calldataload(add(offset, argOffset)))</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint120.</span>
 231 |     | <span class='neutral'>    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {</span>
 232 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 234 |     | <span class='neutral'>        assembly {</span>
 235 |     | <span class='neutral'>            arg := shr(136, calldataload(add(offset, argOffset)))</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint112.</span>
 240 |     | <span class='neutral'>    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {</span>
 241 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 242 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 243 |     | <span class='neutral'>        assembly {</span>
 244 |     | <span class='neutral'>            arg := shr(144, calldataload(add(offset, argOffset)))</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint104.</span>
 249 |     | <span class='neutral'>    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {</span>
 250 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 251 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 252 |     | <span class='neutral'>        assembly {</span>
 253 |     | <span class='neutral'>            arg := shr(152, calldataload(add(offset, argOffset)))</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint96.</span>
 258 |     | <span class='neutral'>    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {</span>
 259 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 261 |     | <span class='neutral'>        assembly {</span>
 262 |     | <span class='neutral'>            arg := shr(160, calldataload(add(offset, argOffset)))</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint88.</span>
 267 |     | <span class='neutral'>    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {</span>
 268 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 270 |     | <span class='neutral'>        assembly {</span>
 271 |     | <span class='neutral'>            arg := shr(168, calldataload(add(offset, argOffset)))</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint80.</span>
 276 |     | <span class='neutral'>    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {</span>
 277 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 279 |     | <span class='neutral'>        assembly {</span>
 280 |     | <span class='neutral'>            arg := shr(176, calldataload(add(offset, argOffset)))</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint72.</span>
 285 |     | <span class='neutral'>    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {</span>
 286 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 288 |     | <span class='neutral'>        assembly {</span>
 289 |     | <span class='neutral'>            arg := shr(184, calldataload(add(offset, argOffset)))</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint64.</span>
 294 |     | <span class='neutral'>    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {</span>
 295 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 296 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>        assembly {</span>
 298 |     | <span class='neutral'>            arg := shr(192, calldataload(add(offset, argOffset)))</span>
 299 |     | <span class='neutral'>        }</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint56.</span>
 303 |     | <span class='neutral'>    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {</span>
 304 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 305 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='neutral'>            arg := shr(200, calldataload(add(offset, argOffset)))</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint48.</span>
 312 |     | <span class='neutral'>    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {</span>
 313 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 314 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 315 |     | <span class='neutral'>        assembly {</span>
 316 |     | <span class='neutral'>            arg := shr(208, calldataload(add(offset, argOffset)))</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint40.</span>
 321 |     | <span class='neutral'>    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {</span>
 322 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 323 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 324 |     | <span class='neutral'>        assembly {</span>
 325 |     | <span class='neutral'>            arg := shr(216, calldataload(add(offset, argOffset)))</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint32.</span>
 330 |     | <span class='neutral'>    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {</span>
 331 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 332 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 333 |     | <span class='neutral'>        assembly {</span>
 334 |     | <span class='neutral'>            arg := shr(224, calldataload(add(offset, argOffset)))</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint24.</span>
 339 |     | <span class='neutral'>    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {</span>
 340 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 341 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 342 |     | <span class='neutral'>        assembly {</span>
 343 |     | <span class='neutral'>            arg := shr(232, calldataload(add(offset, argOffset)))</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint16.</span>
 348 |     | <span class='neutral'>    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {</span>
 349 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 350 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 351 |     | <span class='neutral'>        assembly {</span>
 352 |     | <span class='unexecuted'>            arg := shr(240, calldataload(add(offset, argOffset)))</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint8.</span>
 357 |     | <span class='neutral'>    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {</span>
 358 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 360 |     | <span class='neutral'>        assembly {</span>
 361 |     | <span class='neutral'>            arg := shr(248, calldataload(add(offset, argOffset)))</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    /// @return offset The offset of the packed immutable args in calldata.</span>
 366 |     | <span class='neutral'>    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {</span>
 367 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='unexecuted'>            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/solady/LibClone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Minimal proxy library.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)</span>
   6 |     | <span class='neutral'>/// @author Minimal proxy by 0age (https://github.com/0age)</span>
   7 |     | <span class='neutral'>/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon &amp; Natalie</span>
   8 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   9 |     | <span class='neutral'>///</span>
  10 |     | <span class='neutral'>/// @dev Minimal proxy:</span>
  11 |     | <span class='neutral'>/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,</span>
  12 |     | <span class='neutral'>/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,</span>
  13 |     | <span class='neutral'>/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.</span>
  14 |     | <span class='neutral'>///</span>
  15 |     | <span class='neutral'>/// @dev Clones with immutable args (CWIA):</span>
  16 |     | <span class='neutral'>/// The implementation of CWIA here implements a `receive()` method that emits the</span>
  17 |     | <span class='neutral'>/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,</span>
  18 |     | <span class='neutral'>/// enabling us to accept hard gas-capped `sends` &amp; `transfers` for maximum backwards</span>
  19 |     | <span class='neutral'>/// composability. The minimal proxy implementation does not offer this feature.</span>
  20 |     | <span class='unexecuted'>library LibClone {</span>
  21 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  22 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  23 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev Unable to deploy the clone.</span>
  26 |     | <span class='neutral'>    error DeploymentFailed();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @dev The salt must start with either the zero address or the caller.</span>
  29 |     | <span class='neutral'>    error SaltDoesNotStartWithCaller();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
  32 |     | <span class='neutral'>    /*                  MINIMAL PROXY OPERATIONS                  */</span>
  33 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`,</span>
  36 |     | <span class='neutral'>    /// using immutable  arguments encoded in `data`, with `salt`.</span>
  37 |     | <span class='unexecuted'>    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='unexecuted'>        returns (address instance)</span>
  40 |     | <span class='neutral'>    {</span>
  41 |     | <span class='neutral'>        assembly {</span>
  42 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  43 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
  44 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
  45 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
  46 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
  47 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  48 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  51 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
  54 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
  55 |     | <span class='neutral'>            // Write the address of the implementation.</span>
  56 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
  57 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  58 |     | <span class='unexecuted'>            mstore(</span>
  59 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
  60 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  61 |     | <span class='neutral'>            )</span>
  62 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  63 |     | <span class='unexecuted'>            mstore(</span>
  64 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  65 |     | <span class='neutral'>            )</span>
  66 |     | <span class='unexecuted'>            mstore(</span>
  67 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
  68 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Create the instance.</span>
  73 |     | <span class='unexecuted'>            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            // If `instance` is zero, revert.</span>
  76 |     | <span class='unexecuted'>            if iszero(instance) {</span>
  77 |     | <span class='neutral'>                // Store the function selector of `DeploymentFailed()`.</span>
  78 |     | <span class='unexecuted'>                mstore(0x00, 0x30116425)</span>
  79 |     | <span class='neutral'>                // Revert with (offset, size).</span>
  80 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  84 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
  85 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
  86 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
  87 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
  88 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  93 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  94 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  95 |     | <span class='neutral'>    function initCodeHash(address implementation, bytes memory data)</span>
  96 |     | <span class='neutral'>        internal</span>
  97 |     | <span class='neutral'>        pure</span>
  98 |     | <span class='neutral'>        returns (bytes32 hash)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        assembly {</span>
 101 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
 102 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
 103 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
 104 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
 105 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
 106 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
 107 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
 110 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
 113 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
 114 |     | <span class='neutral'>            // Write the address of the implementation.</span>
 115 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
 116 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
 117 |     | <span class='unexecuted'>            mstore(</span>
 118 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
 119 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
 120 |     | <span class='neutral'>            )</span>
 121 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
 122 |     | <span class='unexecuted'>            mstore(</span>
 123 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
 124 |     | <span class='neutral'>            )</span>
 125 |     | <span class='unexecuted'>            mstore(</span>
 126 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
 127 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
 128 |     | <span class='neutral'>            )</span>
 129 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 132 |     | <span class='unexecuted'>            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
 135 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
 136 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
 137 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
 138 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
 139 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of</span>
 144 |     | <span class='neutral'>    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.</span>
 145 |     | <span class='unexecuted'>    function predictDeterministicAddress(</span>
 146 |     | <span class='neutral'>        address implementation,</span>
 147 |     | <span class='neutral'>        bytes memory data,</span>
 148 |     | <span class='neutral'>        bytes32 salt,</span>
 149 |     | <span class='neutral'>        address deployer</span>
 150 |     | <span class='neutral'>    ) internal pure returns (address predicted) {</span>
 151 |     | <span class='neutral'>        bytes32 hash = initCodeHash(implementation, data);</span>
 152 |     | <span class='unexecuted'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/</span>
 156 |     | <span class='neutral'>    /*                      OTHER OPERATIONS                      */</span>
 157 |     | <span class='neutral'>    /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @dev Returns the address when a contract with initialization code hash,</span>
 160 |     | <span class='neutral'>    /// `hash`, is deployed with `salt`, by `deployer`.</span>
 161 |     | <span class='unexecuted'>    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)</span>
 162 |     | <span class='neutral'>        internal</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='unexecuted'>        returns (address predicted)</span>
 165 |     | <span class='neutral'>    {</span>
 166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 167 |     | <span class='neutral'>        assembly {</span>
 168 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 169 |     | <span class='unexecuted'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 170 |     | <span class='unexecuted'>            mstore(0x35, hash)</span>
 171 |     | <span class='unexecuted'>            mstore(0x01, shl(96, deployer))</span>
 172 |     | <span class='unexecuted'>            mstore(0x15, salt)</span>
 173 |     | <span class='unexecuted'>            predicted := keccak256(0x00, 0x55)</span>
 174 |     | <span class='neutral'>            // Restore the part of the free memory pointer that has been overwritten.</span>
 175 |     | <span class='unexecuted'>            mstore(0x35, 0)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @dev Reverts if `salt` does not start with either the zero address or the caller.</span>
 180 |     | <span class='neutral'>    function checkStartsWithCaller(bytes32 salt) internal view {</span>
 181 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 182 |     | <span class='neutral'>        assembly {</span>
 183 |     | <span class='neutral'>            // If the salt does not start with the zero address or the caller.</span>
 184 |     | <span class='neutral'>            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {</span>
 185 |     | <span class='neutral'>                // Store the function selector of `SaltDoesNotStartWithCaller()`.</span>
 186 |     | <span class='neutral'>                mstore(0x00, 0x2f634836)</span>
 187 |     | <span class='neutral'>                // Revert with (offset, size).</span>
 188 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/Collect.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../limit/PositionsLimit.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library Collect {</span>
  9 |     | <span class='unexecuted'>    function burnLimit(</span>
 10 |     | <span class='neutral'>        ILimitPoolStructs.BurnLimitCache memory cache,</span>
 11 |     | <span class='neutral'>        ILimitPoolStructs.BurnLimitParams memory params</span>
 12 |     | <span class='neutral'>    ) internal returns (</span>
 13 |     | <span class='unexecuted'>        ILimitPoolStructs.BurnLimitCache memory</span>
 14 |     | <span class='neutral'>    )    </span>
 15 |     | <span class='neutral'>    {</span>
 16 |     | <span class='neutral'>        // store amounts for transferOut</span>
 17 |     | <span class='unexecuted'>        uint128 amountIn  = cache.position.amountIn;</span>
 18 |     | <span class='unexecuted'>        uint128 amountOut = cache.position.amountOut;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>        /// zero out balances and transfer out</span>
 21 |     | <span class='unexecuted'>        if (amountIn &gt; 0) {</span>
 22 |     | <span class='unexecuted'>            cache.position.amountIn = 0;</span>
 23 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='unexecuted'>        if (amountOut &gt; 0) {</span>
 26 |     | <span class='unexecuted'>            cache.position.amountOut = 0;</span>
 27 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);</span>
 28 |     | <span class='neutral'>        }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>        return cache;</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='neutral'>}</span>
 33 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 10 |     | <span class='unexecuted'>    function toUint128(uint256 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='unexecuted'>        require((z = uint128(y)) == y);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 15 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 17 |     | <span class='unexecuted'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 18 |     | <span class='unexecuted'>        require((z = uint160(y)) == y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 22 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 23 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 24 |     | <span class='neutral'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 25 |     | <span class='neutral'>        require((z = int128(y)) == y);</span>
 26 |     | <span class='neutral'>    }</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 29 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 30 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 31 |     | <span class='neutral'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 32 |     | <span class='neutral'>        require(y &lt; 2**255);</span>
 33 |     | <span class='neutral'>        z = int256(y);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/SafeTransfers.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library SafeTransfers {</span>
   7 |     | <span class='neutral'>    /**</span>
   8 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
   9 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
  10 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
  11 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  14 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  17 |     | <span class='unexecuted'>    function transferIn(address token, uint256 amount) internal returns (uint256) {</span>
  18 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  19 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  20 |     | <span class='unexecuted'>            return amount;</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='unexecuted'>        if (amount == 0) return 0;</span>
  23 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  24 |     | <span class='unexecuted'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  27 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  28 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  29 |     | <span class='unexecuted'>        erc20Token.transferFrom(msg.sender, address(this), amount);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        bool success;</span>
  32 |     | <span class='neutral'>        assembly {</span>
  33 |     | <span class='unexecuted'>            switch returndatasize()</span>
  34 |     | <span class='unexecuted'>            case 0 {</span>
  35 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  36 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='unexecuted'>            case 32 {</span>
  39 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
  40 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  41 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  42 |     | <span class='neutral'>            }</span>
  43 |     | <span class='neutral'>            default {</span>
  44 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  45 |     | <span class='unexecuted'>                success := 0</span>
  46 |     | <span class='neutral'>            }</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
  51 |     | <span class='unexecuted'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory</span>
  58 |     | <span class='neutral'>     *      error code rather than reverting. If caller has not called checked protocol&#39;s balance, this may revert due to</span>
  59 |     | <span class='neutral'>     *      insufficient cash held in this contract. If caller has checked protocol&#39;s balance prior to this call, and verified</span>
  60 |     | <span class='neutral'>     *      it is &gt;= amount, this should not revert in normal conditions.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  63 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  66 |     | <span class='unexecuted'>    function transferOut(</span>
  67 |     | <span class='neutral'>        address to,</span>
  68 |     | <span class='neutral'>        address token,</span>
  69 |     | <span class='neutral'>        uint256 amount</span>
  70 |     | <span class='unexecuted'>    ) internal {</span>
  71 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  72 |     | <span class='unexecuted'>            if (address(this).balance &lt; amount) require(false, &#39;TransferFailed(address(this), to&#39;);</span>
  73 |     | <span class='unexecuted'>            payable(to).transfer(amount);</span>
  74 |     | <span class='neutral'>            return;</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='unexecuted'>        if (amount == 0) return;</span>
  77 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  78 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  79 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  80 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  81 |     | <span class='unexecuted'>        erc20Token.transfer(to, amount);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        bool success;</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='unexecuted'>            switch returndatasize()</span>
  86 |     | <span class='unexecuted'>            case 0 {</span>
  87 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  88 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='unexecuted'>            case 32 {</span>
  91 |     | <span class='neutral'>                // This is a complaint ERC-20</span>
  92 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  93 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='neutral'>            default {</span>
  96 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  97 |     | <span class='unexecuted'>                success := 0</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(address(this), msg.sender&#39;);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
 105 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
 106 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
 107 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
 110 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
 113 | *   | <span class='executed'>    function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {</span>
 114 | *   | <span class='executed'>        if (token == address(0)) {</span>
 115 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 116 |     | <span class='unexecuted'>            return amount;</span>
 117 |     | <span class='neutral'>        }</span>
 118 | *   | <span class='executed'>        IERC20 erc20Token = IERC20(token);</span>
 119 | *   | <span class='executed'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        /// @dev - msg.sender here is the pool</span>
 122 | *r  | <span class='executed'>        erc20Token.transferFrom(sender, msg.sender, amount);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        bool success;</span>
 125 |     | <span class='neutral'>        assembly {</span>
 126 | *   | <span class='executed'>            switch returndatasize()</span>
 127 | *   | <span class='executed'>            case 0 {</span>
 128 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
 129 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
 130 |     | <span class='neutral'>            }</span>
 131 | *   | <span class='executed'>            case 32 {</span>
 132 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
 133 | *   | <span class='executed'>                returndatacopy(0, 0, 32)</span>
 134 | *   | <span class='executed'>                success := mload(0) // Set `success = returndata` of external call</span>
 135 |     | <span class='neutral'>            }</span>
 136 |     | <span class='neutral'>            default {</span>
 137 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
 138 |     | <span class='unexecuted'>                success := 0</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='neutral'>        }</span>
 141 | *   | <span class='executed'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
 144 | *   | <span class='executed'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/String.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library String {</span>
  5 |     | <span class='neutral'>    bytes16 private constant alphabet = &quot;0123456789abcdef&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function from(bytes32 value) internal pure returns(string memory) {</span>
  8 |     | <span class='neutral'>        return toString(abi.encodePacked(value));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function from(address account) internal pure returns(string memory) {</span>
 12 |     | <span class='neutral'>        return toString(abi.encodePacked(account));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function from(uint256 value) internal pure returns(string memory) {</span>
 16 |     | <span class='neutral'>        unchecked {</span>
 17 |     | <span class='unexecuted'>            uint256 length = log10(value) + 1;</span>
 18 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 19 |     | <span class='neutral'>            uint256 ptr;</span>
 20 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 21 |     | <span class='neutral'>            assembly {</span>
 22 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 23 |     | <span class='neutral'>            }</span>
 24 |     | <span class='unexecuted'>            while (true) {</span>
 25 |     | <span class='unexecuted'>                ptr--;</span>
 26 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 27 |     | <span class='neutral'>                assembly {</span>
 28 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), alphabet))</span>
 29 |     | <span class='neutral'>                }</span>
 30 |     | <span class='unexecuted'>                value /= 10;</span>
 31 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='unexecuted'>            return buffer;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function from(int256 value) internal pure returns (string memory) {</span>
 38 |     | <span class='unexecuted'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, from(abs(value))));</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>    function abs(int256 n) internal pure returns (uint256) {</span>
 42 |     | <span class='neutral'>        unchecked {</span>
 43 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 44 |     | <span class='unexecuted'>            return uint256(n &gt;= 0 ? n : -n);</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 49 |     | <span class='neutral'>        uint256 result = 0;</span>
 50 |     | <span class='neutral'>        unchecked {</span>
 51 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 52 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 53 |     | <span class='unexecuted'>                result += 64;</span>
 54 |     | <span class='neutral'>            }</span>
 55 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 56 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 57 |     | <span class='unexecuted'>                result += 32;</span>
 58 |     | <span class='neutral'>            }</span>
 59 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 60 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 61 |     | <span class='unexecuted'>                result += 16;</span>
 62 |     | <span class='neutral'>            }</span>
 63 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 64 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 65 |     | <span class='unexecuted'>                result += 8;</span>
 66 |     | <span class='neutral'>            }</span>
 67 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 68 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 69 |     | <span class='unexecuted'>                result += 4;</span>
 70 |     | <span class='neutral'>            }</span>
 71 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 72 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 73 |     | <span class='unexecuted'>                result += 2;</span>
 74 |     | <span class='neutral'>            }</span>
 75 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 76 |     | <span class='unexecuted'>                result += 1;</span>
 77 |     | <span class='neutral'>            }</span>
 78 |     | <span class='neutral'>        }</span>
 79 |     | <span class='unexecuted'>        return result;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    function toString(bytes memory data) internal pure returns(string memory) {</span>
 83 |     | <span class='neutral'>        bytes memory str = new bytes(2 + data.length * 2);</span>
 84 |     | <span class='neutral'>        str[0] = &quot;0&quot;;</span>
 85 |     | <span class='neutral'>        str[1] = &quot;x&quot;;</span>
 86 |     | <span class='neutral'>        for (uint i = 0; i &lt; data.length;) {</span>
 87 |     | <span class='neutral'>            str[2+i*2] = alphabet[uint(uint8(data[i] &gt;&gt; 4))];</span>
 88 |     | <span class='neutral'>            str[3+i*2] = alphabet[uint(uint8(data[i] &amp; 0x0f))];</span>
 89 |     | <span class='neutral'>            unchecked {</span>
 90 |     | <span class='neutral'>                ++i;</span>
 91 |     | <span class='neutral'>            }</span>
 92 |     | <span class='neutral'>        }</span>
 93 |     | <span class='neutral'>        return string(str);</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/test/Token20.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract Token20 is ERC20, ERC20Burnable {</span>
  8 |     | <span class='neutral'>    uint8 _decimals;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(</span>
 11 |     | <span class='neutral'>        string memory tokenName,</span>
 12 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 13 |     | <span class='neutral'>        uint8 decimals_</span>
 14 |     | <span class='unexecuted'>    ) ERC20(tokenName, tokenSymbol) {</span>
 15 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function mint(address to, uint256 amount) external {</span>
 19 | *   | <span class='executed'>        _mint(to, amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return _decimals;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function setDecimals(uint8 decimals_) public {</span>
 27 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/LimitPoolErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolErrors {</span>
  5 |     | <span class='neutral'>    error Locked();</span>
  6 |     | <span class='neutral'>    error OwnerOnly();</span>
  7 |     | <span class='neutral'>    error InvalidToken();</span>
  8 |     | <span class='neutral'>    error InvalidPosition();</span>
  9 |     | <span class='neutral'>    error InvalidSwapFee();</span>
 10 |     | <span class='neutral'>    error InvalidTokenDecimals();</span>
 11 |     | <span class='neutral'>    error InvalidTickSpread();</span>
 12 |     | <span class='neutral'>    error LiquidityOverflow();</span>
 13 |     | <span class='neutral'>    error Token0Missing();</span>
 14 |     | <span class='neutral'>    error Token1Missing();</span>
 15 |     | <span class='neutral'>    error InvalidTick();</span>
 16 |     | <span class='neutral'>    error FactoryOnly();</span>
 17 |     | <span class='neutral'>    error LowerNotEvenTick();</span>
 18 |     | <span class='neutral'>    error UpperNotOddTick();</span>
 19 |     | <span class='neutral'>    error MaxTickLiquidity();</span>
 20 |     | <span class='neutral'>    error CollectToZeroAddress();</span>
 21 |     | <span class='neutral'>    error ProtocolFeeCeilingExceeded();</span>
 22 |     | <span class='neutral'>    error Overflow();</span>
 23 |     | <span class='neutral'>    error PoolAlreadyInitialized();</span>
 24 |     | <span class='neutral'>    error NotEnoughOutputLiquidity();</span>
 25 |     | <span class='neutral'>    error WaitUntilEnoughObservations();</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>abstract contract CoverTicksErrors {</span>
 29 |     | <span class='neutral'>    error WrongTickLowerRange();</span>
 30 |     | <span class='neutral'>    error WrongTickUpperRange();</span>
 31 |     | <span class='neutral'>    error WrongTickLowerOrder();</span>
 32 |     | <span class='neutral'>    error WrongTickUpperOrder();</span>
 33 |     | <span class='neutral'>    error WrongTickClaimedAt();</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>abstract contract CoverMiscErrors {</span>
 37 |     | <span class='neutral'>    // to be removed before production</span>
 38 |     | <span class='neutral'>    error NotImplementedYet();</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>abstract contract CoverPositionErrors {</span>
 42 |     | <span class='neutral'>    error NotEnoughPositionLiquidity();</span>
 43 |     | <span class='neutral'>    error InvalidClaimTick();</span>
 44 |     | <span class='neutral'>}</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>abstract contract LimitPoolFactoryErrors {</span>
 47 |     | <span class='neutral'>    error OwnerOnly();</span>
 48 |     | <span class='neutral'>    error InvalidTokenAddress();</span>
 49 |     | <span class='neutral'>    error PoolAlreadyExists();</span>
 50 |     | <span class='neutral'>    error FeeTierNotSupported();</span>
 51 |     | <span class='neutral'>    error PoolTypeNotSupported();</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>abstract contract CoverTransferErrors {</span>
 55 |     | <span class='neutral'>    error TransferFailed(address from, address dest);</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/LimitPoolManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../base/events/LimitPoolManagerEvents.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Defines the actions which can be executed by the factory admin.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='unexecuted'>contract LimitPoolManager is ILimitPoolManager, LimitPoolManagerEvents {</span>
  14 |     | <span class='unexecuted'>    address public owner;</span>
  15 |     | <span class='unexecuted'>    address public feeTo;</span>
  16 |     | <span class='unexecuted'>    address public factory;</span>
  17 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FEE = 1e4; /// @dev - max protocol fee of 1%</span>
  18 |     | <span class='neutral'>    // tickSpacing =&gt; enabled</span>
  19 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _poolImpls;</span>
  20 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _tokenImpls;</span>
  21 |     | <span class='neutral'>    mapping(uint16 =&gt; int16) internal _feeTiers;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    error InvalidSwapFee();</span>
  24 |     | <span class='neutral'>    error InvalidTickSpacing();</span>
  25 |     | <span class='neutral'>    error TickSpacingAlreadyEnabled();</span>
  26 |     | <span class='neutral'>    error ImplementationAlreadyExists();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    constructor() {</span>
  29 |     | <span class='unexecuted'>        owner = msg.sender;</span>
  30 |     | <span class='unexecuted'>        feeTo = msg.sender;</span>
  31 |     | <span class='unexecuted'>        emit OwnerTransfer(address(0), msg.sender);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // create initial fee tiers</span>
  34 |     | <span class='unexecuted'>        _feeTiers[500] = 10;</span>
  35 |     | <span class='unexecuted'>        _feeTiers[10000] = 100;</span>
  36 |     | <span class='unexecuted'>        emit FeeTierEnabled(500, 10);</span>
  37 |     | <span class='unexecuted'>        emit FeeTierEnabled(10000, 100);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /**</span>
  41 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  42 |     | <span class='neutral'>     */</span>
  43 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  44 |     | <span class='unexecuted'>        _checkOwner();</span>
  45 |     | <span class='neutral'>        _;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    modifier onlyFeeTo() {</span>
  49 |     | <span class='unexecuted'>        _checkFeeTo();</span>
  50 |     | <span class='neutral'>        _;</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /**</span>
  54 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  55 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  56 |     | <span class='neutral'>     */</span>
  57 |     | <span class='unexecuted'>    function transferOwner(address newOwner) public virtual onlyOwner {</span>
  58 |     | <span class='unexecuted'>        if(newOwner == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  59 |     | <span class='unexecuted'>        _transferOwner(newOwner);</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {</span>
  63 |     | <span class='unexecuted'>        if(newFeeTo == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  64 |     | <span class='unexecuted'>        _transferFeeTo(newFeeTo);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  69 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='unexecuted'>    function _transferOwner(address newOwner) internal virtual {</span>
  72 |     | <span class='unexecuted'>        address oldOwner = owner;</span>
  73 |     | <span class='unexecuted'>        owner = newOwner;</span>
  74 |     | <span class='unexecuted'>        emit OwnerTransfer(oldOwner, newOwner);</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Transfers fee collection to a new account (`newFeeTo`).</span>
  79 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='unexecuted'>    function _transferFeeTo(address newFeeTo) internal virtual {</span>
  82 |     | <span class='unexecuted'>        address oldFeeTo = feeTo;</span>
  83 |     | <span class='unexecuted'>        feeTo = newFeeTo;</span>
  84 |     | <span class='unexecuted'>        emit OwnerTransfer(oldFeeTo, newFeeTo);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function enableTickSpacing(</span>
  88 |     | <span class='neutral'>        int16 tickSpacing,</span>
  89 |     | <span class='neutral'>        uint16 swapFee</span>
  90 |     | <span class='neutral'>    ) external onlyOwner {</span>
  91 |     | <span class='unexecuted'>        if (_feeTiers[swapFee] != 0) revert TickSpacingAlreadyEnabled();</span>
  92 |     | <span class='unexecuted'>        if (tickSpacing &lt;= 0) revert InvalidTickSpacing();</span>
  93 |     | <span class='unexecuted'>        if (tickSpacing % 2 != 0) revert InvalidTickSpacing();</span>
  94 |     | <span class='unexecuted'>        if (swapFee == 0) revert InvalidSwapFee();</span>
  95 |     | <span class='unexecuted'>        if (swapFee &gt; 10000) revert InvalidSwapFee();</span>
  96 |     | <span class='unexecuted'>        _feeTiers[swapFee] = tickSpacing;</span>
  97 |     | <span class='unexecuted'>        emit FeeTierEnabled(swapFee, tickSpacing);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function enableImplementation(</span>
 101 |     | <span class='neutral'>        bytes32 poolType_,</span>
 102 |     | <span class='neutral'>        address poolImpl_,</span>
 103 |     | <span class='neutral'>        address tokenImpl_</span>
 104 |     | <span class='neutral'>    ) external onlyOwner {</span>
 105 |     | <span class='unexecuted'>        if (_poolImpls[poolType_] != address(0)) revert ImplementationAlreadyExists();</span>
 106 |     | <span class='unexecuted'>        _poolImpls[poolType_] = poolImpl_;</span>
 107 |     | <span class='unexecuted'>        _tokenImpls[poolType_] = tokenImpl_;</span>
 108 |     | <span class='unexecuted'>        emit ImplementationEnabled(poolType_, poolImpl_, tokenImpl_);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function setFactory(</span>
 112 |     | <span class='neutral'>        address factory_</span>
 113 |     | <span class='neutral'>    ) external onlyOwner {</span>
 114 |     | <span class='unexecuted'>        if (factory != address(0)) require (false, &#39;FactoryAlreadySet()&#39;);</span>
 115 |     | <span class='unexecuted'>        emit FactoryChanged(factory, factory_);</span>
 116 |     | <span class='unexecuted'>        factory = factory_;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>    function collectProtocolFees(</span>
 120 |     | <span class='neutral'>        address[] calldata collectPools</span>
 121 |     | <span class='unexecuted'>    ) external {</span>
 122 |     | <span class='unexecuted'>        if (collectPools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 123 |     | <span class='unexecuted'>        uint128[] memory token0Fees = new uint128[](collectPools.length);</span>
 124 |     | <span class='unexecuted'>        uint128[] memory token1Fees = new uint128[](collectPools.length);</span>
 125 |     | <span class='unexecuted'>        for (uint i; i &lt; collectPools.length;) {</span>
 126 |     | <span class='unexecuted'>            (token0Fees[i], token1Fees[i]) = IPool(collectPools[i]).fees(0,0,false);</span>
 127 |     | <span class='neutral'>            unchecked {</span>
 128 |     | <span class='unexecuted'>                ++i;</span>
 129 |     | <span class='neutral'>            }</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(collectPools, token0Fees, token1Fees);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function modifyProtocolFees(</span>
 135 |     | <span class='neutral'>        address[] calldata modifyPools,</span>
 136 |     | <span class='neutral'>        uint16[] calldata syncFees,</span>
 137 |     | <span class='neutral'>        uint16[] calldata fillFees,</span>
 138 |     | <span class='neutral'>        bool[] calldata setFees</span>
 139 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 140 |     | <span class='unexecuted'>        if (modifyPools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 141 |     | <span class='unexecuted'>        if (modifyPools.length != syncFees.length</span>
 142 |     | <span class='unexecuted'>            || syncFees.length != fillFees.length</span>
 143 |     | <span class='unexecuted'>            || fillFees.length != setFees.length) {</span>
 144 |     | <span class='unexecuted'>            require (false, &#39;MismatchedArrayLengths()&#39;);</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='unexecuted'>        uint128[] memory token0Fees = new uint128[](modifyPools.length);</span>
 147 |     | <span class='unexecuted'>        uint128[] memory token1Fees = new uint128[](modifyPools.length);</span>
 148 |     | <span class='unexecuted'>        for (uint i; i &lt; modifyPools.length;) {</span>
 149 |     | <span class='unexecuted'>            if (syncFees[i] &gt; MAX_PROTOCOL_FEE) require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 150 |     | <span class='unexecuted'>            if (fillFees[i] &gt; MAX_PROTOCOL_FEE) require (false, &#39;ProtocolFeeCeilingExceeded()&#39;);</span>
 151 |     | <span class='unexecuted'>            (</span>
 152 |     | <span class='unexecuted'>                token0Fees[i],</span>
 153 |     | <span class='unexecuted'>                token1Fees[i]</span>
 154 |     | <span class='unexecuted'>            ) = IPool(modifyPools[i]).fees(</span>
 155 |     | <span class='unexecuted'>                syncFees[i],</span>
 156 |     | <span class='unexecuted'>                fillFees[i],</span>
 157 |     | <span class='unexecuted'>                setFees[i]</span>
 158 |     | <span class='neutral'>            );</span>
 159 |     | <span class='neutral'>            unchecked {</span>
 160 |     | <span class='unexecuted'>                ++i;</span>
 161 |     | <span class='neutral'>            }</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='unexecuted'>        emit ProtocolFeesModified(modifyPools, syncFees, fillFees, setFees, token0Fees, token1Fees);</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>    function implementations(</span>
 167 |     | <span class='neutral'>        bytes32 key</span>
 168 |     | <span class='neutral'>    ) external view returns (</span>
 169 |     | <span class='unexecuted'>        address,</span>
 170 |     | <span class='neutral'>        address</span>
 171 |     | <span class='neutral'>    ) {</span>
 172 |     | <span class='unexecuted'>        return (_poolImpls[key], _tokenImpls[key]);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function feeTiers(</span>
 176 |     | <span class='neutral'>        uint16 swapFee</span>
 177 |     | <span class='neutral'>    ) external view returns (</span>
 178 |     | <span class='unexecuted'>        int16 tickSpacing</span>
 179 |     | <span class='neutral'>    ) {</span>
 180 |     | <span class='unexecuted'>        return _feeTiers[swapFee];</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'>    </span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 185 |     | <span class='neutral'>     */</span>
 186 |     | <span class='unexecuted'>    function _checkOwner() internal view {</span>
 187 |     | <span class='unexecuted'>        if (owner != msg.sender) require (false, &#39;OwnerOnly()&#39;);</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    /**</span>
 191 |     | <span class='neutral'>     * @dev Throws if the sender is not the feeTo.</span>
 192 |     | <span class='neutral'>     */</span>
 193 |     | <span class='unexecuted'>    function _checkFeeTo() internal view {</span>
 194 |     | <span class='unexecuted'>        if (feeTo != msg.sender) require (false, &#39;FeeToOnly()&#39;);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/PoolRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../interfaces/callbacks/IPoolsharkSwapCallback.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../libraries/utils/SafeTransfers.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../base/structs/PoolsharkStructs.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;../libraries/solady/LibClone.sol&#39;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract PoolRouter is</span>
 11 |     | <span class='neutral'>    IPoolsharkSwapCallback,</span>
 12 |     | <span class='neutral'>    PoolsharkStructs</span>
 13 |     | <span class='neutral'>{</span>
 14 |     | <span class='unexecuted'>    address public immutable factory;</span>
 15 |     | <span class='unexecuted'>    address public immutable implementation;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    struct SwapCallbackData {</span>
 18 |     | <span class='neutral'>        address sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    constructor(</span>
 22 |     | <span class='neutral'>        address factory_,</span>
 23 |     | <span class='neutral'>        address implementation_</span>
 24 |     | <span class='neutral'>    ) {</span>
 25 |     | <span class='unexecuted'>        factory = factory_;</span>
 26 |     | <span class='unexecuted'>        implementation = implementation_;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @inheritdoc IPoolsharkSwapCallback</span>
 30 |     | <span class='unexecuted'>    function poolsharkSwapCallback(</span>
 31 |     | <span class='neutral'>        int256 amount0Delta,</span>
 32 |     | <span class='neutral'>        int256 amount1Delta,</span>
 33 |     | <span class='neutral'>        bytes calldata data</span>
 34 |     | <span class='unexecuted'>    ) external override {</span>
 35 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables memory constants = IPool(msg.sender).immutables();</span>
 36 |     | <span class='neutral'>        // generate key for pool</span>
 37 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 38 |     | <span class='unexecuted'>            implementation,</span>
 39 |     | <span class='unexecuted'>            constants.token0,</span>
 40 |     | <span class='unexecuted'>            constants.token1,</span>
 41 |     | <span class='unexecuted'>            constants.swapFee</span>
 42 |     | <span class='neutral'>        ));</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>        // compute address</span>
 45 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 46 |     | <span class='unexecuted'>            implementation,</span>
 47 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 48 |     | <span class='unexecuted'>                constants.owner,</span>
 49 |     | <span class='unexecuted'>                constants.token0,</span>
 50 |     | <span class='unexecuted'>                constants.token1,</span>
 51 |     | <span class='unexecuted'>                constants.poolToken,</span>
 52 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 53 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 54 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 55 |     | <span class='unexecuted'>                constants.swapFee</span>
 56 |     | <span class='neutral'>            ),</span>
 57 |     | <span class='unexecuted'>            key,</span>
 58 |     | <span class='unexecuted'>            factory</span>
 59 |     | <span class='neutral'>        );</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>        // revert on sender mismatch</span>
 62 |     | <span class='unexecuted'>        if (msg.sender != predictedAddress) require(false, &#39;InvalidCallerAddress()&#39;);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>        // decode original sender</span>
 65 |     | <span class='unexecuted'>        SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));</span>
 66 |     | <span class='neutral'>        </span>
 67 |     | <span class='neutral'>        // transfer from swap caller</span>
 68 |     | <span class='unexecuted'>        if (amount0Delta &lt; 0) {</span>
 69 |     | <span class='unexecuted'>            SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));</span>
 70 |     | <span class='neutral'>        } else {</span>
 71 |     | <span class='unexecuted'>            SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));</span>
 72 |     | <span class='neutral'>        }</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>    function multiCall(</span>
 76 |     | <span class='neutral'>        address[] memory pools,</span>
 77 |     | <span class='neutral'>        SwapParams[] memory params </span>
 78 |     | <span class='neutral'>    ) external {</span>
 79 |     | <span class='unexecuted'>        if (pools.length != params.length) require(false, &#39;InputArrayLengthsMismatch()&#39;);</span>
 80 |     | <span class='unexecuted'>        for (uint i = 0; i &lt; pools.length;) {</span>
 81 |     | <span class='unexecuted'>            params[i].callbackData = abi.encode(SwapCallbackData({sender: msg.sender}));</span>
 82 |     | <span class='unexecuted'>            IPool(pools[i]).swap(params[i]);</span>
 83 |     | <span class='neutral'>            unchecked {</span>
 84 |     | <span class='unexecuted'>                ++i;</span>
 85 |     | <span class='neutral'>            }</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/RangePoolERC1155.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &quot;./RangePoolErrors.sol&quot;;</span>
   7 |     | <span class='neutral'>import &#39;../base/storage/RangePoolERC1155Immutables.sol&#39;;</span>
   8 |     | <span class='neutral'>import &quot;../interfaces/range/IRangePoolERC1155.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../libraries/range/Tokens.sol&quot;;</span>
  10 |     | <span class='neutral'>import &#39;../libraries/solady/LibClone.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// needs to be deployed as a separate clone</span>
  13 |     | <span class='neutral'>// poolImpls; tokenImpls</span>
  14 |     | <span class='neutral'>// store address in Immutables struct</span>
  15 |     | <span class='neutral'>// emit token address on created pool</span>
  16 |     | <span class='neutral'>// launch an ERC1155 template to track events on Subgraph</span>
  17 |     | <span class='neutral'>// emitting msg.sender will give the pool address</span>
  18 |     | <span class='neutral'>// can verify the owner is the pool address designated based on immutables</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract RangePoolERC1155 is</span>
  21 |     | <span class='neutral'>    IRangePoolERC1155,</span>
  22 |     | <span class='neutral'>    RangePoolERC1155Immutables,</span>
  23 |     | <span class='neutral'>    RangePoolERC1155Errors </span>
  24 |     | <span class='neutral'>{</span>
  25 |     | <span class='neutral'>    error OwnerOnly();</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    address public immutable factory;</span>
  28 |     | <span class='unexecuted'>    address public immutable original;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    constructor(</span>
  31 |     | <span class='neutral'>        address factory_</span>
  32 |     | <span class='neutral'>    ) {</span>
  33 |     | <span class='unexecuted'>        factory = factory_;</span>
  34 |     | <span class='unexecuted'>        original = address(this);</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /// @dev token id =&gt; owner =&gt; balance</span>
  38 |     | <span class='neutral'>    mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _tokenBalances;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @dev owner =&gt; spender =&gt; approved</span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _spenderApprovals;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /// @dev token id =&gt; total supply</span>
  44 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private _totalSupplyById;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    string private constant _NAME = &quot;Poolshark Range LP&quot;;</span>
  47 |     | <span class='neutral'>    string private constant _SYMBOL = &quot;PSHARK-RANGE-LP&quot;;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    modifier onlyCanonicalClones(</span>
  50 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  51 |     | <span class='neutral'>    ) {</span>
  52 |     | <span class='unexecuted'>        if(!_onlyCanonicalClones(constants)) require (false, &#39;CanoncialClonesOnly()&#39;);</span>
  53 |     | <span class='neutral'>        _;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    modifier checkApproval(address _from, address _spender) {</span>
  57 |     | <span class='unexecuted'>        if (!_isApprovedForAll(_from, _spender)) revert SpenderNotApproved(_from, _spender);</span>
  58 |     | <span class='unexecuted'>        _;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    modifier checkAddresses(address _from, address _to) {</span>
  62 |     | <span class='unexecuted'>        if (_from == address(0) || _to == address(0)) revert TransferFromOrToAddress0();</span>
  63 |     | <span class='unexecuted'>        if (_from == _to) revert TransferToSelf();</span>
  64 |     | <span class='unexecuted'>        _;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {</span>
  68 |     | <span class='unexecuted'>        if (_lengthA != _lengthB) revert LengthMismatch(_lengthA, _lengthB);</span>
  69 |     | <span class='unexecuted'>        _;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    modifier checkERC1155Support(address recipient) {</span>
  73 |     | <span class='unexecuted'>        if (!_verifyERC1155Support(recipient)) revert ERC1155NotSupported();</span>
  74 |     | <span class='neutral'>        _;</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    function mintFungible(</span>
  78 |     | <span class='neutral'>        address _account,</span>
  79 |     | <span class='neutral'>        uint256 _id,</span>
  80 |     | <span class='neutral'>        uint256 _amount,</span>
  81 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  82 |     | <span class='unexecuted'>    ) external onlyCanonicalClones(constants) {</span>
  83 |     | <span class='unexecuted'>        _mint(_account, _id, _amount);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>    function burnFungible(</span>
  87 |     | <span class='neutral'>        address _account,</span>
  88 |     | <span class='neutral'>        uint256 _id,</span>
  89 |     | <span class='neutral'>        uint256 _amount,</span>
  90 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  91 |     | <span class='unexecuted'>    ) external onlyCanonicalClones(constants) {</span>
  92 |     | <span class='unexecuted'>        _burn(_account, _id, _amount);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function setApprovalForAll(address _spender, bool _approved) public virtual override {</span>
  96 |     | <span class='unexecuted'>        _setApprovalForAll(msg.sender, _spender, _approved);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
 100 |     | <span class='neutral'>        address _from,</span>
 101 |     | <span class='neutral'>        address _to,</span>
 102 |     | <span class='neutral'>        uint256 _id,</span>
 103 |     | <span class='neutral'>        uint256 _amount</span>
 104 |     | <span class='neutral'>    ) public virtual override</span>
 105 |     | <span class='unexecuted'>        checkAddresses(_from, _to)</span>
 106 |     | <span class='unexecuted'>        checkApproval(_from, msg.sender)</span>
 107 |     | <span class='unexecuted'>        checkERC1155Support(_to)</span>
 108 |     | <span class='unexecuted'>    {</span>
 109 |     | <span class='unexecuted'>        address _spender = msg.sender;</span>
 110 |     | <span class='unexecuted'>        _transfer(_from, _to, _id, _amount);</span>
 111 |     | <span class='unexecuted'>        emit TransferSingle(_spender, _from, _to, _id, _amount);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function safeBatchTransferFrom(</span>
 115 |     | <span class='neutral'>        address _from,</span>
 116 |     | <span class='neutral'>        address _to,</span>
 117 |     | <span class='neutral'>        uint256[] calldata _ids,</span>
 118 |     | <span class='neutral'>        uint256[] calldata _amounts</span>
 119 |     | <span class='neutral'>    ) public virtual override</span>
 120 |     | <span class='unexecuted'>        checkLength(_ids.length, _amounts.length)</span>
 121 |     | <span class='unexecuted'>        checkAddresses(_from, _to)</span>
 122 |     | <span class='unexecuted'>        checkApproval(_from, msg.sender)</span>
 123 |     | <span class='unexecuted'>        checkERC1155Support(_to)</span>
 124 |     | <span class='neutral'>    {</span>
 125 |     | <span class='neutral'>        unchecked {</span>
 126 |     | <span class='unexecuted'>            for (uint256 i; i &lt; _ids.length; ++i) {</span>
 127 |     | <span class='unexecuted'>                _transfer(_from, _to, _ids[i], _amounts[i]);</span>
 128 |     | <span class='neutral'>            }</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='unexecuted'>        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {</span>
 134 |     | <span class='unexecuted'>        return _isApprovedForAll(_owner, _spender);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {</span>
 138 |     | <span class='unexecuted'>      return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support</span>
 139 |     | <span class='unexecuted'>              interfaceID == 0xd9b67a26;      // ERC-1155 support</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>    function name() public pure virtual override returns (string memory) {</span>
 143 |     | <span class='unexecuted'>        return _NAME;</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function symbol() public pure virtual override returns (string memory) {</span>
 147 |     | <span class='unexecuted'>        return _SYMBOL;</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='unexecuted'>    function totalSupply(uint256 _id) public view virtual override returns (uint256) {</span>
 151 |     | <span class='unexecuted'>        return _totalSupplyById[_id];</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {</span>
 155 |     | <span class='unexecuted'>        return _tokenBalances[_id][_account];</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='unexecuted'>    function balanceOfBatch(</span>
 159 |     | <span class='neutral'>        address[] calldata _accounts,</span>
 160 |     | <span class='neutral'>        uint256[] calldata _ids</span>
 161 |     | <span class='neutral'>    ) public view virtual override</span>
 162 |     | <span class='unexecuted'>        checkLength(_accounts.length, _ids.length)</span>
 163 |     | <span class='unexecuted'>        returns (uint256[] memory batchBalances)</span>
 164 |     | <span class='neutral'>    {</span>
 165 |     | <span class='unexecuted'>        batchBalances = new uint256[](_accounts.length);</span>
 166 |     | <span class='neutral'>        unchecked {</span>
 167 |     | <span class='unexecuted'>            for (uint256 i; i &lt; _accounts.length; ++i) {</span>
 168 |     | <span class='unexecuted'>                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='neutral'>    }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>    function _mint(</span>
 174 |     | <span class='neutral'>        address _account,</span>
 175 |     | <span class='neutral'>        uint256 _id,</span>
 176 |     | <span class='neutral'>        uint256 _amount</span>
 177 |     | <span class='unexecuted'>    ) internal virtual {</span>
 178 |     | <span class='unexecuted'>        if (_account == address(0)) revert MintToAddress0();</span>
 179 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), _account, _id, _amount);</span>
 180 |     | <span class='unexecuted'>        _totalSupplyById[_id] += _amount;</span>
 181 |     | <span class='unexecuted'>        uint256 _accountBalance = _tokenBalances[_id][_account];</span>
 182 |     | <span class='neutral'>        unchecked {</span>
 183 |     | <span class='unexecuted'>            _tokenBalances[_id][_account] = _accountBalance + _amount;</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='unexecuted'>        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>    function _burn(</span>
 189 |     | <span class='neutral'>        address _account,</span>
 190 |     | <span class='neutral'>        uint256 _id,</span>
 191 |     | <span class='neutral'>        uint256 _amount</span>
 192 |     | <span class='neutral'>    ) internal virtual {</span>
 193 |     | <span class='unexecuted'>        if (_account == address(0)) revert BurnFromAddress0();</span>
 194 |     | <span class='unexecuted'>        uint256 _accountBalance = _tokenBalances[_id][_account];</span>
 195 |     | <span class='unexecuted'>        if (_accountBalance &lt; _amount) revert BurnExceedsBalance(_account, _id, _amount);</span>
 196 |     | <span class='neutral'>        _beforeTokenTransfer(_account, address(0), _id, _amount);</span>
 197 |     | <span class='neutral'>        unchecked {</span>
 198 |     | <span class='unexecuted'>            _tokenBalances[_id][_account] = _accountBalance - _amount;</span>
 199 |     | <span class='unexecuted'>            _totalSupplyById[_id] -= _amount;</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='unexecuted'>        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function _transfer(</span>
 205 |     | <span class='neutral'>        address _from,</span>
 206 |     | <span class='neutral'>        address _to,</span>
 207 |     | <span class='neutral'>        uint256 _id,</span>
 208 |     | <span class='neutral'>        uint256 _amount</span>
 209 |     | <span class='neutral'>    ) internal virtual {</span>
 210 |     | <span class='unexecuted'>        uint256 _fromBalance = _tokenBalances[_id][_from];</span>
 211 |     | <span class='unexecuted'>        if (_fromBalance &lt; _amount) revert TransferExceedsBalance(_from, _id, _amount);</span>
 212 |     | <span class='neutral'>        _beforeTokenTransfer(_from, _to, _id, _amount);</span>
 213 |     | <span class='neutral'>        unchecked {</span>
 214 |     | <span class='unexecuted'>            _tokenBalances[_id][_from] = _fromBalance - _amount;</span>
 215 |     | <span class='neutral'>        }</span>
 216 |     | <span class='unexecuted'>        uint256 _toBalance = _tokenBalances[_id][_to];</span>
 217 |     | <span class='neutral'>        unchecked {</span>
 218 |     | <span class='unexecuted'>            _tokenBalances[_id][_to] = _toBalance + _amount;</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>    function _setApprovalForAll(</span>
 223 |     | <span class='neutral'>        address _owner,</span>
 224 |     | <span class='neutral'>        address _spender,</span>
 225 |     | <span class='neutral'>        bool _approved</span>
 226 |     | <span class='neutral'>    ) internal virtual {</span>
 227 |     | <span class='unexecuted'>        if (_owner == _spender) revert SelfApproval(_owner);</span>
 228 |     | <span class='unexecuted'>        _spenderApprovals[_owner][_spender] = _approved;</span>
 229 |     | <span class='unexecuted'>        emit ApprovalForAll(_owner, _spender, _approved);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {</span>
 233 |     | <span class='unexecuted'>        return _owner == _spender || _spenderApprovals[_owner][_spender];</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    /// @notice Hook that is called before any token transfer.</span>
 237 |     | <span class='unexecuted'>    function _beforeTokenTransfer(</span>
 238 |     | <span class='neutral'>        address from,</span>
 239 |     | <span class='neutral'>        address to,</span>
 240 |     | <span class='neutral'>        uint256 id,</span>
 241 |     | <span class='neutral'>        uint256 amount</span>
 242 |     | <span class='neutral'>    ) internal virtual {}</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    //TODO: check address(this) for valid poolToken clone</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>    function _onlyCanonicalClones(</span>
 247 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 248 |     | <span class='neutral'>    ) private view returns (bool) {</span>
 249 |     | <span class='neutral'>        // generate key for pool</span>
 250 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 251 |     | <span class='neutral'>            poolImpl(),</span>
 252 |     | <span class='unexecuted'>            constants.token0,</span>
 253 |     | <span class='unexecuted'>            constants.token1,</span>
 254 |     | <span class='unexecuted'>            constants.swapFee</span>
 255 |     | <span class='neutral'>        ));</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>        // compute address</span>
 258 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 259 |     | <span class='neutral'>            poolImpl(),</span>
 260 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 261 |     | <span class='unexecuted'>                constants.owner,</span>
 262 |     | <span class='unexecuted'>                constants.token0,</span>
 263 |     | <span class='unexecuted'>                constants.token1,</span>
 264 |     | <span class='unexecuted'>                constants.poolToken,</span>
 265 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 266 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 267 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 268 |     | <span class='unexecuted'>                constants.swapFee</span>
 269 |     | <span class='neutral'>            ),</span>
 270 |     | <span class='unexecuted'>            key,</span>
 271 |     | <span class='unexecuted'>            factory</span>
 272 |     | <span class='neutral'>        );</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        if (predictedAddress != msg.sender) return false;</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        return true;</span>
 277 |     | <span class='neutral'>    }</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>    /// @notice Return if the `_target` contract supports ERC-1155 interface</span>
 280 |     | <span class='neutral'>    /// @param _target The address of the contract</span>
 281 |     | <span class='neutral'>    /// @return supported Whether the contract is supported (true) or not (false)</span>
 282 |     | <span class='unexecuted'>    function _verifyERC1155Support(address _target) private view returns (bool supported) {</span>
 283 |     | <span class='unexecuted'>        if (_target.code.length == 0) return true;</span>
 284 |     | <span class='unexecuted'>        bytes memory encodedParams = abi.encodeWithSelector(</span>
 285 |     | <span class='neutral'>            IERC165.supportsInterface.selector,</span>
 286 |     | <span class='neutral'>            type(IRangePoolERC1155).interfaceId</span>
 287 |     | <span class='neutral'>        );</span>
 288 |     | <span class='unexecuted'>        (bool success, bytes memory result) = _target.staticcall{gas: 30_000}(encodedParams);</span>
 289 |     | <span class='unexecuted'>        if (result.length &lt; 32) return false;</span>
 290 |     | <span class='unexecuted'>        return success &amp;&amp; abi.decode(result, (bool));</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/RangePoolErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract RangePoolErrors {</span>
  5 |     | <span class='neutral'>    error Locked();</span>
  6 |     | <span class='neutral'>    error ManagerOnly();</span>
  7 |     | <span class='neutral'>}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract RangePoolERC1155Errors {</span>
 10 |     | <span class='neutral'>    error SpenderNotApproved(address owner, address spender);</span>
 11 |     | <span class='neutral'>    error TransferFromOrToAddress0();</span>
 12 |     | <span class='neutral'>    error MintToAddress0();</span>
 13 |     | <span class='neutral'>    error BurnFromAddress0();</span>
 14 |     | <span class='neutral'>    error BurnExceedsBalance(address from, uint256 id, uint256 amount);</span>
 15 |     | <span class='neutral'>    error LengthMismatch(uint256 accountsLength, uint256 idsLength);</span>
 16 |     | <span class='neutral'>    error SelfApproval(address owner);</span>
 17 |     | <span class='neutral'>    error TransferExceedsBalance(address from, uint256 id, uint256 amount);</span>
 18 |     | <span class='neutral'>    error TransferToSelf();</span>
 19 |     | <span class='neutral'>    error ERC1155NotSupported();</span>
 20 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/RebaseLibrary.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>struct Rebase {</span>
  5 |     | <span class='neutral'>    uint128 elastic;</span>
  6 |     | <span class='neutral'>    uint128 base;</span>
  7 |     | <span class='neutral'>}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @notice A rebasing library</span>
 10 |     | <span class='neutral'>abstract contract RebaseLibrary {</span>
 11 |     | <span class='neutral'>    /// @notice Calculates the base value in relationship to `elastic` and `total`.</span>
 12 |     | <span class='neutral'>    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {</span>
 13 |     | <span class='neutral'>        if (total.elastic == 0) {</span>
 14 |     | <span class='neutral'>            base = elastic;</span>
 15 |     | <span class='neutral'>        } else {</span>
 16 |     | <span class='neutral'>            base = (elastic * total.base) / total.elastic;</span>
 17 |     | <span class='neutral'>        }</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Calculates the elastic value in relationship to `base` and `total`.</span>
 21 |     | <span class='neutral'>    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {</span>
 22 |     | <span class='neutral'>        if (total.base == 0) {</span>
 23 |     | <span class='neutral'>            elastic = base;</span>
 24 |     | <span class='neutral'>        } else {</span>
 25 |     | <span class='neutral'>            elastic = (base * total.elastic) / total.base;</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

