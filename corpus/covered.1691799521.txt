/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 | *   |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 | *   |     function _burn(address account, uint256 amount) internal virtual {
 278 |     |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 |     |         uint256 accountBalance = _balances[account];
 283 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 |     |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 |     |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 |     |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 |     |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 | *   |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC20.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys `amount` tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 amount) public virtual {
 21 |     |         _burn(_msgSender(), amount);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys `amount` tokens from `account`, deducting from the caller's
 26 |     |      * allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `amount`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 amount) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), amount);
 37 |     |         _burn(account, amount);
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/EchidnaPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | // import './interfaces/ILimitPool.sol';
   5 |     | // import './interfaces/ILimitPoolManager.sol';
   6 |     | // import './interfaces/ILimitPoolStructs.sol';
   7 |     | // import './base/storage/LimitPoolStorage.sol';
   8 |     | import './LimitPool.sol';
   9 |     | import './LimitPoolFactory.sol';
  10 |     | import './utils/LimitPoolManager.sol';
  11 |     | import './test/Token20.sol';
  12 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
  13 |     | import './libraries/utils/SafeTransfers.sol';
  14 |     | 
  15 |     | 
  16 |     | // Fuzz LimitPool functionality
  17 | *r  | contract EchidnaPool {
  18 |     | 
  19 |     |     event Address(address a);
  20 |     |     event Price(uint160 price);
  21 |     |     event Prices(uint160 price0, uint160 price1);
  22 |     |     event LiquidityGlobal(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);
  23 |     |     event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);
  24 |     |     event LiquidityDelta(int128 liqLowerBefore, int128 liqUpperBefore, int128 liqLowerAfter, int128 liqUperAfter);
  25 |     |     event Amount(uint256 amt);
  26 |     |     event PassedMint();
  27 |     |     event PassedBurn();
  28 |     |     event PositionTicks(int24 lower, int24 upper);
  29 |     |     event BurnTicks(int24 lower, int24 upper, bool positionExists);
  30 |     |     event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);
  31 |     |     event PositionCreated(bool isCreated);
  32 |     |     event liquidityDeltaAfterUndercut(bool zeroForOne, int128 liquidityDeltaBefore, int128 liquidityDeltaAfter);
  33 |     |     event AssertFailTest(string message, uint160 priceAfter, uint160 priceBefore);
  34 |     |     
  35 |     |     LimitPoolFactory private factory;
  36 |     |     address private implementation;
  37 |     |     LimitPoolManager private manager;
  38 |     |     LimitPool private pool;
  39 |     |     Token20 private tokenIn;
  40 |     |     Token20 private tokenOut;
  41 |     |     Position[] private positions;
  42 |     |     int16 tickSpacing;
  43 |     | 
  44 |     |     struct LiquidityDeltaValues {
  45 |     |         int128 liquidityDeltaLowerBefore;
  46 |     |         int128 liquidityDeltaUpperBefore;
  47 |     |         int128 liquidityDeltaLowerAfter;
  48 |     |         int128 liquidityDeltaUpperAfter;
  49 |     |     }
  50 |     | 
  51 |     |     struct PoolValues {
  52 |     |         uint160 price0Before;
  53 |     |         uint128 liquidity0Before;
  54 |     |         uint128 liquidityGlobal0Before;
  55 |     |         uint160 price1Before;
  56 |     |         uint128 liquidity1Before;
  57 |     |         uint128 liquidityGlobal1Before;
  58 |     |         uint160 price0After;
  59 |     |         uint128 liquidity0After;
  60 |     |         uint128 liquidityGlobal0After;
  61 |     |         uint160 price1After;
  62 |     |         uint128 liquidity1After;
  63 |     |         uint128 liquidityGlobal1After;
  64 |     |         
  65 |     |         uint160 priceAt0LowerBefore;
  66 |     |         uint160 priceAt0UpperBefore;
  67 |     |         uint160 priceAt0LowerAfter;
  68 |     |         uint160 priceAt0UpperAfter;
  69 |     |         uint160 priceAt1LowerBefore;
  70 |     |         uint160 priceAt1UpperBefore;
  71 |     |         uint160 priceAt1LowerAfter;
  72 |     |         uint160 priceAt1UpperAfter;
  73 |     | 
  74 |     |         int128 liquidityDeltaAtPrice0Before;
  75 |     |         int128 liquidityDeltaAtPrice1Before;
  76 |     | 
  77 |     |         int128 liquidityDeltaAtPrice0After;
  78 |     |         int128 liquidityDeltaAtPrice1After;
  79 |     |     }
  80 |     | 
  81 |     |     struct SwapCallbackData {
  82 |     |         address sender;
  83 |     |     }
  84 |     | 
  85 |     |     struct Position {
  86 |     |         address owner;
  87 |     |         int24 lower;
  88 |     |         int24 upper;
  89 |     |         bool zeroForOne;
  90 |     |     }
  91 |     | 
  92 |     |     modifier tickPreconditions(int24 lower, int24 upper) {
  93 | *r  |         require(lower < upper);
  94 | *r  |         require(upper < 887272);
  95 | *r  |         require(lower > -887272);
  96 | *r  |         require(lower % tickSpacing == 0);
  97 | *r  |         require(upper % tickSpacing == 0);
  98 |     |         _;
  99 |     |     }
 100 |     | 
 101 |     |     constructor() {
 102 |     |         manager = new LimitPoolManager();
 103 |     |         factory = new LimitPoolFactory(address(manager));
 104 |     |         implementation = address(new LimitPool(address(factory)));
 105 |     |         manager.enableImplementation(bytes32(0x0), address(implementation));
 106 |     |         tickSpacing = 10;
 107 |     |         tokenIn = new Token20("IN", "IN", 18);
 108 |     |         tokenOut = new Token20("OUT", "OUT", 18);
 109 |     |         pool =  LimitPool(factory.createLimitPool(bytes32(0x0), address(tokenIn), address(tokenOut), tickSpacing, 79228162514264337593543950336));
 110 |     |     }
 111 |     | 
 112 |     | 
 113 | *   |     function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 114 |     |         // PRE CONDITIONS
 115 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 116 | *   |         mintAndApprove();
 117 | *   |         amount = amount + 1;
 118 |     |         PoolValues memory poolValues;
 119 | *   |         (poolValues.price0Before, poolValues.liquidity0Before, poolValues.liquidityGlobal0Before,,,,) = pool.pool0();
 120 | *   |         (poolValues.price1Before, poolValues.liquidity1Before, poolValues.liquidityGlobal1Before,,,,) = pool.pool1();
 121 |     |         
 122 | *   |         int24 tickAtPrice0Before = ConstantProduct.getTickAtPrice(poolValues.price0Before, pool.immutables());
 123 | *   |         int24 tickAtPrice1Before = ConstantProduct.getTickAtPrice(poolValues.price1Before, pool.immutables());
 124 |     | 
 125 |     | 
 126 |     |         ILimitPoolStructs.MintParams memory params;
 127 | *   |         params.to = msg.sender;
 128 | *   |         params.refundTo = msg.sender;
 129 | *   |         params.amount = amount;
 130 |     |         params.mintPercent = 0;
 131 | *   |         params.lower = lower;
 132 | *   |         params.upper = upper;
 133 | *   |         params.zeroForOne = zeroForOne;
 134 |     | 
 135 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
 136 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
 137 |     |         bool posCreated;
 138 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
 139 | *   |         emit PositionTicks(lower, upper);
 140 | *   |         emit PositionCreated(posCreated);
 141 |     | 
 142 |     |         LiquidityDeltaValues memory values;
 143 |     |         // pool.liquidity0 == sum(liquidityDelta(all ticks for pool 0))
 144 | *   |         if (zeroForOne) {
 145 | *   |             (,poolValues.liquidityDeltaAtPrice0Before) = pool.ticks0(tickAtPrice0Before);
 146 | *   |             (,poolValues.liquidityDeltaAtPrice1Before) = pool.ticks0(tickAtPrice1Before);
 147 |     | 
 148 | *   |             (poolValues.priceAt0LowerBefore, values.liquidityDeltaLowerBefore) = pool.ticks0(lower);
 149 | *   |             (poolValues.priceAt0UpperBefore, values.liquidityDeltaUpperBefore) = pool.ticks0(upper);
 150 |     |         }
 151 |     |         else {
 152 | *   |             (poolValues.priceAt1LowerBefore, values.liquidityDeltaLowerBefore) = pool.ticks1(lower);
 153 | *   |             (poolValues.priceAt1UpperBefore, values.liquidityDeltaUpperBefore) = pool.ticks1(upper);
 154 |     |         }
 155 |     | 
 156 |     |         // ACTION 
 157 | *r  |         pool.mint(params);
 158 | *   |         if (posCreated) positions.push(Position(msg.sender, lower, upper, zeroForOne));
 159 |     | 
 160 | *   |         (poolValues.price0After, poolValues.liquidity0After, poolValues.liquidityGlobal0After,,,,) = pool.pool0();
 161 | *   |         (poolValues.price1After, poolValues.liquidity1After, poolValues.liquidityGlobal1After,,,,) = pool.pool1();
 162 |     | 
 163 | *   |         if (zeroForOne) {
 164 | *   |             (,values.liquidityDeltaLowerAfter) = pool.ticks0(lower);
 165 | *   |             (,values.liquidityDeltaUpperAfter) = pool.ticks0(upper);
 166 |     |         }
 167 |     |         else {
 168 | *   |             (,values.liquidityDeltaLowerAfter) = pool.ticks1(lower);
 169 | *   |             (,values.liquidityDeltaUpperAfter) = pool.ticks1(upper);
 170 |     |         }
 171 |     | 
 172 | *   |         emit Prices(poolValues.price0After, poolValues.price1After);
 173 |     | 
 174 |     |         // POST CONDITIONS
 175 |     | 
 176 |     |         // Ensure that liquidity delta is incremented when undercutting
 177 | *   |         if(zeroForOne){
 178 | *   |             if(poolValues.price0After <= poolValues.price0Before){
 179 | *   |                 emit liquidityDeltaAfterUndercut(zeroForOne, values.liquidityDeltaLowerBefore, values.liquidityDeltaLowerAfter);
 180 | *   |                 assert(values.liquidityDeltaLowerAfter >= values.liquidityDeltaLowerBefore);
 181 |     |             }
 182 |     |         } else {
 183 | *   |             if(poolValues.price1Before <= poolValues.price1After){
 184 | *   |                 emit liquidityDeltaAfterUndercut(zeroForOne, values.liquidityDeltaUpperBefore, values.liquidityDeltaUpperAfter);
 185 | *   |                 assert(values.liquidityDeltaUpperAfter >= values.liquidityDeltaUpperBefore);
 186 |     |             }
 187 |     |         }
 188 |     | 
 189 |     |         // Ensure prices have not crossed
 190 | *   |         assert(poolValues.price0After >= poolValues.price1After);
 191 | *   |         if (posCreated) {
 192 |     |             // Ensure positions ticks arent crossed
 193 | *   |             assert(lower < upper);
 194 |     |             // Ensure minted ticks on proper tick spacing
 195 | *   |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 196 |     |         }
 197 |     |         
 198 |     |         
 199 | *   |         emit LiquidityGlobal(poolValues.liquidityGlobal0Before, poolValues.liquidityGlobal1Before, poolValues.liquidityGlobal0After, poolValues.liquidityGlobal1After);
 200 | *   |         emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);
 201 | *   |         emit LiquidityDelta(values.liquidityDeltaLowerBefore, values.liquidityDeltaUpperBefore, values.liquidityDeltaLowerAfter, values.liquidityDeltaUpperAfter);
 202 |     | 
 203 | *   |         if (zeroForOne) {
 204 |     |             // Ensure liquidity does not decrease on mint
 205 | *   |             assert(poolValues.liquidityGlobal0After >= poolValues.liquidityGlobal0Before);
 206 |     |             // Ensure pool.liquity is incremented when undercutting
 207 | *   |             if (poolValues.price0After < poolValues.price0Before) {
 208 | *   |                 emit AssertFailTest("poolValues.price0After < poolValues.price0Before", poolValues.price0After, poolValues.price0Before);
 209 | *   |                 assert(poolValues.liquidity0After > 0);
 210 |     |             }
 211 |     | 
 212 |     |             // Doesn't hold due to insertSingle stashing pool liquidity on tick to save
 213 |     |             // if (posCreated) {
 214 |     |             //     assert(values.liquidityDeltaLowerAfter >= values.liquidityDeltaLowerBefore);
 215 |     |             //     assert(values.liquidityDeltaUpperAfter <= values.liquidityDeltaUpperBefore);
 216 |     |             // }
 217 |     |         }
 218 |     |         else {
 219 |     |             // Ensure liquidity does not decrease on mint
 220 | *   |             assert(poolValues.liquidityGlobal1After >= poolValues.liquidityGlobal1Before);
 221 |     |             // Ensure pool.liquity is incremented when undercutting
 222 | *   |             if (poolValues.price1After > poolValues.price1Before) {
 223 | *   |                 emit AssertFailTest("poolValues.price1After > poolValues.price1Before", poolValues.price1After, poolValues.price1Before);
 224 | *   |                 assert(poolValues.liquidity1After > 0);
 225 |     |             }
 226 |     | 
 227 |     |             // if (posCreated) {
 228 |     |             //     assert(values.liquidityDeltaUpperAfter >= values.liquidityDeltaUpperBefore);
 229 |     |             //     assert(values.liquidityDeltaLowerAfter <= values.liquidityDeltaLowerBefore);
 230 |     |             // }
 231 |     |             
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 | *   |     function swap(uint160 priceLimit, uint128 amount, bool exactIn, bool zeroForOne) public {
 236 |     |         // PRE CONDITIONS
 237 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 238 | *   |         mintAndApprove();
 239 |     | 
 240 |     |         // ACTION
 241 |     |         ILimitPoolStructs.SwapParams memory params;
 242 | *   |         params.to = msg.sender;
 243 | *   |         params.priceLimit = priceLimit;
 244 | *   |         params.amount = amount;
 245 | *   |         params.exactIn = exactIn;
 246 | *   |         params.zeroForOne = zeroForOne;
 247 | *   |         params.callbackData = abi.encodePacked(address(this));
 248 |     | 
 249 | *r  |         pool.swap(params);
 250 |     | 
 251 |     |         // POST CONDITIONS
 252 | *   |         (uint160 price0,,,,,,) = pool.pool0();
 253 | *   |         (uint160 price1,,,,,,) = pool.pool1();
 254 | *   |         emit Prices(price0, price1);
 255 | *   |         assert(price0 >= price1);
 256 |     |     }
 257 |     | 
 258 | *   |     function burn(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {
 259 |     |         // PRE CONDITIONS 
 260 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 261 | *   |         positionIndex = positionIndex % positions.length;
 262 | *   |         Position memory pos = positions[positionIndex];
 263 | *   |         claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));
 264 | *r  |         require(claimAt % tickSpacing == 0);
 265 |     | 
 266 | *   |         (,/*liquidity*/,uint128 liquidityGlobal0Before,,,,) = pool.pool0();
 267 | *   |         (,/*liquidity*/,uint128 liquidityGlobal1Before,,,,) = pool.pool1();
 268 |     | 
 269 | *   |         ILimitPoolStructs.BurnParams memory params;
 270 | *   |         params.to = pos.owner;
 271 |     |         // TODO: allow for variable burn percentages
 272 | *   |         params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;
 273 | *   |         params.lower = pos.lower;
 274 | *   |         params.claim = claimAt;
 275 | *   |         params.upper = pos.upper;
 276 | *   |         params.zeroForOne = pos.zeroForOne;
 277 |     |         
 278 | *   |         emit PositionTicks(pos.lower, pos.upper);
 279 | *   |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
 280 | *   |         emit BurnTicks(lower, upper, positionExists);
 281 |     | 
 282 |     |         // ACTION
 283 | *r  |         pool.burn(params);
 284 | *   |         if (!positionExists) {
 285 | *   |             positions[positionIndex] = positions[positions.length - 1];
 286 | *   |             delete positions[positions.length - 1];
 287 |     |         }
 288 |     |         else {
 289 |     |             // Update position data in array if not fully burned
 290 | *   |             positions[positionIndex] = Position(pos.owner, lower, upper, pos.zeroForOne);
 291 |     |             // Ensure positions ticks arent crossed
 292 | *   |             assert(lower < upper);
 293 |     |             // Ensure minted ticks on proper tick spacing
 294 | *   |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 295 |     |         }
 296 |     | 
 297 |     |         // POST CONDITIONS
 298 | *   |         (uint160 price0,/*liquidity*/,uint128 liquidityGlobal0After,,,,) = pool.pool0();
 299 | *   |         (uint160 price1,/*liquidity*/,uint128 liquidityGlobal1After,,,,) = pool.pool1();
 300 | *   |         emit Prices(price0, price1);
 301 | *   |         assert(price0 >= price1);
 302 |     | 
 303 | *   |         if(pos.zeroForOne) {
 304 | *   |             emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);
 305 | *   |             assert((liquidityGlobal0After < liquidityGlobal0Before));
 306 |     |         }
 307 |     |         else {
 308 | *   |             emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);
 309 | *   |             assert((liquidityGlobal1After < liquidityGlobal1Before));
 310 |     |         }
 311 |     |     }
 312 |     | 
 313 | *   |     function claim(int24 claimAt, uint256 positionIndex) public {
 314 |     |         // PRE CONDITIONS
 315 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 316 | *   |         positionIndex = positionIndex % positions.length;
 317 | *   |         Position memory pos = positions[positionIndex];
 318 | *   |         claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));
 319 | *r  |         require(claimAt % tickSpacing == 0);
 320 |     | 
 321 | *   |         (,/*liquidity*/,uint128 liquidityGlobal0Before,,,,) = pool.pool0();
 322 | *   |         (,/*liquidity*/,uint128 liquidityGlobal1Before,,,,) = pool.pool1();
 323 |     | 
 324 | *   |         ILimitPoolStructs.BurnParams memory params;
 325 | *   |         params.to = pos.owner;
 326 |     |         // TODO: allow for variable burn percentages
 327 | *   |         params.burnPercent = 0;
 328 | *   |         params.lower = pos.lower;
 329 | *   |         params.claim = claimAt;
 330 | *   |         params.upper = pos.upper;
 331 | *   |         params.zeroForOne = pos.zeroForOne;
 332 |     |         
 333 | *   |         emit PositionTicks(pos.lower, pos.upper);
 334 | *   |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
 335 | *   |         emit BurnTicks(lower, upper, positionExists);
 336 |     | 
 337 |     |         // ACTION
 338 | *r  |         pool.burn(params);
 339 | *   |         if (!positionExists) {
 340 | *   |             positions[positionIndex] = positions[positions.length - 1];
 341 | *   |             delete positions[positions.length - 1];
 342 |     |         }
 343 |     |         else {
 344 |     |             // Update position data in array if not fully burned
 345 | *   |             positions[positionIndex] = Position(pos.owner, lower, upper, pos.zeroForOne);
 346 |     |             // Ensure positions ticks arent crossed
 347 | *   |             assert(lower < upper);
 348 |     |             // Ensure minted ticks on proper tick spacing
 349 | *   |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
 350 |     |         }
 351 |     | 
 352 |     |         // POST CONDITIONS
 353 | *   |         (uint160 price0,/*liquidity*/,uint128 liquidityGlobal0After,,,,) = pool.pool0();
 354 | *   |         (uint160 price1,/*liquidity*/,uint128 liquidityGlobal1After,,,,) = pool.pool1();
 355 | *   |         emit Prices(price0, price1);
 356 | *   |         assert(price0 >= price1);
 357 |     | 
 358 |     |         // if(pos.zeroForOne) {
 359 |     |         //     emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);
 360 |     |         //     if (positionExists) {
 361 |     |         //         assert((liquidityGlobal0After == liquidityGlobal0Before));
 362 |     |         //     }
 363 |     |         // }
 364 |     |         // else {
 365 |     |         //     emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);
 366 |     |         //     if (positionExists) {
 367 |     |         //         assert((liquidityGlobal1After == liquidityGlobal1Before));
 368 |     |         //     }
 369 |     |         // }
 370 |     |     }
 371 |     | 
 372 | *   |     function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
 373 |     |         // PRE CONDITIONS
 374 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 375 | *   |         mintAndApprove();
 376 | *   |         (uint160 price0Before,/*liquidity*/,uint128 liquidityGlobal0Before,,,,) = pool.pool0();
 377 | *   |         (uint160 price1Before,/*liquidity*/,uint128 liquidityGlobal1Before,,,,) = pool.pool1();
 378 |     | 
 379 |     |         // ACTION 
 380 | *   |         mint(amount, zeroForOne, lower, upper);
 381 | *   |         emit PassedMint();
 382 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 383 | *   |         emit PassedBurn();
 384 |     | 
 385 |     |         // POST CONDITIONS
 386 | *   |         (uint160 price0After,/*liquidity*/,uint128 liquidityGlobal0After,,,,) = pool.pool0();
 387 | *   |         (uint160 price1After,/*liquidity*/,uint128 liquidityGlobal1After,,,,) = pool.pool1();
 388 | *   |         emit Prices(price0After, price1After);
 389 | *   |         assert(price0After >= price1After);
 390 | *   |         emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);
 391 | *   |         assert((liquidityGlobal0After == liquidityGlobal0Before) && (liquidityGlobal1After == liquidityGlobal1Before));
 392 |     |     }
 393 |     | 
 394 | *   |     function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
 395 |     |         // PRE CONDITIONS
 396 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 397 | *   |         percent = 1 + (percent % (1e38 - 1));
 398 | *   |         mintAndApprove();
 399 | *   |         (uint160 price0Before,/*liquidity*/,uint128 liquidityGlobal0Before,,,,) = pool.pool0();
 400 | *   |         (uint160 price1Before,/*liquidity*/,uint128 liquidityGlobal1Before,,,,) = pool.pool1();
 401 |     | 
 402 |     |         // ACTION 
 403 | *   |         mint(amount, zeroForOne, lower, upper);
 404 | *   |         emit PassedMint();
 405 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, percent);
 406 | *   |         emit PassedBurn();
 407 | *   |         burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);
 408 | *   |         emit PassedBurn();
 409 |     | 
 410 |     |         // POST CONDITIONS
 411 | *   |         (uint160 price0After,/*liquidity*/,uint128 liquidityGlobal0After,,,,) = pool.pool0();
 412 | *   |         (uint160 price1After,/*liquidity*/,uint128 liquidityGlobal1After,,,,) = pool.pool1();
 413 | *   |         emit Prices(price0After, price1After);
 414 | *   |         assert(price0After >= price1After);
 415 | *   |         emit LiquidityGlobal(liquidityGlobal0Before, liquidityGlobal1Before, liquidityGlobal0After, liquidityGlobal1After);
 416 | *   |         assert((liquidityGlobal0After == liquidityGlobal0Before) && (liquidityGlobal1After == liquidityGlobal1Before));
 417 |     |     }
 418 |     | 
 419 | *   |     function poolsharkSwapCallback(
 420 |     |         int256 amount0Delta,
 421 |     |         int256 amount1Delta,
 422 |     |         bytes calldata data
 423 | *   |     ) external {
 424 | *   |         address token0 = LimitPool(pool).token0();
 425 | *   |         address token1 = LimitPool(pool).token1();
 426 |     |         // SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));
 427 | *   |         if (amount0Delta < 0) {
 428 | *   |             SafeTransfers.transferInto(token0, address(pool), uint256(-amount0Delta));
 429 |     |         } else {
 430 | *   |             SafeTransfers.transferInto(token1, address(pool), uint256(-amount1Delta));
 431 |     |         }
 432 |     |     }
 433 |     | 
 434 | *   |     function mintAndApprove() internal {
 435 |     |         // TODO: can make token mints to be in between some range
 436 | *   |         tokenIn.mint(msg.sender, 100000000000 ether);
 437 | *   |         tokenOut.mint(msg.sender, 100000000000 ether);
 438 | *   |         tokenIn.mint(address(this), 100000000000 ether);
 439 | *   |         tokenOut.mint(address(this), 100000000000 ether);
 440 | *   |         tokenIn.approve(address(pool), type(uint256).max);
 441 | *   |         tokenOut.approve(address(pool), type(uint256).max);
 442 |     |     }
 443 |     | 
 444 | *   |     function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {
 445 | *   |         return uint128(low + (val % (high-low +1))); 
 446 |     |     }
 447 |     | 
 448 |     |     function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {
 449 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 450 |     |         amount = amount + 1e5 + 1;
 451 |     |         ILimitPoolStructs.Immutables memory immutables = pool.immutables();
 452 |     |         uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);
 453 |     |         uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);
 454 |     | 
 455 |     |         uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(
 456 |     |             priceLower,
 457 |     |             priceUpper,
 458 |     |             zeroForOne ? priceLower : priceUpper,
 459 |     |             zeroForOne ? 0 : uint256(amount),
 460 |     |             zeroForOne ? uint256(amount) : 0
 461 |     |         );
 462 |     | 
 463 |     |         (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(
 464 |     |             priceLower,
 465 |     |             priceUpper,
 466 |     |             zeroForOne ? priceLower : priceUpper,
 467 |     |             liquidityMinted,
 468 |     |             true
 469 |     |         );
 470 |     | 
 471 |     |         if(zeroForOne) {
 472 |     |             emit LiquidityMinted(amount, token0Amount, zeroForOne);
 473 |     |             assert(isEqualWithinPercentage(amount, token0Amount, 100));
 474 |     |             
 475 |     |         }
 476 |     |         else {
 477 |     |             emit LiquidityMinted(amount, token1Amount, zeroForOne);
 478 |     |             assert(isEqualWithinPercentage(amount, token1Amount, 100));
 479 |     |         }
 480 |     | 
 481 |     |     }
 482 |     | 
 483 |     |     function isEqualWithinPercentage(uint256 a, uint256 b, uint256 percentage) internal pure returns (bool) {
 484 |     |         uint256 diff = a > b ? a - b : b - a;
 485 |     |         uint256 maxDiff = a * percentage / 10000; // basis points 
 486 |     | 
 487 |     |         return diff <= maxDiff;
 488 |     | }
 489 |     |    
 490 |     | 
 491 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/EchidnaTickMap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | 
  5 |     | import './LimitPool.sol';
  6 |     | import './LimitPoolFactory.sol';
  7 |     | import './utils/LimitPoolManager.sol';
  8 |     | import './test/Token20.sol';
  9 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
 10 |     | import './libraries/utils/SafeTransfers.sol';
 11 |     | import './libraries/math/ConstantProduct.sol';
 12 |     | 
 13 |     | 
 14 |     | // Fuzz TickMap functionality
 15 |     | contract EchidnaTickMap {
 16 |     | 
 17 |     |     event TickResult(int24 inputTick, int24 outputTick);
 18 |     | 
 19 |     |     ILimitPoolStructs.TickMap public tickMap;
 20 |     |     int16 tickSpacing;
 21 |     | 
 22 |     |      constructor() {
 23 |     |         tickSpacing = 10;
 24 |     |         TickMap.set(tickMap, ConstantProduct.minTick(tickSpacing), tickSpacing);
 25 |     |         TickMap.set(tickMap, ConstantProduct.maxTick(tickSpacing), tickSpacing);
 26 |     | 
 27 |     |     }
 28 |     | 
 29 |     |     function setTickTwice(int24 tick) public {
 30 |     |         require(tick > ConstantProduct.minTick(tickSpacing));
 31 |     |         require(tick < ConstantProduct.maxTick(tickSpacing));
 32 |     |         TickMap.set(tickMap, tick, tickSpacing);
 33 |     |         TickMap.set(tickMap, tick, tickSpacing);
 34 |     |         bool exists = TickMap.get(tickMap, tick, tickSpacing);
 35 |     |         assert(exists);
 36 |     |     }
 37 |     | 
 38 |     |     function setThenUnsets(int24 tick) public {
 39 |     |         require(tick > ConstantProduct.minTick(tickSpacing));
 40 |     |         require(tick < ConstantProduct.maxTick(tickSpacing));
 41 |     |         TickMap.set(tickMap, tick, tickSpacing);
 42 |     |         TickMap.unset(tickMap, tick, tickSpacing);
 43 |     |         bool exists = TickMap.get(tickMap, tick, tickSpacing);
 44 |     |         assert(!exists);
 45 |     |     }
 46 |     | 
 47 |     |     function setTick(int24 tick) public {
 48 |     |         require(tick > ConstantProduct.minTick(tickSpacing));
 49 |     |         require(tick < ConstantProduct.maxTick(tickSpacing));
 50 |     |         TickMap.set(tickMap, tick, tickSpacing);
 51 |     |         bool exists = TickMap.get(tickMap, tick, tickSpacing);
 52 |     |         assert(exists);
 53 |     |     }
 54 |     | 
 55 |     |     function unsetTick(int24 tick) public {
 56 |     |         require(tick > ConstantProduct.minTick(tickSpacing));
 57 |     |         require(tick < ConstantProduct.maxTick(tickSpacing));
 58 |     |         TickMap.unset(tickMap, tick, tickSpacing);
 59 |     |         bool exists = TickMap.get(tickMap, tick, tickSpacing);
 60 |     |         assert(!exists);
 61 |     |     }
 62 |     | 
 63 |     |     function next(int24 tick, bool inclusive) public {
 64 |     |         require(tick % tickSpacing == 0);
 65 |     |         require(tick % (tickSpacing/2) == 0);
 66 |     |         int24 nextTick = TickMap.next(tickMap, tick, tickSpacing, inclusive);
 67 |     |         emit TickResult(tick, nextTick);
 68 |     |         // if (inclusive) {
 69 |     |         //     bool exists = TickMap.get(tickMap, tick, tickSpacing);
 70 |     |         //     if (exists) assert(tick == nextTick);
 71 |     |         // }
 72 |     |         assert(nextTick >= tick);
 73 |     |     
 74 |     |     }
 75 |     | 
 76 |     |     function previous(int24 tick, bool inclusive) public {
 77 |     |         require(tick % tickSpacing == 0);
 78 |     |         require(tick % (tickSpacing/2) == 0);
 79 |     |         int24 previousTick = TickMap.previous(tickMap, tick, tickSpacing, inclusive);
 80 |     |         emit TickResult(tick, previousTick);
 81 |     |         if (inclusive) {
 82 |     |             bool exists = TickMap.get(tickMap, tick, tickSpacing);
 83 |     |             if (exists) assert(tick == previousTick);
 84 |     |         }
 85 |     |         assert(previousTick <= tick);
 86 |     |     }
 87 |     | 
 88 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/LimitPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './interfaces/ILimitPool.sol';
   5 |     | import './interfaces/ILimitPoolManager.sol';
   6 |     | import './base/storage/LimitPoolStorage.sol';
   7 |     | import './base/storage/LimitPoolImmutables.sol';
   8 |     | import './base/structs/LimitPoolFactoryStructs.sol';
   9 |     | import './utils/LimitPoolErrors.sol';
  10 |     | import './libraries/pool/SwapCall.sol';
  11 |     | import './libraries/pool/QuoteCall.sol';
  12 |     | import './libraries/pool/MintCall.sol';
  13 |     | import './libraries/pool/BurnCall.sol';
  14 |     | import './libraries/math/ConstantProduct.sol';
  15 |     | import './libraries/solady/LibClone.sol';
  16 |     | import './external/openzeppelin/security/ReentrancyGuard.sol';
  17 |     | 
  18 |     | 
  19 |     | /// @notice Poolshark Cover Pool Implementation
  20 | *   | contract LimitPool is
  21 |     |     ILimitPool,
  22 |     |     LimitPoolStorage,
  23 |     |     LimitPoolImmutables,
  24 |     |     LimitPoolFactoryStructs,
  25 |     |     ReentrancyGuard
  26 |     | {
  27 |     |     event SimulateMint(bytes b);
  28 |     |     event SimulateMint(bytes4 b);
  29 |     |     event SimulateMint(bool b);
  30 |     | 
  31 |     |     modifier ownerOnly() {
  32 |     |         _onlyOwner();
  33 |     |         _;
  34 |     |     }
  35 |     | 
  36 |     |     modifier factoryOnly() {
  37 |     |         _onlyFactory();
  38 |     |         _;
  39 |     |     }
  40 |     | 
  41 |     |     modifier canoncialOnly() {
  42 |     |         _onlyCanoncialClones();
  43 |     |         _;
  44 |     |     }
  45 |     | 
  46 |     |     address public immutable original;
  47 |     |     address public immutable factory;
  48 |     | 
  49 |     |     constructor(
  50 |     |         address factory_
  51 |     |     ) {
  52 |     |         original = address(this);
  53 |     |         factory = factory_;
  54 |     |     }
  55 |     | 
  56 |     |     function initialize(
  57 |     |         uint160 startPrice
  58 |     |     ) external override 
  59 |     |         nonReentrant
  60 |     |         factoryOnly
  61 |     |         canoncialOnly
  62 |     |     {
  63 |     |         // initialize state
  64 |     |         globalState = Ticks.initialize(
  65 |     |             tickMap,
  66 |     |             pool0,
  67 |     |             pool1,
  68 |     |             globalState,
  69 |     |             immutables(),
  70 |     |             startPrice
  71 |     |         );
  72 |     |     }
  73 |     | 
  74 |     |     // limitSwap
  75 |     |     function mint(
  76 |     |         MintParams memory params
  77 |     |     ) external override
  78 |     |         nonReentrant
  79 |     |         canoncialOnly
  80 |     |     {
  81 |     |         MintCache memory cache;
  82 |     |         {
  83 |     |             cache.state = globalState;
  84 |     |             cache.constants = immutables();
  85 |     |             cache.pool = params.zeroForOne ? pool0 : pool1;
  86 |     |             cache.swapPool = params.zeroForOne ? pool1 : pool0;
  87 |     |         }
  88 |     |         cache = MintCall.perform(
  89 |     |             params,
  90 |     |             cache,
  91 |     |             tickMap,
  92 |     |             params.zeroForOne ? pool0 : pool1,
  93 |     |             params.zeroForOne ? pool1 : pool0,
  94 |     |             params.zeroForOne ? ticks0 : ticks1,
  95 |     |             params.zeroForOne ? ticks1 : ticks0,
  96 |     |             params.zeroForOne ? positions0 : positions1
  97 |     |         );
  98 |     |         globalState = cache.state;
  99 |     |     }
 100 |     | 
 101 |     |     function getResizedTicksForMint(
 102 |     |         MintParams memory params
 103 |     |     ) external returns (int24 lower, int24 upper, bool positionCreated){
 104 |     |         MintCache memory cache;
 105 |     |         {
 106 |     |             cache.state = globalState;
 107 |     |             cache.constants = immutables();
 108 |     |             cache.pool = params.zeroForOne ? pool0 : pool1;
 109 |     |             cache.swapPool = params.zeroForOne ? pool1 : pool0;
 110 |     |         }
 111 |     | 
 112 |     |         try MintCall.getResizedTicks(
 113 |     |             params,
 114 |     |             cache,
 115 |     |             tickMap,
 116 |     |             params.zeroForOne ? pool0 : pool1,
 117 |     |             params.zeroForOne ? pool1 : pool0,
 118 |     |             params.zeroForOne ? ticks0 : ticks1,
 119 |     |             params.zeroForOne ? ticks1 : ticks0,
 120 |     |             params.zeroForOne ? positions0 : positions1
 121 |     |         ) {
 122 |     |         } catch (bytes memory data) {
 123 |     |             emit SimulateMint(data);
 124 |     |             bytes4 sig;
 125 |     |             assembly {
 126 |     |                 sig := mload(add(data, 0x20))
 127 |     |             }
 128 |     |             
 129 |     |             // SimulateMint error
 130 |     |             if (sig == hex"5cc1f67b") {
 131 |     |                 (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 132 |     |             }
 133 |     |             else {
 134 |     |                 lower = -8388608;
 135 |     |                 upper = -8388608;
 136 |     |                 positionCreated = false;
 137 |     |             }
 138 |     |         }
 139 |     |     }
 140 |     | 
 141 |     |     function burn(
 142 |     |         BurnParams memory params
 143 |     |     ) external override 
 144 |     |         nonReentrant
 145 |     |         canoncialOnly
 146 |     |     {
 147 |     |         if (params.to == address(0)) revert CollectToZeroAddress();
 148 |     |         BurnCache memory cache = BurnCache({
 149 |     |             state: globalState,
 150 |     |             position: params.zeroForOne ? positions0[params.to][params.lower][params.upper]
 151 |     |                                         : positions1[params.to][params.lower][params.upper],
 152 |     |             constants: immutables(),
 153 |     |             pool: params.zeroForOne ? pool0 : pool1
 154 |     |         });
 155 |     |         cache = BurnCall.perform(
 156 |     |             params, 
 157 |     |             cache, 
 158 |     |             tickMap,
 159 |     |             params.zeroForOne ? ticks0 : ticks1,
 160 |     |             params.zeroForOne ? positions0 : positions1
 161 |     |         );
 162 |     |         if (params.zeroForOne) {
 163 |     |             pool0 = cache.pool;
 164 |     |         } else {
 165 |     |             pool1 = cache.pool;
 166 |     |         }
 167 |     |         globalState = cache.state;
 168 |     |     }
 169 |     | 
 170 |     |     function getResizedTicksForBurn(
 171 |     |         BurnParams memory params
 172 |     |     ) external returns (int24 lower, int24 upper, bool positionExists){
 173 |     |         if (params.to == address(0)) revert CollectToZeroAddress();
 174 |     |         BurnCache memory cache = BurnCache({
 175 |     |             state: globalState,
 176 |     |             position: params.zeroForOne ? positions0[params.to][params.lower][params.upper]
 177 |     |                                         : positions1[params.to][params.lower][params.upper],
 178 |     |             constants: immutables(),
 179 |     |             pool: params.zeroForOne ? pool0 : pool1
 180 |     |         });
 181 |     | 
 182 |     |         try BurnCall.getResizedTicks(
 183 |     |            params, 
 184 |     |             cache, 
 185 |     |             tickMap,
 186 |     |             params.zeroForOne ? ticks0 : ticks1,
 187 |     |             params.zeroForOne ? positions0 : positions1
 188 |     |         ) {
 189 |     |         } catch (bytes memory data) {
 190 |     |             bytes4 sig;
 191 |     |             assembly {
 192 |     |                 sig := mload(add(data, 0x20))
 193 |     |             }
 194 |     |             // SimulateBurn error
 195 |     |             if (sig == hex"97dd6e0a") {
 196 |     |                 (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 197 |     |             }
 198 |     |              else {
 199 |     |                 lower = -8388608;
 200 |     |                 upper = -8388608;
 201 |     |                 positionExists = false;
 202 |     |             }
 203 |     | 
 204 |     |             
 205 |     |         }
 206 |     | 
 207 |     |     }
 208 |     | 
 209 |     | 
 210 |     |     function swap(
 211 |     |         SwapParams memory params
 212 |     |     ) public override
 213 |     |         nonReentrant
 214 |     |         canoncialOnly
 215 |     |     returns (
 216 |     |         int256,
 217 |     |         int256
 218 |     |     ) 
 219 |     |     {
 220 |     |         SwapCache memory cache;
 221 |     |         cache.pool = params.zeroForOne ? pool1 : pool0;
 222 |     |         cache.state = globalState;
 223 |     |         cache.constants = immutables();
 224 |     | 
 225 |     |         return SwapCall.perform(
 226 |     |             params,
 227 |     |             cache,
 228 |     |             tickMap,
 229 |     |             params.zeroForOne ? pool1 : pool0,
 230 |     |             params.zeroForOne ? ticks1 : ticks0
 231 |     |         );
 232 |     |     }
 233 |     | 
 234 |     |     function quote(
 235 |     |         QuoteParams memory params
 236 |     |     ) external view override canoncialOnly returns (
 237 |     |         uint256 inAmount,
 238 |     |         uint256 outAmount,
 239 |     |         uint256 priceAfter
 240 |     |     ) {
 241 |     |         SwapCache memory cache;
 242 |     |         cache.pool = params.zeroForOne ? pool1 : pool0;
 243 |     |         cache.state = globalState;
 244 |     |         cache.constants = immutables();
 245 |     |         return QuoteCall.perform(
 246 |     |             params,
 247 |     |             cache,
 248 |     |             tickMap,
 249 |     |             params.zeroForOne ? ticks1 : ticks0
 250 |     |         );
 251 |     |     }
 252 |     | 
 253 |     |     function snapshot(
 254 |     |        SnapshotParams memory params 
 255 |     |     ) external override canoncialOnly returns (
 256 |     |         Position memory
 257 |     |     ) {
 258 |     |         return Positions.snapshot(
 259 |     |             params.zeroForOne ? positions0 : positions1,
 260 |     |             params.zeroForOne ? ticks0 : ticks1,
 261 |     |             tickMap,
 262 |     |             globalState,
 263 |     |             params.zeroForOne ? pool0 : pool1,
 264 |     |             UpdateParams(
 265 |     |                 params.owner,
 266 |     |                 params.owner,
 267 |     |                 params.burnPercent,
 268 |     |                 params.lower,
 269 |     |                 params.upper,
 270 |     |                 params.claim,
 271 |     |                 params.zeroForOne
 272 |     |             ),
 273 |     |             immutables()
 274 |     |         );
 275 |     |     }
 276 |     | 
 277 |     |     function fees(
 278 |     |         uint16 protocolFee0,
 279 |     |         uint16 protocolFee1,
 280 |     |         bool setFees
 281 |     |     ) external override
 282 |     |         ownerOnly
 283 |     |         nonReentrant
 284 |     |         canoncialOnly 
 285 |     |     returns (
 286 |     |         uint128 token0Fees,
 287 |     |         uint128 token1Fees
 288 |     |     ) {
 289 |     |         if (setFees) {
 290 |     |             if (protocolFee0 > 10000 || protocolFee1 > 10000)
 291 |     |                 revert ProtocolFeeCeilingExceeded();
 292 |     |             pool1.protocolFee = protocolFee0;
 293 |     |             pool0.protocolFee = protocolFee1;
 294 |     |         }
 295 |     |         address feeTo = ILimitPoolManager(owner()).feeTo();
 296 |     |         token0Fees = pool1.protocolFees;
 297 |     |         token1Fees = pool0.protocolFees;
 298 |     |         pool0.protocolFees = 0;
 299 |     |         pool1.protocolFees = 0;
 300 |     |         if (token0Fees > 0)
 301 |     |             SafeTransfers.transferOut(feeTo, token0(), token0Fees);
 302 |     |         if (token1Fees > 0)
 303 |     |             SafeTransfers.transferOut(feeTo, token1(), token1Fees);
 304 |     |     }
 305 |     | 
 306 |     |     function immutables() public view returns (
 307 |     |         Immutables memory
 308 |     |     ) {
 309 |     |         return Immutables(
 310 |     |             owner(),
 311 |     |             factory,
 312 |     |             ConstantProduct.PriceBounds(minPrice(), maxPrice()),
 313 |     |             token0(),
 314 |     |             token1(),
 315 |     |             tickSpacing()
 316 |     |         );
 317 |     |     }
 318 |     | 
 319 |     |     function priceBounds(int16 tickSpacing) external pure returns (uint160, uint160) {
 320 |     |         return ConstantProduct.priceBounds(tickSpacing);
 321 |     |     }
 322 |     | 
 323 |     |     function _onlyOwner() private view {
 324 |     |         if (msg.sender != owner()) revert OwnerOnly();
 325 |     |     }
 326 |     | 
 327 |     |     function _onlyCanoncialClones() private view {
 328 |     |         // compute pool key
 329 |     |         bytes32 key = keccak256(abi.encode(original, token0(), token1(), tickSpacing()));
 330 |     |         
 331 |     |         // compute canonical pool address
 332 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 333 |     |             original,
 334 |     |             abi.encodePacked(
 335 |     |                 owner(),
 336 |     |                 token0(),
 337 |     |                 token1(),
 338 |     |                 minPrice(),
 339 |     |                 maxPrice(),
 340 |     |                 tickSpacing()
 341 |     |             ),
 342 |     |             key,
 343 |     |             factory
 344 |     |         );
 345 |     |         // only allow delegateCall from canonical clones
 346 |     |         if (address(this) != predictedAddress) require(false, 'NoDelegateCall()');
 347 |     |     }
 348 |     | 
 349 |     |     function _onlyFactory() private view {
 350 |     |         if (msg.sender != factory) revert FactoryOnly();
 351 |     |     }
 352 |     | }
 353 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/LimitPoolFactory.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './LimitPool.sol';
   5 |     | import './interfaces/ILimitPoolFactory.sol';
   6 |     | import './base/events/LimitPoolFactoryEvents.sol';
   7 |     | import './base/structs/PoolsharkStructs.sol';
   8 |     | import './utils/LimitPoolErrors.sol';
   9 |     | import './libraries/solady/LibClone.sol';
  10 |     | import './libraries/math/ConstantProduct.sol';
  11 |     | 
  12 |     | contract LimitPoolFactory is 
  13 |     |     ILimitPoolFactory,
  14 |     |     PoolsharkStructs,
  15 |     |     LimitPoolFactoryEvents,
  16 |     |     LimitPoolFactoryErrors
  17 |     | {
  18 |     |     using LibClone for address;
  19 |     | 
  20 |     |     address immutable public owner;
  21 |     |     address immutable public original;
  22 |     | 
  23 |     |     constructor(
  24 |     |         address owner_
  25 |     |     ) {
  26 |     |         owner = owner_;
  27 |     |         original = address(this);
  28 |     |     }
  29 |     | 
  30 |     |     function createLimitPool(
  31 |     |         bytes32 poolType,
  32 |     |         address tokenIn,
  33 |     |         address tokenOut,
  34 |     |         int16  tickSpacing,
  35 |     |         uint160 startPrice
  36 |     |     ) external override returns (address pool) {
  37 |     | 
  38 |     |         // validate token pair
  39 |     |         if (tokenIn == tokenOut || tokenIn == address(0) || tokenOut == address(0)) {
  40 |     |             revert InvalidTokenAddress();
  41 |     |         }
  42 |     | 
  43 |     |         // sort tokens by address
  44 |     |         Immutables memory constants;
  45 |     |         (constants.token0, constants.token1) = tokenIn < tokenOut ? (tokenIn,  tokenOut) 
  46 |     |                                                                   : (tokenOut, tokenIn);
  47 |     | 
  48 |     |         // check if tick spacing supported
  49 |     |         if (!ILimitPoolManager(owner).tickSpacings(tickSpacing)) revert TickSpacingNotSupported();
  50 |     | 
  51 |     |         // check if pool type supported
  52 |     |         address implementation = ILimitPoolManager(owner).implementations(poolType);
  53 |     |         if (implementation == address(0)) revert PoolTypeNotSupported();
  54 |     | 
  55 |     |         // generate key for pool
  56 |     |         bytes32 key = keccak256(abi.encode(
  57 |     |             implementation,
  58 |     |             constants.token0,
  59 |     |             constants.token1,
  60 |     |             tickSpacing
  61 |     |         ));
  62 |     | 
  63 |     |         // check if pool already exists
  64 |     |         if (limitPools[key] != address(0)) revert PoolAlreadyExists();
  65 |     | 
  66 |     |         // set immutables
  67 |     |         constants.owner = owner;
  68 |     |         constants.factory = original;
  69 |     |         constants.tickSpacing = tickSpacing;
  70 |     |         (
  71 |     |             constants.bounds.min,
  72 |     |             constants.bounds.max
  73 |     |         ) = ILimitPool(implementation).priceBounds(constants.tickSpacing);
  74 |     | 
  75 |     |         // launch pool
  76 |     |         pool = implementation.cloneDeterministic({
  77 |     |             salt: key,
  78 |     |             data: abi.encodePacked(
  79 |     |                 constants.owner,
  80 |     |                 constants.token0,
  81 |     |                 constants.token1,
  82 |     |                 constants.bounds.min,
  83 |     |                 constants.bounds.max,
  84 |     |                 constants.tickSpacing
  85 |     |             )
  86 |     |         });
  87 |     | 
  88 |     |         // initialize pool storage
  89 |     |         ILimitPool(pool).initialize(startPrice);
  90 |     | 
  91 |     |         // save pool in mapping
  92 |     |         limitPools[key] = pool;
  93 |     | 
  94 |     |         emit PoolCreated(
  95 |     |             pool,
  96 |     |             implementation,
  97 |     |             constants.token0,
  98 |     |             constants.token1,
  99 |     |             tickSpacing
 100 |     |         );
 101 |     |     }
 102 |     | 
 103 |     |     function getLimitPool(
 104 |     |         bytes32 poolType,
 105 |     |         address tokenIn,
 106 |     |         address tokenOut,
 107 |     |         int16 tickSpacing
 108 |     |     ) external view override returns (address) {
 109 |     |         // set lexographical token address ordering
 110 |     |         address token0 = tokenIn < tokenOut ? tokenIn : tokenOut;
 111 |     |         address token1 = tokenIn < tokenOut ? tokenOut : tokenIn;
 112 |     | 
 113 |     |         // check if tick spacing supported
 114 |     |         if (!ILimitPoolManager(owner).tickSpacings(tickSpacing)) revert TickSpacingNotSupported();
 115 |     | 
 116 |     |         // check if pool type supported
 117 |     |         address implementation = ILimitPoolManager(owner).implementations(poolType);
 118 |     |         if (implementation == address(0)) revert PoolTypeNotSupported();
 119 |     | 
 120 |     |         // generate key for pool
 121 |     |         bytes32 key = keccak256(abi.encode(
 122 |     |             implementation,
 123 |     |             token0,
 124 |     |             token1,
 125 |     |             tickSpacing
 126 |     |         ));
 127 |     | 
 128 |     |         return limitPools[key];
 129 |     |     }
 130 |     | }
 131 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/events/LimitPoolEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolEvents {
  5 |     |     event Initialize(
  6 |     |         int24 minTick,
  7 |     |         int24 maxTick,
  8 |     |         uint160 startPrice,
  9 |     |         int24 startTick
 10 |     |     );
 11 |     | 
 12 |     |     event Sync(
 13 |     |         uint160 price,
 14 |     |         uint128 liquidity
 15 |     |     );
 16 |     | 
 17 |     |     event MintLimit(
 18 |     |         address indexed to,
 19 |     |         int24 lower,
 20 |     |         int24 upper,
 21 |     |         bool zeroForOne,
 22 |     |         uint32 epochLast,
 23 |     |         uint128 amountIn,
 24 |     |         uint128 amountFilled,
 25 |     |         uint128 liquidityMinted,
 26 |     |         uint128 poolLiquidity,
 27 |     |         uint160 poolPrice
 28 |     |     );
 29 |     | 
 30 |     |     event BurnLimit(
 31 |     |         address indexed to,
 32 |     |         int24 lower,
 33 |     |         int24 upper,
 34 |     |         int24 claim,
 35 |     |         bool zeroForOne,
 36 |     |         uint128 liquidityBurned,
 37 |     |         uint128 tokenInClaimed,
 38 |     |         uint128 tokenOutBurned
 39 |     |     );
 40 |     | 
 41 |     |     event Swap(
 42 |     |         address indexed recipient,
 43 |     |         bool zeroForOne,
 44 |     |         uint256 amountIn,
 45 |     |         uint256 amountOut,
 46 |     |         uint160 price,
 47 |     |         uint128 liquidity,
 48 |     |         int24 tickAtPrice
 49 |     |     );
 50 |     | }
 51 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/events/LimitPoolFactoryEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolFactoryEvents {
  5 |     |     event PoolCreated(
  6 |     |         address pool,
  7 |     |         address implementation,
  8 |     |         address indexed token0,
  9 |     |         address indexed token1,
 10 |     |         int16 indexed tickSpacing
 11 |     |     );
 12 |     | }
 13 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/events/LimitPoolManagerEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolManagerEvents {
  5 |     |     event FactoryChanged(address indexed previousFactory, address indexed newFactory);
  6 |     |     event ImplementationEnabled(
  7 |     |         bytes32 key,
  8 |     |         address implementation
  9 |     |     );
 10 |     |     event TickSpacingEnabled(
 11 |     |         int16 tickSpacing
 12 |     |     );
 13 |     |     event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);
 14 |     |     event OwnerTransfer(address indexed previousOwner, address indexed newOwner);
 15 |     |     event ProtocolFeesModified(
 16 |     |         address[] modifyPools,
 17 |     |         uint16[] syncFees,
 18 |     |         uint16[] fillFees,
 19 |     |         bool[] setFees,
 20 |     |         uint128[] token0Fees,
 21 |     |         uint128[] token1Fees
 22 |     |     );
 23 |     |     event ProtocolFeesCollected(
 24 |     |         address[] collectPools,
 25 |     |         uint128[] token0Fees,
 26 |     |         uint128[] token1Fees
 27 |     |     );
 28 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/modifiers/LimitPoolModifiers.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../storage/LimitPoolStorage.sol';
  5 |     | import '../../libraries/Ticks.sol';
  6 |     | 
  7 |     | abstract contract LimitPoolModifiers is LimitPoolStorage {
  8 |     | 
  9 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/LimitPoolFactoryStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolFactoryStorage {
  5 |     |     mapping(bytes32 => address) public limitPools;
  6 |     | }
  7 |     | 
  8 |     | 
  9 |     | 
 10 |     | 
 11 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/LimitPoolImmutables.sol
  1 |     | // SPDX-License-Identifier: BSD
  2 |     | pragma solidity ^0.8.4;
  3 |     | 
  4 |     | import { Clone } from "../../libraries/solady/Clone.sol";
  5 |     | 
  6 |     | contract LimitPoolImmutables is Clone {
  7 |     |     function owner() public pure returns (address) {
  8 |     |         return _getArgAddress(0);
  9 |     |     }
 10 |     | 
 11 |     |     function token0() public pure returns (address) {
 12 |     |         return _getArgAddress(20);
 13 |     |     }
 14 |     | 
 15 |     |     function token1() public pure returns (address) {
 16 |     |         return _getArgAddress(40);
 17 |     |     }
 18 |     | 
 19 |     |     function minPrice() public pure returns (uint160) {
 20 |     |         return _getArgUint160(60);
 21 |     |     }
 22 |     | 
 23 |     |     function maxPrice() public pure returns (uint160) {
 24 |     |         return _getArgUint160(80);
 25 |     |     }
 26 |     | 
 27 |     |     function tickSpacing() public pure returns (int16) {
 28 |     |         return int16(_getArgUint16(100));
 29 |     |     }
 30 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/storage/LimitPoolStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/ILimitPoolStructs.sol';
  5 |     | import '../../interfaces/ILimitPoolFactory.sol';
  6 |     | import '../../utils/LimitPoolErrors.sol';
  7 |     | 
  8 |     | abstract contract LimitPoolStorage is ILimitPoolStructs, LimitPoolErrors {
  9 |     |     GlobalState public globalState;
 10 |     |     PoolState public pool0; /// @dev State for token0 as output
 11 |     |     PoolState public pool1; /// @dev State for token1 as output
 12 |     |     TickMap public tickMap;
 13 |     |     address public feeTo;
 14 |     |     mapping(int24 => Tick) public ticks0; /// @dev Ticks containing token0 as output
 15 |     |     mapping(int24 => Tick) public ticks1; /// @dev Ticks containing token1 as output
 16 |     |     mapping(address => mapping(int24 => mapping(int24 => Position))) public positions0; //positions with token0 deposited
 17 |     |     mapping(address => mapping(int24 => mapping(int24 => Position))) public positions1; //positions with token1 deposited
 18 |     | }
 19 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/structs/CurveMathStructs.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/modules/sources/ITwapSource.sol';
  5 |     | 
  6 |     | interface CurveMathStructs {
  7 |     |     struct PriceBounds {
  8 |     |         uint160 min;
  9 |     |         uint160 max;
 10 |     |     }
 11 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/structs/LimitPoolFactoryStructs.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolFactoryStructs {
  5 |     |     struct LimitPoolParams {
  6 |     |         address owner;
  7 |     |         address token0;
  8 |     |         address token1;
  9 |     |         uint160 minPrice;
 10 |     |         uint160 maxPrice;
 11 |     |         uint160 startPrice;
 12 |     |         int16   tickSpacing;
 13 |     |     }
 14 |     | }
 15 |     | 
 16 |     | 
 17 |     | 
 18 |     | 
 19 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/base/structs/PoolsharkStructs.sol
  1 |     | // SPDX-License-Identifier: GPLv3
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface PoolsharkStructs {
  5 |     |     struct SwapParams {
  6 |     |         address to;
  7 |     |         uint160 priceLimit;
  8 |     |         uint128  amount;
  9 |     |         bool exactIn;
 10 |     |         bool zeroForOne;
 11 |     |         bytes callbackData;
 12 |     |     }
 13 |     |     
 14 |     |     struct Immutables {
 15 |     |         address owner;
 16 |     |         address factory;
 17 |     |         PriceBounds bounds;
 18 |     |         address token0;
 19 |     |         address token1;
 20 |     |         int16 tickSpacing;
 21 |     |     }
 22 |     | 
 23 |     |     struct PriceBounds {
 24 |     |         uint160 min;
 25 |     |         uint160 max;
 26 |     |     }
 27 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/external/openzeppelin/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity 0.8.13;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 |     |     uint256 private constant _NOT_ENTERED = 1;
 35 |     |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Unauthorized reentrant call.
 41 |     |      */
 42 |     |     error ReentrancyGuardReentrantCall();
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 46 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 47 |     |      * function is not supported. It is possible to prevent this from happening
 48 |     |      * by making the `nonReentrant` function external, and making it call a
 49 |     |      * `private` function that does the actual work.
 50 |     |      */
 51 |     |     modifier nonReentrant() {
 52 |     |         _nonReentrantBefore();
 53 |     |         _;
 54 |     |         _nonReentrantAfter();
 55 |     |     }
 56 |     | 
 57 |     |     function _nonReentrantBefore() private {
 58 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 59 |     |         if (_status == _ENTERED) {
 60 |     |             revert ReentrancyGuardReentrantCall();
 61 |     |         }
 62 |     | 
 63 |     |         // Any calls to nonReentrant after this point will fail
 64 |     |         _status = _ENTERED;
 65 |     |     }
 66 |     | 
 67 |     |     function _nonReentrantAfter() private {
 68 |     |         // By storing the original value once again, a refund is triggered (see
 69 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 70 |     |         _status = _NOT_ENTERED;
 71 |     |     }
 72 |     | 
 73 |     |     /**
 74 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 75 |     |      * `nonReentrant` function in the call stack.
 76 |     |      */
 77 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 78 |     |         return _status == _ENTERED;
 79 |     |     }
 80 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IERC20Minimal {
  5 |     |     /// @notice Returns the balance of a token
  6 |     |     /// @param account The address for which to look up the balance for
  7 |     |     /// @return amount of tokens held by the account
  8 |     |     function balanceOf(address account) external view returns (uint256);
  9 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/ILimitPool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import './ILimitPoolStructs.sol';
  5 |     | import '../base/structs/LimitPoolFactoryStructs.sol';
  6 |     | 
  7 |     | interface ILimitPool is ILimitPoolStructs {
  8 |     |     function initialize(
  9 |     |         uint160 startPrice
 10 |     |     ) external;
 11 |     | 
 12 |     |     function mint(
 13 |     |         MintParams memory params
 14 |     |     ) external;
 15 |     | 
 16 |     |     function burn(
 17 |     |         BurnParams memory params
 18 |     |     ) external;
 19 |     | 
 20 |     |     function swap(
 21 |     |         SwapParams memory params
 22 |     |     ) external returns (
 23 |     |         int256 amount0,
 24 |     |         int256 amount1
 25 |     |     );
 26 |     | 
 27 |     |     function quote(
 28 |     |         QuoteParams memory params
 29 |     |     ) external view returns (
 30 |     |         uint256 inAmount,
 31 |     |         uint256 outAmount,
 32 |     |         uint256 priceAfter
 33 |     |     );
 34 |     | 
 35 |     |     function snapshot(
 36 |     |         SnapshotParams memory params
 37 |     |     ) external returns (
 38 |     |         Position memory
 39 |     |     );
 40 |     | 
 41 |     |     function fees(
 42 |     |         uint16 syncFee,
 43 |     |         uint16 fillFee,
 44 |     |         bool setFees
 45 |     |     ) external returns (
 46 |     |         uint128 token0Fees,
 47 |     |         uint128 token1Fees
 48 |     |     );
 49 |     | 
 50 |     |     function priceBounds(
 51 |     |         int16 tickSpacing
 52 |     |     ) external pure returns (
 53 |     |         uint160 minPrice,
 54 |     |         uint160 maxPrice
 55 |     |     );
 56 |     | }
 57 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/ILimitPoolFactory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | import '../base/storage/LimitPoolFactoryStorage.sol';
  4 |     | 
  5 |     | abstract contract ILimitPoolFactory is LimitPoolFactoryStorage {
  6 |     |     function createLimitPool(
  7 |     |         bytes32 poolType,
  8 |     |         address tokenIn,
  9 |     |         address tokenOut,
 10 |     |         int16  tickSpacing,
 11 |     |         uint160 startPrice
 12 |     |     ) external virtual returns (address pool);
 13 |     | 
 14 |     |     function getLimitPool(
 15 |     |         bytes32 poolType,
 16 |     |         address tokenIn,
 17 |     |         address tokenOut,
 18 |     |         int16  tickSpacing
 19 |     |     ) external view virtual returns (address);
 20 |     | }
 21 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/ILimitPoolManager.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @notice LimitPoolManager interface
  5 |     | interface ILimitPoolManager {
  6 |     |     function owner() external view returns (address);
  7 |     |     function feeTo() external view returns (address);
  8 |     |     function implementations(
  9 |     |         bytes32 poolType
 10 |     |     ) external view returns (
 11 |     |         address
 12 |     |     );
 13 |     |     function tickSpacings(
 14 |     |         int16 tickSpacing
 15 |     |     ) external view returns (
 16 |     |         bool
 17 |     |     );
 18 |     | }
 19 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/ILimitPoolStructs.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../libraries/math/ConstantProduct.sol';
   5 |     | import './modules/sources/ITwapSource.sol';
   6 |     | 
   7 |     | interface ILimitPoolStructs {
   8 |     |     struct GlobalState {
   9 |     |         uint8   unlocked;
  10 |     |     }
  11 |     | 
  12 |     |     struct PoolState {
  13 |     |         uint160 price; /// @dev Starting price current
  14 |     |         uint128 liquidity; /// @dev Liquidity currently active
  15 |     |         uint128 liquidityGlobal;
  16 |     |         uint128 protocolFees;
  17 |     |         uint32  swapEpoch;
  18 |     |         uint16 protocolFee;
  19 |     |         int24 tickAtPrice;
  20 |     |     }
  21 |     | 
  22 |     |     struct TickMap {
  23 |     |         uint256 blocks;                     /// @dev - sets of words
  24 |     |         mapping(uint256 => uint256) words;  /// @dev - sets to words
  25 |     |         mapping(uint256 => uint256) ticks;  /// @dev - words to ticks
  26 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs; /// @dev - ticks to epochs
  27 |     |     }
  28 |     | 
  29 |     |     struct Tick {
  30 |     |         uint160 priceAt;
  31 |     |         int128 liquidityDelta;
  32 |     |     }
  33 |     | 
  34 |     |     struct Position {
  35 |     |         uint128 amountIn; // token amount already claimed; balance
  36 |     |         uint128 amountOut; // necessary for non-custodial positions
  37 |     |         uint128 liquidity; // expected amount to be used not actual
  38 |     |         uint32 epochLast;  // epoch when this position was created at
  39 |     |         bool crossedInto; // whether the position was crossed into already
  40 |     |     }
  41 |     | 
  42 |     |     struct PriceBounds {
  43 |     |         uint160 min;
  44 |     |         uint160 max;
  45 |     |     }
  46 |     | 
  47 |     |     struct Immutables {
  48 |     |         address owner;
  49 |     |         address factory;
  50 |     |         ConstantProduct.PriceBounds bounds;
  51 |     |         address token0;
  52 |     |         address token1;
  53 |     |         int16 tickSpacing;
  54 |     |     }
  55 |     | 
  56 |     |     struct MintParams {
  57 |     |         address to;
  58 |     |         address refundTo;
  59 |     |         uint128 amount;
  60 |     |         uint96 mintPercent;
  61 |     |         int24 lower;
  62 |     |         int24 upper;
  63 |     |         bool zeroForOne;
  64 |     |     }
  65 |     | 
  66 |     |     struct BurnParams {
  67 |     |         address to;
  68 |     |         uint128 burnPercent;
  69 |     |         int24 lower;
  70 |     |         int24 claim;
  71 |     |         int24 upper;
  72 |     |         bool zeroForOne;
  73 |     |     }
  74 |     | 
  75 |     |     struct SwapParams {
  76 |     |         address to;
  77 |     |         uint160 priceLimit;
  78 |     |         uint128  amount;
  79 |     |         bool exactIn;
  80 |     |         bool zeroForOne;
  81 |     |         bytes callbackData;
  82 |     |     }
  83 |     | 
  84 |     |     struct QuoteParams {
  85 |     |         uint160 priceLimit;
  86 |     |         uint128 amount;
  87 |     |         bool exactIn;
  88 |     |         bool zeroForOne;
  89 |     |     }
  90 |     | 
  91 |     |     struct SnapshotParams {
  92 |     |         address owner;
  93 |     |         uint128 burnPercent;
  94 |     |         int24 lower;
  95 |     |         int24 upper;
  96 |     |         int24 claim;
  97 |     |         bool zeroForOne;
  98 |     |     }
  99 |     | 
 100 |     |     struct UpdateParams {
 101 |     |         address owner;
 102 |     |         address to;
 103 |     |         uint128 amount;
 104 |     |         int24 lower;
 105 |     |         int24 upper;
 106 |     |         int24 claim;
 107 |     |         bool zeroForOne;
 108 |     |     }
 109 |     | 
 110 |     |     struct MintCache {
 111 |     |         GlobalState state;
 112 |     |         Position position;
 113 |     |         Immutables constants;
 114 |     |         PoolState pool;
 115 |     |         PoolState swapPool;
 116 |     |         SwapCache swapCache;
 117 |     |         uint256 liquidityMinted;
 118 |     |         uint256 mintSize;
 119 |     |         uint256 priceLimit;
 120 |     |         int256 amountIn;
 121 |     |         uint256 amountOut;
 122 |     |         uint256 priceLower;
 123 |     |         uint256 priceUpper;
 124 |     |         int24 tickLimit;
 125 |     |     }
 126 |     | 
 127 |     |     struct BurnCache {
 128 |     |         GlobalState state;
 129 |     |         Position position;
 130 |     |         Immutables constants;
 131 |     |         PoolState pool;
 132 |     |     }
 133 |     | 
 134 |     |     struct SwapCache {
 135 |     |         GlobalState state;
 136 |     |         Immutables constants;
 137 |     |         PoolState pool;
 138 |     |         uint256 price;
 139 |     |         uint256 liquidity;
 140 |     |         uint256 amountLeft;
 141 |     |         uint256 input;
 142 |     |         uint256 output;
 143 |     |         uint160 crossPrice;
 144 |     |         int24 crossTick;
 145 |     |         bool exactIn;
 146 |     |         bool cross;
 147 |     |     }
 148 |     | 
 149 |     |     struct UpdateCache {
 150 |     |         PoolState pool;
 151 |     |         Tick claimTick;
 152 |     |         Position position;
 153 |     |         uint160 priceLower;
 154 |     |         uint160 priceClaim;
 155 |     |         uint160 priceUpper;
 156 |     |         bool earlyReturn;
 157 |     |         bool removeLower;
 158 |     |         bool removeUpper;
 159 |     |     }
 160 |     | 
 161 |     |     struct InsertSingleLocals {
 162 |     |         int24 previousFullTick;
 163 |     |         int24 nextFullTick;
 164 |     |         uint256 priceNext;
 165 |     |         uint256 pricePrevious;
 166 |     |         uint256 amountInExact;
 167 |     |         uint256 amountOutExact;
 168 |     |         uint256 amountToCross;
 169 |     |     }
 170 |     | 
 171 |     |     struct GetDeltasLocals {
 172 |     |         int24 previousFullTick;
 173 |     |         uint256 pricePrevious;
 174 |     |         uint256 priceNext;
 175 |     |     }
 176 |     | }
 177 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/IPool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../base/structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface IPool is PoolsharkStructs {
  7 |     |     function immutables() external view returns (Immutables memory);
  8 |     |     function swap(
  9 |     |         SwapParams memory params
 10 |     |     ) external returns (
 11 |     |         int256 amount0,
 12 |     |         int256 amount1
 13 |     |     );
 14 |     | }
 15 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/callbacks/IPoolsharkSwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Callback for swaps
  5 |     | /// @notice Any contract that calls the `swap` function must implement this interface.
  6 |     | interface IPoolsharkSwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 10 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
 11 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 12 |     |     function poolsharkSwapCallback(
 13 |     |         int256 amount0Delta,
 14 |     |         int256 amount1Delta,
 15 |     |         bytes calldata data
 16 |     |     ) external;
 17 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/modules/curves/ICurveMath.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import './IDyDxMath.sol';
  5 |     | import './ITickMath.sol';
  6 |     | 
  7 |     | interface ICurveMath is 
  8 |     |     IDyDxMath,
  9 |     |     ITickMath
 10 |     | {}
 11 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/modules/curves/IDyDxMath.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../../interfaces/ILimitPoolStructs.sol';
  5 |     | import '../../../base/structs/CurveMathStructs.sol';
  6 |     | 
  7 |     | interface IDyDxMath {
  8 |     |     function getDy(
  9 |     |         uint256 liquidity,
 10 |     |         uint256 priceLower,
 11 |     |         uint256 priceUpper,
 12 |     |         bool roundUp
 13 |     |     ) external pure returns (
 14 |     |         uint256 dy
 15 |     |     );
 16 |     | 
 17 |     |     function getDx(
 18 |     |         uint256 liquidity,
 19 |     |         uint256 priceLower,
 20 |     |         uint256 priceUpper,
 21 |     |         bool roundUp
 22 |     |     ) external pure returns (
 23 |     |         uint256 dx
 24 |     |     );
 25 |     | 
 26 |     |     function getLiquidityForAmounts(
 27 |     |         uint256 priceLower,
 28 |     |         uint256 priceUpper,
 29 |     |         uint256 currentPrice,
 30 |     |         uint256 dy,
 31 |     |         uint256 dx
 32 |     |     ) external pure returns (
 33 |     |         uint256 liquidity
 34 |     |     );
 35 |     | 
 36 |     |     function getAmountsForLiquidity(
 37 |     |         uint256 priceLower,
 38 |     |         uint256 priceUpper,
 39 |     |         uint256 price,
 40 |     |         uint256 liquidity,
 41 |     |         bool roundUp
 42 |     |     ) external pure returns (
 43 |     |         uint128 token0amount,
 44 |     |         uint128 token1amount
 45 |     |     );
 46 |     | 
 47 |     |     function getNewPrice(
 48 |     |         uint256 price,
 49 |     |         uint256 liquidity,
 50 |     |         uint256 input,
 51 |     |         bool zeroForOne
 52 |     |     ) external pure returns (
 53 |     |         uint256 newPrice
 54 |     |     );
 55 |     | }
 56 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/modules/curves/ITickMath.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../../interfaces/ILimitPoolStructs.sol';
  5 |     | import '../../../base/structs/CurveMathStructs.sol';
  6 |     | 
  7 |     | interface ITickMath {
  8 |     |     struct PriceBounds {
  9 |     |         uint160 min;
 10 |     |         uint160 max;
 11 |     |     }
 12 |     | 
 13 |     |     function getPriceAtTick(
 14 |     |         int24 tick,
 15 |     |         ILimitPoolStructs.Immutables memory
 16 |     |     ) external pure returns (
 17 |     |         uint160 price
 18 |     |     );
 19 |     | 
 20 |     |     function getTickAtPrice(
 21 |     |         uint160 price,
 22 |     |         ILimitPoolStructs.Immutables memory
 23 |     |     ) external view returns (
 24 |     |         int24 tick
 25 |     |     );
 26 |     | 
 27 |     |     function minTick(
 28 |     |         int16 tickSpacing
 29 |     |     ) external pure returns (
 30 |     |         int24 tick
 31 |     |     );
 32 |     | 
 33 |     |     function maxTick(
 34 |     |         int16 tickSpacing
 35 |     |     ) external pure returns (
 36 |     |         int24 tick
 37 |     |     );
 38 |     | 
 39 |     |     function minPrice(
 40 |     |         int16 tickSpacing
 41 |     |     ) external pure returns (
 42 |     |         uint160 minPrice
 43 |     |     );
 44 |     | 
 45 |     |     function maxPrice(
 46 |     |         int16 tickSpacing
 47 |     |     ) external pure returns (
 48 |     |         uint160 maxPrice
 49 |     |     );
 50 |     | 
 51 |     |     function checkTicks(
 52 |     |         int24 lower,
 53 |     |         int24 upper,
 54 |     |         int16 tickSpacing
 55 |     |     ) external pure;
 56 |     | 
 57 |     |     function checkPrice(
 58 |     |         uint160 price,
 59 |     |         PriceBounds memory bounds
 60 |     |     ) external pure;
 61 |     | }
 62 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/interfaces/modules/sources/ITwapSource.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../ILimitPoolStructs.sol';
  5 |     | 
  6 |     | interface ITwapSource {
  7 |     |     function initialize(
  8 |     |         ILimitPoolStructs.Immutables memory constants
  9 |     |     ) external returns (
 10 |     |         uint8 initializable,
 11 |     |         int24 startingTick
 12 |     |     );
 13 |     | 
 14 |     |     function calculateAverageTick(
 15 |     |         ILimitPoolStructs.Immutables memory constants
 16 |     |     ) external view returns (
 17 |     |         int24 averageTick
 18 |     |     );
 19 |     | 
 20 |     |     function getPool(
 21 |     |         address tokenA,
 22 |     |         address tokenB,
 23 |     |         uint16 feeTier
 24 |     |     ) external view returns (
 25 |     |         address pool
 26 |     |     );
 27 |     | 
 28 |     |     function feeTierTickSpacing(
 29 |     |         uint16 feeTier
 30 |     |     ) external view returns (
 31 |     |         int24 tickSpacing
 32 |     |     );
 33 |     | 
 34 |     |     function factory()
 35 |     |     external view returns (address);
 36 |     | }
 37 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/Claims.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/ILimitPoolStructs.sol';
   5 |     | import '../interfaces/modules/curves/ICurveMath.sol';
   6 |     | import './EpochMap.sol';
   7 |     | import './TickMap.sol';
   8 |     | import './utils/String.sol';
   9 |     | import './utils/SafeCast.sol';
  10 |     | import 'hardhat/console.sol';
  11 |     | import './EchidnaAssertions.sol';
  12 |     | library Claims {
  13 |     | 
  14 |     |     using SafeCast for uint256;
  15 |     | 
  16 |     |     function validate(
  17 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
  18 |     |             storage positions,
  19 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
  20 |     |         ILimitPoolStructs.TickMap storage tickMap,
  21 |     |         ILimitPoolStructs.PoolState memory pool,
  22 |     |         ILimitPoolStructs.UpdateParams memory params,
  23 |     |         ILimitPoolStructs.UpdateCache memory cache,
  24 |     |         ILimitPoolStructs.Immutables memory constants
  25 |     |     ) internal returns (
  26 |     |         ILimitPoolStructs.UpdateParams memory,
  27 |     |         ILimitPoolStructs.UpdateCache memory
  28 |     |     ) {
  29 |     |         // validate position liquidity
  30 |     |         if (params.amount > cache.position.liquidity) require (false, 'NotEnoughPositionLiquidity()');
  31 |     |         if (cache.position.liquidity == 0) {
  32 |     |             require(false, 'NoPositionLiquidityFound()');
  33 |     |         }
  34 |     |         
  35 |     |         if (params.claim < params.lower || params.claim > params.upper) require (false, 'InvalidClaimTick()');
  36 |     | 
  37 |     |         uint32 claimTickEpoch = EpochMap.get(params.claim, tickMap, constants);
  38 |     | 
  39 |     |         if (params.zeroForOne){
  40 |     |             if (pool.price >= cache.priceClaim) {
  41 |     |                 if (pool.price <= cache.priceUpper) {
  42 |     |                     cache.priceClaim = pool.price;
  43 |     |                     params.claim = TickMap.roundBack(pool.tickAtPrice, constants, params.zeroForOne, cache.priceClaim);
  44 |     |                     claimTickEpoch = pool.swapEpoch;
  45 |     |                 } else {
  46 |     |                     cache.priceClaim = cache.priceUpper;
  47 |     |                     params.claim = params.upper;
  48 |     |                     cache.claimTick = ticks[params.upper];
  49 |     |                 }
  50 |     |                 claimTickEpoch = pool.swapEpoch;
  51 |     |             } else if (params.claim % constants.tickSpacing != 0) {
  52 |     |                 if (cache.claimTick.priceAt == 0) {
  53 |     |                     require (false, 'WrongTickClaimedAt1()');
  54 |     |                 }
  55 |     |                 cache.priceClaim = cache.claimTick.priceAt;
  56 |     |             }
  57 |     |         } else {
  58 |     |             if (pool.price <= cache.priceClaim) {
  59 |     |                 if (pool.price >= cache.priceLower) {
  60 |     |                     cache.priceClaim = pool.price;
  61 |     |                     params.claim = TickMap.roundBack(pool.tickAtPrice, constants, params.zeroForOne, cache.priceClaim);
  62 |     |                     claimTickEpoch = pool.swapEpoch;
  63 |     |                 } else {
  64 |     |                     cache.priceClaim = cache.priceLower;
  65 |     |                     params.claim = params.lower;
  66 |     |                     cache.claimTick = ticks[params.upper];
  67 |     |                 }
  68 |     |                 claimTickEpoch = pool.swapEpoch;
  69 |     |             } else if (params.claim % constants.tickSpacing != 0) {
  70 |     |                 if (cache.claimTick.priceAt == 0) {
  71 |     |                     require (false, 'WrongTickClaimedAt2()');
  72 |     |                 }
  73 |     |                 cache.priceClaim = cache.claimTick.priceAt;
  74 |     |             }
  75 |     |         }
  76 |     | 
  77 |     |         // validate claim tick
  78 |     |         if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {
  79 |     |              if (claimTickEpoch <= cache.position.epochLast)
  80 |     |                 require (false, 'WrongTickClaimedAt3()');
  81 |     |         } else if (params.amount > 0) {
  82 |     |             /// @dev - partway claim is valid as long as liquidity is not being removed
  83 |     |             int24 claimTickNext = params.zeroForOne
  84 |     |                 ? TickMap.next(tickMap, params.claim, constants.tickSpacing, false)
  85 |     |                 : TickMap.previous(tickMap, params.claim, constants.tickSpacing, false);
  86 |     |             console.log('claim tick next check', uint24(-claimTickNext));
  87 |     |             // if we cleared the final tick of their position, this is the wrong claim tick
  88 |     |             if (params.zeroForOne ? claimTickNext > params.upper
  89 |     |                                   : claimTickNext < params.lower) {
  90 |     |                 EchidnaAssertions.assertWrongTickClaimedAt4(params.zeroForOne, claimTickNext, params.upper, params.lower);
  91 |     |                 require (false, 'WrongTickClaimedAt4()');
  92 |     |             }
  93 |     |             // zero fill or partial fill
  94 |     |             /// @dev - if the next tick was crossed after position creation, the claim tick is incorrect
  95 |     |             /// @dev - we can cycle to find the right claim tick for the user
  96 |     |             uint32 claimTickNextAccumEpoch = EpochMap.get(claimTickNext, tickMap, constants);
  97 |     |             ///@dev - next swapEpoch should not be greater
  98 |     |             if (claimTickNextAccumEpoch > cache.position.epochLast) {
  99 |     |                 require (false, 'WrongTickClaimedAt5()');
 100 |     |             }
 101 |     | 
 102 |     |             uint32 endTickAccumEpoch = EpochMap.get(params.zeroForOne ? params.upper : params.lower, tickMap, constants);
 103 |     |             if (endTickAccumEpoch > cache.position.epochLast) {
 104 |     |                 require (false, 'WrongTickClaimedAt5()');
 105 |     |             }
 106 |     |         }
 107 |     |         /// @dev - start tick does not overwrite position and final tick clears position
 108 |     |         if (params.claim != params.upper && params.claim != params.lower) {
 109 |     |             // check epochLast on claim tick
 110 |     |             if (claimTickEpoch <= cache.position.epochLast)
 111 |     |                 require (false, 'WrongTickClaimedAt6()');
 112 |     |             // prevent position overwriting at claim tick
 113 |     |             if (params.zeroForOne) {
 114 |     |                 if (positions[params.owner][params.claim][params.upper].liquidity > 0) {
 115 |     |                     require (false, string.concat('UpdatePositionFirstAt(', String.from(params.claim), ', ', String.from(params.upper), ')'));
 116 |     |                 }
 117 |     |             } else {
 118 |     |                 if (positions[params.owner][params.lower][params.claim].liquidity > 0) {
 119 |     |                     require (false, string.concat('UpdatePositionFirstAt(', String.from(params.lower), ', ', String.from(params.claim), ')'));
 120 |     |                 }
 121 |     |             }
 122 |     |         }
 123 |     | 
 124 |     |         // early return if no update and amount burned is 0
 125 |     |         //TODO: after we've cycled through claim ticks and there are no position updates just revert - DONE
 126 |     |         if (params.zeroForOne ? params.claim == params.lower
 127 |     |                               : params.claim == params.upper) {
 128 |     |             if (params.amount == 0)
 129 |     |                 require(false, 'NoPositionUpdates()');
 130 |     |         }
 131 |     | 
 132 |     |         return (params, cache);
 133 |     |     }
 134 |     | 
 135 |     |     function getDeltas(
 136 |     |         ILimitPoolStructs.UpdateCache memory cache,
 137 |     |         ILimitPoolStructs.UpdateParams memory params,
 138 |     |         ILimitPoolStructs.Immutables memory constants
 139 |     |     ) internal pure returns (
 140 |     |         ILimitPoolStructs.UpdateCache memory
 141 |     |     ) {
 142 |     |         // if half tick priceAt > 0 add amountOut to amountOutClaimed
 143 |     |         // set claimPriceLast if zero
 144 |     |         if (!cache.position.crossedInto) {
 145 |     |             cache.position.crossedInto = true;
 146 |     |         }
 147 |     |         ILimitPoolStructs.GetDeltasLocals memory locals;
 148 |     | 
 149 |     |         if (params.claim % constants.tickSpacing != 0)
 150 |     |         // this should pass price at the claim tick
 151 |     |             locals.previousFullTick = TickMap.roundBack(params.claim, constants, params.zeroForOne, ConstantProduct.getPriceAtTick(params.claim, constants));
 152 |     |         else
 153 |     |             locals.previousFullTick = params.claim;
 154 |     |         locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);
 155 |     |         if (params.zeroForOne ? locals.previousFullTick > params.lower
 156 |     |                               : locals.previousFullTick < params.upper) {
 157 |     |             
 158 |     |             // claim amounts up to latest full tick crossed
 159 |     |             cache.position.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.position.liquidity, cache.priceLower, locals.pricePrevious, false)
 160 |     |                                                                  : ConstantProduct.getDx(cache.position.liquidity, locals.pricePrevious, cache.priceUpper, false));
 161 |     |         }
 162 |     |         if (params.amount > 0) {
 163 |     |            // if tick hasn't been set back calculate amountIn
 164 |     |             if (params.zeroForOne ? cache.priceClaim > locals.pricePrevious
 165 |     |                                   : cache.priceClaim < locals.pricePrevious) {
 166 |     |                 // allow partial tick claim if removing liquidity
 167 |     |                 cache.position.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(params.amount, locals.pricePrevious, cache.priceClaim, false)
 168 |     |                                                                      : ConstantProduct.getDx(params.amount, cache.priceClaim, locals.pricePrevious, false));
 169 |     |             }
 170 |     |             // use priceClaim if tick hasn't been set back
 171 |     |             // else use claimPriceLast to calculate amountOut
 172 |     |             if (params.claim != (params.zeroForOne ? params.upper : params.lower)) {
 173 |     |                 cache.position.amountOut += uint128(params.zeroForOne ? ConstantProduct.getDx(params.amount, cache.priceClaim, cache.priceUpper, false)
 174 |     |                                                                       : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceClaim, false));
 175 |     |             }
 176 |     |         }
 177 |     |         // take protocol fee if needed
 178 |     |         if (cache.pool.protocolFee > 0 && cache.position.amountIn > 0) {
 179 |     |             uint128 protocolFeeAmount = cache.position.amountIn * cache.pool.protocolFee / 1e6;
 180 |     |             cache.position.amountIn -= protocolFeeAmount;
 181 |     |             cache.pool.protocolFees += protocolFeeAmount;
 182 |     |         }
 183 |     | 
 184 |     |         return cache;
 185 |     |     }
 186 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/EchidnaAssertions.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/ILimitPoolStructs.sol';
  5 |     | 
  6 |     | library EchidnaAssertions {
  7 |     | 
  8 |     |     event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);
  9 |     |     event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);
 10 |     |     event LiquidityUnlock(int128 liquidity);
 11 |     |     event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);
 12 |     |     event LiquidityDelta(int128 liquidityDelta);
 13 |     |     event WrongTickClaimedAt4(bool zeroForOne, int24 claimTickNext, int24 upper, int24 lower);
 14 |     |     event TickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing);
 15 |     | 
 16 |     |     function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {
 17 |     |         emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);
 18 |     |         assert(liquidityGlobal >= amount);
 19 |     |     }
 20 |     | 
 21 |     |     function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {
 22 |     |         emit LiquidityUnderflow(liquidity, amount, location);
 23 |     |         assert(liquidity >= amount);
 24 |     |     }
 25 |     | 
 26 |     |     function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {
 27 |     |         emit LiquidityUnlock(liquidity);
 28 |     |         assert(liquidity >= 0);
 29 |     |     }
 30 |     | 
 31 |     |     function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {
 32 |     |         emit PoolBalanceExceeded(poolBalance, outputAmount);
 33 |     |         assert(poolBalance >= outputAmount);
 34 |     |     }
 35 |     | 
 36 |     |     function assertWrongTickClaimedAt4(bool zeroForOne, int24 claimTickNext, int24 upper, int24 lower) internal {
 37 |     |         emit WrongTickClaimedAt4(zeroForOne, claimTickNext, upper, lower);
 38 |     |         assert(false);
 39 |     |     }
 40 |     | 
 41 |     |     function assertTickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing) internal {
 42 |     |         emit TickAtPriceDivisibleByTickSpacing(tick, priceAt, tickSpacing);
 43 |     |         if(tick % tickSpacing == 0) assert(priceAt == 0);
 44 |     |     }
 45 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/EpochMap.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './math/ConstantProduct.sol';
   5 |     | import '../interfaces/ILimitPoolStructs.sol';
   6 |     | 
   7 |     | library EpochMap {
   8 |     |     function set(
   9 |     |         int24  tick,
  10 |     |         uint256 epoch,
  11 |     |         ILimitPoolStructs.TickMap storage tickMap,
  12 |     |         ILimitPoolStructs.Immutables memory constants
  13 |     |     ) internal {
  14 |     |         (
  15 |     |             uint256 tickIndex,
  16 |     |             uint256 wordIndex,
  17 |     |             uint256 blockIndex,
  18 |     |             uint256 volumeIndex
  19 |     |         ) = getIndices(tick, constants);
  20 |     |         // assert epoch isn't bigger than max uint32
  21 |     |         uint256 epochValue = tickMap.epochs[volumeIndex][blockIndex][wordIndex];
  22 |     |         // clear previous value
  23 |     |         epochValue &=  ~(((1 << 9) - 1) << ((tickIndex & 0x7) * 32));
  24 |     |         // add new value to word
  25 |     |         epochValue |= epoch << ((tickIndex & 0x7) * 32);
  26 |     |         // store word in map
  27 |     |         tickMap.epochs[volumeIndex][blockIndex][wordIndex] = epochValue;
  28 |     |     }
  29 |     | 
  30 |     |     function unset(
  31 |     |         int24 tick,
  32 |     |         ILimitPoolStructs.TickMap storage tickMap,
  33 |     |         ILimitPoolStructs.Immutables memory constants
  34 |     |     ) internal {
  35 |     |         (
  36 |     |             uint256 tickIndex,
  37 |     |             uint256 wordIndex,
  38 |     |             uint256 blockIndex,
  39 |     |             uint256 volumeIndex
  40 |     |         ) = getIndices(tick, constants);
  41 |     | 
  42 |     |         uint256 epochValue = tickMap.epochs[volumeIndex][blockIndex][wordIndex];
  43 |     |         // clear previous value
  44 |     |         epochValue &= ~(1 << (tickIndex & 0x7 * 32) - 1);
  45 |     |         // store word in map
  46 |     |         tickMap.epochs[volumeIndex][blockIndex][wordIndex] = epochValue;
  47 |     |     }
  48 |     | 
  49 |     |     function get(
  50 |     |         int24 tick,
  51 |     |         ILimitPoolStructs.TickMap storage tickMap,
  52 |     |         ILimitPoolStructs.Immutables memory constants
  53 |     |     ) internal view returns (
  54 |     |         uint32 epoch
  55 |     |     ) {
  56 |     |         (
  57 |     |             uint256 tickIndex,
  58 |     |             uint256 wordIndex,
  59 |     |             uint256 blockIndex,
  60 |     |             uint256 volumeIndex
  61 |     |         ) = getIndices(tick, constants);
  62 |     | 
  63 |     |         uint256 epochValue = tickMap.epochs[volumeIndex][blockIndex][wordIndex];
  64 |     |         // right shift so first 8 bits are epoch value
  65 |     |         epochValue >>= ((tickIndex & 0x7) * 32);
  66 |     |         // clear other bits
  67 |     |         epochValue &= ((1 << 32) - 1);
  68 |     |         return uint32(epochValue);
  69 |     |     }
  70 |     | 
  71 |     |     function getIndices(
  72 |     |         int24 tick,
  73 |     |         ILimitPoolStructs.Immutables memory constants
  74 |     |     ) internal pure returns (
  75 |     |             uint256 tickIndex,
  76 |     |             uint256 wordIndex,
  77 |     |             uint256 blockIndex,
  78 |     |             uint256 volumeIndex
  79 |     |         )
  80 |     |     {
  81 |     |         unchecked {
  82 |     |             if (tick > ConstantProduct.maxTick(constants.tickSpacing)) require (false, 'TickIndexOverflow()');
  83 |     |             if (tick < ConstantProduct.minTick(constants.tickSpacing)) require (false, 'TickIndexUnderflow()');
  84 |     |             if (tick % (constants.tickSpacing / 2) != 0) {
  85 |     |                 require (false, 'TickIndexInvalid()');
  86 |     |             } 
  87 |     |             tickIndex = uint256(int256((_round(tick, constants.tickSpacing / 2) 
  88 |     |                                         - _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2)) 
  89 |     |                                         / (constants.tickSpacing / 2)));
  90 |     |             wordIndex = tickIndex >> 3;        // 2^3 epochs per word
  91 |     |             blockIndex = tickIndex >> 11;      // 2^8 words per block
  92 |     |             volumeIndex = tickIndex >> 19;     // 2^8 blocks per volume
  93 |     |             if (blockIndex > 2046) require (false, 'BlockIndexOverflow()');
  94 |     |         }
  95 |     |     }
  96 |     | 
  97 |     |     function _tick (
  98 |     |         uint256 tickIndex,
  99 |     |         ILimitPoolStructs.Immutables memory constants
 100 |     |     ) internal pure returns (
 101 |     |         int24 tick
 102 |     |     ) {
 103 |     |         unchecked {
 104 |     |             if (tickIndex > uint24(_round(ConstantProduct.MAX_TICK, constants.tickSpacing) * 2) * 2) 
 105 |     |                 require(false, 'TickIndexOverflow()');
 106 |     |             tick = int24(int256(tickIndex) * (constants.tickSpacing / 2) + _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2));
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     function _round(
 111 |     |         int24 tick,
 112 |     |         int24 tickSpacing
 113 |     |     ) internal pure returns (
 114 |     |         int24 roundedTick
 115 |     |     ) {
 116 |     |         return tick / tickSpacing * tickSpacing;
 117 |     |     }
 118 |     | }
 119 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/Positions.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/modules/curves/ICurveMath.sol';
   5 |     | import './Ticks.sol';
   6 |     | import '../interfaces/ILimitPoolStructs.sol';
   7 |     | import './math/OverflowMath.sol';
   8 |     | import '../interfaces/modules/curves/ICurveMath.sol';
   9 |     | import './Claims.sol';
  10 |     | import './EpochMap.sol';
  11 |     | import './utils/SafeCast.sol';
  12 |     | import './pool/SwapCall.sol';
  13 |     | import './EchidnaAssertions.sol';
  14 |     | 
  15 |     | /// @notice Position management library for ranged liquidity.
  16 |     | library Positions {
  17 |     |     using SafeCast for uint256;
  18 |     | 
  19 |     |     event BurnLimit(
  20 |     |         address indexed to,
  21 |     |         int24 lower,
  22 |     |         int24 upper,
  23 |     |         int24 claim,
  24 |     |         bool zeroForOne,
  25 |     |         uint128 liquidityBurned,
  26 |     |         uint128 tokenInClaimed,
  27 |     |         uint128 tokenOutBurned
  28 |     |     );
  29 |     | 
  30 |     |     function resize(
  31 |     |         ILimitPoolStructs.MintParams memory params,
  32 |     |         ILimitPoolStructs.MintCache memory cache,
  33 |     |         ILimitPoolStructs.TickMap storage tickMap,
  34 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage swapTicks
  35 |     |     ) internal returns (
  36 |     |         ILimitPoolStructs.MintParams memory,
  37 |     |         ILimitPoolStructs.MintCache memory
  38 |     |     )
  39 |     |     {
  40 |     |         ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);
  41 |     | 
  42 |     |         cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
  43 |     |         cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
  44 |     | 
  45 |     |         // cannot mint empty position
  46 |     |         if (params.amount == 0) require (false, 'PositionAmountZero()');
  47 |     | 
  48 |     |         cache.mintSize = uint256(params.mintPercent) * uint256(params.amount) / 1e28;
  49 |     |         // calculate L constant
  50 |     |         cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
  51 |     |             cache.priceLower,
  52 |     |             cache.priceUpper,
  53 |     |             params.zeroForOne ? cache.priceLower : cache.priceUpper,
  54 |     |             params.zeroForOne ? 0 : uint256(params.amount),
  55 |     |             params.zeroForOne ? uint256(params.amount) : 0
  56 |     |         );
  57 |     | 
  58 |     |         if (cache.liquidityMinted == 0) require (false, 'PositionLiquidityZero()');
  59 |     |         // calculate price limit by using half of input
  60 |     |         {
  61 |     |             cache.priceLimit = params.zeroForOne ? ConstantProduct.getNewPrice(cache.priceUpper, cache.liquidityMinted, params.amount / 2, true, true)
  62 |     |                                                  : ConstantProduct.getNewPrice(cache.priceLower, cache.liquidityMinted, params.amount / 2, false, true);
  63 |     |             if (cache.priceLimit == 0) require (false, 'PriceLimitZero()');
  64 |     |             // get tick at price
  65 |     |             cache.tickLimit = ConstantProduct.getTickAtPrice(cache.priceLimit.toUint160(), cache.constants);
  66 |     |             // round to nearest tick spacing
  67 |     |             cache.priceLimit = ConstantProduct.getPriceAtTick(cache.tickLimit, cache.constants);
  68 |     |         }
  69 |     | 
  70 |     |         ILimitPoolStructs.SwapCache memory swapCache;
  71 |     |         swapCache.pool = cache.swapPool;
  72 |     |         swapCache.state = cache.state;
  73 |     |         swapCache.constants = cache.constants;
  74 |     | 
  75 |     |         // sync up pool epochs for position epoch stamping
  76 |     |         if (cache.pool.swapEpoch < cache.swapPool.swapEpoch)
  77 |     |             cache.pool.swapEpoch = cache.swapPool.swapEpoch;
  78 |     |         else if (cache.swapPool.swapEpoch < cache.pool.swapEpoch)
  79 |     |             cache.swapPool.swapEpoch = cache.pool.swapEpoch;
  80 |     | 
  81 |     |         // only swap if priceLimit is beyond current pool price
  82 |     |         if (params.zeroForOne ? cache.priceLimit < cache.swapPool.price
  83 |     |                               : cache.priceLimit > cache.swapPool.price) {
  84 |     |             // swap and save the pool state
  85 |     |             (cache.swapPool, swapCache) = Ticks.swap(
  86 |     |                 swapTicks,
  87 |     |                 tickMap,
  88 |     |                 ILimitPoolStructs.SwapParams({
  89 |     |                     to: params.to,
  90 |     |                     priceLimit: cache.priceLimit.toUint160(),
  91 |     |                     amount: params.amount,
  92 |     |                     //TODO: handle exactOut
  93 |     |                     exactIn: true,
  94 |     |                     zeroForOne: params.zeroForOne,
  95 |     |                     callbackData: abi.encodePacked(bytes1(0x0))
  96 |     |                 }),
  97 |     |                 swapCache,
  98 |     |                 cache.swapPool
  99 |     |             );
 100 |     |             // subtract from remaining input amount
 101 |     |             params.amount -= uint128(swapCache.input);
 102 |     |         }
 103 |     | 
 104 |     |         if (params.amount < cache.mintSize) params.amount = 0;
 105 |     |         // move start tick based on amount filled in swap
 106 |     |         if ((params.amount > 0 && swapCache.input > 0) ||
 107 |     |             (params.zeroForOne ? cache.priceLower < cache.swapPool.price
 108 |     |                                : cache.priceUpper > cache.swapPool.price)
 109 |     |         ) {
 110 |     |             // move the tick limit based on pool.tickAtPrice
 111 |     |             if (params.zeroForOne ? cache.priceLower < cache.swapPool.price
 112 |     |                                   : cache.priceUpper > cache.swapPool.price) {
 113 |     |                 cache.tickLimit = cache.swapPool.tickAtPrice;
 114 |     |             }
 115 |     |             // round ahead tickLimit to avoid crossing epochs
 116 |     |             cache.tickLimit = TickMap.roundAhead(cache.tickLimit, cache.constants, params.zeroForOne, cache.swapPool.price);
 117 |     |             if (params.zeroForOne) {
 118 |     |                 if (cache.priceLower < cache.swapPool.price) {
 119 |     |                     // if rounding goes past limit trim position
 120 |     |                     /// @dev - if swap didn't go to limit user would be 100% filled
 121 |     |                     params.lower = cache.tickLimit;
 122 |     |                     cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 123 |     |                 }
 124 |     |                 if (params.lower == params.upper && params.upper < ConstantProduct.maxTick(cache.constants.tickSpacing)) {
 125 |     |                     params.upper += cache.constants.tickSpacing;
 126 |     |                 }
 127 |     |                 cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 128 |     |             } else {
 129 |     |                 if (cache.priceUpper > cache.swapPool.price) {
 130 |     |                     // if rounding goes past limit trim position
 131 |     |                     params.upper = cache.tickLimit;
 132 |     |                     cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 133 |     |                 }
 134 |     |                 if (params.upper == params.lower && params.lower > ConstantProduct.minTick(cache.constants.tickSpacing)) {
 135 |     |                     params.lower -= cache.constants.tickSpacing;
 136 |     |                 }
 137 |     |                 cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 138 |     |             }
 139 |     |             if (params.amount > 0 && params.lower < params.upper)
 140 |     |                 cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
 141 |     |                     cache.priceLower,
 142 |     |                     cache.priceUpper,
 143 |     |                     params.zeroForOne ? cache.priceLower : cache.priceUpper,
 144 |     |                     params.zeroForOne ? 0 : uint256(params.amount),
 145 |     |                     params.zeroForOne ? uint256(params.amount) : 0
 146 |     |                 );
 147 |     |             else
 148 |     |                 /// @auditor unnecessary since params.amount is 0
 149 |     |                 cache.liquidityMinted = 0;
 150 |     |             cache.pool.swapEpoch += 1;
 151 |     |         }
 152 |     |         // save swapCache
 153 |     |         cache.swapCache = swapCache;
 154 |     | 
 155 |     |         console.log('amount left for position', params.amount);
 156 |     | 
 157 |     |         return (
 158 |     |             params,
 159 |     |             cache
 160 |     |         );
 161 |     |     }
 162 |     | 
 163 |     |     function add(
 164 |     |         ILimitPoolStructs.MintCache memory cache,
 165 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 166 |     |         ILimitPoolStructs.TickMap storage tickMap,
 167 |     |         ILimitPoolStructs.MintParams memory params
 168 |     |     ) internal returns (
 169 |     |         ILimitPoolStructs.PoolState memory,
 170 |     |         ILimitPoolStructs.Position memory
 171 |     |     ) {
 172 |     |         if (cache.liquidityMinted == 0) return (cache.pool, cache.position);
 173 |     | 
 174 |     |         if (cache.position.liquidity == 0) {
 175 |     |             cache.position.epochLast = cache.pool.swapEpoch;
 176 |     |         } else {
 177 |     |             // safety check in case we somehow get here
 178 |     |             if (
 179 |     |                 params.zeroForOne
 180 |     |                     ? EpochMap.get(params.lower, tickMap, cache.constants)
 181 |     |                             > cache.position.epochLast
 182 |     |                     : EpochMap.get(params.upper, tickMap, cache.constants)
 183 |     |                             > cache.position.epochLast
 184 |     |             ) {
 185 |     |                 require (false, string.concat('UpdatePositionFirstAt(', String.from(params.lower), ', ', String.from(params.upper), ')'));
 186 |     |             }
 187 |     |             /// @auditor maybe this shouldn't be a revert but rather just not mint the position?
 188 |     |         }
 189 |     |         
 190 |     |         // add liquidity to ticks
 191 |     |         Ticks.insert(
 192 |     |             ticks,
 193 |     |             tickMap,
 194 |     |             cache,
 195 |     |             params
 196 |     |         );
 197 |     | 
 198 |     |         // update liquidity global
 199 |     |         cache.pool.liquidityGlobal += uint128(cache.liquidityMinted);
 200 |     | 
 201 |     |         cache.position.liquidity += uint128(cache.liquidityMinted);
 202 |     | 
 203 |     |         return (cache.pool, cache.position);
 204 |     |     }
 205 |     | 
 206 |     |     function remove(
 207 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
 208 |     |             storage positions,
 209 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 210 |     |         ILimitPoolStructs.TickMap storage tickMap,
 211 |     |         ILimitPoolStructs.PoolState memory pool,
 212 |     |         ILimitPoolStructs.UpdateParams memory params,
 213 |     |         ILimitPoolStructs.Immutables memory constants
 214 |     |     ) internal returns (
 215 |     |         ILimitPoolStructs.PoolState memory,
 216 |     |         ILimitPoolStructs.Position memory
 217 |     |     ) {
 218 |     |         // initialize cache
 219 |     |         ILimitPoolStructs.UpdateCache memory cache;
 220 |     |         cache.position = positions[msg.sender][params.lower][params.upper];
 221 |     |         cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, constants);
 222 |     |         cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, constants);
 223 |     |         cache.removeLower = true; cache.removeUpper = true;
 224 |     | 
 225 |     |         // convert percentage to liquidity amount
 226 |     |         params.amount = _convert(cache.position.liquidity, params.amount);
 227 |     | 
 228 |     |         // early return if no liquidity to remove
 229 |     |         if (params.amount == 0) return (pool, cache.position);
 230 |     |         if (params.amount > cache.position.liquidity) {
 231 |     |             require (false, 'NotEnoughPositionLiquidity()');
 232 |     |         }
 233 |     |         /// @dev - validate position has not been crossed into
 234 |     |         if (params.zeroForOne) {
 235 |     |             if (EpochMap.get(params.lower, tickMap, constants)
 236 |     |                         > cache.position.epochLast) {
 237 |     |                 int24 nextTick = TickMap.next(tickMap, params.lower, constants.tickSpacing, false);
 238 |     |                 if (pool.price > cache.priceLower ||
 239 |     |                     EpochMap.get(nextTick, tickMap, constants)
 240 |     |                         > cache.position.epochLast) {
 241 |     |                     require (false, 'WrongTickClaimedAt7()');            
 242 |     |                 }
 243 |     |                 if (pool.price == cache.priceLower) {
 244 |     |                     EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, "PLU-1");
 245 |     |                     pool.liquidity -= params.amount;
 246 |     |                 }
 247 |     |             }
 248 |     |             // if pool price is further along
 249 |     |             // OR next tick has a greater epoch
 250 |     |         } else {
 251 |     |             if (EpochMap.get(params.upper, tickMap, constants)
 252 |     |                         > cache.position.epochLast) {
 253 |     |                 int24 previousTick = TickMap.previous(tickMap, params.upper, constants.tickSpacing, false);
 254 |     |                 if (pool.price < cache.priceUpper ||
 255 |     |                     EpochMap.get(previousTick, tickMap, constants)
 256 |     |                         > cache.position.epochLast) {
 257 |     |                     require (false, 'WrongTickClaimedAt8()');            
 258 |     |                 }
 259 |     |                 if (pool.price == cache.priceUpper) {
 260 |     |                     EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, "PLU-2");
 261 |     |                     pool.liquidity -= params.amount;
 262 |     |                 }
 263 |     |             }
 264 |     |         }
 265 |     | 
 266 |     |         Ticks.remove(
 267 |     |             ticks,
 268 |     |             tickMap,
 269 |     |             cache,
 270 |     |             params,
 271 |     |             constants
 272 |     |         );
 273 |     | 
 274 |     |         // update liquidity global
 275 |     |         EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, params.amount, "LGU-1");
 276 |     |         pool.liquidityGlobal -= params.amount;
 277 |     | 
 278 |     |         cache.position.amountOut += uint128(
 279 |     |             params.zeroForOne
 280 |     |                 ? ConstantProduct.getDx(params.amount, cache.priceLower, cache.priceUpper, false)
 281 |     |                 : ConstantProduct.getDy(params.amount, cache.priceLower, cache.priceUpper, false)
 282 |     |         );
 283 |     | 
 284 |     |         cache.position.liquidity -= uint128(params.amount);
 285 |     |         positions[msg.sender][params.lower][params.upper] = cache.position;
 286 |     | 
 287 |     |         if (params.amount > 0) {
 288 |     |             emit BurnLimit(
 289 |     |                     params.to,
 290 |     |                     params.lower,
 291 |     |                     params.upper,
 292 |     |                     params.zeroForOne ? params.lower : params.upper,
 293 |     |                     params.zeroForOne,
 294 |     |                     params.amount,
 295 |     |                     0,
 296 |     |                     cache.position.amountOut
 297 |     |             );
 298 |     |         }
 299 |     |         return (pool, cache.position);
 300 |     |     }
 301 |     | 
 302 |     |     function update(
 303 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
 304 |     |             storage positions,
 305 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 306 |     |         ILimitPoolStructs.TickMap storage tickMap,
 307 |     |         ILimitPoolStructs.GlobalState memory state,
 308 |     |         ILimitPoolStructs.PoolState memory pool,
 309 |     |         ILimitPoolStructs.UpdateParams memory params,
 310 |     |         ILimitPoolStructs.Immutables memory constants
 311 |     |     ) internal returns (
 312 |     |         ILimitPoolStructs.GlobalState memory,
 313 |     |         ILimitPoolStructs.PoolState memory,
 314 |     |         ILimitPoolStructs.Position memory,
 315 |     |         int24
 316 |     |     )
 317 |     |     {
 318 |     |         ILimitPoolStructs.UpdateCache memory cache;
 319 |     |         (
 320 |     |             params,
 321 |     |             cache,
 322 |     |             state
 323 |     |         ) = _deltas(
 324 |     |             positions,
 325 |     |             ticks,
 326 |     |             tickMap,
 327 |     |             state,
 328 |     |             pool,
 329 |     |             params,
 330 |     |             constants
 331 |     |         );
 332 |     | 
 333 |     |         if (cache.earlyReturn)
 334 |     |             return (state, pool, cache.position, params.claim);
 335 |     | 
 336 |     |         // update pool liquidity
 337 |     |         if (cache.priceClaim == pool.price && params.amount > 0) {
 338 |     |             // handle pool.price at edge of range
 339 |     |             if (params.zeroForOne ? cache.priceClaim < cache.priceUpper
 340 |     |                                   : cache.priceClaim > cache.priceLower) {
 341 |     |                 EchidnaAssertions.assertLiquidityUnderflows(pool.liquidity, params.amount, "PLU-3");
 342 |     |                 pool.liquidity -= params.amount;
 343 |     |             }
 344 |     |         }
 345 |     | 
 346 |     | 
 347 |     |         if (params.amount > 0) {
 348 |     |             if (params.claim == (params.zeroForOne ? params.upper : params.lower)) {
 349 |     |                 // only remove once if final tick of position
 350 |     |                 cache.removeLower = false;
 351 |     |                 cache.removeUpper = false;
 352 |     |             } else {
 353 |     |                 params.zeroForOne ? cache.removeUpper = true 
 354 |     |                                   : cache.removeLower = true;
 355 |     |             }
 356 |     |             if (params.zeroForOne) {
 357 |     |                 if (params.claim == params.lower && 
 358 |     |                     cache.pool.price < cache.priceLower
 359 |     |                 ) {
 360 |     |                     cache.removeLower = true;
 361 |     |                 } else if (params.claim % constants.tickSpacing != 0 && 
 362 |     |                     cache.pool.price < cache.priceClaim)
 363 |     |                     cache.removeLower = true;
 364 |     |             } else {
 365 |     |                 if (params.claim == params.upper &&
 366 |     |                     cache.pool.price > cache.priceUpper
 367 |     |                 )
 368 |     |                     cache.removeUpper = true;
 369 |     |                 else if (params.claim % constants.tickSpacing != 0 &&
 370 |     |                             cache.pool.price > cache.priceClaim)
 371 |     |                     cache.removeUpper = true;
 372 |     |             }
 373 |     |             Ticks.remove(
 374 |     |                 ticks,
 375 |     |                 tickMap,
 376 |     |                 cache,
 377 |     |                 params,
 378 |     |                 constants
 379 |     |             );
 380 |     |             // update position liquidity
 381 |     |             cache.position.liquidity -= uint128(params.amount);
 382 |     |             // update global liquidity
 383 |     |             EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, params.amount, "LGU-2");
 384 |     |             pool.liquidityGlobal -= params.amount;
 385 |     |         }
 386 |     |         if (params.zeroForOne ? params.claim == params.upper
 387 |     |                               : params.claim == params.lower) {
 388 |     |             EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, cache.position.liquidity, "LGU-3");
 389 |     |             pool.liquidityGlobal -= cache.position.liquidity;
 390 |     |             // set params.amount for BurnLimit event
 391 |     |             params.amount = cache.position.liquidity;
 392 |     |             cache.position.liquidity = 0;
 393 |     |         }
 394 |     |         // clear out old position
 395 |     |         if (params.zeroForOne ? params.claim != params.lower 
 396 |     |                               : params.claim != params.upper) {
 397 |     |             
 398 |     |             /// @dev - this also clears out position end claims
 399 |     |             if (params.zeroForOne ? params.claim == params.lower 
 400 |     |                                   : params.claim == params.upper) {
 401 |     |                 // subtract remaining position liquidity out from global
 402 |     |                 EchidnaAssertions.assertLiquidityGlobalUnderflows(pool.liquidityGlobal, cache.position.liquidity, "LGU-4");
 403 |     |                 pool.liquidityGlobal -= cache.position.liquidity;
 404 |     |             }
 405 |     |             delete positions[msg.sender][params.lower][params.upper];
 406 |     |         }
 407 |     |         // clear position if empty
 408 |     |         if (cache.position.liquidity == 0) {
 409 |     |             cache.position.epochLast = 0;
 410 |     |             cache.position.crossedInto = false;
 411 |     |         }
 412 |     | 
 413 |     |         // round back claim tick for storage
 414 |     |         if (params.claim % constants.tickSpacing != 0)
 415 |     |             params.claim = TickMap.roundBack(params.claim, constants, params.zeroForOne, cache.priceClaim);
 416 |     |         
 417 |     |         emit BurnLimit(
 418 |     |             params.to,
 419 |     |             params.lower,
 420 |     |             params.upper,
 421 |     |             params.claim,
 422 |     |             params.zeroForOne,
 423 |     |             params.amount,
 424 |     |             cache.position.amountIn,
 425 |     |             cache.position.amountOut
 426 |     |         );
 427 |     |         // return cached position in memory and transfer out
 428 |     |         return (state, pool, cache.position, params.claim);
 429 |     |     }
 430 |     | 
 431 |     |     function snapshot(
 432 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
 433 |     |             storage positions,
 434 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 435 |     |         ILimitPoolStructs.TickMap storage tickMap,
 436 |     |         ILimitPoolStructs.GlobalState memory state,
 437 |     |         ILimitPoolStructs.PoolState memory pool,
 438 |     |         ILimitPoolStructs.UpdateParams memory params,
 439 |     |         ILimitPoolStructs.Immutables memory constants
 440 |     |     ) internal returns (
 441 |     |         ILimitPoolStructs.Position memory
 442 |     |     ) {
 443 |     |         ILimitPoolStructs.UpdateCache memory cache;
 444 |     |         (
 445 |     |             params,
 446 |     |             cache,
 447 |     |             state
 448 |     |         ) = _deltas(
 449 |     |             positions,
 450 |     |             ticks,
 451 |     |             tickMap,
 452 |     |             state,
 453 |     |             pool,
 454 |     |             params,
 455 |     |             constants
 456 |     |         );
 457 |     | 
 458 |     |         if (cache.earlyReturn)
 459 |     |             return (cache.position);
 460 |     | 
 461 |     |         if (params.amount > 0) {
 462 |     |             cache.position.liquidity -= uint128(params.amount);
 463 |     |         }
 464 |     |         
 465 |     |         // clear position values if empty
 466 |     |         if (cache.position.liquidity == 0) {
 467 |     |             cache.position.epochLast = 0;
 468 |     |             cache.position.crossedInto = false;
 469 |     |         }    
 470 |     |         return cache.position;
 471 |     |     }
 472 |     | 
 473 |     |     function _convert(
 474 |     |         uint128 liquidity,
 475 |     |         uint128 percent
 476 |     |     ) internal pure returns (
 477 |     |         uint128
 478 |     |     ) {
 479 |     |         // convert percentage to liquidity amount
 480 |     |         if (percent > 1e38) percent = 1e38;
 481 |     |         if (liquidity == 0 && percent > 0) require (false, 'PositionNotFound()');
 482 |     |         return uint128(uint256(liquidity) * uint256(percent) / 1e38);
 483 |     |     }
 484 |     | 
 485 |     |     function _deltas(
 486 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
 487 |     |             storage positions,
 488 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 489 |     |         ILimitPoolStructs.TickMap storage tickMap,
 490 |     |         ILimitPoolStructs.GlobalState memory state,
 491 |     |         ILimitPoolStructs.PoolState memory pool,
 492 |     |         ILimitPoolStructs.UpdateParams memory params,
 493 |     |         ILimitPoolStructs.Immutables memory constants
 494 |     |     ) internal returns (
 495 |     |         ILimitPoolStructs.UpdateParams memory,
 496 |     |         ILimitPoolStructs.UpdateCache memory,
 497 |     |         ILimitPoolStructs.GlobalState memory
 498 |     |     ) {
 499 |     |         ILimitPoolStructs.UpdateCache memory cache = ILimitPoolStructs.UpdateCache({
 500 |     |             position: positions[params.owner][params.lower][params.upper],
 501 |     |             pool: pool,
 502 |     |             priceLower: ConstantProduct.getPriceAtTick(params.lower, constants),
 503 |     |             priceClaim: ConstantProduct.getPriceAtTick(params.claim, constants),
 504 |     |             priceUpper: ConstantProduct.getPriceAtTick(params.upper, constants),
 505 |     |             claimTick: ticks[params.claim],
 506 |     |             earlyReturn: false,
 507 |     |             removeLower: false,
 508 |     |             removeUpper: false
 509 |     |         });
 510 |     | 
 511 |     |         params.amount = _convert(cache.position.liquidity, params.amount);
 512 |     | 
 513 |     |         // check claim is valid
 514 |     |         (params, cache) = Claims.validate(
 515 |     |             positions,
 516 |     |             ticks,
 517 |     |             tickMap,
 518 |     |             cache.pool,
 519 |     |             params,
 520 |     |             cache,
 521 |     |             constants
 522 |     |         );
 523 |     |         if (cache.earlyReturn) {
 524 |     |             return (params, cache, state);
 525 |     |         }
 526 |     |         // calculate position deltas
 527 |     |         cache = Claims.getDeltas(cache, params, constants);
 528 |     | 
 529 |     |         return (params, cache, state);
 530 |     |     }
 531 |     | }
 532 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/TickMap.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './math/ConstantProduct.sol';
   5 |     | import '../interfaces/ILimitPool.sol';
   6 |     | import '../interfaces/ILimitPoolStructs.sol';
   7 |     | 
   8 |     | library TickMap {
   9 |     | 
  10 |     |     error TickIndexOverflow();
  11 |     |     error TickIndexUnderflow();
  12 |     |     error TickIndexBadSpacing();
  13 |     |     error BlockIndexOverflow();
  14 |     | 
  15 |     |     function get(
  16 |     |         ILimitPoolStructs.TickMap storage tickMap,
  17 |     |         int24 tick,
  18 |     |         int24 tickSpacing
  19 |     |     ) internal view returns (
  20 |     |         bool exists
  21 |     |     ) {
  22 |     |         (
  23 |     |             uint256 tickIndex,
  24 |     |             uint256 wordIndex,
  25 |     |         ) = getIndices(tick, tickSpacing);
  26 |     | 
  27 |     |         // check if bit is already set
  28 |     |         uint256 word = tickMap.ticks[wordIndex] | 1 << (tickIndex & 0xFF);
  29 |     |         if (word == tickMap.ticks[wordIndex]) {
  30 |     |             return true;
  31 |     |         }
  32 |     |         return false;
  33 |     |     }
  34 |     | 
  35 |     |     function set(
  36 |     |         ILimitPoolStructs.TickMap storage tickMap,
  37 |     |         int24 tick,
  38 |     |         int24 tickSpacing
  39 |     |     ) internal returns (
  40 |     |         bool exists
  41 |     |     ) {
  42 |     |         (
  43 |     |             uint256 tickIndex,
  44 |     |             uint256 wordIndex,
  45 |     |             uint256 blockIndex
  46 |     |         ) = getIndices(tick, tickSpacing);
  47 |     | 
  48 |     |         // check if bit is already set
  49 |     |         uint256 word = tickMap.ticks[wordIndex] | 1 << (tickIndex & 0xFF);
  50 |     |         if (word == tickMap.ticks[wordIndex]) {
  51 |     |             return true;
  52 |     |         }
  53 |     | 
  54 |     |         tickMap.ticks[wordIndex]     = word; 
  55 |     |         tickMap.words[blockIndex]   |= 1 << (wordIndex & 0xFF); // same as modulus 255
  56 |     |         tickMap.blocks              |= 1 << blockIndex;
  57 |     |         return false;
  58 |     |     }
  59 |     | 
  60 |     |     function unset(
  61 |     |         ILimitPoolStructs.TickMap storage tickMap,
  62 |     |         int24 tick,
  63 |     |         int16 tickSpacing
  64 |     |     ) internal {
  65 |     |         (
  66 |     |             uint256 tickIndex,
  67 |     |             uint256 wordIndex,
  68 |     |             uint256 blockIndex
  69 |     |         ) = getIndices(tick, tickSpacing);
  70 |     | 
  71 |     |         tickMap.ticks[wordIndex] &= ~(1 << (tickIndex & 0xFF));
  72 |     |         if (tickMap.ticks[wordIndex] == 0) {
  73 |     |             tickMap.words[blockIndex] &= ~(1 << (wordIndex & 0xFF));
  74 |     |             if (tickMap.words[blockIndex] == 0) {
  75 |     |                 tickMap.blocks &= ~(1 << blockIndex);
  76 |     |             }
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 |     |     function previous(
  81 |     |         ILimitPoolStructs.TickMap storage tickMap,
  82 |     |         int24 tick,
  83 |     |         int16 tickSpacing,
  84 |     |         bool inclusive
  85 |     |     ) internal view returns (
  86 |     |         int24 previousTick
  87 |     |     ) {
  88 |     |         unchecked {
  89 |     |             // rounds up to ensure relative position
  90 |     |             if (tick % (tickSpacing / 2) != 0 || inclusive) {
  91 |     |                 if (tick < (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {
  92 |     |                     /// @dev - ensures we cross when tick >= 0
  93 |     |                     if (tick >= 0) {
  94 |     |                         tick += tickSpacing / 2;
  95 |     |                     } else if (inclusive && tick % (tickSpacing / 2) == 0) {
  96 |     |                     /// @dev - ensures we cross when tick == tickAtPrice
  97 |     |                         tick += tickSpacing / 2;
  98 |     |                     }
  99 |     |                 }
 100 |     |             }
 101 |     |             (
 102 |     |               uint256 tickIndex,
 103 |     |               uint256 wordIndex,
 104 |     |               uint256 blockIndex
 105 |     |             ) = getIndices(tick, tickSpacing);
 106 |     | 
 107 |     |             uint256 word = tickMap.ticks[wordIndex] & ((1 << (tickIndex & 0xFF)) - 1);
 108 |     |             if (word == 0) {
 109 |     |                 uint256 block_ = tickMap.words[blockIndex] & ((1 << (wordIndex & 0xFF)) - 1);
 110 |     |                 if (block_ == 0) {
 111 |     |                     uint256 blockMap = tickMap.blocks & ((1 << blockIndex) - 1);
 112 |     |                     if (blockMap == 0) return tick;
 113 |     | 
 114 |     |                     blockIndex = _msb(blockMap);
 115 |     |                     block_ = tickMap.words[blockIndex];
 116 |     |                 }
 117 |     |                 wordIndex = (blockIndex << 8) | _msb(block_);
 118 |     |                 word = tickMap.ticks[wordIndex];
 119 |     |             }
 120 |     |             previousTick = _tick((wordIndex << 8) | _msb(word), tickSpacing);
 121 |     |         }
 122 |     |     }
 123 |     | 
 124 |     |     function next(
 125 |     |         ILimitPoolStructs.TickMap storage tickMap,
 126 |     |         int24 tick,
 127 |     |         int16 tickSpacing,
 128 |     |         bool inclusive
 129 |     |     ) internal view returns (
 130 |     |         int24 nextTick
 131 |     |     ) {
 132 |     |         unchecked {
 133 |     |             /// @dev - handles tickAtPrice being past tickSpacing / 2
 134 |     |             if (inclusive && tick % tickSpacing != 0) {
 135 |     |                 tick -= 1;
 136 |     |             }
 137 |     |             /// @dev - handles negative ticks rounding up
 138 |     |             if (tick % (tickSpacing / 2) != 0) {
 139 |     |                 if (tick < 0)
 140 |     |                     if (tick > (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))
 141 |     |                         tick -= tickSpacing / 2;
 142 |     |             }
 143 |     |             (
 144 |     |               uint256 tickIndex,
 145 |     |               uint256 wordIndex,
 146 |     |               uint256 blockIndex
 147 |     |             ) = getIndices(tick, tickSpacing);
 148 |     |             uint256 word;
 149 |     |             if ((tickIndex & 0xFF) != 255) {
 150 |     |                 word = tickMap.ticks[wordIndex] & ~((1 << ((tickIndex & 0xFF) + 1)) - 1);
 151 |     |             }
 152 |     |             if (word == 0) {
 153 |     |                 uint256 block_;
 154 |     |                 if ((blockIndex & 0xFF) != 255) {
 155 |     |                     block_ = tickMap.words[blockIndex] & ~((1 << ((wordIndex & 0xFF) + 1)) - 1);
 156 |     |                 }
 157 |     |                 if (block_ == 0) {
 158 |     |                     uint256 blockMap = tickMap.blocks & ~((1 << blockIndex + 1) - 1);
 159 |     |                     if (blockMap == 0) return tick;
 160 |     |                     blockIndex = _lsb(blockMap);
 161 |     |                     block_ = tickMap.words[blockIndex];
 162 |     |                 }
 163 |     |                 wordIndex = (blockIndex << 8) | _lsb(block_);
 164 |     |                 word = tickMap.ticks[wordIndex];
 165 |     |             }
 166 |     |             nextTick = _tick((wordIndex << 8) | _lsb(word), tickSpacing);
 167 |     |         }
 168 |     |     }
 169 |     | 
 170 |     |     function getIndices(
 171 |     |         int24 tick,
 172 |     |         int24 tickSpacing
 173 |     |     ) internal pure returns (
 174 |     |             uint256 tickIndex,
 175 |     |             uint256 wordIndex,
 176 |     |             uint256 blockIndex
 177 |     |         )
 178 |     |     {
 179 |     |         unchecked {
 180 |     |             if (tick > ConstantProduct.MAX_TICK) require(false, ' TickIndexOverflow()');
 181 |     |             if (tick < ConstantProduct.MIN_TICK) require(false, 'TickIndexUnderflow()');
 182 |     |             if (tick % (tickSpacing / 2) != 0) tick = round(tick, tickSpacing / 2);
 183 |     |             tickIndex = uint256(int256((round(tick, tickSpacing / 2) 
 184 |     |                                         - round(ConstantProduct.MIN_TICK, tickSpacing / 2)) 
 185 |     |                                         / (tickSpacing / 2)));
 186 |     |             wordIndex = tickIndex >> 8;   // 2^8 ticks per word
 187 |     |             blockIndex = tickIndex >> 16; // 2^8 words per block
 188 |     |             if (blockIndex > 255) require(false, 'BlockIndexOverflow()');
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 |     | 
 193 |     | 
 194 |     |     function _tick (
 195 |     |         uint256 tickIndex,
 196 |     |         int24 tickSpacing
 197 |     |     ) internal pure returns (
 198 |     |         int24 tick
 199 |     |     ) {
 200 |     |         unchecked {
 201 |     |             if (tickIndex > uint24(round(ConstantProduct.MAX_TICK, tickSpacing) * 2) * 2) 
 202 |     |                 require(false, 'TickIndexOverflow()');
 203 |     |             tick = int24(int256(tickIndex) * (tickSpacing / 2) + round(ConstantProduct.MIN_TICK, tickSpacing / 2));
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     function _msb(
 208 |     |         uint256 x
 209 |     |     ) internal pure returns (
 210 |     |         uint8 r
 211 |     |     ) {
 212 |     |         unchecked {
 213 |     |             assert(x > 0);
 214 |     |             if (x >= 0x100000000000000000000000000000000) {
 215 |     |                 x >>= 128;
 216 |     |                 r += 128;
 217 |     |             }
 218 |     |             if (x >= 0x10000000000000000) {
 219 |     |                 x >>= 64;
 220 |     |                 r += 64;
 221 |     |             }
 222 |     |             if (x >= 0x100000000) {
 223 |     |                 x >>= 32;
 224 |     |                 r += 32;
 225 |     |             }
 226 |     |             if (x >= 0x10000) {
 227 |     |                 x >>= 16;
 228 |     |                 r += 16;
 229 |     |             }
 230 |     |             if (x >= 0x100) {
 231 |     |                 x >>= 8;
 232 |     |                 r += 8;
 233 |     |             }
 234 |     |             if (x >= 0x10) {
 235 |     |                 x >>= 4;
 236 |     |                 r += 4;
 237 |     |             }
 238 |     |             if (x >= 0x4) {
 239 |     |                 x >>= 2;
 240 |     |                 r += 2;
 241 |     |             }
 242 |     |             if (x >= 0x2) r += 1;
 243 |     |         }
 244 |     |     }
 245 |     | 
 246 |     |     function _lsb(
 247 |     |         uint256 x
 248 |     |     ) internal pure returns (
 249 |     |         uint8 r
 250 |     |     ) {
 251 |     |         unchecked {
 252 |     |             assert(x > 0); // if x is 0 return 0
 253 |     |             r = 255;
 254 |     |             if (x & type(uint128).max > 0) {
 255 |     |                 r -= 128;
 256 |     |             } else {
 257 |     |                 x >>= 128;
 258 |     |             }
 259 |     |             if (x & type(uint64).max > 0) {
 260 |     |                 r -= 64;
 261 |     |             } else {
 262 |     |                 x >>= 64;
 263 |     |             }
 264 |     |             if (x & type(uint32).max > 0) {
 265 |     |                 r -= 32;
 266 |     |             } else {
 267 |     |                 x >>= 32;
 268 |     |             }
 269 |     |             if (x & type(uint16).max > 0) {
 270 |     |                 r -= 16;
 271 |     |             } else {
 272 |     |                 x >>= 16;
 273 |     |             }
 274 |     |             if (x & type(uint8).max > 0) {
 275 |     |                 r -= 8;
 276 |     |             } else {
 277 |     |                 x >>= 8;
 278 |     |             }
 279 |     |             if (x & 0xf > 0) {
 280 |     |                 r -= 4;
 281 |     |             } else {
 282 |     |                 x >>= 4;
 283 |     |             }
 284 |     |             if (x & 0x3 > 0) {
 285 |     |                 r -= 2;
 286 |     |             } else {
 287 |     |                 x >>= 2;
 288 |     |             }
 289 |     |             if (x & 0x1 > 0) r -= 1;
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     function round(
 294 |     |         int24 tick,
 295 |     |         int24 tickSpacing
 296 |     |     ) internal pure returns (
 297 |     |         int24 roundedTick
 298 |     |     ) {
 299 |     |         return tick / tickSpacing * tickSpacing;
 300 |     |     }
 301 |     | 
 302 |     |     function roundHalf(
 303 |     |         int24 tick,
 304 |     |         ILimitPoolStructs.Immutables memory constants,
 305 |     |         uint256 price
 306 |     |     ) internal pure returns (
 307 |     |         int24 roundedTick,
 308 |     |         uint160 roundedTickPrice
 309 |     |     ) {
 310 |     |         //pool.tickAtPrice -99.5
 311 |     |         //pool.tickAtPrice -100
 312 |     |         //-105
 313 |     |         //-95
 314 |     |         roundedTick = tick / constants.tickSpacing * constants.tickSpacing;
 315 |     |         roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);
 316 |     |         if (price == roundedTickPrice)
 317 |     |             return (roundedTick, roundedTickPrice);
 318 |     |         if (roundedTick > 0) {
 319 |     |             roundedTick += constants.tickSpacing / 2;
 320 |     |         } else if (roundedTick < 0) {
 321 |     |             if (roundedTickPrice < price)
 322 |     |                 roundedTick += constants.tickSpacing / 2;
 323 |     |             else
 324 |     |                 roundedTick -= constants.tickSpacing / 2;
 325 |     |         } else {
 326 |     |             if (price > roundedTickPrice) {
 327 |     |                 roundedTick += constants.tickSpacing / 2;
 328 |     |             } else if (price < roundedTickPrice) {
 329 |     |                 roundedTick -= constants.tickSpacing / 2;
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     function roundAhead(
 335 |     |         int24 tick,
 336 |     |         ILimitPoolStructs.Immutables memory constants,
 337 |     |         bool zeroForOne,
 338 |     |         uint256 price
 339 |     |     ) internal pure returns (
 340 |     |         int24 roundedTick
 341 |     |     ) {
 342 |     |         roundedTick = tick / constants.tickSpacing * constants.tickSpacing;
 343 |     |         uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);
 344 |     |         if (price == roundedTickPrice)
 345 |     |             return roundedTick;
 346 |     |         if (zeroForOne) {
 347 |     |             // round up if positive
 348 |     |             if (roundedTick > 0 || (roundedTick == 0 && tick >= 0))
 349 |     |                 roundedTick += constants.tickSpacing;
 350 |     |             else if (tick % constants.tickSpacing == 0) {
 351 |     |                 // handle price at -99.5 and tickAtPrice == -100
 352 |     |                 if (tick < 0 && roundedTickPrice < price) {
 353 |     |                     roundedTick += constants.tickSpacing;
 354 |     |                 }
 355 |     |             }
 356 |     |         } else {
 357 |     |             // round down if negative
 358 |     |             if (roundedTick < 0 || (roundedTick == 0 && tick < 0))
 359 |     |             /// @dev - strictly less due to TickMath always rounding to lesser values
 360 |     |                 roundedTick -= constants.tickSpacing;
 361 |     |         }
 362 |     |     }
 363 |     | 
 364 |     |     function roundBack(
 365 |     |         int24 tick,
 366 |     |         ILimitPoolStructs.Immutables memory constants,
 367 |     |         bool zeroForOne,
 368 |     |         uint256 price
 369 |     |     ) internal pure returns (
 370 |     |         int24 roundedTick
 371 |     |     ) {
 372 |     |         roundedTick = tick / constants.tickSpacing * constants.tickSpacing;
 373 |     |         uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);
 374 |     |         if (price == roundedTickPrice)
 375 |     |             return roundedTick;
 376 |     |         if (zeroForOne) {
 377 |     |             // round down if negative
 378 |     |             if (roundedTick < 0 || (roundedTick == 0 && tick < 0))
 379 |     |                 roundedTick -= constants.tickSpacing;
 380 |     |         } else {
 381 |     |             // round up if positive
 382 |     |             if (roundedTick > 0 || (roundedTick == 0 && tick >= 0))
 383 |     |                 roundedTick += constants.tickSpacing;
 384 |     |             else if (tick % constants.tickSpacing == 0) {
 385 |     |                 // handle price at -99.5 and tickAtPrice == -100
 386 |     |                 if (tick < 0 && roundedTickPrice < price) {
 387 |     |                     roundedTick += constants.tickSpacing;
 388 |     |                 }
 389 |     |             }
 390 |     |         }
 391 |     |     }
 392 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/Ticks.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/ILimitPoolStructs.sol';
   5 |     | import '../interfaces/ILimitPoolFactory.sol';
   6 |     | import '../base/structs/LimitPoolFactoryStructs.sol';
   7 |     | import '../interfaces/ILimitPool.sol';
   8 |     | import './math/ConstantProduct.sol';
   9 |     | import './Positions.sol';
  10 |     | import './math/OverflowMath.sol';
  11 |     | import './TickMap.sol';
  12 |     | import './EpochMap.sol';
  13 |     | import './utils/SafeCast.sol';
  14 |     | import './EchidnaAssertions.sol';
  15 |     | import 'hardhat/console.sol';
  16 |     | import './math/constant-product/TickMath.sol';
  17 |     | 
  18 |     | /// @notice Tick management library
  19 |     | library Ticks {
  20 |     |     error LiquidityOverflow();
  21 |     |     error LiquidityUnderflow();
  22 |     |     error InvalidLowerTick();
  23 |     |     error InvalidUpperTick();
  24 |     |     error InvalidPositionAmount();
  25 |     |     error InvalidPositionBounds();
  26 |     | 
  27 |     |     using SafeCast for uint256;
  28 |     | 
  29 |     |     event Initialize(
  30 |     |         int24 minTick,
  31 |     |         int24 maxTick,
  32 |     |         uint160 startPrice,
  33 |     |         int24 startTick
  34 |     |     );
  35 |     | 
  36 |     |     event Swap(
  37 |     |         address indexed recipient,
  38 |     |         bool zeroForOne,
  39 |     |         uint256 amountIn,
  40 |     |         uint256 amountOut,
  41 |     |         uint160 price,
  42 |     |         uint128 liquidity,
  43 |     |         int24 tickAtPrice
  44 |     |     );
  45 |     | 
  46 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  47 |     | 
  48 |     |     function initialize(
  49 |     |         ILimitPoolStructs.TickMap storage tickMap,
  50 |     |         ILimitPoolStructs.PoolState storage pool0,
  51 |     |         ILimitPoolStructs.PoolState storage pool1,
  52 |     |         ILimitPoolStructs.GlobalState memory state,
  53 |     |         ILimitPoolStructs.Immutables memory constants,
  54 |     |         uint160 startPrice
  55 |     |     ) internal returns (
  56 |     |         ILimitPoolStructs.GlobalState memory
  57 |     |     ) {
  58 |     |         // state should only be initialized once
  59 |     |         if (pool0.price > 0) require (false, 'PoolAlreadyInitialized()');
  60 |     | 
  61 |     |         // initialize epoch
  62 |     |         pool0.swapEpoch = 1;
  63 |     |         pool1.swapEpoch = 1;
  64 |     | 
  65 |     |         // check price bounds
  66 |     |         if (startPrice < constants.bounds.min || startPrice >= constants.bounds.max) require(false, 'StartPriceInvalid()');
  67 |     | 
  68 |     |         // initialize ticks
  69 |     |         TickMap.set(tickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);
  70 |     |         TickMap.set(tickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);
  71 |     | 
  72 |     |         // initialize price
  73 |     |         pool0.price = startPrice;
  74 |     |         pool1.price = startPrice;
  75 |     | 
  76 |     |         int24 startTick = ConstantProduct.getTickAtPrice(startPrice, constants);
  77 |     |         pool0.tickAtPrice = startTick;
  78 |     |         pool1.tickAtPrice = startTick;
  79 |     | 
  80 |     |         // emit event
  81 |     |         emit Initialize(
  82 |     |             ConstantProduct.minTick(constants.tickSpacing),
  83 |     |             ConstantProduct.maxTick(constants.tickSpacing),
  84 |     |             pool0.price,
  85 |     |             pool0.tickAtPrice
  86 |     |         );
  87 |     | 
  88 |     |         return state;
  89 |     |     }
  90 |     | 
  91 |     |     function validate(
  92 |     |         int24 lower,
  93 |     |         int24 upper,
  94 |     |         int24 tickSpacing
  95 |     |     ) internal pure {
  96 |     |         if (lower % tickSpacing != 0) require(false, 'InvalidLowerTick()');
  97 |     |         if (lower <= ConstantProduct.MIN_TICK) require(false, 'InvalidLowerTick()');
  98 |     |         if (upper % tickSpacing != 0) require(false, 'InvalidUpperTick()');
  99 |     |         if (upper >= ConstantProduct.MAX_TICK) require(false, 'InvalidUpperTick()');
 100 |     |         if (lower >= upper) require(false, 'InvalidPositionBounds()');
 101 |     |     }
 102 |     | 
 103 |     |     function swap(
 104 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 105 |     |         ILimitPoolStructs.TickMap storage tickMap,
 106 |     |         ILimitPoolStructs.SwapParams memory params,
 107 |     |         ILimitPoolStructs.SwapCache memory cache,
 108 |     |         ILimitPoolStructs.PoolState memory pool
 109 |     |     ) internal returns (
 110 |     |             ILimitPoolStructs.PoolState memory,
 111 |     |             ILimitPoolStructs.SwapCache memory
 112 |     |         )
 113 |     |     {
 114 |     |         (cache.crossTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);
 115 |     |         cache = ILimitPoolStructs.SwapCache({
 116 |     |             state: cache.state,
 117 |     |             constants: cache.constants,
 118 |     |             pool: cache.pool,
 119 |     |             price: pool.price,
 120 |     |             liquidity: pool.liquidity,
 121 |     |             cross: true,
 122 |     |             crossTick: params.zeroForOne ? TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, true) 
 123 |     |                                          : TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, true),
 124 |     |             crossPrice: 0,
 125 |     |             input:  0,
 126 |     |             output: 0,
 127 |     |             exactIn: params.exactIn,
 128 |     |             amountLeft: params.amount
 129 |     |         });
 130 |     | 
 131 |     |         // increment swap epoch
 132 |     |         cache.pool.swapEpoch += 1;
 133 |     |         // grab latest sample and store in cache for _cross
 134 |     |         while (cache.cross) {
 135 |     |             cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? 
 136 |     |                                     ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)
 137 |     |                                   : ticks[cache.crossTick].priceAt;
 138 |     |             // handle price being at cross tick
 139 |     |             if (params.zeroForOne && pool.price == cache.crossPrice) {
 140 |     |                 cache.crossTick = TickMap.previous(tickMap, pool.tickAtPrice, cache.constants.tickSpacing, false);
 141 |     |                 cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? 
 142 |     |                                     ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)
 143 |     |                                   : ticks[cache.crossTick].priceAt;
 144 |     | 
 145 |     |             }
 146 |     |             (pool, cache) = _quoteSingle(pool, cache, params.priceLimit, params.zeroForOne);
 147 |     |             if (cache.cross) {
 148 |     |                 (pool, cache) = _cross(
 149 |     |                     ticks,
 150 |     |                     tickMap,
 151 |     |                     pool,
 152 |     |                     cache,
 153 |     |                     params.zeroForOne
 154 |     |                 );
 155 |     |             }
 156 |     |         }
 157 |     |         pool.price = cache.price.toUint160();
 158 |     |         pool.liquidity = cache.liquidity.toUint128();
 159 |     | 
 160 |     |         if (cache.price != cache.crossPrice) {
 161 |     |             pool.tickAtPrice = ConstantProduct.getTickAtPrice(pool.price, cache.constants);
 162 |     |         } else {
 163 |     |             pool.tickAtPrice = cache.crossTick;
 164 |     |         }
 165 |     |         emit Swap(
 166 |     |             params.to,
 167 |     |             params.zeroForOne,
 168 |     |             cache.input,
 169 |     |             cache.output, /// @dev - subgraph will do math to compute fee amount
 170 |     |             pool.price,
 171 |     |             pool.liquidity,
 172 |     |             pool.tickAtPrice
 173 |     |         );
 174 |     |         return (pool, cache);
 175 |     |     }
 176 |     | 
 177 |     |     function quote(
 178 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 179 |     |         ILimitPoolStructs.TickMap storage tickMap,
 180 |     |         ILimitPoolStructs.QuoteParams memory params,
 181 |     |         ILimitPoolStructs.SwapCache memory cache,
 182 |     |         ILimitPoolStructs.PoolState memory pool
 183 |     |     ) internal view returns (
 184 |     |         uint256,
 185 |     |         uint256,
 186 |     |         uint160
 187 |     |     ) {
 188 |     |         (cache.crossTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);
 189 |     |         cache = ILimitPoolStructs.SwapCache({
 190 |     |             state: cache.state,
 191 |     |             constants: cache.constants,
 192 |     |             pool: cache.pool,
 193 |     |             price: pool.price,
 194 |     |             liquidity: pool.liquidity,
 195 |     |             cross: true,
 196 |     |             crossTick: params.zeroForOne ? TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, true) 
 197 |     |                                          : TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, true),
 198 |     |             crossPrice: 0,
 199 |     |             input:  0,
 200 |     |             output: 0,
 201 |     |             exactIn: params.exactIn,
 202 |     |             amountLeft: params.amount
 203 |     |         });
 204 |     |         while (cache.cross) {
 205 |     |             cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? 
 206 |     |                                  ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)
 207 |     |                                : ticks[cache.crossTick].priceAt;
 208 |     |             // handle price being at cross tick
 209 |     |             if (params.zeroForOne && pool.price == cache.crossPrice) {
 210 |     |                 cache.crossTick = TickMap.previous(tickMap, pool.tickAtPrice, cache.constants.tickSpacing, false);
 211 |     |                 cache.crossPrice = ticks[cache.crossTick].priceAt == 0 ? 
 212 |     |                                     ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)
 213 |     |                                   : ticks[cache.crossTick].priceAt;
 214 |     |             }
 215 |     |             (pool, cache) = _quoteSingle(pool, cache, params.priceLimit, params.zeroForOne);
 216 |     |             if (cache.cross) {
 217 |     |                 (pool, cache) = _pass(
 218 |     |                     ticks,
 219 |     |                     tickMap,
 220 |     |                     pool,
 221 |     |                     cache,
 222 |     |                     params.zeroForOne
 223 |     |                 );
 224 |     |             }
 225 |     |         }
 226 |     |         return (
 227 |     |             cache.input,
 228 |     |             cache.output,
 229 |     |             uint160(cache.price)
 230 |     |         );
 231 |     |     }
 232 |     | 
 233 |     |     function _quoteSingle(
 234 |     |         ILimitPoolStructs.PoolState memory pool,
 235 |     |         ILimitPoolStructs.SwapCache memory cache,
 236 |     |         uint160 priceLimit,
 237 |     |         bool zeroForOne
 238 |     |     ) internal pure returns (
 239 |     |         ILimitPoolStructs.PoolState memory,
 240 |     |         ILimitPoolStructs.SwapCache memory
 241 |     |     ) {
 242 |     |         if ((zeroForOne ? priceLimit >= cache.price
 243 |     |                         : priceLimit <= cache.price) ||
 244 |     |             (zeroForOne && cache.price == cache.constants.bounds.min) ||
 245 |     |             (!zeroForOne && cache.price == cache.constants.bounds.max) ||
 246 |     |             cache.amountLeft == 0)
 247 |     |         {
 248 |     |             cache.cross = false;
 249 |     |             return (pool, cache);
 250 |     |         }
 251 |     |         uint256 nextPrice = cache.crossPrice;
 252 |     |         uint256 amountOut;
 253 |     |         if (zeroForOne) {
 254 |     |             // Trading token 0 (x) for token 1 (y).
 255 |     |             // price  is decreasing.
 256 |     |             if (nextPrice < priceLimit) {
 257 |     |                 nextPrice = priceLimit;
 258 |     |             }
 259 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)
 260 |     |                                               : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
 261 |     |             if (cache.amountLeft < amountMax) {
 262 |     |                 // We can swap within the current range.
 263 |     |                 uint256 liquidityPadded = uint256(cache.liquidity) << 96;
 264 |     |                 // calculate price after swap
 265 |     |                 uint256 newPrice;
 266 |     |                 if (cache.exactIn) {
 267 |     |                     newPrice = OverflowMath.mulDivRoundingUp(
 268 |     |                         liquidityPadded,
 269 |     |                         cache.price,
 270 |     |                         liquidityPadded + uint256(cache.price) * uint256(cache.amountLeft)
 271 |     |                     );
 272 |     |                     amountOut = ConstantProduct.getDy(cache.liquidity, newPrice, uint256(cache.price), false);
 273 |     |                     cache.input += cache.amountLeft;
 274 |     |                 } else {
 275 |     |                     newPrice = cache.price - 
 276 |     |                         OverflowMath.divRoundingUp(cache.amountLeft << 96, cache.liquidity);
 277 |     |                     amountOut = cache.amountLeft;
 278 |     |                     cache.input += ConstantProduct.getDx(cache.liquidity, newPrice, uint256(cache.price), true);
 279 |     |                 }
 280 |     |                 cache.amountLeft = 0;
 281 |     |                 cache.cross = false;
 282 |     |                 cache.price = uint160(newPrice);
 283 |     |             } else {
 284 |     |                 if (cache.exactIn) {
 285 |     |                     amountOut = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
 286 |     |                     cache.input += amountMax;
 287 |     |                 } else {
 288 |     |                     amountOut = amountMax;
 289 |     |                     cache.input += ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true);
 290 |     |                 }
 291 |     |                 cache.amountLeft -= amountMax;
 292 |     |                 if (nextPrice == cache.crossPrice) { cache.cross = true; }
 293 |     |                 else cache.cross = false;
 294 |     |                 cache.price = uint160(nextPrice);
 295 |     |             }
 296 |     |         } else {
 297 |     |             // Price is increasing.
 298 |     |             if (nextPrice > priceLimit) {
 299 |     |                 nextPrice = priceLimit;
 300 |     |             }
 301 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)
 302 |     |                                               : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);
 303 |     |             if (cache.amountLeft < amountMax) {
 304 |     |                 uint256 newPrice;
 305 |     |                 if (cache.exactIn) {
 306 |     |                     newPrice = cache.price +
 307 |     |                         OverflowMath.mulDiv(cache.amountLeft, Q96, cache.liquidity);
 308 |     |                     amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);
 309 |     |                     cache.input += cache.amountLeft;
 310 |     |                 } else {
 311 |     |                     uint256 liquidityPadded = uint256(cache.liquidity) << 96;
 312 |     |                     newPrice = OverflowMath.mulDivRoundingUp(
 313 |     |                         liquidityPadded, 
 314 |     |                         cache.price,
 315 |     |                         liquidityPadded - uint256(cache.price) * cache.amountLeft
 316 |     |                     );
 317 |     |                     amountOut = cache.amountLeft;
 318 |     |                     cache.input += ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true);
 319 |     |                 }
 320 |     |                 cache.amountLeft = 0;
 321 |     |                 cache.cross = false;
 322 |     |                 cache.price = uint160(newPrice);
 323 |     |             } else {
 324 |     |                 if (cache.exactIn) {
 325 |     |                     amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);
 326 |     |                     cache.input += amountMax;
 327 |     |                 } else {
 328 |     |                     amountOut = amountMax;
 329 |     |                     cache.input += ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true);
 330 |     |                 }
 331 |     |                 cache.amountLeft -= amountMax;
 332 |     |                 if (nextPrice == cache.crossPrice) { cache.cross = true; }
 333 |     |                 else cache.cross = false;
 334 |     |                 cache.price = uint160(nextPrice);
 335 |     |             }
 336 |     |         }
 337 |     |         cache.output += amountOut;
 338 |     |         return (pool, cache);
 339 |     |     }
 340 |     | 
 341 |     |     function unlock(
 342 |     |         ILimitPoolStructs.MintCache memory cache,
 343 |     |         ILimitPoolStructs.PoolState memory pool,
 344 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 345 |     |         ILimitPoolStructs.TickMap storage tickMap,
 346 |     |         bool zeroForOne
 347 |     |     ) internal returns (
 348 |     |         ILimitPoolStructs.MintCache memory,
 349 |     |         ILimitPoolStructs.PoolState memory
 350 |     |     )
 351 |     |     {
 352 |     |         if (pool.liquidity > 0) return (cache, pool);
 353 |     | 
 354 |     |         (int24 startTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);
 355 |     | 
 356 |     |         if (zeroForOne) {
 357 |     |             pool.tickAtPrice = TickMap.next(tickMap, startTick, cache.constants.tickSpacing, true);
 358 |     |             if (pool.tickAtPrice < ConstantProduct.maxTick(cache.constants.tickSpacing)) {
 359 |     |                 EpochMap.set(pool.tickAtPrice, pool.swapEpoch, tickMap, cache.constants);
 360 |     |             }
 361 |     |         } else {
 362 |     |             /// @dev - roundedUp true since liquidity could be equal to the current pool tickAtPrice
 363 |     |             pool.tickAtPrice = TickMap.previous(tickMap, startTick, cache.constants.tickSpacing, true);
 364 |     |             if (pool.tickAtPrice > ConstantProduct.minTick(cache.constants.tickSpacing)) {
 365 |     |                 EpochMap.set(pool.tickAtPrice, pool.swapEpoch, tickMap, cache.constants);
 366 |     |             }
 367 |     |         }
 368 |     | 
 369 |     |         // increment pool liquidity
 370 |     |         EchidnaAssertions.assertPositiveLiquidityOnUnlock(ticks[pool.tickAtPrice].liquidityDelta);
 371 |     |         pool.liquidity += uint128(ticks[pool.tickAtPrice].liquidityDelta);
 372 |     |         int24 tickToClear = pool.tickAtPrice;
 373 |     |         uint160 tickPriceAt = ticks[pool.tickAtPrice].priceAt;
 374 |     | 
 375 |     |         if (tickPriceAt == 0) {
 376 |     |             // if full tick crossed
 377 |     |             pool.price = ConstantProduct.getPriceAtTick(pool.tickAtPrice, cache.constants);
 378 |     |         } else {
 379 |     |             // if half tick crossed
 380 |     |             pool.price = tickPriceAt;
 381 |     |             pool.tickAtPrice = ConstantProduct.getTickAtPrice(tickPriceAt, cache.constants);
 382 |     |         }
 383 |     | 
 384 |     |         // zero out tick
 385 |     |         ticks[tickToClear].liquidityDelta = 0;
 386 |     |         Ticks.clear(ticks, cache.constants, tickMap, tickToClear);
 387 |     | 
 388 |     |         return (cache, pool);
 389 |     |     }
 390 |     | 
 391 |     |     function _cross(
 392 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 393 |     |         ILimitPoolStructs.TickMap storage tickMap,
 394 |     |         ILimitPoolStructs.PoolState memory pool,
 395 |     |         ILimitPoolStructs.SwapCache memory cache,
 396 |     |         bool zeroForOne
 397 |     |     ) internal returns (
 398 |     |         ILimitPoolStructs.PoolState memory,
 399 |     |         ILimitPoolStructs.SwapCache memory
 400 |     |     ) {
 401 |     |         EpochMap.set(cache.crossTick, cache.pool.swapEpoch, tickMap, cache.constants);
 402 |     |         int128 liquidityDelta = ticks[cache.crossTick].liquidityDelta;
 403 |     | 
 404 |     |         if (liquidityDelta > 0) cache.liquidity += uint128(liquidityDelta);
 405 |     |         else {
 406 |     |             EchidnaAssertions.assertLiquidityUnderflows(uint128(cache.liquidity), uint128(-liquidityDelta), "TK-1");
 407 |     |             cache.liquidity -= uint128(-liquidityDelta);
 408 |     |         }
 409 |     |         pool.tickAtPrice = cache.crossTick;
 410 |     | 
 411 |     |         // zero out liquidityDelta and priceAt
 412 |     |         ticks[cache.crossTick] = ILimitPoolStructs.Tick(0,0);
 413 |     |         clear(ticks, cache.constants, tickMap, cache.crossTick);
 414 |     |         if (zeroForOne) {
 415 |     |             cache.crossTick = TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, false);
 416 |     |         } else {
 417 |     |             cache.crossTick = TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, false);
 418 |     |         }
 419 |     |         return (pool, cache);
 420 |     |     }
 421 |     | 
 422 |     |     function _pass(
 423 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 424 |     |         ILimitPoolStructs.TickMap storage tickMap,
 425 |     |         ILimitPoolStructs.PoolState memory pool,
 426 |     |         ILimitPoolStructs.SwapCache memory cache,
 427 |     |         bool zeroForOne
 428 |     |     ) internal view returns (
 429 |     |         ILimitPoolStructs.PoolState memory,
 430 |     |         ILimitPoolStructs.SwapCache memory
 431 |     |     ) {
 432 |     |         int128 liquidityDelta = ticks[cache.crossTick].liquidityDelta;
 433 |     |         if (liquidityDelta > 0) cache.liquidity += uint128(liquidityDelta);
 434 |     |         else cache.liquidity -= uint128(-liquidityDelta);
 435 |     |         if (zeroForOne) {
 436 |     |             cache.crossTick = TickMap.previous(tickMap, cache.crossTick, cache.constants.tickSpacing, false);
 437 |     |         } else {
 438 |     |             cache.crossTick = TickMap.next(tickMap, cache.crossTick, cache.constants.tickSpacing, false);
 439 |     |         }
 440 |     |         return (pool, cache);
 441 |     |     }
 442 |     |     
 443 |     |     function insert(
 444 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 445 |     |         ILimitPoolStructs.TickMap storage tickMap,
 446 |     |         ILimitPoolStructs.MintCache memory cache,
 447 |     |         ILimitPoolStructs.MintParams memory params
 448 |     |     ) internal {
 449 |     |         /// @auditor - validation of ticks is in Positions.validate
 450 |     |         if (cache.liquidityMinted > (uint128(type(int128).max) - cache.pool.liquidityGlobal) )
 451 |     |             require (false, 'LiquidityOverflow()');
 452 |     | 
 453 |     |         int256 liquidityMinted = int256(cache.liquidityMinted);
 454 |     | 
 455 |     |         // check if adding liquidity necessary
 456 |     |         if (!params.zeroForOne || cache.priceLower > cache.pool.price) {
 457 |     |             // sets bit in map
 458 |     |             if(!TickMap.set(tickMap, params.lower, cache.constants.tickSpacing)){
 459 |     |                 // inherit epoch 
 460 |     |                 int24 tickAhead;
 461 |     |                 if (params.zeroForOne) {
 462 |     |                     tickAhead  = TickMap.next(tickMap, params.lower, cache.constants.tickSpacing, false);
 463 |     |                 } else {
 464 |     |                     tickAhead  = TickMap.previous(tickMap, params.lower, cache.constants.tickSpacing, false);
 465 |     |                 }
 466 |     |                 uint32 epochAhead = EpochMap.get(tickAhead, tickMap, cache.constants);
 467 |     |                 EpochMap.set(params.lower, epochAhead, tickMap, cache.constants);
 468 |     |             }
 469 |     |             ILimitPoolStructs.Tick memory tickLower = ticks[params.lower];
 470 |     |             if (params.zeroForOne) {
 471 |     |                 tickLower.liquidityDelta += int128(liquidityMinted);
 472 |     |             } else {
 473 |     |                 tickLower.liquidityDelta -= int128(liquidityMinted);
 474 |     |             }
 475 |     |             ticks[params.lower] = tickLower;
 476 |     |         } else {
 477 |     |             /// @dev - i.e. if zeroForOne && cache.priceLower <= cache.pool.price
 478 |     |             cache.pool.swapEpoch += 1;
 479 |     |             // mark epoch on undercut tick
 480 |     |             EpochMap.set(params.lower, cache.pool.swapEpoch, tickMap, cache.constants);
 481 |     |         }
 482 |     | 
 483 |     |         if (params.zeroForOne || cache.priceUpper < cache.pool.price) {
 484 |     |             if(!TickMap.set(tickMap, params.upper, cache.constants.tickSpacing)) {
 485 |     |                 int24 tickAhead;
 486 |     |                 if (params.zeroForOne) {
 487 |     |                     tickAhead  = TickMap.next(tickMap, params.upper, cache.constants.tickSpacing, false);
 488 |     |                 } else {
 489 |     |                     tickAhead  = TickMap.previous(tickMap, params.upper, cache.constants.tickSpacing, false);
 490 |     |                 }
 491 |     |                 uint32 epochAhead = EpochMap.get(tickAhead, tickMap, cache.constants);
 492 |     |                 EpochMap.set(params.upper, epochAhead, tickMap, cache.constants);
 493 |     |             }
 494 |     |             ILimitPoolStructs.Tick memory tickUpper = ticks[params.upper];
 495 |     |             if (params.zeroForOne) {
 496 |     |                 tickUpper.liquidityDelta -= int128(liquidityMinted);
 497 |     |             } else {
 498 |     |                 tickUpper.liquidityDelta += int128(liquidityMinted);
 499 |     |             }
 500 |     |             ticks[params.upper] = tickUpper;
 501 |     |         } else {
 502 |     |             /// @dev - i.e. if !zeroForOne && cache.priceUpper >= cache.pool.price
 503 |     |             cache.pool.swapEpoch += 1;
 504 |     |             // mark epoch on undercut tick
 505 |     |             EpochMap.set(params.upper, cache.pool.swapEpoch, tickMap, cache.constants);
 506 |     |         }
 507 |     |     }
 508 |     | 
 509 |     |     function insertSingle(
 510 |     |         ILimitPoolStructs.MintParams memory params,
 511 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 512 |     |         ILimitPoolStructs.TickMap storage tickMap,
 513 |     |         ILimitPoolStructs.MintCache memory cache,
 514 |     |         ILimitPoolStructs.PoolState memory pool,
 515 |     |         ILimitPoolStructs.Immutables memory constants
 516 |     |     ) internal returns (
 517 |     |         ILimitPoolStructs.PoolState memory
 518 |     |     ){
 519 |     |         /// @auditor - would be smart to protect against the case of epochs crossing
 520 |     |         (
 521 |     |             int24 tickToSave,
 522 |     |             uint160 roundedPrice
 523 |     |         ) = TickMap.roundHalf(pool.tickAtPrice, constants, pool.price);
 524 |     |         // update tick to save
 525 |     |         ILimitPoolStructs.Tick memory tick = ticks[tickToSave];
 526 |     |         /// @auditor - tick.priceAt will be zero for tick % tickSpacing == 0
 527 |     |         if (tick.priceAt == 0) {
 528 |     |             if (pool.price != (params.zeroForOne ? cache.priceLower : cache.priceUpper)) {
 529 |     |                 TickMap.set(tickMap, tickToSave, constants.tickSpacing);
 530 |     |             }
 531 |     |             EpochMap.set(tickToSave, pool.swapEpoch, tickMap, constants);
 532 |     |         }
 533 |     |         // skip if we are at the nearest full tick
 534 |     |         if(pool.price != roundedPrice) {
 535 |     |             // if empty just save the pool price
 536 |     |             if (tick.priceAt == 0) {
 537 |     |                 tick.priceAt = pool.price;
 538 |     |                 EchidnaAssertions.assertTickAtPriceDivisibleByTickSpacing(tickToSave, ticks[tickToSave].priceAt, constants.tickSpacing);
 539 |     |             }
 540 |     |             else {
 541 |     |                 //TODO: set in tickMap for safety
 542 |     |                 // we need to blend the two partial fills into a single tick
 543 |     |                 ILimitPoolStructs.InsertSingleLocals memory locals;
 544 |     |                 if (params.zeroForOne) {
 545 |     |                     // 0 -> 1 positions price moves up so nextFullTick is greater
 546 |     |                     locals.previousFullTick = tickToSave - constants.tickSpacing / 2;
 547 |     |                     locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);
 548 |     |                     // calculate amountOut filled across both partial fills
 549 |     |                     locals.amountOutExact = ConstantProduct.getDy(pool.liquidity, locals.pricePrevious, pool.price, false);
 550 |     |                     locals.amountOutExact += ConstantProduct.getDy(uint128(tick.liquidityDelta), locals.pricePrevious, tick.priceAt, false);
 551 |     |                     uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);
 552 |     |                     /// @auditor - the opposing amount calculated is off by 1/100 millionth
 553 |     |                     ///            (i.e. since we're using exactOut we lose precision on exactInput amount)
 554 |     |                     ///            the expected dy to the next tick is either exact or slightly more
 555 |     |                     ///            the expected dx to the next tick is 1/100 millionth less after the blend
 556 |     |                     // advance price past closest full tick using amountOut filled
 557 |     |                     tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, false, true).toUint160();
 558 |     |                     // dx to the next tick is less than before the tick blend
 559 |     |                     EpochMap.set(tickToSave, pool.swapEpoch, tickMap, constants);
 560 |     |                 } else {
 561 |     |                     // 0 -> 1 positions price moves up so nextFullTick is lesser
 562 |     |                     locals.previousFullTick = tickToSave + constants.tickSpacing / 2;
 563 |     |                     locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);
 564 |     |                     // calculate amountOut filled across both partial fills
 565 |     |                     locals.amountOutExact = ConstantProduct.getDx(pool.liquidity, pool.price, locals.pricePrevious, false);
 566 |     |                     locals.amountOutExact += ConstantProduct.getDx(uint128(tick.liquidityDelta), tick.priceAt, locals.pricePrevious, false);
 567 |     |                     // add current pool liquidity to partial tick
 568 |     |                     uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);
 569 |     |                     // advance price past closest full tick using amountOut filled
 570 |     |                     tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, true, true).toUint160();
 571 |     |                     // mark epoch for second partial fill positions
 572 |     |                     EpochMap.set(tickToSave, pool.swapEpoch, tickMap, constants);
 573 |     |                 }
 574 |     |             }
 575 |     |         }
 576 |     |         // invariant => if we save liquidity to tick clear pool liquidity
 577 |     |         if ((tickToSave != (params.zeroForOne ? params.lower : params.upper))) {
 578 |     |             tick.liquidityDelta += int128(pool.liquidity);
 579 |     |             pool.liquidity = 0;
 580 |     |         }
 581 |     |         ticks[tickToSave] = tick;
 582 |     |         return pool;
 583 |     |     }
 584 |     | 
 585 |     |     function remove(
 586 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 587 |     |         ILimitPoolStructs.TickMap storage tickMap,
 588 |     |         ILimitPoolStructs.UpdateCache memory cache,
 589 |     |         ILimitPoolStructs.UpdateParams memory params,
 590 |     |         ILimitPoolStructs.Immutables memory constants
 591 |     |     ) internal {
 592 |     |         // set ticks based on claim and zeroForOne
 593 |     |         int24 lower = params.zeroForOne ? params.claim : params.lower;
 594 |     |         int24 upper = params.zeroForOne ? params.upper : params.claim;
 595 |     |         {    
 596 |     |             ILimitPoolStructs.Tick memory tickLower = ticks[lower];
 597 |     |             
 598 |     |             if (cache.removeLower) {
 599 |     |                 if (params.zeroForOne) {
 600 |     |                     tickLower.liquidityDelta -= int128(params.amount);
 601 |     |                 } else {
 602 |     |                     tickLower.liquidityDelta += int128(params.amount);
 603 |     |                 }
 604 |     |                 ticks[lower] = tickLower;
 605 |     |             }
 606 |     |             clear(ticks, constants, tickMap, lower);
 607 |     |         }
 608 |     |         {
 609 |     |             ILimitPoolStructs.Tick memory tickUpper = ticks[upper];
 610 |     |             if (cache.removeUpper) {
 611 |     |                 if (params.zeroForOne) {
 612 |     |                     tickUpper.liquidityDelta += int128(params.amount);
 613 |     |                 } else {
 614 |     |                     tickUpper.liquidityDelta -= int128(params.amount);
 615 |     |                 }
 616 |     |                 ticks[upper] = tickUpper;
 617 |     |             }
 618 |     |             clear(ticks, constants, tickMap, upper);
 619 |     |         }
 620 |     |     }
 621 |     | 
 622 |     |     function clear(
 623 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 624 |     |         ILimitPoolStructs.Immutables memory constants,
 625 |     |         ILimitPoolStructs.TickMap storage tickMap,
 626 |     |         int24 tickToClear
 627 |     |     ) internal {
 628 |     |         if (_empty(ticks[tickToClear])) {
 629 |     |             if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &&
 630 |     |                 tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {
 631 |     |                 ticks[tickToClear] = ILimitPoolStructs.Tick(0,0);
 632 |     |                 TickMap.unset(tickMap, tickToClear, constants.tickSpacing);
 633 |     |             }
 634 |     |         }
 635 |     |     }
 636 |     | 
 637 |     |     function _empty(
 638 |     |         ILimitPoolStructs.Tick memory tick
 639 |     |     ) internal pure returns (
 640 |     |         bool
 641 |     |     ) {
 642 |     |         if (tick.liquidityDelta != 0) {
 643 |     |             return false;
 644 |     |         }
 645 |     |         return true;
 646 |     |     }
 647 |     | }
 648 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/math/ConstantProduct.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './OverflowMath.sol';
   5 |     | import '../../interfaces/ILimitPoolStructs.sol';
   6 |     | 
   7 |     | /// @notice Math library that facilitates ranged liquidity calculations.
   8 |     | library ConstantProduct {
   9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  10 |     | 
  11 |     |     struct PriceBounds {
  12 |     |         uint160 min;
  13 |     |         uint160 max;
  14 |     |     }
  15 |     | 
  16 |     |     /////////////////////////////////////////////////////////////
  17 |     |     ///////////////////////// DYDX MATH /////////////////////////
  18 |     |     /////////////////////////////////////////////////////////////
  19 |     | 
  20 |     |     function getDy(
  21 |     |         uint256 liquidity,
  22 |     |         uint256 priceLower,
  23 |     |         uint256 priceUpper,
  24 |     |         bool roundUp
  25 |     |     ) internal pure returns (uint256 dy) {
  26 |     |         return _getDy(liquidity, priceLower, priceUpper, roundUp);
  27 |     |     }
  28 |     | 
  29 |     |     function getDx(
  30 |     |         uint256 liquidity,
  31 |     |         uint256 priceLower,
  32 |     |         uint256 priceUpper,
  33 |     |         bool roundUp
  34 |     |     ) internal pure returns (uint256 dx) {
  35 |     |         return _getDx(liquidity, priceLower, priceUpper, roundUp);
  36 |     |     }
  37 |     | 
  38 |     |     function _getDy(
  39 |     |         uint256 liquidity,
  40 |     |         uint256 priceLower,
  41 |     |         uint256 priceUpper,
  42 |     |         bool roundUp
  43 |     |     ) internal pure returns (uint256 dy) {
  44 |     |         unchecked {
  45 |     |             if (liquidity == 0) return 0;
  46 |     |             if (roundUp) {
  47 |     |                 dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);
  48 |     |             } else {
  49 |     |                 dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);
  50 |     |             }
  51 |     |         }
  52 |     |     }
  53 |     | 
  54 |     |     function _getDx(
  55 |     |         uint256 liquidity,
  56 |     |         uint256 priceLower,
  57 |     |         uint256 priceUpper,
  58 |     |         bool roundUp
  59 |     |     ) internal pure returns (uint256 dx) {
  60 |     |         unchecked {
  61 |     |             if (liquidity == 0) return 0;
  62 |     |             if (roundUp) {
  63 |     |                 dx = OverflowMath.divRoundingUp(
  64 |     |                         OverflowMath.mulDivRoundingUp(
  65 |     |                             liquidity << 96, 
  66 |     |                             priceUpper - priceLower,
  67 |     |                             priceUpper
  68 |     |                         ),
  69 |     |                         priceLower
  70 |     |                 );
  71 |     |             } else {
  72 |     |                 dx = OverflowMath.mulDiv(
  73 |     |                         liquidity << 96,
  74 |     |                         priceUpper - priceLower,
  75 |     |                         priceUpper
  76 |     |                 ) / priceLower;
  77 |     |             }
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     function getLiquidityForAmounts(
  82 |     |         uint256 priceLower,
  83 |     |         uint256 priceUpper,
  84 |     |         uint256 currentPrice,
  85 |     |         uint256 dy,
  86 |     |         uint256 dx
  87 |     |     ) internal pure returns (uint256 liquidity) {
  88 |     |         unchecked {
  89 |     |             if (priceUpper == currentPrice) {
  90 |     |                 liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);
  91 |     |             } else if (currentPrice == priceLower) {
  92 |     |                 liquidity = OverflowMath.mulDiv(
  93 |     |                     dx,
  94 |     |                     OverflowMath.mulDiv(priceLower, priceUpper, Q96),
  95 |     |                     priceUpper - priceLower
  96 |     |                 );
  97 |     |             } else {
  98 |     |                 /// @dev - price should either be priceUpper or priceLower
  99 |     |                 require (false, 'PriceOutsideBounds()');
 100 |     |             }  
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     function getAmountsForLiquidity(
 105 |     |         uint256 priceLower,
 106 |     |         uint256 priceUpper,
 107 |     |         uint256 currentPrice,
 108 |     |         uint256 liquidityAmount,
 109 |     |         bool roundUp
 110 |     |     ) internal pure returns (uint128 token0amount, uint128 token1amount) {
 111 |     |         if (priceUpper <= currentPrice) {
 112 |     |             token1amount = uint128(_getDy(liquidityAmount, priceLower, priceUpper, roundUp));
 113 |     |         } else if (currentPrice <= priceLower) {
 114 |     |             token0amount = uint128(_getDx(liquidityAmount, priceLower, priceUpper, roundUp));
 115 |     |         } else {
 116 |     |             token0amount = uint128(_getDx(liquidityAmount, currentPrice, priceUpper, roundUp));
 117 |     |             token1amount = uint128(_getDy(liquidityAmount, priceLower, currentPrice, roundUp));
 118 |     |         }
 119 |     |     }
 120 |     | 
 121 |     |     function getNewPrice(
 122 |     |         uint256 price,
 123 |     |         uint256 liquidity,
 124 |     |         uint256 amount,
 125 |     |         bool zeroForOne,
 126 |     |         bool exactIn
 127 |     |     ) internal pure returns (
 128 |     |         uint256 newPrice
 129 |     |     ) {
 130 |     |         if (exactIn) {
 131 |     |             if (zeroForOne) {
 132 |     |                 uint256 liquidityPadded = liquidity << 96;
 133 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 134 |     |                                 liquidityPadded,
 135 |     |                                 price,
 136 |     |                                 liquidityPadded + price * amount
 137 |     |                     );
 138 |     |             } else {
 139 |     |                 newPrice = price + (amount << 96) / liquidity;
 140 |     |             }
 141 |     |         } else {
 142 |     |             if (zeroForOne) {
 143 |     |                 newPrice = price - 
 144 |     |                         OverflowMath.divRoundingUp(amount << 96, liquidity);
 145 |     |             } else {
 146 |     |                 uint256 liquidityPadded = uint256(liquidity) << 96;
 147 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 148 |     |                         liquidityPadded, 
 149 |     |                         price,
 150 |     |                         liquidityPadded - uint256(price) * amount
 151 |     |                 );
 152 |     |             }
 153 |     |         }
 154 |     |     }
 155 |     | 
 156 |     |     /////////////////////////////////////////////////////////////
 157 |     |     ///////////////////////// TICK MATH /////////////////////////
 158 |     |     /////////////////////////////////////////////////////////////
 159 |     | 
 160 |     |     int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128
 161 | *   |     int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128
 162 |     | 
 163 |     |     function minTick(
 164 |     |         int16 tickSpacing
 165 |     |     ) internal pure returns (
 166 |     |         int24 tick
 167 |     |     ) {
 168 |     |         return MIN_TICK / tickSpacing * tickSpacing;
 169 |     |     }
 170 |     | 
 171 | *   |     function maxTick(
 172 |     |         int16 tickSpacing
 173 |     |     ) internal pure returns (
 174 | *   |         int24 tick
 175 |     |     ) {
 176 | *   |         return MAX_TICK / tickSpacing * tickSpacing;
 177 |     |     }
 178 |     | 
 179 |     |     function priceBounds(
 180 |     |         int16 tickSpacing
 181 |     |     ) internal pure returns (
 182 |     |         uint160,
 183 |     |         uint160
 184 |     |     ) {
 185 |     |         return (minPrice(tickSpacing), maxPrice(tickSpacing));
 186 |     |     }
 187 |     | 
 188 |     |     function minPrice(
 189 |     |         int16 tickSpacing
 190 |     |     ) internal pure returns (
 191 |     |         uint160 price
 192 |     |     ) {
 193 |     |         ILimitPoolStructs.Immutables memory constants;
 194 |     |         constants.tickSpacing = tickSpacing;
 195 |     |         return getPriceAtTick(minTick(tickSpacing), constants);
 196 |     |     }
 197 |     | 
 198 |     |     function maxPrice(
 199 |     |         int16 tickSpacing
 200 |     |     ) internal pure returns (
 201 |     |         uint160 price
 202 |     |     ) {
 203 |     |         ILimitPoolStructs.Immutables memory constants;
 204 |     |         constants.tickSpacing = tickSpacing;
 205 |     |         return getPriceAtTick(maxTick(tickSpacing), constants);
 206 |     |     }
 207 |     | 
 208 |     |     function checkTicks(
 209 |     |         int24 lower,
 210 |     |         int24 upper,
 211 |     |         int16 tickSpacing
 212 |     |     ) internal pure
 213 |     |     {
 214 |     |         if (lower <= minTick(tickSpacing)) require (false, 'LowerTickOutOfBounds()');
 215 |     |         if (upper >= maxTick(tickSpacing)) require (false, 'UpperTickOutOfBounds()');
 216 |     |         if (lower % tickSpacing != 0) require (false, 'LowerTickOutsideTickSpacing()');
 217 |     |         if (upper % tickSpacing != 0) require (false, 'UpperTickOutsideTickSpacing()');
 218 |     |         if (lower >= upper) require (false, 'LowerUpperTickOrderInvalid()');
 219 |     |     }
 220 |     | 
 221 |     |     function checkPrice(
 222 |     |         uint160 price,
 223 |     |         PriceBounds memory bounds
 224 |     |     ) internal pure {
 225 |     |         if (price < bounds.min || price >= bounds.max) require (false, 'PriceOutOfBounds()');
 226 |     |     }
 227 |     | 
 228 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96.
 229 |     |     /// @dev Throws if |tick| > max tick.
 230 |     |     /// @param tick The input tick for the above formula.
 231 |     |     /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
 232 |     |     /// at the given tick.
 233 | *   |     function getPriceAtTick(
 234 |     |         int24 tick,
 235 |     |         ILimitPoolStructs.Immutables memory constants
 236 |     |     ) internal pure returns (
 237 | *   |         uint160 price
 238 | *   |     ) {
 239 | *   |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
 240 | *   |         if (absTick > uint256(uint24(maxTick(constants.tickSpacing)))) require (false, 'TickOutOfBounds()');
 241 | *   |         unchecked {
 242 | *   |             uint256 ratio = absTick & 0x1 != 0
 243 | *   |                 ? 0xfffcb933bd6fad37aa2d162d1a594001
 244 |     |                 : 0x100000000000000000000000000000000;
 245 | *   |             if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
 246 | *   |             if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
 247 | *   |             if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
 248 | *   |             if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
 249 | *   |             if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
 250 | *   |             if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
 251 | *   |             if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
 252 | *   |             if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
 253 | *   |             if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
 254 | *   |             if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
 255 | *   |             if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
 256 | *   |             if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
 257 | *   |             if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
 258 | *   |             if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
 259 | *   |             if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
 260 | *   |             if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
 261 | *   |             if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
 262 | *   |             if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
 263 | *   |             if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
 264 |     | 
 265 | *   |             if (tick > 0) ratio = type(uint256).max / ratio;
 266 |     |             // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
 267 |     |             // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
 268 |     |             // We round up in the division so getTickAtPrice of the output price is always consistent.
 269 | *   |             price = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
 270 |     |         }
 271 |     |     }
 272 |     | 
 273 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
 274 |     |     /// @param price The sqrt ratio for which to compute the tick as a Q64.96.
 275 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
 276 | *   |     function getTickAtPrice(
 277 |     |         uint160 price,
 278 |     |         ILimitPoolStructs.Immutables memory constants
 279 | *   |     ) internal pure returns (int24 tick) {
 280 |     |         // Second inequality must be < because the price can never reach the price at the max tick.
 281 | *   |         if (price < constants.bounds.min || price >= constants.bounds.max)
 282 | *   |             require (false, 'PriceOutOfBounds()');
 283 | *   |         uint256 ratio = uint256(price) << 32;
 284 |     | 
 285 |     |         uint256 r = ratio;
 286 |     |         uint256 msb = 0;
 287 |     | 
 288 |     |         assembly {
 289 | *   |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
 290 |     |             msb := or(msb, f)
 291 | *   |             r := shr(f, r)
 292 |     |         }
 293 |     |         assembly {
 294 | *   |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
 295 | *   |             msb := or(msb, f)
 296 | *   |             r := shr(f, r)
 297 |     |         }
 298 |     |         assembly {
 299 | *   |             let f := shl(5, gt(r, 0xFFFFFFFF))
 300 | *   |             msb := or(msb, f)
 301 | *   |             r := shr(f, r)
 302 |     |         }
 303 |     |         assembly {
 304 | *   |             let f := shl(4, gt(r, 0xFFFF))
 305 | *   |             msb := or(msb, f)
 306 | *   |             r := shr(f, r)
 307 |     |         }
 308 |     |         assembly {
 309 | *   |             let f := shl(3, gt(r, 0xFF))
 310 | *   |             msb := or(msb, f)
 311 | *   |             r := shr(f, r)
 312 |     |         }
 313 |     |         assembly {
 314 | *   |             let f := shl(2, gt(r, 0xF))
 315 | *   |             msb := or(msb, f)
 316 | *   |             r := shr(f, r)
 317 |     |         }
 318 |     |         assembly {
 319 | *   |             let f := shl(1, gt(r, 0x3))
 320 | *   |             msb := or(msb, f)
 321 | *   |             r := shr(f, r)
 322 |     |         }
 323 |     |         assembly {
 324 | *   |             let f := gt(r, 0x1)
 325 | *   |             msb := or(msb, f)
 326 |     |         }
 327 |     | 
 328 | *   |         if (msb >= 128) r = ratio >> (msb - 127);
 329 | *   |         else r = ratio << (127 - msb);
 330 |     | 
 331 | *   |         int256 log_2 = (int256(msb) - 128) << 64;
 332 |     | 
 333 |     |         assembly {
 334 | *   |             r := shr(127, mul(r, r))
 335 | *   |             let f := shr(128, r)
 336 | *   |             log_2 := or(log_2, shl(63, f))
 337 | *   |             r := shr(f, r)
 338 |     |         }
 339 |     |         assembly {
 340 | *   |             r := shr(127, mul(r, r))
 341 | *   |             let f := shr(128, r)
 342 | *   |             log_2 := or(log_2, shl(62, f))
 343 | *   |             r := shr(f, r)
 344 |     |         }
 345 |     |         assembly {
 346 | *   |             r := shr(127, mul(r, r))
 347 | *   |             let f := shr(128, r)
 348 | *   |             log_2 := or(log_2, shl(61, f))
 349 | *   |             r := shr(f, r)
 350 |     |         }
 351 |     |         assembly {
 352 | *   |             r := shr(127, mul(r, r))
 353 | *   |             let f := shr(128, r)
 354 | *   |             log_2 := or(log_2, shl(60, f))
 355 | *   |             r := shr(f, r)
 356 |     |         }
 357 |     |         assembly {
 358 | *   |             r := shr(127, mul(r, r))
 359 | *   |             let f := shr(128, r)
 360 | *   |             log_2 := or(log_2, shl(59, f))
 361 | *   |             r := shr(f, r)
 362 |     |         }
 363 |     |         assembly {
 364 | *   |             r := shr(127, mul(r, r))
 365 | *   |             let f := shr(128, r)
 366 | *   |             log_2 := or(log_2, shl(58, f))
 367 | *   |             r := shr(f, r)
 368 |     |         }
 369 |     |         assembly {
 370 | *   |             r := shr(127, mul(r, r))
 371 | *   |             let f := shr(128, r)
 372 | *   |             log_2 := or(log_2, shl(57, f))
 373 | *   |             r := shr(f, r)
 374 |     |         }
 375 |     |         assembly {
 376 | *   |             r := shr(127, mul(r, r))
 377 | *   |             let f := shr(128, r)
 378 | *   |             log_2 := or(log_2, shl(56, f))
 379 | *   |             r := shr(f, r)
 380 |     |         }
 381 |     |         assembly {
 382 | *   |             r := shr(127, mul(r, r))
 383 | *   |             let f := shr(128, r)
 384 | *   |             log_2 := or(log_2, shl(55, f))
 385 | *   |             r := shr(f, r)
 386 |     |         }
 387 |     |         assembly {
 388 | *   |             r := shr(127, mul(r, r))
 389 | *   |             let f := shr(128, r)
 390 | *   |             log_2 := or(log_2, shl(54, f))
 391 | *   |             r := shr(f, r)
 392 |     |         }
 393 |     |         assembly {
 394 | *   |             r := shr(127, mul(r, r))
 395 | *   |             let f := shr(128, r)
 396 | *   |             log_2 := or(log_2, shl(53, f))
 397 | *   |             r := shr(f, r)
 398 |     |         }
 399 |     |         assembly {
 400 | *   |             r := shr(127, mul(r, r))
 401 | *   |             let f := shr(128, r)
 402 | *   |             log_2 := or(log_2, shl(52, f))
 403 | *   |             r := shr(f, r)
 404 |     |         }
 405 |     |         assembly {
 406 | *   |             r := shr(127, mul(r, r))
 407 | *   |             let f := shr(128, r)
 408 | *   |             log_2 := or(log_2, shl(51, f))
 409 | *   |             r := shr(f, r)
 410 |     |         }
 411 |     |         assembly {
 412 | *   |             r := shr(127, mul(r, r))
 413 | *   |             let f := shr(128, r)
 414 | *   |             log_2 := or(log_2, shl(50, f))
 415 |     |         }
 416 |     | 
 417 | *   |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 418 |     | 
 419 | *   |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 420 | *   |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 421 |     | 
 422 | *   |         tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) <= price
 423 | *   |             ? tickHi
 424 | *   |             : tickLow;
 425 |     |     }
 426 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/math/OverflowMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.
   5 |     | library OverflowMath {
   6 |     | 
   7 |     |     // @dev no underflow or overflow checks
   8 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
   9 |     |         assembly {
  10 |     |             z := add(div(x, y), gt(mod(x, y), 0))
  11 |     |         }
  12 |     |     }
  13 |     | 
  14 |     |     /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
  15 |     |     /// @param a The multiplicand.
  16 |     |     /// @param b The multiplier.
  17 |     |     /// @param denominator The divisor.
  18 |     |     /// @return result The 256-bit result.
  19 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.
  20 |     |     function mulDiv(
  21 |     |         uint256 a,
  22 |     |         uint256 b,
  23 |     |         uint256 denominator
  24 |     |     ) internal pure returns (uint256 result) {
  25 |     |         unchecked {
  26 |     |             // 512-bit multiply [prod1 prod0] = a * b.
  27 |     |             // Compute the product mod 2**256 and mod 2**256 - 1,
  28 |     |             // then use the Chinese Remainder Theorem to reconstruct
  29 |     |             // the 512 bit result. The result is stored in two 256
  30 |     |             // variables such that product = prod1 * 2**256 + prod0.
  31 |     |             uint256 prod0; // Least significant 256 bits of the product.
  32 |     |             uint256 prod1; // Most significant 256 bits of the product.
  33 |     |             assembly {
  34 |     |                 let mm := mulmod(a, b, not(0))
  35 |     |                 prod0 := mul(a, b)
  36 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  37 |     |             }
  38 |     |             // Handle non-overflow cases, 256 by 256 division.
  39 |     |             if (prod1 == 0) {
  40 |     |                 require(denominator > 0);
  41 |     |                 assembly {
  42 |     |                     result := div(prod0, denominator)
  43 |     |                 }
  44 |     |                 return result;
  45 |     |             }
  46 |     |             // Make sure the result is less than 2**256 -
  47 |     |             // also prevents denominator == 0.
  48 |     |             require(denominator > prod1);
  49 |     |             ///////////////////////////////////////////////
  50 |     |             // 512 by 256 division.
  51 |     |             ///////////////////////////////////////////////
  52 |     |             // Make division exact by subtracting the remainder from [prod1 prod0] -
  53 |     |             // compute remainder using mulmod.
  54 |     |             uint256 remainder;
  55 |     |             assembly {
  56 |     |                 remainder := mulmod(a, b, denominator)
  57 |     |             }
  58 |     |             // Subtract 256 bit number from 512 bit number.
  59 |     |             assembly {
  60 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  61 |     |                 prod0 := sub(prod0, remainder)
  62 |     |             }
  63 |     |             // Factor powers of two out of denominator -
  64 |     |             // compute largest power of two divisor of denominator
  65 |     |             // (always >= 1).
  66 |     |             uint256 twos = uint256(-int256(denominator)) & denominator;
  67 |     |             // Divide denominator by power of two.
  68 |     |             assembly {
  69 |     |                 denominator := div(denominator, twos)
  70 |     |             }
  71 |     |             // Divide [prod1 prod0] by the factors of two.
  72 |     |             assembly {
  73 |     |                 prod0 := div(prod0, twos)
  74 |     |             }
  75 |     |             // Shift in bits from prod1 into prod0. For this we need
  76 |     |             // to flip `twos` such that it is 2**256 / twos -
  77 |     |             // if twos is zero, then it becomes one.
  78 |     |             assembly {
  79 |     |                 twos := add(div(sub(0, twos), twos), 1)
  80 |     |             }
  81 |     |             prod0 |= prod1 * twos;
  82 |     |             // Invert denominator mod 2**256 -
  83 |     |             // now that denominator is an odd number, it has an inverse
  84 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |             // Compute the inverse by starting with a seed that is correct
  86 |     |             // for four bits. That is, denominator * inv = 1 mod 2**4.
  87 |     |             uint256 inv = (3 * denominator) ^ 2;
  88 |     |             // Now use Newton-Raphson iteration to improve the precision.
  89 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |             // arithmetic, doubling the correct bits in each step.
  91 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**8.
  92 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**16.
  93 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**32.
  94 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**64.
  95 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**128.
  96 |     |             inv *= 2 - denominator * inv; // Inverse mod 2**256.
  97 |     |             // Because the division is now exact we can divide by multiplying
  98 |     |             // with the modular inverse of denominator. This will give us the
  99 |     |             // correct result modulo 2**256. Since the precoditions guarantee
 100 |     |             // that the outcome is less than 2**256, this is the final result.
 101 |     |             // We don't need to compute the high bits of the result and prod1
 102 |     |             // is no longer required.
 103 |     |             result = prod0 * inv;
 104 |     |             return result;
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
 109 |     |     /// @param a The multiplicand.
 110 |     |     /// @param b The multiplier.
 111 |     |     /// @param denominator The divisor.
 112 |     |     /// @return result The 256-bit result.
 113 |     |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 |     |     ) internal pure returns (uint256 result) {
 118 |     |         result = mulDiv(a, b, denominator);
 119 |     |         unchecked {
 120 |     |             if (mulmod(a, b, denominator) != 0) {
 121 |     |                 if (result >= type(uint256).max) require (false, 'MaxUintExceeded()');
 122 |     |                 result++;
 123 |     |             }
 124 |     |         }
 125 |     |     }
 126 |     | }
 127 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/math/constant-product/DyDxMath.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../../interfaces/modules/curves/IDyDxMath.sol';
  5 |     | import '../../../libraries/math/OverflowMath.sol';
  6 |     | 
  7 |     | /// @notice Math library that facilitates ranged liquidity calculations.
  8 |     | library DyDxMath
  9 |     | {
 10 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 11 |     | 
 12 |     |     function getDy(
 13 |     |         uint256 liquidity,
 14 |     |         uint256 priceLower,
 15 |     |         uint256 priceUpper,
 16 |     |         bool roundUp
 17 |     |     ) internal pure returns (uint256 dy) {
 18 |     |         return _getDy(liquidity, priceLower, priceUpper, roundUp);
 19 |     |     }
 20 |     | 
 21 |     |     function getDx(
 22 |     |         uint256 liquidity,
 23 |     |         uint256 priceLower,
 24 |     |         uint256 priceUpper,
 25 |     |         bool roundUp
 26 |     |     ) internal pure returns (uint256 dx) {
 27 |     |         return _getDx(liquidity, priceLower, priceUpper, roundUp);
 28 |     |     }
 29 |     | 
 30 |     |     function _getDy(
 31 |     |         uint256 liquidity,
 32 |     |         uint256 priceLower,
 33 |     |         uint256 priceUpper,
 34 |     |         bool roundUp
 35 |     |     ) internal pure returns (uint256 dy) {
 36 |     |         unchecked {
 37 |     |             if (roundUp) {
 38 |     |                 dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);
 39 |     |             } else {
 40 |     |                 dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);
 41 |     |             }
 42 |     |         }
 43 |     |     }
 44 |     | 
 45 |     |     function _getDx(
 46 |     |         uint256 liquidity,
 47 |     |         uint256 priceLower,
 48 |     |         uint256 priceUpper,
 49 |     |         bool roundUp
 50 |     |     ) internal pure returns (uint256 dx) {
 51 |     |         unchecked {
 52 |     |             if (roundUp) {
 53 |     |                 dx = OverflowMath.divRoundingUp(OverflowMath.mulDivRoundingUp(liquidity << 96, priceUpper - priceLower, priceUpper), priceLower);
 54 |     |             } else {
 55 |     |                 dx = OverflowMath.mulDiv(liquidity << 96, priceUpper - priceLower, priceUpper) / priceLower;
 56 |     |             }
 57 |     |         }
 58 |     |     }
 59 |     | }
 60 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/math/constant-product/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../../interfaces/modules/curves/ITickMath.sol';
   5 |     | import '../../../libraries/math/OverflowMath.sol';
   6 |     | 
   7 |     | /// @notice Math library for computing sqrt price for ticks of size 1.0001, i.e., sqrt(1.0001^tick) as fixed point Q64.96 numbers - supports
   8 |     | /// prices between 2**-128 and 2**128 - 1.
   9 |     | /// @author Adapted from https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/libraries/TickMath.sol.
  10 |     | library TickMath {
  11 |     |     /// @dev The minimum tick that may be passed to #getPriceAtTick computed from log base 1.0001 of 2**-128.
  12 |     |     int24 internal constant MIN_TICK = -887272;
  13 |     |     /// @dev The maximum tick that may be passed to #getPriceAtTick computed from log base 1.0001 of 2**128 - 1.
  14 |     |     int24 internal constant MAX_TICK = -MIN_TICK;
  15 |     |     uint256 private constant Q96 = 0x1000000000000000000000000;
  16 |     | 
  17 |     |     function maxTick(
  18 |     |         int16 tickSpacing
  19 |     |     ) internal pure returns (
  20 |     |         int24 tick
  21 |     |     ) {
  22 |     |         return MAX_TICK / tickSpacing * tickSpacing;
  23 |     |     }
  24 |     | 
  25 |     |     function checkPrice(
  26 |     |         uint160 price,
  27 |     |         ITickMath.PriceBounds memory bounds
  28 |     |     ) internal pure {
  29 |     |         if (price < bounds.min || price >= bounds.max) require (false, 'PriceOutOfBounds()');
  30 |     |     }
  31 |     | 
  32 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96.
  33 |     |     /// @dev Throws if |tick| > max tick.
  34 |     |     /// @param tick The input tick for the above formula.
  35 |     |     /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  36 |     |     /// at the given tick.
  37 |     |     function getPriceAtTick(
  38 |     |         int24 tick,
  39 |     |         ILimitPoolStructs.Immutables memory constants
  40 |     |     ) internal pure returns (
  41 |     |         uint160 price
  42 |     |     ) {
  43 |     |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  44 |     |         if (absTick > uint256(uint24(maxTick(constants.tickSpacing)))) require (false, 'TickOutOfBounds()');
  45 |     |         unchecked {
  46 |     |             uint256 ratio = absTick & 0x1 != 0
  47 |     |                 ? 0xfffcb933bd6fad37aa2d162d1a594001
  48 |     |                 : 0x100000000000000000000000000000000;
  49 |     |             if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  50 |     |             if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  51 |     |             if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  52 |     |             if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  53 |     |             if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  54 |     |             if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  55 |     |             if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  56 |     |             if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  57 |     |             if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  58 |     |             if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  59 |     |             if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  60 |     |             if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  61 |     |             if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  62 |     |             if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  63 |     |             if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  64 |     |             if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  65 |     |             if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  66 |     |             if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  67 |     |             if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  68 |     | 
  69 |     |             if (tick > 0) ratio = type(uint256).max / ratio;
  70 |     |             // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  71 |     |             // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
  72 |     |             // We round up in the division so getTickAtPrice of the output price is always consistent.
  73 |     |             price = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
  78 |     |     /// @param price The sqrt ratio for which to compute the tick as a Q64.96.
  79 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
  80 |     |     function getTickAtPrice(
  81 |     |         uint160 price,
  82 |     |         ILimitPoolStructs.Immutables memory constants
  83 |     |     ) internal pure returns (int24 tick) {
  84 |     |         // Second inequality must be < because the price can never reach the price at the max tick.
  85 |     |         if (price < constants.bounds.min || price >= constants.bounds.max)
  86 |     |             require (false, 'PriceOutOfBounds()');
  87 |     |         uint256 ratio = uint256(price) << 32;
  88 |     | 
  89 |     |         uint256 r = ratio;
  90 |     |         uint256 msb = 0;
  91 |     | 
  92 |     |         assembly {
  93 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  94 |     |             msb := or(msb, f)
  95 |     |             r := shr(f, r)
  96 |     |         }
  97 |     |         assembly {
  98 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  99 |     |             msb := or(msb, f)
 100 |     |             r := shr(f, r)
 101 |     |         }
 102 |     |         assembly {
 103 |     |             let f := shl(5, gt(r, 0xFFFFFFFF))
 104 |     |             msb := or(msb, f)
 105 |     |             r := shr(f, r)
 106 |     |         }
 107 |     |         assembly {
 108 |     |             let f := shl(4, gt(r, 0xFFFF))
 109 |     |             msb := or(msb, f)
 110 |     |             r := shr(f, r)
 111 |     |         }
 112 |     |         assembly {
 113 |     |             let f := shl(3, gt(r, 0xFF))
 114 |     |             msb := or(msb, f)
 115 |     |             r := shr(f, r)
 116 |     |         }
 117 |     |         assembly {
 118 |     |             let f := shl(2, gt(r, 0xF))
 119 |     |             msb := or(msb, f)
 120 |     |             r := shr(f, r)
 121 |     |         }
 122 |     |         assembly {
 123 |     |             let f := shl(1, gt(r, 0x3))
 124 |     |             msb := or(msb, f)
 125 |     |             r := shr(f, r)
 126 |     |         }
 127 |     |         assembly {
 128 |     |             let f := gt(r, 0x1)
 129 |     |             msb := or(msb, f)
 130 |     |         }
 131 |     | 
 132 |     |         if (msb >= 128) r = ratio >> (msb - 127);
 133 |     |         else r = ratio << (127 - msb);
 134 |     | 
 135 |     |         int256 log_2 = (int256(msb) - 128) << 64;
 136 |     | 
 137 |     |         assembly {
 138 |     |             r := shr(127, mul(r, r))
 139 |     |             let f := shr(128, r)
 140 |     |             log_2 := or(log_2, shl(63, f))
 141 |     |             r := shr(f, r)
 142 |     |         }
 143 |     |         assembly {
 144 |     |             r := shr(127, mul(r, r))
 145 |     |             let f := shr(128, r)
 146 |     |             log_2 := or(log_2, shl(62, f))
 147 |     |             r := shr(f, r)
 148 |     |         }
 149 |     |         assembly {
 150 |     |             r := shr(127, mul(r, r))
 151 |     |             let f := shr(128, r)
 152 |     |             log_2 := or(log_2, shl(61, f))
 153 |     |             r := shr(f, r)
 154 |     |         }
 155 |     |         assembly {
 156 |     |             r := shr(127, mul(r, r))
 157 |     |             let f := shr(128, r)
 158 |     |             log_2 := or(log_2, shl(60, f))
 159 |     |             r := shr(f, r)
 160 |     |         }
 161 |     |         assembly {
 162 |     |             r := shr(127, mul(r, r))
 163 |     |             let f := shr(128, r)
 164 |     |             log_2 := or(log_2, shl(59, f))
 165 |     |             r := shr(f, r)
 166 |     |         }
 167 |     |         assembly {
 168 |     |             r := shr(127, mul(r, r))
 169 |     |             let f := shr(128, r)
 170 |     |             log_2 := or(log_2, shl(58, f))
 171 |     |             r := shr(f, r)
 172 |     |         }
 173 |     |         assembly {
 174 |     |             r := shr(127, mul(r, r))
 175 |     |             let f := shr(128, r)
 176 |     |             log_2 := or(log_2, shl(57, f))
 177 |     |             r := shr(f, r)
 178 |     |         }
 179 |     |         assembly {
 180 |     |             r := shr(127, mul(r, r))
 181 |     |             let f := shr(128, r)
 182 |     |             log_2 := or(log_2, shl(56, f))
 183 |     |             r := shr(f, r)
 184 |     |         }
 185 |     |         assembly {
 186 |     |             r := shr(127, mul(r, r))
 187 |     |             let f := shr(128, r)
 188 |     |             log_2 := or(log_2, shl(55, f))
 189 |     |             r := shr(f, r)
 190 |     |         }
 191 |     |         assembly {
 192 |     |             r := shr(127, mul(r, r))
 193 |     |             let f := shr(128, r)
 194 |     |             log_2 := or(log_2, shl(54, f))
 195 |     |             r := shr(f, r)
 196 |     |         }
 197 |     |         assembly {
 198 |     |             r := shr(127, mul(r, r))
 199 |     |             let f := shr(128, r)
 200 |     |             log_2 := or(log_2, shl(53, f))
 201 |     |             r := shr(f, r)
 202 |     |         }
 203 |     |         assembly {
 204 |     |             r := shr(127, mul(r, r))
 205 |     |             let f := shr(128, r)
 206 |     |             log_2 := or(log_2, shl(52, f))
 207 |     |             r := shr(f, r)
 208 |     |         }
 209 |     |         assembly {
 210 |     |             r := shr(127, mul(r, r))
 211 |     |             let f := shr(128, r)
 212 |     |             log_2 := or(log_2, shl(51, f))
 213 |     |             r := shr(f, r)
 214 |     |         }
 215 |     |         assembly {
 216 |     |             r := shr(127, mul(r, r))
 217 |     |             let f := shr(128, r)
 218 |     |             log_2 := or(log_2, shl(50, f))
 219 |     |         }
 220 |     | 
 221 |     |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 222 |     | 
 223 |     |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 224 |     |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 225 |     | 
 226 |     |         tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) <= price
 227 |     |             ? tickHi
 228 |     |             : tickLow;
 229 |     |     }
 230 |     | }
 231 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/BurnCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/ILimitPoolStructs.sol';
   5 |     | import '../Positions.sol';
   6 |     | import '../utils/Collect.sol';
   7 |     | 
   8 | *   | library BurnCall {
   9 |     | 
  10 |     |     error SimulateBurn(int24 lower, int24 upper, bool positionExists);
  11 |     | 
  12 |     |     event BurnLimit(
  13 |     |         address indexed to,
  14 |     |         int24 lower,
  15 |     |         int24 upper,
  16 |     |         int24 claim,
  17 |     |         bool zeroForOne,
  18 |     |         uint128 liquidityBurned,
  19 |     |         uint128 tokenInClaimed,
  20 |     |         uint128 tokenOutBurned
  21 |     |     );
  22 |     | 
  23 |     |     function perform(
  24 |     |         ILimitPoolStructs.BurnParams memory params,
  25 |     |         ILimitPoolStructs.BurnCache memory cache,
  26 |     |         ILimitPoolStructs.TickMap storage tickMap,
  27 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
  28 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
  29 |     |             storage positions
  30 |     |     ) internal returns (ILimitPoolStructs.BurnCache memory) {
  31 |     |         if (params.lower >= params.upper) require (false, 'InvalidPositionBounds()');
  32 |     |         if (cache.position.epochLast == 0) require(false, 'PositionNotFound()');
  33 |     |         if (cache.position.crossedInto
  34 |     |             || params.claim != (params.zeroForOne ? params.lower : params.upper)
  35 |     |             || cache.position.epochLast < (params.zeroForOne ? EpochMap.get(params.lower, tickMap, cache.constants)
  36 |     |                                                              : EpochMap.get(params.upper, tickMap, cache.constants)))
  37 |     |         {
  38 |     |             // position has been crossed into
  39 |     |             (
  40 |     |                 cache.state,
  41 |     |                 cache.pool,
  42 |     |                 cache.position,
  43 |     |                 params.claim
  44 |     |             ) = Positions.update(
  45 |     |                 positions,
  46 |     |                 ticks,
  47 |     |                 tickMap,
  48 |     |                 cache.state,
  49 |     |                 cache.pool,
  50 |     |                 ILimitPoolStructs.UpdateParams(
  51 |     |                     params.to,
  52 |     |                     params.to,
  53 |     |                     params.burnPercent,
  54 |     |                     params.lower,
  55 |     |                     params.upper,
  56 |     |                     params.claim,
  57 |     |                     params.zeroForOne
  58 |     |                 ),
  59 |     |                 cache.constants
  60 |     |             );
  61 |     |         } else {
  62 |     |             // position has not been crossed into
  63 |     |             (cache.pool, cache.position) = Positions.remove(
  64 |     |                 positions,
  65 |     |                 ticks,
  66 |     |                 tickMap,
  67 |     |                 cache.pool,
  68 |     |                 ILimitPoolStructs.UpdateParams(
  69 |     |                     params.to,
  70 |     |                     params.to,
  71 |     |                     params.burnPercent,
  72 |     |                     params.lower,
  73 |     |                     params.upper,
  74 |     |                     params.zeroForOne ? params.lower : params.upper,
  75 |     |                     params.zeroForOne
  76 |     |                 ),
  77 |     |                 cache.constants
  78 |     |             );
  79 |     |         }
  80 |     |         cache = Collect.burn(
  81 |     |             cache,
  82 |     |             params
  83 |     |         );
  84 |     |         if ((params.zeroForOne ? params.claim != params.upper
  85 |     |                                : params.claim != params.lower))
  86 |     |             params.zeroForOne
  87 |     |                 ? positions[params.to][params.claim][params.upper] = cache.position
  88 |     |                 : positions[params.to][params.lower][params.claim] = cache.position;
  89 |     |         return cache;
  90 |     |     }
  91 |     | 
  92 |     |     // Echidna funcs
  93 | *   |     function getResizedTicks(
  94 |     |         ILimitPoolStructs.BurnParams memory params,
  95 |     |         ILimitPoolStructs.BurnCache memory cache,
  96 |     |         ILimitPoolStructs.TickMap storage tickMap,
  97 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
  98 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
  99 |     |             storage positions
 100 |     |     ) external {
 101 | *   |         if (params.lower >= params.upper) require (false, 'InvalidPositionBounds()');
 102 | *   |         if (cache.position.epochLast == 0) require(false, 'PositionNotFound()');
 103 |     |         if (cache.position.crossedInto
 104 |     |             || params.claim != (params.zeroForOne ? params.lower : params.upper)
 105 |     |             || cache.position.epochLast < (params.zeroForOne ? EpochMap.get(params.lower, tickMap, cache.constants)
 106 |     |                                                              : EpochMap.get(params.upper, tickMap, cache.constants)))
 107 |     |         {
 108 |     |             // position has been crossed into
 109 |     |             (
 110 |     |                 cache.state,
 111 |     |                 cache.pool,
 112 |     |                 cache.position,
 113 |     |                 params.claim
 114 |     |             ) = Positions.update(
 115 |     |                 positions,
 116 |     |                 ticks,
 117 |     |                 tickMap,
 118 |     |                 cache.state,
 119 |     |                 cache.pool,
 120 |     |                 ILimitPoolStructs.UpdateParams(
 121 |     |                     params.to,
 122 |     |                     params.to,
 123 |     |                     params.burnPercent,
 124 |     |                     params.lower,
 125 |     |                     params.upper,
 126 |     |                     params.claim,
 127 |     |                     params.zeroForOne
 128 |     |                 ),
 129 |     |                 cache.constants
 130 |     |             );
 131 |     |         } else {
 132 |     |             // position has not been crossed into
 133 |     |             (cache.pool, cache.position) = Positions.remove(
 134 |     |                 positions,
 135 |     |                 ticks,
 136 |     |                 tickMap,
 137 |     |                 cache.pool,
 138 |     |                 ILimitPoolStructs.UpdateParams(
 139 |     |                     params.to,
 140 |     |                     params.to,
 141 |     |                     params.burnPercent,
 142 |     |                     params.lower,
 143 |     |                     params.upper,
 144 |     |                     params.zeroForOne ? params.lower : params.upper,
 145 |     |                     params.zeroForOne
 146 |     |                 ),
 147 |     |                 cache.constants
 148 |     |             );
 149 |     |         }
 150 |     |         cache = Collect.burn(
 151 |     |             cache,
 152 |     |             params
 153 |     |         );
 154 |     | 
 155 |     |         bool positionExists = cache.position.epochLast != 0;
 156 |     | 
 157 |     |         if ((params.zeroForOne ? params.claim != params.upper
 158 |     |                                : params.claim != params.lower)) {
 159 |     |             params.zeroForOne
 160 |     |                 ? positions[params.to][params.claim][params.upper] = cache.position
 161 |     |                 : positions[params.to][params.lower][params.claim] = cache.position;
 162 |     | 
 163 |     |             if (params.zeroForOne) {
 164 |     |                 revert SimulateBurn(params.claim, params.upper, positionExists);
 165 |     |             }
 166 |     |             else {
 167 |     |                 revert SimulateBurn(params.lower, params.claim, positionExists);
 168 |     |             }
 169 |     |         }
 170 |     |         
 171 |     |         revert SimulateBurn(params.lower, params.upper, positionExists);
 172 |     |     }
 173 |     | }
 174 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/MintCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/ILimitPoolStructs.sol';
   5 |     | import '../Positions.sol';
   6 |     | import '../utils/Collect.sol';
   7 |     | import '../EchidnaAssertions.sol';
   8 |     | import '../../interfaces/IERC20Minimal.sol';
   9 |     | 
  10 |     | 
  11 | *   | library MintCall {
  12 |     | 
  13 |     |     error SimulateMint(int24 lower, int24 upper, bool positionCreated);
  14 |     | 
  15 |     |     event MintLimit(
  16 |     |         address indexed to,
  17 |     |         int24 lower,
  18 |     |         int24 upper,
  19 |     |         bool zeroForOne,
  20 |     |         uint32 epochLast,
  21 |     |         uint128 amountIn,
  22 |     |         uint128 amountFilled,
  23 |     |         uint128 liquidityMinted
  24 |     |     );
  25 |     | 
  26 |     |     event Sync(
  27 |     |         uint160 price,
  28 |     |         uint128 liquidity
  29 |     |     );
  30 |     | 
  31 |     |     function perform(
  32 |     |         ILimitPoolStructs.MintParams memory params,
  33 |     |         ILimitPoolStructs.MintCache memory cache,
  34 |     |         ILimitPoolStructs.TickMap storage tickMap,
  35 |     |         ILimitPoolStructs.PoolState storage pool,
  36 |     |         ILimitPoolStructs.PoolState storage swapPool,
  37 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
  38 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage swapTicks,
  39 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
  40 |     |             storage positions
  41 |     |     ) internal returns (ILimitPoolStructs.MintCache memory) {
  42 |     |         // bump swapPool in case user is trying to undercut
  43 |     |         // this avoids trimming positions unnecessarily
  44 |     |         if (cache.swapPool.liquidity == 0) {
  45 |     |             (cache, cache.swapPool) = Ticks.unlock(cache, cache.swapPool, swapTicks, tickMap, !params.zeroForOne);
  46 |     |         }
  47 |     | 
  48 |     |         // resize position if necessary
  49 |     |         (params, cache) = Positions.resize(
  50 |     |             params,
  51 |     |             cache,
  52 |     |             tickMap,
  53 |     |             swapTicks
  54 |     |         );
  55 |     | 
  56 |     |         // save state for safe reentrancy
  57 |     |         save(cache.swapPool, swapPool);
  58 |     | 
  59 |     |         // transfer in token amount
  60 |     |         SafeTransfers.transferIn(
  61 |     |                                  params.zeroForOne ? cache.constants.token0 
  62 |     |                                                    : cache.constants.token1,
  63 |     |                                  params.amount + cache.swapCache.input
  64 |     |                                 );
  65 |     |         // uint256 poolBalanceOut = params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0);
  66 |     |         EchidnaAssertions.assertPoolBalanceExceeded(
  67 |     |             (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)), 
  68 |     |             cache.swapCache.output
  69 |     |         );
  70 |     |         // if swap output
  71 |     |         if (cache.swapCache.output > 0)
  72 |     |             SafeTransfers.transferOut(
  73 |     |                 params.to,
  74 |     |                 params.zeroForOne ? cache.constants.token1 
  75 |     |                                   : cache.constants.token0,
  76 |     |                 cache.swapCache.output
  77 |     |             );
  78 |     |         // mint position if amount is left
  79 |     |         if (params.amount > 0 && params.lower < params.upper) {
  80 |     |             // load position given params
  81 |     |             cache.position = positions[params.to][params.lower][params.upper];
  82 |     |             
  83 |     |             // bump to the next tick if there is no liquidity
  84 |     |             if (cache.pool.liquidity == 0) {
  85 |     |                 /// @dev - this makes sure to have liquidity unlocked if undercutting
  86 |     |                 (cache, cache.pool) = Ticks.unlock(cache, cache.pool, ticks, tickMap, params.zeroForOne);
  87 |     |             }
  88 |     | 
  89 |     |             if (params.zeroForOne) {
  90 |     |                 uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
  91 |     |                 if (priceLower <= cache.pool.price) {
  92 |     |                     // save liquidity if active
  93 |     |                     if (cache.pool.liquidity > 0) {
  94 |     |                         cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);
  95 |     |                     }
  96 |     |                     cache.pool.price = priceLower;
  97 |     |                     cache.pool.tickAtPrice = params.lower;
  98 |     |                     /// @auditor - double check liquidity is set correctly for this in insertSingle
  99 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 100 |     |                     cache.position.crossedInto = true;
 101 |     |                     // set epoch on start tick to signify position being crossed into
 102 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 103 |     |                     emit Sync(cache.pool.price, cache.pool.liquidity);
 104 |     |                 }
 105 |     |             } else {
 106 |     |                 uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 107 |     |                 if (priceUpper >= cache.pool.price) {
 108 |     |                     if (cache.pool.liquidity > 0) {
 109 |     |                         cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);
 110 |     |                     }
 111 |     |                     cache.pool.price = priceUpper;
 112 |     |                     cache.pool.tickAtPrice = params.upper;
 113 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 114 |     |                     cache.position.crossedInto = true;
 115 |     |                     // set epoch on start tick to signify position being crossed into
 116 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 117 |     |                     emit Sync(cache.pool.price, cache.pool.liquidity);
 118 |     |                 }
 119 |     |             }
 120 |     |             (cache.pool, cache.position) = Positions.add(
 121 |     |                 cache,
 122 |     |                 ticks,
 123 |     |                 tickMap,
 124 |     |                 params
 125 |     |             );
 126 |     | 
 127 |     |             // save position to storage
 128 |     |             positions[params.to][params.lower][params.upper] = cache.position;
 129 |     | 
 130 |     |             emit MintLimit(
 131 |     |                 params.to,
 132 |     |                 params.lower,
 133 |     |                 params.upper,
 134 |     |                 params.zeroForOne,
 135 |     |                 cache.position.epochLast,
 136 |     |                 uint128(params.amount + cache.swapCache.input),
 137 |     |                 uint128(cache.swapCache.output),
 138 |     |                 uint128(cache.liquidityMinted)
 139 |     |             );
 140 |     |         }
 141 |     | 
 142 |     |         // save lp side for safe reentrancy
 143 |     |         save(cache.pool, pool);
 144 |     | 
 145 |     |         return cache;
 146 |     |     }
 147 |     | 
 148 |     |     function save(
 149 |     |         ILimitPoolStructs.PoolState memory pool,
 150 |     |         ILimitPoolStructs.PoolState storage poolState
 151 |     |     ) internal {
 152 |     |         poolState.price = pool.price;
 153 |     |         poolState.liquidity = pool.liquidity;
 154 |     |         poolState.liquidityGlobal = pool.liquidityGlobal;
 155 |     |         poolState.swapEpoch = pool.swapEpoch;
 156 |     |         poolState.tickAtPrice = pool.tickAtPrice;
 157 |     |     }
 158 |     | 
 159 |     |     // Echidna funcs
 160 | *   |     function getResizedTicks(
 161 |     |        ILimitPoolStructs.MintParams memory params,
 162 |     |         ILimitPoolStructs.MintCache memory cache,
 163 |     |         ILimitPoolStructs.TickMap storage tickMap,
 164 |     |         ILimitPoolStructs.PoolState storage pool,
 165 |     |         ILimitPoolStructs.PoolState storage swapPool,
 166 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks,
 167 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage swapTicks,
 168 |     |         mapping(address => mapping(int24 => mapping(int24 => ILimitPoolStructs.Position)))
 169 |     |             storage positions
 170 |     |     ) external {
 171 | *   |         bool positionCreated = false;
 172 |     |         // bump swapPool in case user is trying to undercut
 173 |     |         // this avoids trimming positions unnecessarily
 174 | *   |         if (cache.swapPool.liquidity == 0) {
 175 | *   |             (cache, cache.swapPool) = Ticks.unlock(cache, cache.swapPool, swapTicks, tickMap, !params.zeroForOne);
 176 |     |         }
 177 |     | 
 178 |     |         // resize position if necessary
 179 | *   |         (params, cache) = Positions.resize(
 180 | *   |             params,
 181 | *   |             cache,
 182 | *   |             tickMap,
 183 | *   |             swapTicks
 184 |     |         );
 185 |     | 
 186 |     |         // save state for safe reentrancy
 187 | *   |         save(cache.swapPool, swapPool);
 188 |     | 
 189 |     |         // transfer in token amount
 190 | *   |         SafeTransfers.transferIn(
 191 | *   |                                  params.zeroForOne ? cache.constants.token0 
 192 | *   |                                                    : cache.constants.token1,
 193 |     |                                  params.amount + cache.swapCache.input
 194 |     |                                 );
 195 |     |         // if swap output
 196 |     |         if (cache.swapCache.output > 0)
 197 |     |             SafeTransfers.transferOut(
 198 |     |                 params.to,
 199 |     |                 params.zeroForOne ? cache.constants.token1 
 200 |     |                                   : cache.constants.token0,
 201 |     |                 cache.swapCache.output
 202 |     |             );
 203 |     |         // mint position if amount is left
 204 |     |         if (params.amount > 0 && params.lower < params.upper) {
 205 |     |             // load position given params
 206 |     |             cache.position = positions[params.to][params.lower][params.upper];
 207 |     |             
 208 |     |             // bump to the next tick if there is no liquidity
 209 |     |             if (cache.pool.liquidity == 0) {
 210 |     |                 /// @dev - this makes sure to have liquidity unlocked if undercutting
 211 |     |                 (cache, cache.pool) = Ticks.unlock(cache, cache.pool, ticks, tickMap, params.zeroForOne);
 212 |     |             }
 213 |     | 
 214 |     |             if (params.zeroForOne) {
 215 |     |                 uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 216 |     |                 if (priceLower <= cache.pool.price) {
 217 |     |                     // save liquidity if active
 218 |     |                     if (cache.pool.liquidity > 0) {
 219 |     |                         cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);
 220 |     |                     }
 221 |     |                     cache.pool.price = priceLower;
 222 |     |                     cache.pool.tickAtPrice = params.lower;
 223 |     |                     /// @auditor - double check liquidity is set correctly for this in insertSingle
 224 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 225 |     |                     cache.position.crossedInto = true;
 226 |     |                     // set epoch on start tick to signify position being crossed into
 227 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 228 |     |                     emit Sync(cache.pool.price, cache.pool.liquidity);
 229 |     |                 }
 230 |     |             } else {
 231 |     |                 uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 232 |     |                 if (priceUpper >= cache.pool.price) {
 233 |     |                     if (cache.pool.liquidity > 0) {
 234 |     |                         cache.pool = Ticks.insertSingle(params, ticks, tickMap, cache, cache.pool, cache.constants);
 235 |     |                     }
 236 |     |                     cache.pool.price = priceUpper;
 237 |     |                     cache.pool.tickAtPrice = params.upper;
 238 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 239 |     |                     cache.position.crossedInto = true;
 240 |     |                     // set epoch on start tick to signify position being crossed into
 241 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 242 |     |                     emit Sync(cache.pool.price, cache.pool.liquidity);
 243 |     |                 }
 244 |     |             }
 245 |     |             (cache.pool, cache.position) = Positions.add(
 246 |     |                 cache,
 247 |     |                 ticks,
 248 |     |                 tickMap,
 249 |     |                 params
 250 |     |             );
 251 |     | 
 252 |     |             // save position to storage
 253 |     |             positionCreated = true;
 254 |     |             positions[params.to][params.lower][params.upper] = cache.position;
 255 |     | 
 256 |     |             emit MintLimit(
 257 |     |                 params.to,
 258 |     |                 params.lower,
 259 |     |                 params.upper,
 260 |     |                 params.zeroForOne,
 261 |     |                 cache.position.epochLast,
 262 |     |                 uint128(params.amount + cache.swapCache.input),
 263 |     |                 uint128(cache.swapCache.output),
 264 |     |                 uint128(cache.liquidityMinted)
 265 |     |             );
 266 |     |         }
 267 |     | 
 268 |     |         // save lp side for safe reentrancy
 269 |     |         save(cache.pool, pool);
 270 |     |     
 271 |     |         revert SimulateMint(params.lower, params.upper, positionCreated);
 272 |     |     }
 273 |     | 
 274 |     |     function balance(
 275 |     |         address token
 276 |     |     ) private view returns (uint256) {
 277 |     |         (
 278 |     |             bool success,
 279 |     |             bytes memory data
 280 |     |         ) = token.staticcall(
 281 |     |                                     abi.encodeWithSelector(
 282 |     |                                         IERC20Minimal.balanceOf.selector,
 283 |     |                                         address(this)
 284 |     |                                     )
 285 |     |                                 );
 286 |     |         require(success && data.length >= 32);
 287 |     |         return abi.decode(data, (uint256));
 288 |     |     }
 289 |     | }
 290 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/QuoteCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/ILimitPoolStructs.sol';
  5 |     | import '../Ticks.sol';
  6 |     | 
  7 |     | library QuoteCall {
  8 |     |     event Swap(
  9 |     |         address indexed recipient,
 10 |     |         bool zeroForOne,
 11 |     |         uint256 amountIn,
 12 |     |         uint256 amountOut,
 13 |     |         uint160 price,
 14 |     |         uint128 liquidity,
 15 |     |         int24 tickAtPrice
 16 |     |     );
 17 |     | 
 18 |     |     function perform(
 19 |     |         ILimitPoolStructs.QuoteParams memory params,
 20 |     |         ILimitPoolStructs.SwapCache memory cache,
 21 |     |         ILimitPoolStructs.TickMap storage tickMap,
 22 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks
 23 |     |     ) internal view returns (
 24 |     |         uint256,
 25 |     |         uint256,
 26 |     |         uint160
 27 |     |     ) {
 28 |     |         return Ticks.quote(
 29 |     |             ticks,
 30 |     |             tickMap,
 31 |     |             params,
 32 |     |             cache,
 33 |     |             cache.pool
 34 |     |         );
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/pool/SwapCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/ILimitPoolStructs.sol';
   5 |     | import '../../interfaces/callbacks/IPoolsharkSwapCallback.sol';
   6 |     | import '../../interfaces/IERC20Minimal.sol';
   7 |     | import '../Positions.sol';
   8 |     | import '../Ticks.sol';
   9 |     | import '../utils/Collect.sol';
  10 |     | import '../utils/SafeTransfers.sol';
  11 |     | 
  12 |     | library SwapCall {
  13 |     |     event SwapPool0(
  14 |     |         address indexed recipient,
  15 |     |         uint128 amountIn,
  16 |     |         uint128 amountOut,
  17 |     |         uint160 priceLimit,
  18 |     |         uint160 newPrice
  19 |     |     );
  20 |     | 
  21 |     |     event SwapPool1(
  22 |     |         address indexed recipient,
  23 |     |         uint128 amountIn,
  24 |     |         uint128 amountOut,
  25 |     |         uint160 priceLimit,
  26 |     |         uint160 newPrice
  27 |     |     );
  28 |     | 
  29 |     |     function perform(
  30 |     |         ILimitPoolStructs.SwapParams memory params,
  31 |     |         ILimitPoolStructs.SwapCache memory cache,
  32 |     |         ILimitPoolStructs.TickMap storage tickMap,
  33 |     |         ILimitPoolStructs.PoolState storage poolState,
  34 |     |         mapping(int24 => ILimitPoolStructs.Tick) storage ticks
  35 |     |     ) internal returns (
  36 |     |         int256,
  37 |     |         int256
  38 |     |     ) {
  39 |     |         (cache.pool, cache) = Ticks.swap(
  40 |     |             ticks,
  41 |     |             tickMap,
  42 |     |             params,
  43 |     |             cache,
  44 |     |             cache.pool
  45 |     |         );
  46 |     |         save(cache.pool, poolState);
  47 |     |         EchidnaAssertions.assertPoolBalanceExceeded(
  48 |     |             (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)), 
  49 |     |             cache.output
  50 |     |         );
  51 |     |         // transfer output amount
  52 |     |         SafeTransfers.transferOut(
  53 |     |             params.to, 
  54 |     |             params.zeroForOne ? cache.constants.token1
  55 |     |                               : cache.constants.token0,
  56 |     |             cache.output
  57 |     |         );
  58 |     | 
  59 |     |         // check balance and execute callback
  60 |     |         uint256 balanceStart = balance(params, cache);
  61 |     |         IPoolsharkSwapCallback(msg.sender).poolsharkSwapCallback(
  62 |     |             params.zeroForOne ? -int256(cache.input) : int256(cache.output),
  63 |     |             params.zeroForOne ? int256(cache.output) : -int256(cache.input),
  64 |     |             params.callbackData
  65 |     |         );
  66 |     | 
  67 |     |         // check balance requirements after callback
  68 |     |         if (balance(params, cache) < balanceStart + cache.input)
  69 |     |             require(false, 'SwapInputAmountTooLow()');
  70 |     | 
  71 |     |         return (
  72 |     |             params.zeroForOne ? 
  73 |     |                 (
  74 |     |                     -int256(cache.input),
  75 |     |                      int256(cache.output)
  76 |     |                 )
  77 |     |               : (
  78 |     |                      int256(cache.output),
  79 |     |                     -int256(cache.input)
  80 |     |                 )
  81 |     |         );
  82 |     |     }
  83 |     | 
  84 |     |     function save(
  85 |     |         ILimitPoolStructs.PoolState memory pool,
  86 |     |         ILimitPoolStructs.PoolState storage poolState
  87 |     |     ) internal {
  88 |     |         poolState.price = pool.price;
  89 |     |         poolState.liquidity = pool.liquidity;
  90 |     |         poolState.liquidityGlobal = pool.liquidityGlobal;
  91 |     |         poolState.swapEpoch = pool.swapEpoch;
  92 |     |         poolState.tickAtPrice = pool.tickAtPrice;
  93 |     |     }
  94 |     | 
  95 |     |     function balance(
  96 |     |         ILimitPoolStructs.SwapParams memory params,
  97 |     |         ILimitPoolStructs.SwapCache memory cache
  98 |     |     ) private view returns (uint256) {
  99 |     |         (
 100 |     |             bool success,
 101 |     |             bytes memory data
 102 |     |         ) = (params.zeroForOne ? cache.constants.token0
 103 |     |                                : cache.constants.token1)
 104 |     |                                .staticcall(
 105 |     |                                     abi.encodeWithSelector(
 106 |     |                                         IERC20Minimal.balanceOf.selector,
 107 |     |                                         address(this)
 108 |     |                                     )
 109 |     |                                 );
 110 |     |         require(success && data.length >= 32);
 111 |     |         return abi.decode(data, (uint256));
 112 |     |     }
 113 |     | 
 114 |     |     function balance(
 115 |     |         address token
 116 |     |     ) private view returns (uint256) {
 117 |     |         (
 118 |     |             bool success,
 119 |     |             bytes memory data
 120 |     |         ) = token.staticcall(
 121 |     |                                     abi.encodeWithSelector(
 122 |     |                                         IERC20Minimal.balanceOf.selector,
 123 |     |                                         address(this)
 124 |     |                                     )
 125 |     |                                 );
 126 |     |         require(success && data.length >= 32);
 127 |     |         return abi.decode(data, (uint256));
 128 |     |     }
 129 |     | }
 130 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/solady/Clone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Class with helper read functions for clone with immutable args.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)
   6 |     | /// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie
   7 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   8 |     | abstract contract Clone {
   9 |     |     /// @dev Reads an immutable arg with type bytes.
  10 |     |     function _getArgBytes(uint256 argOffset, uint256 length)
  11 |     |         internal
  12 |     |         pure
  13 |     |         returns (bytes memory arg)
  14 |     |     {
  15 |     |         uint256 offset = _getImmutableArgsOffset();
  16 |     |         /// @solidity memory-safe-assembly
  17 |     |         assembly {
  18 |     |             arg := mload(0x40)
  19 |     |             mstore(arg, length) // Store the length.
  20 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), length)
  21 |     |             let o := add(add(arg, 0x20), length)
  22 |     |             mstore(o, 0) // Zeroize the slot after the bytes.
  23 |     |             mstore(0x40, add(o, 0x20)) // Allocate the memory.
  24 |     |         }
  25 |     |     }
  26 |     | 
  27 |     |     /// @dev Reads an immutable arg with type address.
  28 |     |     function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {
  29 |     |         uint256 offset = _getImmutableArgsOffset();
  30 |     |         /// @solidity memory-safe-assembly
  31 |     |         assembly {
  32 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /// @dev Reads a uint256 array stored in the immutable args.
  37 |     |     function _getArgUint256Array(uint256 argOffset, uint256 length)
  38 |     |         internal
  39 |     |         pure
  40 |     |         returns (uint256[] memory arg)
  41 |     |     {
  42 |     |         uint256 offset = _getImmutableArgsOffset();
  43 |     |         /// @solidity memory-safe-assembly
  44 |     |         assembly {
  45 |     |             arg := mload(0x40)
  46 |     |             mstore(arg, length) // Store the length.
  47 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  48 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @dev Reads a bytes32 array stored in the immutable args.
  53 |     |     function _getArgBytes32Array(uint256 argOffset, uint256 length)
  54 |     |         internal
  55 |     |         pure
  56 |     |         returns (bytes32[] memory arg)
  57 |     |     {
  58 |     |         uint256 offset = _getImmutableArgsOffset();
  59 |     |         /// @solidity memory-safe-assembly
  60 |     |         assembly {
  61 |     |             arg := mload(0x40)
  62 |     |             mstore(arg, length) // Store the length.
  63 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  64 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /// @dev Reads an immutable arg with type bytes32.
  69 |     |     function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {
  70 |     |         uint256 offset = _getImmutableArgsOffset();
  71 |     |         /// @solidity memory-safe-assembly
  72 |     |         assembly {
  73 |     |             arg := calldataload(add(offset, argOffset))
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @dev Reads an immutable arg with type uint256.
  78 |     |     function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {
  79 |     |         uint256 offset = _getImmutableArgsOffset();
  80 |     |         /// @solidity memory-safe-assembly
  81 |     |         assembly {
  82 |     |             arg := calldataload(add(offset, argOffset))
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /// @dev Reads an immutable arg with type uint248.
  87 |     |     function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {
  88 |     |         uint256 offset = _getImmutableArgsOffset();
  89 |     |         /// @solidity memory-safe-assembly
  90 |     |         assembly {
  91 |     |             arg := shr(8, calldataload(add(offset, argOffset)))
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @dev Reads an immutable arg with type uint240.
  96 |     |     function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {
  97 |     |         uint256 offset = _getImmutableArgsOffset();
  98 |     |         /// @solidity memory-safe-assembly
  99 |     |         assembly {
 100 |     |             arg := shr(16, calldataload(add(offset, argOffset)))
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @dev Reads an immutable arg with type uint232.
 105 |     |     function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {
 106 |     |         uint256 offset = _getImmutableArgsOffset();
 107 |     |         /// @solidity memory-safe-assembly
 108 |     |         assembly {
 109 |     |             arg := shr(24, calldataload(add(offset, argOffset)))
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @dev Reads an immutable arg with type uint224.
 114 |     |     function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {
 115 |     |         uint256 offset = _getImmutableArgsOffset();
 116 |     |         /// @solidity memory-safe-assembly
 117 |     |         assembly {
 118 |     |             arg := shr(0x20, calldataload(add(offset, argOffset)))
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev Reads an immutable arg with type uint216.
 123 |     |     function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {
 124 |     |         uint256 offset = _getImmutableArgsOffset();
 125 |     |         /// @solidity memory-safe-assembly
 126 |     |         assembly {
 127 |     |             arg := shr(40, calldataload(add(offset, argOffset)))
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev Reads an immutable arg with type uint208.
 132 |     |     function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {
 133 |     |         uint256 offset = _getImmutableArgsOffset();
 134 |     |         /// @solidity memory-safe-assembly
 135 |     |         assembly {
 136 |     |             arg := shr(48, calldataload(add(offset, argOffset)))
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     /// @dev Reads an immutable arg with type uint200.
 141 |     |     function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {
 142 |     |         uint256 offset = _getImmutableArgsOffset();
 143 |     |         /// @solidity memory-safe-assembly
 144 |     |         assembly {
 145 |     |             arg := shr(56, calldataload(add(offset, argOffset)))
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @dev Reads an immutable arg with type uint192.
 150 |     |     function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {
 151 |     |         uint256 offset = _getImmutableArgsOffset();
 152 |     |         /// @solidity memory-safe-assembly
 153 |     |         assembly {
 154 |     |             arg := shr(64, calldataload(add(offset, argOffset)))
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /// @dev Reads an immutable arg with type uint184.
 159 |     |     function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {
 160 |     |         uint256 offset = _getImmutableArgsOffset();
 161 |     |         /// @solidity memory-safe-assembly
 162 |     |         assembly {
 163 |     |             arg := shr(72, calldataload(add(offset, argOffset)))
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @dev Reads an immutable arg with type uint176.
 168 |     |     function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {
 169 |     |         uint256 offset = _getImmutableArgsOffset();
 170 |     |         /// @solidity memory-safe-assembly
 171 |     |         assembly {
 172 |     |             arg := shr(80, calldataload(add(offset, argOffset)))
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /// @dev Reads an immutable arg with type uint168.
 177 |     |     function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {
 178 |     |         uint256 offset = _getImmutableArgsOffset();
 179 |     |         /// @solidity memory-safe-assembly
 180 |     |         assembly {
 181 |     |             arg := shr(88, calldataload(add(offset, argOffset)))
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @dev Reads an immutable arg with type uint160.
 186 |     |     function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {
 187 |     |         uint256 offset = _getImmutableArgsOffset();
 188 |     |         /// @solidity memory-safe-assembly
 189 |     |         assembly {
 190 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
 191 |     |         }
 192 |     |     }
 193 |     | 
 194 |     |     /// @dev Reads an immutable arg with type uint152.
 195 |     |     function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {
 196 |     |         uint256 offset = _getImmutableArgsOffset();
 197 |     |         /// @solidity memory-safe-assembly
 198 |     |         assembly {
 199 |     |             arg := shr(104, calldataload(add(offset, argOffset)))
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @dev Reads an immutable arg with type uint144.
 204 |     |     function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {
 205 |     |         uint256 offset = _getImmutableArgsOffset();
 206 |     |         /// @solidity memory-safe-assembly
 207 |     |         assembly {
 208 |     |             arg := shr(112, calldataload(add(offset, argOffset)))
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     /// @dev Reads an immutable arg with type uint136.
 213 |     |     function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {
 214 |     |         uint256 offset = _getImmutableArgsOffset();
 215 |     |         /// @solidity memory-safe-assembly
 216 |     |         assembly {
 217 |     |             arg := shr(120, calldataload(add(offset, argOffset)))
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @dev Reads an immutable arg with type uint128.
 222 |     |     function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {
 223 |     |         uint256 offset = _getImmutableArgsOffset();
 224 |     |         /// @solidity memory-safe-assembly
 225 |     |         assembly {
 226 |     |             arg := shr(128, calldataload(add(offset, argOffset)))
 227 |     |         }
 228 |     |     }
 229 |     | 
 230 |     |     /// @dev Reads an immutable arg with type uint120.
 231 |     |     function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {
 232 |     |         uint256 offset = _getImmutableArgsOffset();
 233 |     |         /// @solidity memory-safe-assembly
 234 |     |         assembly {
 235 |     |             arg := shr(136, calldataload(add(offset, argOffset)))
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @dev Reads an immutable arg with type uint112.
 240 |     |     function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {
 241 |     |         uint256 offset = _getImmutableArgsOffset();
 242 |     |         /// @solidity memory-safe-assembly
 243 |     |         assembly {
 244 |     |             arg := shr(144, calldataload(add(offset, argOffset)))
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /// @dev Reads an immutable arg with type uint104.
 249 |     |     function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {
 250 |     |         uint256 offset = _getImmutableArgsOffset();
 251 |     |         /// @solidity memory-safe-assembly
 252 |     |         assembly {
 253 |     |             arg := shr(152, calldataload(add(offset, argOffset)))
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     /// @dev Reads an immutable arg with type uint96.
 258 |     |     function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {
 259 |     |         uint256 offset = _getImmutableArgsOffset();
 260 |     |         /// @solidity memory-safe-assembly
 261 |     |         assembly {
 262 |     |             arg := shr(160, calldataload(add(offset, argOffset)))
 263 |     |         }
 264 |     |     }
 265 |     | 
 266 |     |     /// @dev Reads an immutable arg with type uint88.
 267 |     |     function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {
 268 |     |         uint256 offset = _getImmutableArgsOffset();
 269 |     |         /// @solidity memory-safe-assembly
 270 |     |         assembly {
 271 |     |             arg := shr(168, calldataload(add(offset, argOffset)))
 272 |     |         }
 273 |     |     }
 274 |     | 
 275 |     |     /// @dev Reads an immutable arg with type uint80.
 276 |     |     function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {
 277 |     |         uint256 offset = _getImmutableArgsOffset();
 278 |     |         /// @solidity memory-safe-assembly
 279 |     |         assembly {
 280 |     |             arg := shr(176, calldataload(add(offset, argOffset)))
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     /// @dev Reads an immutable arg with type uint72.
 285 |     |     function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {
 286 |     |         uint256 offset = _getImmutableArgsOffset();
 287 |     |         /// @solidity memory-safe-assembly
 288 |     |         assembly {
 289 |     |             arg := shr(184, calldataload(add(offset, argOffset)))
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     /// @dev Reads an immutable arg with type uint64.
 294 |     |     function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {
 295 |     |         uint256 offset = _getImmutableArgsOffset();
 296 |     |         /// @solidity memory-safe-assembly
 297 |     |         assembly {
 298 |     |             arg := shr(192, calldataload(add(offset, argOffset)))
 299 |     |         }
 300 |     |     }
 301 |     | 
 302 |     |     /// @dev Reads an immutable arg with type uint56.
 303 |     |     function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {
 304 |     |         uint256 offset = _getImmutableArgsOffset();
 305 |     |         /// @solidity memory-safe-assembly
 306 |     |         assembly {
 307 |     |             arg := shr(200, calldataload(add(offset, argOffset)))
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     /// @dev Reads an immutable arg with type uint48.
 312 |     |     function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {
 313 |     |         uint256 offset = _getImmutableArgsOffset();
 314 |     |         /// @solidity memory-safe-assembly
 315 |     |         assembly {
 316 |     |             arg := shr(208, calldataload(add(offset, argOffset)))
 317 |     |         }
 318 |     |     }
 319 |     | 
 320 |     |     /// @dev Reads an immutable arg with type uint40.
 321 |     |     function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {
 322 |     |         uint256 offset = _getImmutableArgsOffset();
 323 |     |         /// @solidity memory-safe-assembly
 324 |     |         assembly {
 325 |     |             arg := shr(216, calldataload(add(offset, argOffset)))
 326 |     |         }
 327 |     |     }
 328 |     | 
 329 |     |     /// @dev Reads an immutable arg with type uint32.
 330 |     |     function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {
 331 |     |         uint256 offset = _getImmutableArgsOffset();
 332 |     |         /// @solidity memory-safe-assembly
 333 |     |         assembly {
 334 |     |             arg := shr(224, calldataload(add(offset, argOffset)))
 335 |     |         }
 336 |     |     }
 337 |     | 
 338 |     |     /// @dev Reads an immutable arg with type uint24.
 339 |     |     function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {
 340 |     |         uint256 offset = _getImmutableArgsOffset();
 341 |     |         /// @solidity memory-safe-assembly
 342 |     |         assembly {
 343 |     |             arg := shr(232, calldataload(add(offset, argOffset)))
 344 |     |         }
 345 |     |     }
 346 |     | 
 347 |     |     /// @dev Reads an immutable arg with type uint16.
 348 |     |     function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {
 349 |     |         uint256 offset = _getImmutableArgsOffset();
 350 |     |         /// @solidity memory-safe-assembly
 351 |     |         assembly {
 352 |     |             arg := shr(240, calldataload(add(offset, argOffset)))
 353 |     |         }
 354 |     |     }
 355 |     | 
 356 |     |     /// @dev Reads an immutable arg with type uint8.
 357 |     |     function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {
 358 |     |         uint256 offset = _getImmutableArgsOffset();
 359 |     |         /// @solidity memory-safe-assembly
 360 |     |         assembly {
 361 |     |             arg := shr(248, calldataload(add(offset, argOffset)))
 362 |     |         }
 363 |     |     }
 364 |     | 
 365 |     |     /// @return offset The offset of the packed immutable args in calldata.
 366 |     |     function _getImmutableArgsOffset() internal pure returns (uint256 offset) {
 367 |     |         /// @solidity memory-safe-assembly
 368 |     |         assembly {
 369 |     |             offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))
 370 |     |         }
 371 |     |     }
 372 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/solady/LibClone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.4;
   3 |     | 
   4 |     | /// @notice Minimal proxy library.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)
   6 |     | /// @author Minimal proxy by 0age (https://github.com/0age)
   7 |     | /// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie
   8 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   9 |     | ///
  10 |     | /// @dev Minimal proxy:
  11 |     | /// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,
  12 |     | /// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,
  13 |     | /// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.
  14 |     | ///
  15 |     | /// @dev Clones with immutable args (CWIA):
  16 |     | /// The implementation of CWIA here implements a `receive()` method that emits the
  17 |     | /// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,
  18 |     | /// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards
  19 |     | /// composability. The minimal proxy implementation does not offer this feature.
  20 |     | library LibClone {
  21 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  22 |     |     /*                       CUSTOM ERRORS                        */
  23 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  24 |     | 
  25 |     |     /// @dev Unable to deploy the clone.
  26 |     |     error DeploymentFailed();
  27 |     | 
  28 |     |     /// @dev The salt must start with either the zero address or the caller.
  29 |     |     error SaltDoesNotStartWithCaller();
  30 |     | 
  31 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  32 |     |     /*                  MINIMAL PROXY OPERATIONS                  */
  33 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  34 |     | 
  35 |     |     /// @dev Deploys a deterministic clone of `implementation`,
  36 |     |     /// using immutable  arguments encoded in `data`, with `salt`.
  37 |     |     function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)
  38 |     |         internal
  39 |     |         returns (address instance)
  40 |     |     {
  41 |     |         assembly {
  42 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  43 |     |             let mBefore3 := mload(sub(data, 0x60))
  44 |     |             let mBefore2 := mload(sub(data, 0x40))
  45 |     |             let mBefore1 := mload(sub(data, 0x20))
  46 |     |             let dataLength := mload(data)
  47 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  48 |     |             let mAfter1 := mload(dataEnd)
  49 |     | 
  50 |     |             // +2 bytes for telling how much data there is appended to the call.
  51 |     |             let extraLength := add(dataLength, 2)
  52 |     | 
  53 |     |             // Write the bytecode before the data.
  54 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
  55 |     |             // Write the address of the implementation.
  56 |     |             mstore(sub(data, 0x0d), implementation)
  57 |     |             // Write the rest of the bytecode.
  58 |     |             mstore(
  59 |     |                 sub(data, 0x21),
  60 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  61 |     |             )
  62 |     |             // `keccak256("ReceiveETH(uint256)")`
  63 |     |             mstore(
  64 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  65 |     |             )
  66 |     |             mstore(
  67 |     |                 sub(data, 0x5a),
  68 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
  69 |     |             )
  70 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  71 |     | 
  72 |     |             // Create the instance.
  73 |     |             instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)
  74 |     | 
  75 |     |             // If `instance` is zero, revert.
  76 |     |             if iszero(instance) {
  77 |     |                 // Store the function selector of `DeploymentFailed()`.
  78 |     |                 mstore(0x00, 0x30116425)
  79 |     |                 // Revert with (offset, size).
  80 |     |                 revert(0x1c, 0x04)
  81 |     |             }
  82 |     | 
  83 |     |             // Restore the overwritten memory surrounding `data`.
  84 |     |             mstore(dataEnd, mAfter1)
  85 |     |             mstore(data, dataLength)
  86 |     |             mstore(sub(data, 0x20), mBefore1)
  87 |     |             mstore(sub(data, 0x40), mBefore2)
  88 |     |             mstore(sub(data, 0x60), mBefore3)
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`
  93 |     |     /// using immutable arguments encoded in `data`.
  94 |     |     /// Used for mining vanity addresses with create2crunch.
  95 |     |     function initCodeHash(address implementation, bytes memory data)
  96 |     |         internal
  97 |     |         pure
  98 |     |         returns (bytes32 hash)
  99 |     |     {
 100 |     |         assembly {
 101 |     |             // Compute the boundaries of the data and cache the memory slots around it.
 102 |     |             let mBefore3 := mload(sub(data, 0x60))
 103 |     |             let mBefore2 := mload(sub(data, 0x40))
 104 |     |             let mBefore1 := mload(sub(data, 0x20))
 105 |     |             let dataLength := mload(data)
 106 |     |             let dataEnd := add(add(data, 0x20), dataLength)
 107 |     |             let mAfter1 := mload(dataEnd)
 108 |     | 
 109 |     |             // +2 bytes for telling how much data there is appended to the call.
 110 |     |             let extraLength := add(dataLength, 2)
 111 |     | 
 112 |     |             // Write the bytecode before the data.
 113 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
 114 |     |             // Write the address of the implementation.
 115 |     |             mstore(sub(data, 0x0d), implementation)
 116 |     |             // Write the rest of the bytecode.
 117 |     |             mstore(
 118 |     |                 sub(data, 0x21),
 119 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
 120 |     |             )
 121 |     |             // `keccak256("ReceiveETH(uint256)")`
 122 |     |             mstore(
 123 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
 124 |     |             )
 125 |     |             mstore(
 126 |     |                 sub(data, 0x5a),
 127 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
 128 |     |             )
 129 |     |             mstore(dataEnd, shl(0xf0, extraLength))
 130 |     | 
 131 |     |             // Compute and store the bytecode hash.
 132 |     |             hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))
 133 |     | 
 134 |     |             // Restore the overwritten memory surrounding `data`.
 135 |     |             mstore(dataEnd, mAfter1)
 136 |     |             mstore(data, dataLength)
 137 |     |             mstore(sub(data, 0x20), mBefore1)
 138 |     |             mstore(sub(data, 0x40), mBefore2)
 139 |     |             mstore(sub(data, 0x60), mBefore3)
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev Returns the address of the deterministic clone of
 144 |     |     /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.
 145 |     |     function predictDeterministicAddress(
 146 |     |         address implementation,
 147 |     |         bytes memory data,
 148 |     |         bytes32 salt,
 149 |     |         address deployer
 150 |     |     ) internal pure returns (address predicted) {
 151 |     |         bytes32 hash = initCodeHash(implementation, data);
 152 |     |         predicted = predictDeterministicAddress(hash, salt, deployer);
 153 |     |     }
 154 |     | 
 155 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
 156 |     |     /*                      OTHER OPERATIONS                      */
 157 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
 158 |     | 
 159 |     |     /// @dev Returns the address when a contract with initialization code hash,
 160 |     |     /// `hash`, is deployed with `salt`, by `deployer`.
 161 |     |     function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)
 162 |     |         internal
 163 |     |         pure
 164 |     |         returns (address predicted)
 165 |     |     {
 166 |     |         /// @solidity memory-safe-assembly
 167 |     |         assembly {
 168 |     |             // Compute and store the bytecode hash.
 169 |     |             mstore8(0x00, 0xff) // Write the prefix.
 170 |     |             mstore(0x35, hash)
 171 |     |             mstore(0x01, shl(96, deployer))
 172 |     |             mstore(0x15, salt)
 173 |     |             predicted := keccak256(0x00, 0x55)
 174 |     |             // Restore the part of the free memory pointer that has been overwritten.
 175 |     |             mstore(0x35, 0)
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @dev Reverts if `salt` does not start with either the zero address or the caller.
 180 |     |     function checkStartsWithCaller(bytes32 salt) internal view {
 181 |     |         /// @solidity memory-safe-assembly
 182 |     |         assembly {
 183 |     |             // If the salt does not start with the zero address or the caller.
 184 |     |             if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {
 185 |     |                 // Store the function selector of `SaltDoesNotStartWithCaller()`.
 186 |     |                 mstore(0x00, 0x2f634836)
 187 |     |                 // Revert with (offset, size).
 188 |     |                 revert(0x1c, 0x04)
 189 |     |             }
 190 |     |         }
 191 |     |     }
 192 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/Collect.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/ILimitPoolStructs.sol';
  5 |     | import '../Positions.sol';
  6 |     | import '../utils/SafeTransfers.sol';
  7 |     | 
  8 |     | library Collect {
  9 |     |     function burn(
 10 |     |         ILimitPoolStructs.BurnCache memory cache,
 11 |     |         ILimitPoolStructs.BurnParams memory params
 12 |     |     ) internal returns (
 13 |     |         ILimitPoolStructs.BurnCache memory
 14 |     |     )    
 15 |     |     {
 16 |     |         // store amounts for transferOut
 17 |     |         uint128 amountIn  = cache.position.amountIn;
 18 |     |         uint128 amountOut = cache.position.amountOut;
 19 |     | 
 20 |     |         /// zero out balances and transfer out
 21 |     |         if (amountIn > 0) {
 22 |     |             cache.position.amountIn = 0;
 23 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token1 : cache.constants.token0, amountIn);
 24 |     |         }
 25 |     |         if (amountOut > 0) {
 26 |     |             cache.position.amountOut = 0;
 27 |     |             SafeTransfers.transferOut(params.to, params.zeroForOne ? cache.constants.token0 : cache.constants.token1, amountOut);
 28 |     |         }
 29 |     | 
 30 |     |         return cache;
 31 |     |     }
 32 |     | }
 33 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint128
 10 |     |     function toUint128(uint256 y) internal pure returns (uint128 z) {
 11 |     |         require((z = uint128(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 15 |     |     /// @param y The uint256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type uint160
 17 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 18 |     |         require((z = uint160(y)) == y);
 19 |     |     }
 20 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/SafeState.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/ILimitPoolStructs.sol';
  5 |     | import '../../interfaces/IERC20Minimal.sol';
  6 |     | 
  7 |     | library Checks {
  8 |     | }
  9 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/SafeTransfers.sol
   1 |     | //SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
   5 |     | 
   6 |     | library SafeTransfers {
   7 |     |     /**
   8 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
   9 |     |      *      This will revert due to insufficient balance or insufficient allowance.
  10 |     |      *      This function returns the actual amount received,
  11 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
  12 |     |      *
  13 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  14 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  15 |     |      */
  16 |     |     // slither-disable-next-line assembly
  17 |     |     function transferIn(address token, uint256 amount) internal returns (uint256) {
  18 |     |         if (token == address(0)) {
  19 |     |             if (msg.value < amount) require(false, 'TransferFailed(msg.sender, address(this)');
  20 |     |             return amount;
  21 |     |         }
  22 |     |         if (amount == 0) return 0;
  23 |     |         IERC20 erc20Token = IERC20(token);
  24 |     |         uint256 balanceBefore = IERC20(token).balanceOf(address(this));
  25 |     | 
  26 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  27 |     |         // ? Slither does not pick up on that and results in a hit
  28 |     |         // slither-disable-next-line unchecked-transfer
  29 |     |         erc20Token.transferFrom(msg.sender, address(this), amount);
  30 |     | 
  31 |     |         bool success;
  32 |     |         assembly {
  33 |     |             switch returndatasize()
  34 |     |             case 0 {
  35 |     |                 // This is a non-standard ERC-20
  36 |     |                 success := 1 // set success to true
  37 |     |             }
  38 |     |             case 32 {
  39 |     |                 // This is a compliant ERC-20
  40 |     |                 returndatacopy(0, 0, 32)
  41 |     |                 success := mload(0) // Set `success = returndata` of external call
  42 |     |             }
  43 |     |             default {
  44 |     |                 // This is an excessively non-compliant ERC-20, revert.
  45 |     |                 success := 0
  46 |     |             }
  47 |     |         }
  48 |     |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
  49 |     | 
  50 |     |         // Calculate the amount that was *actually* transferred
  51 |     |         uint256 balanceAfter = IERC20(token).balanceOf(address(this));
  52 |     | 
  53 |     |         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
  58 |     |      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
  59 |     |      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
  60 |     |      *      it is >= amount, this should not revert in normal conditions.
  61 |     |      *
  62 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  63 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  64 |     |      */
  65 |     |     // slither-disable-next-line assembly
  66 |     |     function transferOut(
  67 |     |         address to,
  68 |     |         address token,
  69 |     |         uint256 amount
  70 |     |     ) internal {
  71 |     |         if (token == address(0)) {
  72 |     |             if (address(this).balance < amount) require(false, 'TransferFailed(address(this), to');
  73 |     |             payable(to).transfer(amount);
  74 |     |             return;
  75 |     |         }
  76 |     |         if (amount == 0) return;
  77 |     |         IERC20 erc20Token = IERC20(token);
  78 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  79 |     |         // ? Slither does not pick up on that and results in a hit
  80 |     |         // slither-disable-next-line unchecked-transfer
  81 |     |         erc20Token.transfer(to, amount);
  82 |     | 
  83 |     |         bool success;
  84 |     |         assembly {
  85 |     |             switch returndatasize()
  86 |     |             case 0 {
  87 |     |                 // This is a non-standard ERC-20
  88 |     |                 success := 1 // set success to true
  89 |     |             }
  90 |     |             case 32 {
  91 |     |                 // This is a complaint ERC-20
  92 |     |                 returndatacopy(0, 0, 32)
  93 |     |                 success := mload(0) // Set `success = returndata` of external call
  94 |     |             }
  95 |     |             default {
  96 |     |                 // This is an excessively non-compliant ERC-20, revert.
  97 |     |                 success := 0
  98 |     |             }
  99 |     |         }
 100 |     |         if (!success) require(false, 'TransferFailed(address(this), msg.sender');
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
 105 |     |      *      This will revert due to insufficient balance or insufficient allowance.
 106 |     |      *      This function returns the actual amount received,
 107 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
 108 |     |      *
 109 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
 110 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
 111 |     |      */
 112 |     |     // slither-disable-next-line assembly
 113 | *   |     function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {
 114 | *   |         if (token == address(0)) {
 115 | *r  |             if (msg.value < amount) require(false, 'TransferFailed(msg.sender, address(this)');
 116 |     |             return amount;
 117 |     |         }
 118 | *   |         IERC20 erc20Token = IERC20(token);
 119 | *   |         uint256 balanceBefore = IERC20(token).balanceOf(address(this));
 120 |     | 
 121 |     |         /// @dev - msg.sender here is the pool
 122 | *r  |         erc20Token.transferFrom(sender, msg.sender, amount);
 123 |     | 
 124 | *   |         bool success;
 125 |     |         assembly {
 126 | *   |             switch returndatasize()
 127 | *   |             case 0 {
 128 |     |                 // This is a non-standard ERC-20
 129 |     |                 success := 1 // set success to true
 130 |     |             }
 131 | *   |             case 32 {
 132 |     |                 // This is a compliant ERC-20
 133 | *   |                 returndatacopy(0, 0, 32)
 134 | *   |                 success := mload(0) // Set `success = returndata` of external call
 135 |     |             }
 136 |     |             default {
 137 |     |                 // This is an excessively non-compliant ERC-20, revert.
 138 |     |                 success := 0
 139 |     |             }
 140 |     |         }
 141 | *   |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
 142 |     | 
 143 |     |         // Calculate the amount that was *actually* transferred
 144 | *   |         uint256 balanceAfter = IERC20(token).balanceOf(address(this));
 145 |     | 
 146 | *   |         return balanceAfter - balanceBefore; // underflow already checked above, just subtract
 147 |     |     }
 148 |     | }
 149 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/libraries/utils/String.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | library String {
  5 |     |     bytes16 private constant alphabet = "0123456789abcdef";
  6 |     | 
  7 |     |     function from(bytes32 value) internal pure returns(string memory) {
  8 |     |         return toString(abi.encodePacked(value));
  9 |     |     }
 10 |     | 
 11 |     |     function from(address account) internal pure returns(string memory) {
 12 |     |         return toString(abi.encodePacked(account));
 13 |     |     }
 14 |     | 
 15 |     |     function from(uint256 value) internal pure returns(string memory) {
 16 |     |         unchecked {
 17 |     |             uint256 length = log10(value) + 1;
 18 |     |             string memory buffer = new string(length);
 19 |     |             uint256 ptr;
 20 |     |             /// @solidity memory-safe-assembly
 21 |     |             assembly {
 22 |     |                 ptr := add(buffer, add(32, length))
 23 |     |             }
 24 |     |             while (true) {
 25 |     |                 ptr--;
 26 |     |                 /// @solidity memory-safe-assembly
 27 |     |                 assembly {
 28 |     |                     mstore8(ptr, byte(mod(value, 10), alphabet))
 29 |     |                 }
 30 |     |                 value /= 10;
 31 |     |                 if (value == 0) break;
 32 |     |             }
 33 |     |             return buffer;
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function from(int256 value) internal pure returns (string memory) {
 38 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", from(abs(value))));
 39 |     |     }
 40 |     | 
 41 |     |     function abs(int256 n) internal pure returns (uint256) {
 42 |     |         unchecked {
 43 |     |             // must be unchecked in order to support `n = type(int256).min`
 44 |     |             return uint256(n >= 0 ? n : -n);
 45 |     |         }
 46 |     |     }
 47 |     | 
 48 |     |     function log10(uint256 value) internal pure returns (uint256) {
 49 |     |         uint256 result = 0;
 50 |     |         unchecked {
 51 |     |             if (value >= 10 ** 64) {
 52 |     |                 value /= 10 ** 64;
 53 |     |                 result += 64;
 54 |     |             }
 55 |     |             if (value >= 10 ** 32) {
 56 |     |                 value /= 10 ** 32;
 57 |     |                 result += 32;
 58 |     |             }
 59 |     |             if (value >= 10 ** 16) {
 60 |     |                 value /= 10 ** 16;
 61 |     |                 result += 16;
 62 |     |             }
 63 |     |             if (value >= 10 ** 8) {
 64 |     |                 value /= 10 ** 8;
 65 |     |                 result += 8;
 66 |     |             }
 67 |     |             if (value >= 10 ** 4) {
 68 |     |                 value /= 10 ** 4;
 69 |     |                 result += 4;
 70 |     |             }
 71 |     |             if (value >= 10 ** 2) {
 72 |     |                 value /= 10 ** 2;
 73 |     |                 result += 2;
 74 |     |             }
 75 |     |             if (value >= 10 ** 1) {
 76 |     |                 result += 1;
 77 |     |             }
 78 |     |         }
 79 |     |         return result;
 80 |     |     }
 81 |     | 
 82 |     |     function toString(bytes memory data) internal pure returns(string memory) {
 83 |     |         bytes memory str = new bytes(2 + data.length * 2);
 84 |     |         str[0] = "0";
 85 |     |         str[1] = "x";
 86 |     |         for (uint i = 0; i < data.length;) {
 87 |     |             str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];
 88 |     |             str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];
 89 |     |             unchecked {
 90 |     |                 ++i;
 91 |     |             }
 92 |     |         }
 93 |     |         return string(str);
 94 |     |     }
 95 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/test/Token20.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
  5 |     | import '@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';
  6 |     | 
  7 | *   | contract Token20 is ERC20, ERC20Burnable {
  8 |     |     uint8 _decimals;
  9 |     | 
 10 |     |     constructor(
 11 |     |         string memory tokenName,
 12 |     |         string memory tokenSymbol,
 13 |     |         uint8 decimals_
 14 |     |     ) ERC20(tokenName, tokenSymbol) {
 15 |     |         _decimals = decimals_;
 16 |     |     }
 17 |     | 
 18 | *   |     function mint(address to, uint256 amount) external {
 19 | *   |         _mint(to, amount);
 20 |     |     }
 21 |     | 
 22 |     |     function decimals() public view override returns (uint8) {
 23 |     |         return _decimals;
 24 |     |     }
 25 |     | 
 26 |     |     function setDecimals(uint8 decimals_) public {
 27 |     |         _decimals = decimals_;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/LimitPoolErrors.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolErrors {
  5 |     |     error Locked();
  6 |     |     error OwnerOnly();
  7 |     |     error InvalidToken();
  8 |     |     error InvalidPosition();
  9 |     |     error InvalidSwapFee();
 10 |     |     error InvalidTokenDecimals();
 11 |     |     error InvalidTickSpread();
 12 |     |     error LiquidityOverflow();
 13 |     |     error Token0Missing();
 14 |     |     error Token1Missing();
 15 |     |     error InvalidTick();
 16 |     |     error FactoryOnly();
 17 |     |     error LowerNotEvenTick();
 18 |     |     error UpperNotOddTick();
 19 |     |     error MaxTickLiquidity();
 20 |     |     error CollectToZeroAddress();
 21 |     |     error ProtocolFeeCeilingExceeded();
 22 |     |     error Overflow();
 23 |     |     error PoolAlreadyInitialized();
 24 |     |     error NotEnoughOutputLiquidity();
 25 |     |     error WaitUntilEnoughObservations();
 26 |     | }
 27 |     | 
 28 |     | abstract contract CoverTicksErrors {
 29 |     |     error WrongTickLowerRange();
 30 |     |     error WrongTickUpperRange();
 31 |     |     error WrongTickLowerOrder();
 32 |     |     error WrongTickUpperOrder();
 33 |     |     error WrongTickClaimedAt();
 34 |     | }
 35 |     | 
 36 |     | abstract contract CoverMiscErrors {
 37 |     |     // to be removed before production
 38 |     |     error NotImplementedYet();
 39 |     | }
 40 |     | 
 41 |     | abstract contract CoverPositionErrors {
 42 |     |     error NotEnoughPositionLiquidity();
 43 |     |     error InvalidClaimTick();
 44 |     | }
 45 |     | 
 46 |     | abstract contract LimitPoolFactoryErrors {
 47 |     |     error OwnerOnly();
 48 |     |     error InvalidTokenAddress();
 49 |     |     error PoolAlreadyExists();
 50 |     |     error FeeTierNotSupported();
 51 |     |     error TickSpacingNotSupported();
 52 |     |     error PoolTypeNotSupported();
 53 |     | }
 54 |     | 
 55 |     | abstract contract CoverTransferErrors {
 56 |     |     error TransferFailed(address from, address dest);
 57 |     | }
 58 |     | 

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/LimitPoolManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity ^0.8.0;
   4 |     | 
   5 |     | import '../interfaces/ILimitPool.sol';
   6 |     | import '../interfaces/ILimitPoolFactory.sol';
   7 |     | import '../interfaces/ILimitPoolManager.sol';
   8 |     | import '../base/events/LimitPoolManagerEvents.sol';
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Defines the actions which can be executed by the factory admin.
  12 |     |  */
  13 |     | contract LimitPoolManager is ILimitPoolManager, LimitPoolManagerEvents {
  14 |     |     address public owner;
  15 |     |     address public feeTo;
  16 |     |     address public factory;
  17 |     |     uint16  public constant MAX_PROTOCOL_FEE = 1e4; /// @dev - max protocol fee of 1%
  18 |     |     // tickSpacing => enabled
  19 |     |     mapping(bytes32 => address) internal _implementations;
  20 |     |     mapping(int16 => bool) internal _tickSpacings;
  21 |     | 
  22 |     |     error InvalidTickSpacing();
  23 |     |     error TickSpacingAlreadyEnabled();
  24 |     |     error ImplementationAlreadyExists();
  25 |     | 
  26 |     |     constructor() {
  27 |     |         owner = msg.sender;
  28 |     |         feeTo = msg.sender;
  29 |     |         emit OwnerTransfer(address(0), msg.sender);
  30 |     | 
  31 |     |         // create supported tick spacings
  32 |     |         _tickSpacings[10] = true;
  33 |     |         _tickSpacings[20] = true;
  34 |     |         emit TickSpacingEnabled(10);
  35 |     |         emit TickSpacingEnabled(20);
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Throws if called by any account other than the owner.
  40 |     |      */
  41 |     |     modifier onlyOwner() {
  42 |     |         _checkOwner();
  43 |     |         _;
  44 |     |     }
  45 |     | 
  46 |     |     modifier onlyFeeTo() {
  47 |     |         _checkFeeTo();
  48 |     |         _;
  49 |     |     }
  50 |     | 
  51 |     |     /**
  52 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  53 |     |      * Can only be called by the current owner.
  54 |     |      */
  55 |     |     function transferOwner(address newOwner) public virtual onlyOwner {
  56 |     |         if(newOwner == address(0)) require (false, 'TransferredToZeroAddress()');
  57 |     |         _transferOwner(newOwner);
  58 |     |     }
  59 |     | 
  60 |     |     function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {
  61 |     |         if(newFeeTo == address(0)) require (false, 'TransferredToZeroAddress()');
  62 |     |         _transferFeeTo(newFeeTo);
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  67 |     |      * Internal function without access restriction.
  68 |     |      */
  69 |     |     function _transferOwner(address newOwner) internal virtual {
  70 |     |         address oldOwner = owner;
  71 |     |         owner = newOwner;
  72 |     |         emit OwnerTransfer(oldOwner, newOwner);
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Transfers fee collection to a new account (`newFeeTo`).
  77 |     |      * Internal function without access restriction.
  78 |     |      */
  79 |     |     function _transferFeeTo(address newFeeTo) internal virtual {
  80 |     |         address oldFeeTo = feeTo;
  81 |     |         feeTo = newFeeTo;
  82 |     |         emit OwnerTransfer(oldFeeTo, newFeeTo);
  83 |     |     }
  84 |     | 
  85 |     |     function enableTickSpacing(
  86 |     |         int16 tickSpacing
  87 |     |     ) external onlyOwner {
  88 |     |         if (_tickSpacings[tickSpacing]) revert TickSpacingAlreadyEnabled();
  89 |     |         if (tickSpacing <= 0) revert InvalidTickSpacing();
  90 |     |         if (tickSpacing % 2 != 0) revert InvalidTickSpacing();
  91 |     |         _tickSpacings[tickSpacing] = true;
  92 |     |         emit TickSpacingEnabled(tickSpacing);
  93 |     |     }
  94 |     | 
  95 |     |     function enableImplementation(
  96 |     |         bytes32 poolType_,
  97 |     |         address implementation_
  98 |     |     ) external onlyOwner {
  99 |     |         if (_implementations[poolType_] != address(0)) revert ImplementationAlreadyExists();
 100 |     |         _implementations[poolType_] = implementation_;
 101 |     |         emit ImplementationEnabled(poolType_, implementation_);
 102 |     |     }
 103 |     | 
 104 |     |     function setFactory(
 105 |     |         address factory_
 106 |     |     ) external onlyOwner {
 107 |     |         if (factory != address(0)) require (false, 'FactoryAlreadySet()');
 108 |     |         emit FactoryChanged(factory, factory_);
 109 |     |         factory = factory_;
 110 |     |     }
 111 |     | 
 112 |     |     function collectProtocolFees(
 113 |     |         address[] calldata collectPools
 114 |     |     ) external {
 115 |     |         if (collectPools.length == 0) require (false, 'EmptyPoolsArray()');
 116 |     |         uint128[] memory token0Fees = new uint128[](collectPools.length);
 117 |     |         uint128[] memory token1Fees = new uint128[](collectPools.length);
 118 |     |         for (uint i; i < collectPools.length;) {
 119 |     |             (token0Fees[i], token1Fees[i]) = ILimitPool(collectPools[i]).fees(0,0,false);
 120 |     |             unchecked {
 121 |     |                 ++i;
 122 |     |             }
 123 |     |         }
 124 |     |         emit ProtocolFeesCollected(collectPools, token0Fees, token1Fees);
 125 |     |     }
 126 |     | 
 127 |     |     function modifyProtocolFees(
 128 |     |         address[] calldata modifyPools,
 129 |     |         uint16[] calldata syncFees,
 130 |     |         uint16[] calldata fillFees,
 131 |     |         bool[] calldata setFees
 132 |     |     ) external onlyOwner {
 133 |     |         if (modifyPools.length == 0) require (false, 'EmptyPoolsArray()');
 134 |     |         if (modifyPools.length != syncFees.length
 135 |     |             || syncFees.length != fillFees.length
 136 |     |             || fillFees.length != setFees.length) {
 137 |     |             require (false, 'MismatchedArrayLengths()');
 138 |     |         }
 139 |     |         uint128[] memory token0Fees = new uint128[](modifyPools.length);
 140 |     |         uint128[] memory token1Fees = new uint128[](modifyPools.length);
 141 |     |         for (uint i; i < modifyPools.length;) {
 142 |     |             if (syncFees[i] > MAX_PROTOCOL_FEE) require (false, 'ProtocolFeeCeilingExceeded()');
 143 |     |             if (fillFees[i] > MAX_PROTOCOL_FEE) require (false, 'ProtocolFeeCeilingExceeded()');
 144 |     |             (
 145 |     |                 token0Fees[i],
 146 |     |                 token1Fees[i]
 147 |     |             ) = ILimitPool(modifyPools[i]).fees(
 148 |     |                 syncFees[i],
 149 |     |                 fillFees[i],
 150 |     |                 setFees[i]
 151 |     |             );
 152 |     |             unchecked {
 153 |     |                 ++i;
 154 |     |             }
 155 |     |         }
 156 |     |         emit ProtocolFeesModified(modifyPools, syncFees, fillFees, setFees, token0Fees, token1Fees);
 157 |     |     }
 158 |     | 
 159 |     |     function implementations(
 160 |     |         bytes32 key
 161 |     |     ) external view returns (
 162 |     |         address
 163 |     |     ) {
 164 |     |         return _implementations[key];
 165 |     |     }
 166 |     | 
 167 |     |     function tickSpacings(
 168 |     |         int16 tickSpacing
 169 |     |     ) external view returns (
 170 |     |         bool
 171 |     |     ) {
 172 |     |         return _tickSpacings[tickSpacing];
 173 |     |     }
 174 |     |     
 175 |     |     /**
 176 |     |      * @dev Throws if the sender is not the owner.
 177 |     |      */
 178 |     |     function _checkOwner() internal view {
 179 |     |         if (owner != msg.sender) require (false, 'OwnerOnly()');
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @dev Throws if the sender is not the feeTo.
 184 |     |      */
 185 |     |     function _checkFeeTo() internal view {
 186 |     |         if (feeTo != msg.sender) require (false, 'FeeToOnly()');
 187 |     |     }
 188 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/contracts/utils/PoolRouter.sol
  1 |     | // SPDX-License-Identifier: GPLv3
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/IPool.sol';
  5 |     | import '../interfaces/callbacks/IPoolsharkSwapCallback.sol';
  6 |     | import '../libraries/utils/SafeTransfers.sol';
  7 |     | import '../base/structs/PoolsharkStructs.sol';
  8 |     | import '../libraries/solady/LibClone.sol';
  9 |     | 
 10 |     | contract PoolRouter is
 11 |     |     IPoolsharkSwapCallback,
 12 |     |     PoolsharkStructs
 13 |     | {
 14 |     |     address public immutable factory;
 15 |     |     address public immutable implementation;
 16 |     | 
 17 |     |     struct SwapCallbackData {
 18 |     |         address sender;
 19 |     |     }
 20 |     | 
 21 |     |     constructor(
 22 |     |         address factory_,
 23 |     |         address implementation_
 24 |     |     ) {
 25 |     |         factory = factory_;
 26 |     |         implementation = implementation_;
 27 |     |     }
 28 |     | 
 29 |     |     /// @inheritdoc IPoolsharkSwapCallback
 30 |     |     function poolsharkSwapCallback(
 31 |     |         int256 amount0Delta,
 32 |     |         int256 amount1Delta,
 33 |     |         bytes calldata data
 34 |     |     ) external override {
 35 |     |         PoolsharkStructs.Immutables memory constants = IPool(msg.sender).immutables();
 36 |     |         // generate key for pool
 37 |     |         bytes32 key = keccak256(abi.encode(
 38 |     |             implementation,
 39 |     |             constants.token0,
 40 |     |             constants.token1,
 41 |     |             constants.tickSpacing
 42 |     |         ));
 43 |     | 
 44 |     |         // compute address
 45 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 46 |     |             implementation,
 47 |     |             abi.encodePacked(
 48 |     |                 constants.owner,
 49 |     |                 constants.token0,
 50 |     |                 constants.token1,
 51 |     |                 constants.bounds.min,
 52 |     |                 constants.bounds.max,
 53 |     |                 constants.tickSpacing
 54 |     |             ),
 55 |     |             key,
 56 |     |             factory
 57 |     |         );
 58 |     | 
 59 |     |         // revert on sender mismatch
 60 |     |         if (msg.sender != predictedAddress) require(false, 'InvalidCallerAddress()');
 61 |     | 
 62 |     |         // decode original sender
 63 |     |         SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));
 64 |     |         
 65 |     |         // transfer from swap caller
 66 |     |         if (amount0Delta < 0) {
 67 |     |             SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));
 68 |     |         } else {
 69 |     |             SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));
 70 |     |         }
 71 |     |     }
 72 |     | 
 73 |     |     function multiCall(
 74 |     |         address[] memory pools,
 75 |     |         SwapParams[] memory params 
 76 |     |     ) external {
 77 |     |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 78 |     |         for (uint i = 0; i < pools.length;) {
 79 |     |             params[i].callbackData = abi.encode(SwapCallbackData({sender: msg.sender}));
 80 |     |             IPool(pools[i]).swap(params[i]);
 81 |     |             unchecked {
 82 |     |                 ++i;
 83 |     |             }
 84 |     |         }
 85 |     |     }
 86 |     | }

/Users/kevinli/Desktop/All/PersonalCoding/GuardianAudits/poolshark-limit/limit-pocs/node_modules/hardhat/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS =
    6 |     |         0x000000000000000000636F6e736F6c652e6c6f67;
    7 |     | 
    8 |     |     function _sendLogPayloadImplementation(bytes memory payload) internal view {
    9 |     |         address consoleAddress = CONSOLE_ADDRESS;
   10 |     |         /// @solidity memory-safe-assembly
   11 |     |         assembly {
   12 |     |             pop(
   13 |     |                 staticcall(
   14 |     |                     gas(),
   15 |     |                     consoleAddress,
   16 |     |                     add(payload, 32),
   17 |     |                     mload(payload),
   18 |     |                     0,
   19 |     |                     0
   20 |     |                 )
   21 |     |             )
   22 |     |         }
   23 |     |     }
   24 |     | 
   25 |     |     function _castToPure(
   26 |     |       function(bytes memory) internal view fnIn
   27 |     |     ) internal pure returns (function(bytes memory) pure fnOut) {
   28 |     |         assembly {
   29 |     |             fnOut := fnIn
   30 |     |         }
   31 |     |     }
   32 |     | 
   33 |     |     function _sendLogPayload(bytes memory payload) internal pure {
   34 |     |         _castToPure(_sendLogPayloadImplementation)(payload);
   35 |     |     }
   36 |     | 
   37 |     |     function log() internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   39 |     |     }
   40 |     |     function logInt(int256 p0) internal pure {
   41 |     |         _sendLogPayload(abi.encodeWithSignature("log(int256)", p0));
   42 |     |     }
   43 |     | 
   44 |     |     function logUint(uint256 p0) internal pure {
   45 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
   46 |     |     }
   47 |     | 
   48 |     |     function logString(string memory p0) internal pure {
   49 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   50 |     |     }
   51 |     | 
   52 |     |     function logBool(bool p0) internal pure {
   53 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   54 |     |     }
   55 |     | 
   56 |     |     function logAddress(address p0) internal pure {
   57 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   58 |     |     }
   59 |     | 
   60 |     |     function logBytes(bytes memory p0) internal pure {
   61 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   62 |     |     }
   63 |     | 
   64 |     |     function logBytes1(bytes1 p0) internal pure {
   65 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   66 |     |     }
   67 |     | 
   68 |     |     function logBytes2(bytes2 p0) internal pure {
   69 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   70 |     |     }
   71 |     | 
   72 |     |     function logBytes3(bytes3 p0) internal pure {
   73 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   74 |     |     }
   75 |     | 
   76 |     |     function logBytes4(bytes4 p0) internal pure {
   77 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   78 |     |     }
   79 |     | 
   80 |     |     function logBytes5(bytes5 p0) internal pure {
   81 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   82 |     |     }
   83 |     | 
   84 |     |     function logBytes6(bytes6 p0) internal pure {
   85 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   86 |     |     }
   87 |     | 
   88 |     |     function logBytes7(bytes7 p0) internal pure {
   89 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   90 |     |     }
   91 |     | 
   92 |     |     function logBytes8(bytes8 p0) internal pure {
   93 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   94 |     |     }
   95 |     | 
   96 |     |     function logBytes9(bytes9 p0) internal pure {
   97 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   98 |     |     }
   99 |     | 
  100 |     |     function logBytes10(bytes10 p0) internal pure {
  101 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
  102 |     |     }
  103 |     | 
  104 |     |     function logBytes11(bytes11 p0) internal pure {
  105 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
  106 |     |     }
  107 |     | 
  108 |     |     function logBytes12(bytes12 p0) internal pure {
  109 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  110 |     |     }
  111 |     | 
  112 |     |     function logBytes13(bytes13 p0) internal pure {
  113 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  114 |     |     }
  115 |     | 
  116 |     |     function logBytes14(bytes14 p0) internal pure {
  117 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  118 |     |     }
  119 |     | 
  120 |     |     function logBytes15(bytes15 p0) internal pure {
  121 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  122 |     |     }
  123 |     | 
  124 |     |     function logBytes16(bytes16 p0) internal pure {
  125 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  126 |     |     }
  127 |     | 
  128 |     |     function logBytes17(bytes17 p0) internal pure {
  129 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  130 |     |     }
  131 |     | 
  132 |     |     function logBytes18(bytes18 p0) internal pure {
  133 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  134 |     |     }
  135 |     | 
  136 |     |     function logBytes19(bytes19 p0) internal pure {
  137 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  138 |     |     }
  139 |     | 
  140 |     |     function logBytes20(bytes20 p0) internal pure {
  141 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  142 |     |     }
  143 |     | 
  144 |     |     function logBytes21(bytes21 p0) internal pure {
  145 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  146 |     |     }
  147 |     | 
  148 |     |     function logBytes22(bytes22 p0) internal pure {
  149 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  150 |     |     }
  151 |     | 
  152 |     |     function logBytes23(bytes23 p0) internal pure {
  153 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  154 |     |     }
  155 |     | 
  156 |     |     function logBytes24(bytes24 p0) internal pure {
  157 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  158 |     |     }
  159 |     | 
  160 |     |     function logBytes25(bytes25 p0) internal pure {
  161 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  162 |     |     }
  163 |     | 
  164 |     |     function logBytes26(bytes26 p0) internal pure {
  165 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  166 |     |     }
  167 |     | 
  168 |     |     function logBytes27(bytes27 p0) internal pure {
  169 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  170 |     |     }
  171 |     | 
  172 |     |     function logBytes28(bytes28 p0) internal pure {
  173 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  174 |     |     }
  175 |     | 
  176 |     |     function logBytes29(bytes29 p0) internal pure {
  177 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  178 |     |     }
  179 |     | 
  180 |     |     function logBytes30(bytes30 p0) internal pure {
  181 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  182 |     |     }
  183 |     | 
  184 |     |     function logBytes31(bytes31 p0) internal pure {
  185 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  186 |     |     }
  187 |     | 
  188 |     |     function logBytes32(bytes32 p0) internal pure {
  189 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  190 |     |     }
  191 |     | 
  192 |     |     function log(uint256 p0) internal pure {
  193 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256)", p0));
  194 |     |     }
  195 |     | 
  196 |     |     function log(string memory p0) internal pure {
  197 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  198 |     |     }
  199 |     | 
  200 |     |     function log(bool p0) internal pure {
  201 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  202 |     |     }
  203 |     | 
  204 |     |     function log(address p0) internal pure {
  205 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  206 |     |     }
  207 |     | 
  208 |     |     function log(uint256 p0, uint256 p1) internal pure {
  209 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256)", p0, p1));
  210 |     |     }
  211 |     | 
  212 |     |     function log(uint256 p0, string memory p1) internal pure {
  213 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string)", p0, p1));
  214 |     |     }
  215 |     | 
  216 |     |     function log(uint256 p0, bool p1) internal pure {
  217 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool)", p0, p1));
  218 |     |     }
  219 |     | 
  220 |     |     function log(uint256 p0, address p1) internal pure {
  221 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address)", p0, p1));
  222 |     |     }
  223 |     | 
  224 |     |     function log(string memory p0, uint256 p1) internal pure {
  225 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
  226 |     |     }
  227 |     | 
  228 |     |     function log(string memory p0, string memory p1) internal pure {
  229 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  230 |     |     }
  231 |     | 
  232 |     |     function log(string memory p0, bool p1) internal pure {
  233 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  234 |     |     }
  235 |     | 
  236 |     |     function log(string memory p0, address p1) internal pure {
  237 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  238 |     |     }
  239 |     | 
  240 |     |     function log(bool p0, uint256 p1) internal pure {
  241 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256)", p0, p1));
  242 |     |     }
  243 |     | 
  244 |     |     function log(bool p0, string memory p1) internal pure {
  245 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  246 |     |     }
  247 |     | 
  248 |     |     function log(bool p0, bool p1) internal pure {
  249 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  250 |     |     }
  251 |     | 
  252 |     |     function log(bool p0, address p1) internal pure {
  253 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  254 |     |     }
  255 |     | 
  256 |     |     function log(address p0, uint256 p1) internal pure {
  257 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256)", p0, p1));
  258 |     |     }
  259 |     | 
  260 |     |     function log(address p0, string memory p1) internal pure {
  261 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  262 |     |     }
  263 |     | 
  264 |     |     function log(address p0, bool p1) internal pure {
  265 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  266 |     |     }
  267 |     | 
  268 |     |     function log(address p0, address p1) internal pure {
  269 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  270 |     |     }
  271 |     | 
  272 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  273 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256)", p0, p1, p2));
  274 |     |     }
  275 |     | 
  276 |     |     function log(uint256 p0, uint256 p1, string memory p2) internal pure {
  277 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string)", p0, p1, p2));
  278 |     |     }
  279 |     | 
  280 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  281 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool)", p0, p1, p2));
  282 |     |     }
  283 |     | 
  284 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  285 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address)", p0, p1, p2));
  286 |     |     }
  287 |     | 
  288 |     |     function log(uint256 p0, string memory p1, uint256 p2) internal pure {
  289 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256)", p0, p1, p2));
  290 |     |     }
  291 |     | 
  292 |     |     function log(uint256 p0, string memory p1, string memory p2) internal pure {
  293 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string)", p0, p1, p2));
  294 |     |     }
  295 |     | 
  296 |     |     function log(uint256 p0, string memory p1, bool p2) internal pure {
  297 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool)", p0, p1, p2));
  298 |     |     }
  299 |     | 
  300 |     |     function log(uint256 p0, string memory p1, address p2) internal pure {
  301 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address)", p0, p1, p2));
  302 |     |     }
  303 |     | 
  304 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  305 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256)", p0, p1, p2));
  306 |     |     }
  307 |     | 
  308 |     |     function log(uint256 p0, bool p1, string memory p2) internal pure {
  309 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string)", p0, p1, p2));
  310 |     |     }
  311 |     | 
  312 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  313 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool)", p0, p1, p2));
  314 |     |     }
  315 |     | 
  316 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  317 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address)", p0, p1, p2));
  318 |     |     }
  319 |     | 
  320 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  321 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256)", p0, p1, p2));
  322 |     |     }
  323 |     | 
  324 |     |     function log(uint256 p0, address p1, string memory p2) internal pure {
  325 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string)", p0, p1, p2));
  326 |     |     }
  327 |     | 
  328 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  329 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool)", p0, p1, p2));
  330 |     |     }
  331 |     | 
  332 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  333 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address)", p0, p1, p2));
  334 |     |     }
  335 |     | 
  336 |     |     function log(string memory p0, uint256 p1, uint256 p2) internal pure {
  337 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256)", p0, p1, p2));
  338 |     |     }
  339 |     | 
  340 |     |     function log(string memory p0, uint256 p1, string memory p2) internal pure {
  341 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string)", p0, p1, p2));
  342 |     |     }
  343 |     | 
  344 |     |     function log(string memory p0, uint256 p1, bool p2) internal pure {
  345 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool)", p0, p1, p2));
  346 |     |     }
  347 |     | 
  348 |     |     function log(string memory p0, uint256 p1, address p2) internal pure {
  349 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address)", p0, p1, p2));
  350 |     |     }
  351 |     | 
  352 |     |     function log(string memory p0, string memory p1, uint256 p2) internal pure {
  353 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256)", p0, p1, p2));
  354 |     |     }
  355 |     | 
  356 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  357 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  358 |     |     }
  359 |     | 
  360 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  361 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  362 |     |     }
  363 |     | 
  364 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  365 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  366 |     |     }
  367 |     | 
  368 |     |     function log(string memory p0, bool p1, uint256 p2) internal pure {
  369 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256)", p0, p1, p2));
  370 |     |     }
  371 |     | 
  372 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  373 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  374 |     |     }
  375 |     | 
  376 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  377 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  378 |     |     }
  379 |     | 
  380 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  381 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  382 |     |     }
  383 |     | 
  384 |     |     function log(string memory p0, address p1, uint256 p2) internal pure {
  385 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256)", p0, p1, p2));
  386 |     |     }
  387 |     | 
  388 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  389 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  390 |     |     }
  391 |     | 
  392 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  393 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  394 |     |     }
  395 |     | 
  396 |     |     function log(string memory p0, address p1, address p2) internal pure {
  397 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  398 |     |     }
  399 |     | 
  400 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  401 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256)", p0, p1, p2));
  402 |     |     }
  403 |     | 
  404 |     |     function log(bool p0, uint256 p1, string memory p2) internal pure {
  405 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string)", p0, p1, p2));
  406 |     |     }
  407 |     | 
  408 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  409 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool)", p0, p1, p2));
  410 |     |     }
  411 |     | 
  412 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  413 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address)", p0, p1, p2));
  414 |     |     }
  415 |     | 
  416 |     |     function log(bool p0, string memory p1, uint256 p2) internal pure {
  417 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256)", p0, p1, p2));
  418 |     |     }
  419 |     | 
  420 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  421 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  422 |     |     }
  423 |     | 
  424 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  425 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  426 |     |     }
  427 |     | 
  428 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  429 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  430 |     |     }
  431 |     | 
  432 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  433 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256)", p0, p1, p2));
  434 |     |     }
  435 |     | 
  436 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  437 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  438 |     |     }
  439 |     | 
  440 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  441 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  442 |     |     }
  443 |     | 
  444 |     |     function log(bool p0, bool p1, address p2) internal pure {
  445 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  446 |     |     }
  447 |     | 
  448 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  449 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256)", p0, p1, p2));
  450 |     |     }
  451 |     | 
  452 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  453 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  454 |     |     }
  455 |     | 
  456 |     |     function log(bool p0, address p1, bool p2) internal pure {
  457 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  458 |     |     }
  459 |     | 
  460 |     |     function log(bool p0, address p1, address p2) internal pure {
  461 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  462 |     |     }
  463 |     | 
  464 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
  465 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256)", p0, p1, p2));
  466 |     |     }
  467 |     | 
  468 |     |     function log(address p0, uint256 p1, string memory p2) internal pure {
  469 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string)", p0, p1, p2));
  470 |     |     }
  471 |     | 
  472 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
  473 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool)", p0, p1, p2));
  474 |     |     }
  475 |     | 
  476 |     |     function log(address p0, uint256 p1, address p2) internal pure {
  477 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address)", p0, p1, p2));
  478 |     |     }
  479 |     | 
  480 |     |     function log(address p0, string memory p1, uint256 p2) internal pure {
  481 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256)", p0, p1, p2));
  482 |     |     }
  483 |     | 
  484 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  485 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  486 |     |     }
  487 |     | 
  488 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  489 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  490 |     |     }
  491 |     | 
  492 |     |     function log(address p0, string memory p1, address p2) internal pure {
  493 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  494 |     |     }
  495 |     | 
  496 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
  497 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256)", p0, p1, p2));
  498 |     |     }
  499 |     | 
  500 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  501 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  502 |     |     }
  503 |     | 
  504 |     |     function log(address p0, bool p1, bool p2) internal pure {
  505 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  506 |     |     }
  507 |     | 
  508 |     |     function log(address p0, bool p1, address p2) internal pure {
  509 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  510 |     |     }
  511 |     | 
  512 |     |     function log(address p0, address p1, uint256 p2) internal pure {
  513 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256)", p0, p1, p2));
  514 |     |     }
  515 |     | 
  516 |     |     function log(address p0, address p1, string memory p2) internal pure {
  517 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  518 |     |     }
  519 |     | 
  520 |     |     function log(address p0, address p1, bool p2) internal pure {
  521 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  522 |     |     }
  523 |     | 
  524 |     |     function log(address p0, address p1, address p2) internal pure {
  525 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  526 |     |     }
  527 |     | 
  528 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  529 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,uint256)", p0, p1, p2, p3));
  530 |     |     }
  531 |     | 
  532 |     |     function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  533 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,string)", p0, p1, p2, p3));
  534 |     |     }
  535 |     | 
  536 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  537 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,bool)", p0, p1, p2, p3));
  538 |     |     }
  539 |     | 
  540 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  541 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,uint256,address)", p0, p1, p2, p3));
  542 |     |     }
  543 |     | 
  544 |     |     function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  545 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,uint256)", p0, p1, p2, p3));
  546 |     |     }
  547 |     | 
  548 |     |     function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {
  549 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,string)", p0, p1, p2, p3));
  550 |     |     }
  551 |     | 
  552 |     |     function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {
  553 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,bool)", p0, p1, p2, p3));
  554 |     |     }
  555 |     | 
  556 |     |     function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {
  557 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,string,address)", p0, p1, p2, p3));
  558 |     |     }
  559 |     | 
  560 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  561 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,uint256)", p0, p1, p2, p3));
  562 |     |     }
  563 |     | 
  564 |     |     function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {
  565 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,string)", p0, p1, p2, p3));
  566 |     |     }
  567 |     | 
  568 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  569 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,bool)", p0, p1, p2, p3));
  570 |     |     }
  571 |     | 
  572 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  573 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,bool,address)", p0, p1, p2, p3));
  574 |     |     }
  575 |     | 
  576 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  577 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,uint256)", p0, p1, p2, p3));
  578 |     |     }
  579 |     | 
  580 |     |     function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {
  581 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,string)", p0, p1, p2, p3));
  582 |     |     }
  583 |     | 
  584 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  585 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,bool)", p0, p1, p2, p3));
  586 |     |     }
  587 |     | 
  588 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  589 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,uint256,address,address)", p0, p1, p2, p3));
  590 |     |     }
  591 |     | 
  592 |     |     function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  593 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,uint256)", p0, p1, p2, p3));
  594 |     |     }
  595 |     | 
  596 |     |     function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {
  597 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,string)", p0, p1, p2, p3));
  598 |     |     }
  599 |     | 
  600 |     |     function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {
  601 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,bool)", p0, p1, p2, p3));
  602 |     |     }
  603 |     | 
  604 |     |     function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {
  605 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,uint256,address)", p0, p1, p2, p3));
  606 |     |     }
  607 |     | 
  608 |     |     function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {
  609 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,uint256)", p0, p1, p2, p3));
  610 |     |     }
  611 |     | 
  612 |     |     function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {
  613 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,string)", p0, p1, p2, p3));
  614 |     |     }
  615 |     | 
  616 |     |     function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {
  617 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,bool)", p0, p1, p2, p3));
  618 |     |     }
  619 |     | 
  620 |     |     function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {
  621 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,string,address)", p0, p1, p2, p3));
  622 |     |     }
  623 |     | 
  624 |     |     function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {
  625 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,uint256)", p0, p1, p2, p3));
  626 |     |     }
  627 |     | 
  628 |     |     function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {
  629 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,string)", p0, p1, p2, p3));
  630 |     |     }
  631 |     | 
  632 |     |     function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {
  633 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,bool)", p0, p1, p2, p3));
  634 |     |     }
  635 |     | 
  636 |     |     function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {
  637 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,bool,address)", p0, p1, p2, p3));
  638 |     |     }
  639 |     | 
  640 |     |     function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {
  641 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,uint256)", p0, p1, p2, p3));
  642 |     |     }
  643 |     | 
  644 |     |     function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {
  645 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,string)", p0, p1, p2, p3));
  646 |     |     }
  647 |     | 
  648 |     |     function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {
  649 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,bool)", p0, p1, p2, p3));
  650 |     |     }
  651 |     | 
  652 |     |     function log(uint256 p0, string memory p1, address p2, address p3) internal pure {
  653 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,string,address,address)", p0, p1, p2, p3));
  654 |     |     }
  655 |     | 
  656 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  657 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,uint256)", p0, p1, p2, p3));
  658 |     |     }
  659 |     | 
  660 |     |     function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {
  661 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,string)", p0, p1, p2, p3));
  662 |     |     }
  663 |     | 
  664 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  665 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,bool)", p0, p1, p2, p3));
  666 |     |     }
  667 |     | 
  668 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  669 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,uint256,address)", p0, p1, p2, p3));
  670 |     |     }
  671 |     | 
  672 |     |     function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {
  673 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,uint256)", p0, p1, p2, p3));
  674 |     |     }
  675 |     | 
  676 |     |     function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {
  677 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,string)", p0, p1, p2, p3));
  678 |     |     }
  679 |     | 
  680 |     |     function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {
  681 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,bool)", p0, p1, p2, p3));
  682 |     |     }
  683 |     | 
  684 |     |     function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {
  685 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,string,address)", p0, p1, p2, p3));
  686 |     |     }
  687 |     | 
  688 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  689 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,uint256)", p0, p1, p2, p3));
  690 |     |     }
  691 |     | 
  692 |     |     function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {
  693 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,string)", p0, p1, p2, p3));
  694 |     |     }
  695 |     | 
  696 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  697 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,bool)", p0, p1, p2, p3));
  698 |     |     }
  699 |     | 
  700 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  701 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,bool,address)", p0, p1, p2, p3));
  702 |     |     }
  703 |     | 
  704 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  705 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,uint256)", p0, p1, p2, p3));
  706 |     |     }
  707 |     | 
  708 |     |     function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {
  709 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,string)", p0, p1, p2, p3));
  710 |     |     }
  711 |     | 
  712 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  713 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,bool)", p0, p1, p2, p3));
  714 |     |     }
  715 |     | 
  716 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  717 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,bool,address,address)", p0, p1, p2, p3));
  718 |     |     }
  719 |     | 
  720 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  721 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,uint256)", p0, p1, p2, p3));
  722 |     |     }
  723 |     | 
  724 |     |     function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {
  725 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,string)", p0, p1, p2, p3));
  726 |     |     }
  727 |     | 
  728 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  729 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,bool)", p0, p1, p2, p3));
  730 |     |     }
  731 |     | 
  732 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  733 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,uint256,address)", p0, p1, p2, p3));
  734 |     |     }
  735 |     | 
  736 |     |     function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {
  737 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,uint256)", p0, p1, p2, p3));
  738 |     |     }
  739 |     | 
  740 |     |     function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {
  741 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,string)", p0, p1, p2, p3));
  742 |     |     }
  743 |     | 
  744 |     |     function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {
  745 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,bool)", p0, p1, p2, p3));
  746 |     |     }
  747 |     | 
  748 |     |     function log(uint256 p0, address p1, string memory p2, address p3) internal pure {
  749 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,string,address)", p0, p1, p2, p3));
  750 |     |     }
  751 |     | 
  752 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  753 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,uint256)", p0, p1, p2, p3));
  754 |     |     }
  755 |     | 
  756 |     |     function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {
  757 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,string)", p0, p1, p2, p3));
  758 |     |     }
  759 |     | 
  760 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  761 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,bool)", p0, p1, p2, p3));
  762 |     |     }
  763 |     | 
  764 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  765 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,bool,address)", p0, p1, p2, p3));
  766 |     |     }
  767 |     | 
  768 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  769 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,uint256)", p0, p1, p2, p3));
  770 |     |     }
  771 |     | 
  772 |     |     function log(uint256 p0, address p1, address p2, string memory p3) internal pure {
  773 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,string)", p0, p1, p2, p3));
  774 |     |     }
  775 |     | 
  776 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  777 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,bool)", p0, p1, p2, p3));
  778 |     |     }
  779 |     | 
  780 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  781 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint256,address,address,address)", p0, p1, p2, p3));
  782 |     |     }
  783 |     | 
  784 |     |     function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  785 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,uint256)", p0, p1, p2, p3));
  786 |     |     }
  787 |     | 
  788 |     |     function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {
  789 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,string)", p0, p1, p2, p3));
  790 |     |     }
  791 |     | 
  792 |     |     function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {
  793 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,bool)", p0, p1, p2, p3));
  794 |     |     }
  795 |     | 
  796 |     |     function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {
  797 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,uint256,address)", p0, p1, p2, p3));
  798 |     |     }
  799 |     | 
  800 |     |     function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {
  801 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,uint256)", p0, p1, p2, p3));
  802 |     |     }
  803 |     | 
  804 |     |     function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {
  805 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,string)", p0, p1, p2, p3));
  806 |     |     }
  807 |     | 
  808 |     |     function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {
  809 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,bool)", p0, p1, p2, p3));
  810 |     |     }
  811 |     | 
  812 |     |     function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {
  813 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,string,address)", p0, p1, p2, p3));
  814 |     |     }
  815 |     | 
  816 |     |     function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {
  817 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,uint256)", p0, p1, p2, p3));
  818 |     |     }
  819 |     | 
  820 |     |     function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {
  821 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,string)", p0, p1, p2, p3));
  822 |     |     }
  823 |     | 
  824 |     |     function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {
  825 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,bool)", p0, p1, p2, p3));
  826 |     |     }
  827 |     | 
  828 |     |     function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {
  829 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,bool,address)", p0, p1, p2, p3));
  830 |     |     }
  831 |     | 
  832 |     |     function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {
  833 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,uint256)", p0, p1, p2, p3));
  834 |     |     }
  835 |     | 
  836 |     |     function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {
  837 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,string)", p0, p1, p2, p3));
  838 |     |     }
  839 |     | 
  840 |     |     function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {
  841 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,bool)", p0, p1, p2, p3));
  842 |     |     }
  843 |     | 
  844 |     |     function log(string memory p0, uint256 p1, address p2, address p3) internal pure {
  845 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256,address,address)", p0, p1, p2, p3));
  846 |     |     }
  847 |     | 
  848 |     |     function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {
  849 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,uint256)", p0, p1, p2, p3));
  850 |     |     }
  851 |     | 
  852 |     |     function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {
  853 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,string)", p0, p1, p2, p3));
  854 |     |     }
  855 |     | 
  856 |     |     function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {
  857 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,bool)", p0, p1, p2, p3));
  858 |     |     }
  859 |     | 
  860 |     |     function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {
  861 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint256,address)", p0, p1, p2, p3));
  862 |     |     }
  863 |     | 
  864 |     |     function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {
  865 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint256)", p0, p1, p2, p3));
  866 |     |     }
  867 |     | 
  868 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  869 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  870 |     |     }
  871 |     | 
  872 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  873 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  874 |     |     }
  875 |     | 
  876 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  877 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  878 |     |     }
  879 |     | 
  880 |     |     function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {
  881 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint256)", p0, p1, p2, p3));
  882 |     |     }
  883 |     | 
  884 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  885 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  886 |     |     }
  887 |     | 
  888 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  889 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  890 |     |     }
  891 |     | 
  892 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  893 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  894 |     |     }
  895 |     | 
  896 |     |     function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {
  897 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint256)", p0, p1, p2, p3));
  898 |     |     }
  899 |     | 
  900 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  901 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  902 |     |     }
  903 |     | 
  904 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  905 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  906 |     |     }
  907 |     | 
  908 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  909 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  910 |     |     }
  911 |     | 
  912 |     |     function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {
  913 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,uint256)", p0, p1, p2, p3));
  914 |     |     }
  915 |     | 
  916 |     |     function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {
  917 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,string)", p0, p1, p2, p3));
  918 |     |     }
  919 |     | 
  920 |     |     function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {
  921 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,bool)", p0, p1, p2, p3));
  922 |     |     }
  923 |     | 
  924 |     |     function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {
  925 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint256,address)", p0, p1, p2, p3));
  926 |     |     }
  927 |     | 
  928 |     |     function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {
  929 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint256)", p0, p1, p2, p3));
  930 |     |     }
  931 |     | 
  932 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  933 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  934 |     |     }
  935 |     | 
  936 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  937 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  938 |     |     }
  939 |     | 
  940 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  941 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  942 |     |     }
  943 |     | 
  944 |     |     function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {
  945 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint256)", p0, p1, p2, p3));
  946 |     |     }
  947 |     | 
  948 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  949 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  950 |     |     }
  951 |     | 
  952 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  953 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  954 |     |     }
  955 |     | 
  956 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  957 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  958 |     |     }
  959 |     | 
  960 |     |     function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {
  961 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint256)", p0, p1, p2, p3));
  962 |     |     }
  963 |     | 
  964 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  965 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  966 |     |     }
  967 |     | 
  968 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  969 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  970 |     |     }
  971 |     | 
  972 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  973 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  974 |     |     }
  975 |     | 
  976 |     |     function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {
  977 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,uint256)", p0, p1, p2, p3));
  978 |     |     }
  979 |     | 
  980 |     |     function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {
  981 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,string)", p0, p1, p2, p3));
  982 |     |     }
  983 |     | 
  984 |     |     function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {
  985 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,bool)", p0, p1, p2, p3));
  986 |     |     }
  987 |     | 
  988 |     |     function log(string memory p0, address p1, uint256 p2, address p3) internal pure {
  989 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint256,address)", p0, p1, p2, p3));
  990 |     |     }
  991 |     | 
  992 |     |     function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {
  993 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint256)", p0, p1, p2, p3));
  994 |     |     }
  995 |     | 
  996 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
  997 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  998 |     |     }
  999 |     | 
 1000 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
 1001 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
 1002 |     |     }
 1003 |     | 
 1004 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
 1005 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
 1006 |     |     }
 1007 |     | 
 1008 |     |     function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {
 1009 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint256)", p0, p1, p2, p3));
 1010 |     |     }
 1011 |     | 
 1012 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1013 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1014 |     |     }
 1015 |     | 
 1016 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1017 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1018 |     |     }
 1019 |     | 
 1020 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1021 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1022 |     |     }
 1023 |     | 
 1024 |     |     function log(string memory p0, address p1, address p2, uint256 p3) internal pure {
 1025 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint256)", p0, p1, p2, p3));
 1026 |     |     }
 1027 |     | 
 1028 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1029 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1030 |     |     }
 1031 |     | 
 1032 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1033 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1034 |     |     }
 1035 |     | 
 1036 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1037 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1038 |     |     }
 1039 |     | 
 1040 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1041 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,uint256)", p0, p1, p2, p3));
 1042 |     |     }
 1043 |     | 
 1044 |     |     function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1045 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,string)", p0, p1, p2, p3));
 1046 |     |     }
 1047 |     | 
 1048 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1049 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,bool)", p0, p1, p2, p3));
 1050 |     |     }
 1051 |     | 
 1052 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
 1053 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,uint256,address)", p0, p1, p2, p3));
 1054 |     |     }
 1055 |     | 
 1056 |     |     function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1057 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,uint256)", p0, p1, p2, p3));
 1058 |     |     }
 1059 |     | 
 1060 |     |     function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1061 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,string)", p0, p1, p2, p3));
 1062 |     |     }
 1063 |     | 
 1064 |     |     function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {
 1065 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,bool)", p0, p1, p2, p3));
 1066 |     |     }
 1067 |     | 
 1068 |     |     function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {
 1069 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,string,address)", p0, p1, p2, p3));
 1070 |     |     }
 1071 |     | 
 1072 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1073 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,uint256)", p0, p1, p2, p3));
 1074 |     |     }
 1075 |     | 
 1076 |     |     function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {
 1077 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,string)", p0, p1, p2, p3));
 1078 |     |     }
 1079 |     | 
 1080 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
 1081 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,bool)", p0, p1, p2, p3));
 1082 |     |     }
 1083 |     | 
 1084 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
 1085 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,bool,address)", p0, p1, p2, p3));
 1086 |     |     }
 1087 |     | 
 1088 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
 1089 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,uint256)", p0, p1, p2, p3));
 1090 |     |     }
 1091 |     | 
 1092 |     |     function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {
 1093 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,string)", p0, p1, p2, p3));
 1094 |     |     }
 1095 |     | 
 1096 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
 1097 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,bool)", p0, p1, p2, p3));
 1098 |     |     }
 1099 |     | 
 1100 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
 1101 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint256,address,address)", p0, p1, p2, p3));
 1102 |     |     }
 1103 |     | 
 1104 |     |     function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1105 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,uint256)", p0, p1, p2, p3));
 1106 |     |     }
 1107 |     | 
 1108 |     |     function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1109 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,string)", p0, p1, p2, p3));
 1110 |     |     }
 1111 |     | 
 1112 |     |     function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {
 1113 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,bool)", p0, p1, p2, p3));
 1114 |     |     }
 1115 |     | 
 1116 |     |     function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {
 1117 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint256,address)", p0, p1, p2, p3));
 1118 |     |     }
 1119 |     | 
 1120 |     |     function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1121 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint256)", p0, p1, p2, p3));
 1122 |     |     }
 1123 |     | 
 1124 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1125 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1126 |     |     }
 1127 |     | 
 1128 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1129 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1130 |     |     }
 1131 |     | 
 1132 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1133 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1134 |     |     }
 1135 |     | 
 1136 |     |     function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {
 1137 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint256)", p0, p1, p2, p3));
 1138 |     |     }
 1139 |     | 
 1140 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1141 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1142 |     |     }
 1143 |     | 
 1144 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1145 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1146 |     |     }
 1147 |     | 
 1148 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1149 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1150 |     |     }
 1151 |     | 
 1152 |     |     function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {
 1153 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint256)", p0, p1, p2, p3));
 1154 |     |     }
 1155 |     | 
 1156 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1157 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1158 |     |     }
 1159 |     | 
 1160 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1161 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1162 |     |     }
 1163 |     | 
 1164 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1165 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1166 |     |     }
 1167 |     | 
 1168 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1169 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,uint256)", p0, p1, p2, p3));
 1170 |     |     }
 1171 |     | 
 1172 |     |     function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {
 1173 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,string)", p0, p1, p2, p3));
 1174 |     |     }
 1175 |     | 
 1176 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
 1177 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,bool)", p0, p1, p2, p3));
 1178 |     |     }
 1179 |     | 
 1180 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
 1181 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint256,address)", p0, p1, p2, p3));
 1182 |     |     }
 1183 |     | 
 1184 |     |     function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {
 1185 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint256)", p0, p1, p2, p3));
 1186 |     |     }
 1187 |     | 
 1188 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1189 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1190 |     |     }
 1191 |     | 
 1192 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1193 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1194 |     |     }
 1195 |     | 
 1196 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1197 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1198 |     |     }
 1199 |     | 
 1200 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
 1201 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint256)", p0, p1, p2, p3));
 1202 |     |     }
 1203 |     | 
 1204 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1205 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1206 |     |     }
 1207 |     | 
 1208 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1209 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1210 |     |     }
 1211 |     | 
 1212 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1213 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1214 |     |     }
 1215 |     | 
 1216 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
 1217 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint256)", p0, p1, p2, p3));
 1218 |     |     }
 1219 |     | 
 1220 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1221 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1222 |     |     }
 1223 |     | 
 1224 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1225 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1226 |     |     }
 1227 |     | 
 1228 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1229 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1230 |     |     }
 1231 |     | 
 1232 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
 1233 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,uint256)", p0, p1, p2, p3));
 1234 |     |     }
 1235 |     | 
 1236 |     |     function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {
 1237 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,string)", p0, p1, p2, p3));
 1238 |     |     }
 1239 |     | 
 1240 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
 1241 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,bool)", p0, p1, p2, p3));
 1242 |     |     }
 1243 |     | 
 1244 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
 1245 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint256,address)", p0, p1, p2, p3));
 1246 |     |     }
 1247 |     | 
 1248 |     |     function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {
 1249 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint256)", p0, p1, p2, p3));
 1250 |     |     }
 1251 |     | 
 1252 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1253 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1254 |     |     }
 1255 |     | 
 1256 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1257 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1258 |     |     }
 1259 |     | 
 1260 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1261 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1262 |     |     }
 1263 |     | 
 1264 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
 1265 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint256)", p0, p1, p2, p3));
 1266 |     |     }
 1267 |     | 
 1268 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1269 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1270 |     |     }
 1271 |     | 
 1272 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1273 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1274 |     |     }
 1275 |     | 
 1276 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1277 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1278 |     |     }
 1279 |     | 
 1280 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
 1281 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint256)", p0, p1, p2, p3));
 1282 |     |     }
 1283 |     | 
 1284 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1285 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1286 |     |     }
 1287 |     | 
 1288 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1289 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1290 |     |     }
 1291 |     | 
 1292 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1293 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1294 |     |     }
 1295 |     | 
 1296 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 1297 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,uint256)", p0, p1, p2, p3));
 1298 |     |     }
 1299 |     | 
 1300 |     |     function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {
 1301 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,string)", p0, p1, p2, p3));
 1302 |     |     }
 1303 |     | 
 1304 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
 1305 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,bool)", p0, p1, p2, p3));
 1306 |     |     }
 1307 |     | 
 1308 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
 1309 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,uint256,address)", p0, p1, p2, p3));
 1310 |     |     }
 1311 |     | 
 1312 |     |     function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {
 1313 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,uint256)", p0, p1, p2, p3));
 1314 |     |     }
 1315 |     | 
 1316 |     |     function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {
 1317 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,string)", p0, p1, p2, p3));
 1318 |     |     }
 1319 |     | 
 1320 |     |     function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {
 1321 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,bool)", p0, p1, p2, p3));
 1322 |     |     }
 1323 |     | 
 1324 |     |     function log(address p0, uint256 p1, string memory p2, address p3) internal pure {
 1325 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,string,address)", p0, p1, p2, p3));
 1326 |     |     }
 1327 |     | 
 1328 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
 1329 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,uint256)", p0, p1, p2, p3));
 1330 |     |     }
 1331 |     | 
 1332 |     |     function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {
 1333 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,string)", p0, p1, p2, p3));
 1334 |     |     }
 1335 |     | 
 1336 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
 1337 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,bool)", p0, p1, p2, p3));
 1338 |     |     }
 1339 |     | 
 1340 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
 1341 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,bool,address)", p0, p1, p2, p3));
 1342 |     |     }
 1343 |     | 
 1344 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
 1345 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,uint256)", p0, p1, p2, p3));
 1346 |     |     }
 1347 |     | 
 1348 |     |     function log(address p0, uint256 p1, address p2, string memory p3) internal pure {
 1349 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,string)", p0, p1, p2, p3));
 1350 |     |     }
 1351 |     | 
 1352 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
 1353 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,bool)", p0, p1, p2, p3));
 1354 |     |     }
 1355 |     | 
 1356 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
 1357 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint256,address,address)", p0, p1, p2, p3));
 1358 |     |     }
 1359 |     | 
 1360 |     |     function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {
 1361 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,uint256)", p0, p1, p2, p3));
 1362 |     |     }
 1363 |     | 
 1364 |     |     function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {
 1365 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,string)", p0, p1, p2, p3));
 1366 |     |     }
 1367 |     | 
 1368 |     |     function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {
 1369 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,bool)", p0, p1, p2, p3));
 1370 |     |     }
 1371 |     | 
 1372 |     |     function log(address p0, string memory p1, uint256 p2, address p3) internal pure {
 1373 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint256,address)", p0, p1, p2, p3));
 1374 |     |     }
 1375 |     | 
 1376 |     |     function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {
 1377 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint256)", p0, p1, p2, p3));
 1378 |     |     }
 1379 |     | 
 1380 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1381 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1382 |     |     }
 1383 |     | 
 1384 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1385 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1386 |     |     }
 1387 |     | 
 1388 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1389 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1390 |     |     }
 1391 |     | 
 1392 |     |     function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {
 1393 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint256)", p0, p1, p2, p3));
 1394 |     |     }
 1395 |     | 
 1396 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1397 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1398 |     |     }
 1399 |     | 
 1400 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1401 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1402 |     |     }
 1403 |     | 
 1404 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1405 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1406 |     |     }
 1407 |     | 
 1408 |     |     function log(address p0, string memory p1, address p2, uint256 p3) internal pure {
 1409 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint256)", p0, p1, p2, p3));
 1410 |     |     }
 1411 |     | 
 1412 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1413 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1414 |     |     }
 1415 |     | 
 1416 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1417 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1418 |     |     }
 1419 |     | 
 1420 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1421 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1422 |     |     }
 1423 |     | 
 1424 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
 1425 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,uint256)", p0, p1, p2, p3));
 1426 |     |     }
 1427 |     | 
 1428 |     |     function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {
 1429 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,string)", p0, p1, p2, p3));
 1430 |     |     }
 1431 |     | 
 1432 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
 1433 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,bool)", p0, p1, p2, p3));
 1434 |     |     }
 1435 |     | 
 1436 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
 1437 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint256,address)", p0, p1, p2, p3));
 1438 |     |     }
 1439 |     | 
 1440 |     |     function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {
 1441 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint256)", p0, p1, p2, p3));
 1442 |     |     }
 1443 |     | 
 1444 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1445 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1446 |     |     }
 1447 |     | 
 1448 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1449 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1450 |     |     }
 1451 |     | 
 1452 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1453 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1454 |     |     }
 1455 |     | 
 1456 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
 1457 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint256)", p0, p1, p2, p3));
 1458 |     |     }
 1459 |     | 
 1460 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1461 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1462 |     |     }
 1463 |     | 
 1464 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1465 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1466 |     |     }
 1467 |     | 
 1468 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1469 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1470 |     |     }
 1471 |     | 
 1472 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
 1473 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint256)", p0, p1, p2, p3));
 1474 |     |     }
 1475 |     | 
 1476 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1477 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1478 |     |     }
 1479 |     | 
 1480 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1481 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1482 |     |     }
 1483 |     | 
 1484 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1485 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1486 |     |     }
 1487 |     | 
 1488 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
 1489 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,uint256)", p0, p1, p2, p3));
 1490 |     |     }
 1491 |     | 
 1492 |     |     function log(address p0, address p1, uint256 p2, string memory p3) internal pure {
 1493 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,string)", p0, p1, p2, p3));
 1494 |     |     }
 1495 |     | 
 1496 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
 1497 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,bool)", p0, p1, p2, p3));
 1498 |     |     }
 1499 |     | 
 1500 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
 1501 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint256,address)", p0, p1, p2, p3));
 1502 |     |     }
 1503 |     | 
 1504 |     |     function log(address p0, address p1, string memory p2, uint256 p3) internal pure {
 1505 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint256)", p0, p1, p2, p3));
 1506 |     |     }
 1507 |     | 
 1508 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1509 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1510 |     |     }
 1511 |     | 
 1512 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1513 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1514 |     |     }
 1515 |     | 
 1516 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1517 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1518 |     |     }
 1519 |     | 
 1520 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
 1521 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint256)", p0, p1, p2, p3));
 1522 |     |     }
 1523 |     | 
 1524 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1525 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1526 |     |     }
 1527 |     | 
 1528 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1529 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1530 |     |     }
 1531 |     | 
 1532 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1533 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1534 |     |     }
 1535 |     | 
 1536 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
 1537 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint256)", p0, p1, p2, p3));
 1538 |     |     }
 1539 |     | 
 1540 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1541 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1542 |     |     }
 1543 |     | 
 1544 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1545 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1546 |     |     }
 1547 |     | 
 1548 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1549 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1550 |     |     }
 1551 |     | 
 1552 |     | }
 1553 |     | 

