<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/home/ec2-user/git/limit/contracts/EchidnaPool.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./LimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./utils/LimitPoolManager.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./test/Token20.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./libraries/utils/SafeTransfers.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/PositionERC1155.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>// Fuzz LimitPool functionality</span>
  14 | *r  | <span class='executed'>contract EchidnaPool {</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    event PassedMint();</span>
  17 |     | <span class='neutral'>    event PassedBurn();</span>
  18 |     | <span class='neutral'>    event Prices(uint160 price0, uint160 price1);</span>
  19 |     | <span class='neutral'>    event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);</span>
  20 |     | <span class='neutral'>    event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);</span>
  21 |     | <span class='neutral'>    event PositionTicks(int24 lower, int24 upper);</span>
  22 |     | <span class='neutral'>    event BurnTicks(int24 lower, int24 upper, bool positionExists);</span>
  23 |     | <span class='neutral'>    event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);</span>
  24 |     | <span class='neutral'>    event PositionCreated(bool isCreated);</span>
  25 |     | <span class='neutral'>    event LiquidityAbsolute(uint128 beforeAbs, uint128 afterAbs);</span>
  26 |     | <span class='neutral'>    event LiquidityDeltaAndAbsolute(int128 delta, uint128 abs);</span>
  27 |     | <span class='neutral'>    event PriceChange(uint160 priceBefore, uint160 priceAfter);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    int16 tickSpacing;</span>
  30 |     | <span class='neutral'>    uint16 swapFee;</span>
  31 |     | <span class='neutral'>    address private implementation;</span>
  32 |     | <span class='neutral'>    LimitPoolFactory private factory;</span>
  33 |     | <span class='neutral'>    LimitPoolManager private manager;</span>
  34 |     | <span class='neutral'>    PositionERC1155 private rangePool;</span>
  35 |     | <span class='neutral'>    LimitPool private pool;</span>
  36 |     | <span class='neutral'>    Token20 private tokenIn;</span>
  37 |     | <span class='neutral'>    Token20 private tokenOut;</span>
  38 |     | <span class='neutral'>    Position[] private positions;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    struct LiquidityDeltaValues {</span>
  41 |     | <span class='neutral'>        int128 liquidityDeltaLowerAfter;</span>
  42 |     | <span class='neutral'>        int128 liquidityDeltaUpperAfter;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct PoolValues {</span>
  46 |     | <span class='neutral'>        uint160 price0Before;</span>
  47 |     | <span class='neutral'>        uint128 liquidity0Before;</span>
  48 |     | <span class='neutral'>        uint160 price1Before;</span>
  49 |     | <span class='neutral'>        uint128 liquidity1Before;</span>
  50 |     | <span class='neutral'>        uint160 price0After;</span>
  51 |     | <span class='neutral'>        uint128 liquidity0After;</span>
  52 |     | <span class='neutral'>        uint160 price1After;</span>
  53 |     | <span class='neutral'>        uint128 liquidity1After;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>        uint128 liquidityGlobalBefore;</span>
  56 |     | <span class='neutral'>        uint128 liquidityGlobalAfter;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>        uint128 liquidityAbsoluteUpperBefore;</span>
  59 |     | <span class='neutral'>        uint128 liquidityAbsoluteLowerBefore;</span>
  60 |     | <span class='neutral'>        uint128 liquidityAbsoluteUpperAfter;</span>
  61 |     | <span class='neutral'>        uint128 liquidityAbsoluteLowerAfter;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        uint160 price0;</span>
  64 |     | <span class='neutral'>        uint160 price1;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        uint32 positionIdNextBefore;</span>
  67 |     | <span class='neutral'>        uint32 positionIdNextAfter;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  71 |     | <span class='neutral'>        address sender;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    struct Position {</span>
  75 |     | <span class='neutral'>        address owner;</span>
  76 |     | <span class='neutral'>        uint32 positionId;</span>
  77 |     | <span class='neutral'>        int24 lower;</span>
  78 |     | <span class='neutral'>        int24 upper;</span>
  79 |     | <span class='neutral'>        bool zeroForOne;</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    struct PoolStructs {</span>
  83 |     | <span class='neutral'>        PoolsharkStructs.LimitTick lower;</span>
  84 |     | <span class='neutral'>        PoolsharkStructs.LimitTick upper;</span>
  85 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool0;</span>
  86 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState pool1;</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    modifier tickPreconditions(int24 lower, int24 upper) {</span>
  90 | *r  | <span class='executed'>        require(lower &lt; upper);</span>
  91 | *r  | <span class='executed'>        require(upper &lt; 887272);</span>
  92 | *r  | <span class='executed'>        require(lower &gt; -887272);</span>
  93 | *r  | <span class='executed'>        require(lower % tickSpacing == 0);</span>
  94 | *r  | <span class='executed'>        require(upper % tickSpacing == 0);</span>
  95 |     | <span class='neutral'>        _;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='unexecuted'>    constructor() {</span>
  99 |     | <span class='unexecuted'>        manager = new LimitPoolManager();</span>
 100 |     | <span class='unexecuted'>        factory = new LimitPoolFactory(address(manager));</span>
 101 |     | <span class='unexecuted'>        implementation = address(new LimitPool(address(factory)));</span>
 102 |     | <span class='unexecuted'>        rangePool = new PositionERC1155(address(factory));</span>
 103 |     | <span class='neutral'>        </span>
 104 |     | <span class='unexecuted'>        manager.enableImplementation(bytes32(0x0), address(implementation), address(rangePool));</span>
 105 |     | <span class='unexecuted'>        tickSpacing = 10;</span>
 106 |     | <span class='unexecuted'>        tokenIn = new Token20(&quot;IN&quot;, &quot;IN&quot;, 18);</span>
 107 |     | <span class='unexecuted'>        tokenOut = new Token20(&quot;OUT&quot;, &quot;OUT&quot;, 18);</span>
 108 |     | <span class='unexecuted'>        (address poolAddr,) = factory.createLimitPool(bytes32(0x0), address(tokenIn), address(tokenOut), 500, 79228162514264337593543950336);</span>
 109 |     | <span class='unexecuted'>        pool = LimitPool(poolAddr);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 | *   | <span class='executed'>    function mint(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 113 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 114 | *   | <span class='executed'>        mintAndApprove();</span>
 115 | *   | <span class='executed'>        amount = amount + 1;</span>
 116 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
 117 | *   | <span class='executed'>        for(uint i = 0; i &lt; positions.length;) {</span>
 118 |     | <span class='unexecuted'>            if(positions[i].owner == msg.sender &amp;&amp; positions[i].lower == lower &amp;&amp; positions[i].upper == upper &amp;&amp; positions[i].zeroForOne == zeroForOne) {</span>
 119 |     | <span class='unexecuted'>                revert(&quot;Position already exists&quot;);</span>
 120 |     | <span class='neutral'>            }</span>
 121 |     | <span class='neutral'>            unchecked {</span>
 122 |     | <span class='unexecuted'>                ++i;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'></span>
 126 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 127 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 128 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 129 |     | <span class='neutral'></span>
 130 | *   | <span class='executed'>        (,poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalBefore,poolValues.positionIdNextBefore,,) = pool.globalState();</span>
 131 | *   | <span class='executed'>        poolValues.price0Before = poolStructs.pool0.price;</span>
 132 | *   | <span class='executed'>        poolValues.liquidity0Before = poolStructs.pool0.liquidity;</span>
 133 | *   | <span class='executed'>        poolValues.price1Before = poolStructs.pool1.price;</span>
 134 | *   | <span class='executed'>        poolValues.liquidity1Before = poolStructs.pool1.liquidity;</span>
 135 |     | <span class='neutral'></span>
 136 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 137 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 138 |     | <span class='neutral'></span>
 139 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = poolStructs.lower.liquidityAbsolute;</span>
 140 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = poolStructs.upper.liquidityAbsolute;</span>
 141 |     | <span class='neutral'></span>
 142 | *   | <span class='executed'>        LimitPoolStructs.MintLimitParams memory params;</span>
 143 | *   | <span class='executed'>        params.to = msg.sender;</span>
 144 | *   | <span class='executed'>        params.amount = amount;</span>
 145 | *   | <span class='executed'>        params.mintPercent = 0;</span>
 146 | *   | <span class='executed'>        params.lower = lower;</span>
 147 | *   | <span class='executed'>        params.upper = upper;</span>
 148 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 151 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 152 | *   | <span class='executed'>        bool posCreated;</span>
 153 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 154 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
 155 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // ACTION </span>
 158 | *r  | <span class='executed'>        pool.mintLimit(params);</span>
 159 |     | <span class='unexecuted'>        if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 162 |     | <span class='unexecuted'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerAfter = poolStructs.lower.liquidityAbsolute;</span>
 165 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperAfter = poolStructs.upper.liquidityAbsolute;</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 168 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>        (, poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 171 |     | <span class='unexecuted'>        poolValues.price0After = poolStructs.pool0.price;</span>
 172 |     | <span class='unexecuted'>        poolValues.liquidity0After = poolStructs.pool0.liquidity;</span>
 173 |     | <span class='unexecuted'>        poolValues.price1After = poolStructs.pool1.price;</span>
 174 |     | <span class='unexecuted'>        poolValues.liquidity1After = poolStructs.pool1.liquidity;</span>
 175 |     | <span class='unexecuted'>        poolValues.price0 = poolStructs.pool0.price;</span>
 176 |     | <span class='unexecuted'>        poolValues.price1 = poolStructs.pool1.price;</span>
 177 |     | <span class='neutral'>        </span>
 178 |     | <span class='neutral'>        // POST CONDITIONS</span>
 179 |     | <span class='unexecuted'>        emit Prices(poolValues.price0, poolValues.price1);</span>
 180 |     | <span class='unexecuted'>        assert(poolValues.price0 &gt;= poolValues.price1);</span>
 181 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 182 |     | <span class='unexecuted'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 183 |     | <span class='unexecuted'>        assert(poolValues.price0After &gt;= poolValues.price1After);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>        // Ensure liquidityDelta is always less or equal to liquidityAbsolute</span>
 186 |     | <span class='unexecuted'>        emit LiquidityDeltaAndAbsolute(values.liquidityDeltaLowerAfter, poolValues.liquidityAbsoluteLowerAfter);</span>
 187 |     | <span class='unexecuted'>        assert(int256(values.liquidityDeltaLowerAfter) &lt;= int256(uint256(poolValues.liquidityAbsoluteLowerAfter)));</span>
 188 |     | <span class='unexecuted'>        emit LiquidityDeltaAndAbsolute(values.liquidityDeltaUpperAfter, poolValues.liquidityAbsoluteUpperAfter);</span>
 189 |     | <span class='unexecuted'>        assert(int256(values.liquidityDeltaUpperAfter) &lt;= int256(uint256(poolValues.liquidityAbsoluteUpperAfter)));</span>
 190 |     | <span class='neutral'>        </span>
 191 |     | <span class='neutral'>        // Ensure that liquidityAbsolute is incremented when not undercutting</span>
 192 |     | <span class='unexecuted'>        if(zeroForOne){</span>
 193 |     | <span class='unexecuted'>            if(poolValues.price0After &gt;= poolValues.price0Before){</span>
 194 |     | <span class='unexecuted'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 195 |     | <span class='unexecuted'>                assert(poolValues.liquidityAbsoluteUpperAfter &gt;= poolValues.liquidityAbsoluteUpperBefore);</span>
 196 |     | <span class='unexecuted'>                emit LiquidityAbsolute(1234, 1234);</span>
 197 |     | <span class='neutral'>            }</span>
 198 |     | <span class='neutral'>        } else {</span>
 199 |     | <span class='unexecuted'>            if(poolValues.price1Before &gt;= poolValues.price1After){</span>
 200 |     | <span class='unexecuted'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 201 |     | <span class='unexecuted'>                assert(poolValues.liquidityAbsoluteLowerAfter &gt;= poolValues.liquidityAbsoluteLowerBefore);</span>
 202 |     | <span class='unexecuted'>                emit LiquidityAbsolute(5678, 5678);</span>
 203 |     | <span class='neutral'>            }</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        if (posCreated) {</span>
 207 |     | <span class='unexecuted'>            emit PositionTicks(lower, upper);</span>
 208 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 209 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 210 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 211 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>        </span>
 214 |     | <span class='unexecuted'>        emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 215 |     | <span class='unexecuted'>        emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 216 |     | <span class='neutral'>        </span>
 217 |     | <span class='neutral'>        // Ensure liquidityGlobal is incremented after mint</span>
 218 |     | <span class='unexecuted'>        assert(poolValues.liquidityGlobalAfter &gt;= poolValues.liquidityGlobalBefore);</span>
 219 |     | <span class='neutral'>        </span>
 220 |     | <span class='neutral'>        // Ensure pool liquidity is non-zero after mint with no undercuts</span>
 221 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 222 |     | <span class='unexecuted'>            emit PriceChange(poolValues.price0Before, poolValues.price0After);</span>
 223 |     | <span class='unexecuted'>            if (poolValues.price0After &lt; poolValues.price0Before) assert(poolValues.liquidity0After &gt; 0);</span>
 224 |     | <span class='neutral'>        }</span>
 225 |     | <span class='neutral'>        else {</span>
 226 |     | <span class='unexecuted'>            emit PriceChange(poolValues.price1Before, poolValues.price1After);</span>
 227 |     | <span class='unexecuted'>            if (poolValues.price1After &gt; poolValues.price1Before) assert(poolValues.liquidity1After &gt; 0);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 | *   | <span class='executed'>    function mintVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
 232 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 233 | *   | <span class='executed'>        mintAndApprove();</span>
 234 | *   | <span class='executed'>        amount = amount + 1;</span>
 235 |     | <span class='neutral'>        // Ensure the newly created position is using different ticks</span>
 236 | *   | <span class='executed'>        for(uint i = 0; i &lt; positions.length;) {</span>
 237 |     | <span class='unexecuted'>            if(positions[i].owner == msg.sender &amp;&amp; positions[i].lower == lower &amp;&amp; positions[i].upper == upper &amp;&amp; positions[i].zeroForOne == zeroForOne) {</span>
 238 |     | <span class='unexecuted'>                revert(&quot;Position already exists&quot;);</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>            unchecked {</span>
 241 |     | <span class='unexecuted'>                ++i;</span>
 242 |     | <span class='neutral'>            }</span>
 243 |     | <span class='neutral'>        }</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 246 | *   | <span class='executed'>        PoolStructs memory poolStructs;</span>
 247 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 248 |     | <span class='neutral'></span>
 249 | *   | <span class='executed'>        (,poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalBefore,poolValues.positionIdNextBefore,,) = pool.globalState();</span>
 250 | *   | <span class='executed'>        poolValues.price0Before = poolStructs.pool0.price;</span>
 251 | *   | <span class='executed'>        poolValues.liquidity0Before = poolStructs.pool0.liquidity;</span>
 252 | *   | <span class='executed'>        poolValues.price1Before = poolStructs.pool1.price;</span>
 253 | *   | <span class='executed'>        poolValues.liquidity1Before = poolStructs.pool1.liquidity;</span>
 254 |     | <span class='neutral'></span>
 255 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 256 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 257 |     | <span class='neutral'></span>
 258 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = poolStructs.lower.liquidityAbsolute;</span>
 259 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = poolStructs.upper.liquidityAbsolute;</span>
 260 |     | <span class='neutral'></span>
 261 | *   | <span class='executed'>        LimitPoolStructs.MintLimitParams memory params;</span>
 262 | *   | <span class='executed'>        params.to = msg.sender;</span>
 263 | *   | <span class='executed'>        params.amount = amount;</span>
 264 | *   | <span class='executed'>        params.mintPercent = mintPercent;</span>
 265 | *   | <span class='executed'>        params.lower = lower;</span>
 266 | *   | <span class='executed'>        params.upper = upper;</span>
 267 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>        // Get the ticks the position will be minted with rather than what was passed directly by fuzzer</span>
 270 |     | <span class='neutral'>        // This is so the we can properly compare before and after mint states of particular ticks.</span>
 271 | *   | <span class='executed'>        bool posCreated;</span>
 272 | *   | <span class='executed'>        (lower, upper, posCreated) = pool.getResizedTicksForMint(params);</span>
 273 | *   | <span class='executed'>        emit PositionTicks(lower, upper);</span>
 274 | *   | <span class='executed'>        emit PositionCreated(posCreated);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>        // ACTION </span>
 277 | *   | <span class='executed'>        pool.mintLimit(params);</span>
 278 | *   | <span class='executed'>        if (posCreated) positions.push(Position(msg.sender, poolValues.positionIdNextBefore, lower, upper, zeroForOne));</span>
 279 |     | <span class='neutral'></span>
 280 | *   | <span class='executed'>        (, poolStructs.lower) = pool.ticks(lower);</span>
 281 | *   | <span class='executed'>        (, poolStructs.upper) = pool.ticks(upper);</span>
 282 |     | <span class='neutral'></span>
 283 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerAfter = poolStructs.lower.liquidityAbsolute;</span>
 284 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperAfter = poolStructs.upper.liquidityAbsolute;</span>
 285 |     | <span class='neutral'></span>
 286 | *   | <span class='executed'>        values.liquidityDeltaLowerAfter = poolStructs.lower.liquidityDelta;</span>
 287 | *   | <span class='executed'>        values.liquidityDeltaUpperAfter = poolStructs.upper.liquidityDelta;</span>
 288 |     | <span class='neutral'></span>
 289 | *   | <span class='executed'>        (, poolStructs.pool0, poolStructs.pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 290 | *   | <span class='executed'>        poolValues.price0After = poolStructs.pool0.price;</span>
 291 | *   | <span class='executed'>        poolValues.liquidity0After = poolStructs.pool0.liquidity;</span>
 292 | *   | <span class='executed'>        poolValues.price1After = poolStructs.pool1.price;</span>
 293 | *   | <span class='executed'>        poolValues.liquidity1After = poolStructs.pool1.liquidity;</span>
 294 |     | <span class='neutral'>        </span>
 295 | *   | <span class='executed'>        poolValues.price0 = poolStructs.pool0.price;</span>
 296 | *   | <span class='executed'>        poolValues.price1 = poolStructs.pool1.price;</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>        // POST CONDITIONS</span>
 299 | *   | <span class='executed'>        emit Prices(poolValues.price0, poolValues.price1);</span>
 300 | *   | <span class='executed'>        assert(poolValues.price0 &gt;= poolValues.price1);</span>
 301 | *   | <span class='executed'>        emit Prices(poolValues.price0After, poolValues.price1After);</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='neutral'>        // Ensure liquidityDelta is always less or equal to liquidityAbsolute</span>
 304 | *   | <span class='executed'>        emit LiquidityDeltaAndAbsolute(values.liquidityDeltaLowerAfter, poolValues.liquidityAbsoluteLowerAfter);</span>
 305 | *   | <span class='executed'>        assert(int256(values.liquidityDeltaLowerAfter) &lt;= int256(uint256(poolValues.liquidityAbsoluteLowerAfter)));</span>
 306 | *   | <span class='executed'>        emit LiquidityDeltaAndAbsolute(values.liquidityDeltaUpperAfter, poolValues.liquidityAbsoluteUpperAfter);</span>
 307 | *   | <span class='executed'>        assert(int256(values.liquidityDeltaUpperAfter) &lt;= int256(uint256(poolValues.liquidityAbsoluteUpperAfter)));</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>        // Ensure that liquidityAbsolute is incremented when not undercutting</span>
 310 | *   | <span class='executed'>        if(zeroForOne){</span>
 311 |     | <span class='unexecuted'>            if(poolValues.price0After &gt;= poolValues.price0Before){</span>
 312 |     | <span class='unexecuted'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteUpperBefore, poolValues.liquidityAbsoluteUpperAfter);</span>
 313 |     | <span class='unexecuted'>                assert(poolValues.liquidityAbsoluteUpperAfter &gt; poolValues.liquidityAbsoluteUpperBefore);</span>
 314 |     | <span class='neutral'>            }</span>
 315 |     | <span class='neutral'>        } else {</span>
 316 | *   | <span class='executed'>            if(poolValues.price1Before &gt;= poolValues.price1After){</span>
 317 | *   | <span class='executed'>                emit LiquidityAbsolute(poolValues.liquidityAbsoluteLowerBefore, poolValues.liquidityAbsoluteLowerAfter);</span>
 318 | *   | <span class='executed'>                assert(poolValues.liquidityAbsoluteLowerAfter &gt; poolValues.liquidityAbsoluteLowerBefore);</span>
 319 |     | <span class='neutral'>            }</span>
 320 |     | <span class='neutral'>        }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>        // Ensure prices have not crossed</span>
 323 |     | <span class='unexecuted'>        assert(poolValues.price0After &gt;= poolValues.price1After);</span>
 324 |     | <span class='unexecuted'>        if (posCreated) {</span>
 325 |     | <span class='unexecuted'>            emit PositionTicks(lower, upper);</span>
 326 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 327 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 328 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 329 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 330 |     | <span class='neutral'>        }</span>
 331 |     | <span class='neutral'>        </span>
 332 |     | <span class='unexecuted'>        emit LiquidityGlobal(poolValues.liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 333 |     | <span class='unexecuted'>        emit Liquidity(poolValues.liquidity0Before, poolValues.liquidity1Before, poolValues.liquidity0After, poolValues.liquidity1After);</span>
 334 |     | <span class='neutral'>        </span>
 335 |     | <span class='neutral'>        // Ensure liquidityGlobal is incremented after mint</span>
 336 |     | <span class='unexecuted'>        assert(poolValues.liquidityGlobalAfter &gt;= poolValues.liquidityGlobalBefore);</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>        // Ensure pool liquidity is non-zero after mint with no undercuts</span>
 339 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 340 |     | <span class='unexecuted'>            if (poolValues.price0After &lt; poolValues.price0Before) assert(poolValues.liquidity0After &gt; 0);</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>        else {</span>
 343 |     | <span class='unexecuted'>            if (poolValues.price1After &gt; poolValues.price1Before) assert(poolValues.liquidity1After &gt; 0);</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 | *   | <span class='executed'>    function swap(uint160 priceLimit, uint128 amount, bool exactIn, bool zeroForOne) public {</span>
 348 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 349 | *   | <span class='executed'>        mintAndApprove();</span>
 350 |     | <span class='neutral'></span>
 351 | *   | <span class='executed'>        LimitPoolStructs.SwapParams memory params;</span>
 352 | *   | <span class='executed'>        params.to = msg.sender;</span>
 353 | *   | <span class='executed'>        params.priceLimit = priceLimit;</span>
 354 | *   | <span class='executed'>        params.amount = amount;</span>
 355 | *   | <span class='executed'>        params.exactIn = exactIn;</span>
 356 | *   | <span class='executed'>        params.zeroForOne = zeroForOne;</span>
 357 | *   | <span class='executed'>        params.callbackData = abi.encodePacked(address(this));</span>
 358 |     | <span class='neutral'>        </span>
 359 |     | <span class='neutral'>        // ACTION</span>
 360 | *r  | <span class='executed'>        pool.swap(params);</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='neutral'>        // POST CONDITIONS</span>
 363 |     | <span class='unexecuted'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1,,,,) = pool.globalState();</span>
 364 |     | <span class='unexecuted'>        uint160 price0 = pool0.price;</span>
 365 |     | <span class='unexecuted'>        uint160 price1 = pool1.price;</span>
 366 |     | <span class='neutral'>        </span>
 367 |     | <span class='neutral'>        // Ensure prices never cross</span>
 368 |     | <span class='unexecuted'>        emit Prices(price0, price1);</span>
 369 |     | <span class='unexecuted'>        assert(price0 &gt;= price1);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 | *   | <span class='executed'>    function burn(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {</span>
 373 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 374 | *   | <span class='executed'>        positionIndex = positionIndex % positions.length;</span>
 375 |     | <span class='unexecuted'>        Position memory pos = positions[positionIndex];</span>
 376 |     | <span class='unexecuted'>        require(claimAt &gt;= pos.lower &amp;&amp; claimAt &lt;= pos.upper);</span>
 377 |     | <span class='unexecuted'>        require(claimAt % tickSpacing == 0);</span>
 378 |     | <span class='unexecuted'>        PoolValues memory poolValues;</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,,) = pool.globalState();</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitParams memory params;</span>
 383 |     | <span class='unexecuted'>        params.to = pos.owner;</span>
 384 |     | <span class='unexecuted'>        params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;</span>
 385 |     | <span class='unexecuted'>        params.positionId = pos.positionId;</span>
 386 |     | <span class='unexecuted'>        params.claim = claimAt;</span>
 387 |     | <span class='unexecuted'>        params.zeroForOne = pos.zeroForOne;</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='unexecuted'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(pos.lower);</span>
 390 |     | <span class='unexecuted'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(pos.upper);</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 393 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 394 |     | <span class='neutral'>        </span>
 395 |     | <span class='unexecuted'>        emit PositionTicks(pos.lower, pos.upper);</span>
 396 |     | <span class='unexecuted'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 397 |     | <span class='unexecuted'>        emit BurnTicks(lower, upper, positionExists);</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>        // ACTION</span>
 400 |     | <span class='unexecuted'>        pool.burnLimit(params);</span>
 401 |     | <span class='unexecuted'>        if (!positionExists) {</span>
 402 |     | <span class='unexecuted'>            positions[positionIndex] = positions[positions.length - 1];</span>
 403 |     | <span class='unexecuted'>            delete positions[positions.length - 1];</span>
 404 |     | <span class='neutral'>        }</span>
 405 |     | <span class='neutral'>        else {</span>
 406 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 407 |     | <span class='unexecuted'>            positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);</span>
 408 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 409 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 410 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 411 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 412 |     | <span class='neutral'>        }</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='unexecuted'>        (, lowerTick) = pool.ticks(lower);</span>
 415 |     | <span class='unexecuted'>        (, upperTick) = pool.ticks(upper);</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 418 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='unexecuted'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 421 |     | <span class='unexecuted'>        uint160 price0 = pool0.price;</span>
 422 |     | <span class='unexecuted'>        uint160 price1 = pool1.price;</span>
 423 |     | <span class='neutral'>        </span>
 424 |     | <span class='neutral'>        // POST CONDITIONS</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>        // Ensure prices never cross</span>
 427 |     | <span class='unexecuted'>        emit Prices(price0, price1);</span>
 428 |     | <span class='unexecuted'>        assert(price0 &gt;= price1);</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 431 |     | <span class='unexecuted'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 432 |     | <span class='unexecuted'>        assert((poolValues.liquidityGlobalAfter &lt;= liquidityGlobalBefore));</span>
 433 |     | <span class='neutral'>    }</span>
 434 |     | <span class='neutral'></span>
 435 | *   | <span class='executed'>    function claim(int24 claimAt, uint256 positionIndex) public {</span>
 436 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 437 | *   | <span class='executed'>        positionIndex = positionIndex % positions.length;</span>
 438 |     | <span class='unexecuted'>        Position memory pos = positions[positionIndex];</span>
 439 |     | <span class='unexecuted'>        claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));</span>
 440 |     | <span class='unexecuted'>        require(claimAt % tickSpacing == 0);</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='unexecuted'>        PoolValues memory poolValues;</span>
 443 |     | <span class='unexecuted'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,,) = pool.globalState();</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitParams memory params;</span>
 446 |     | <span class='unexecuted'>        params.to = pos.owner;</span>
 447 |     | <span class='unexecuted'>        params.burnPercent = 0;</span>
 448 |     | <span class='unexecuted'>        params.positionId = pos.positionId;</span>
 449 |     | <span class='unexecuted'>        params.claim = claimAt;</span>
 450 |     | <span class='unexecuted'>        params.zeroForOne = pos.zeroForOne;</span>
 451 |     | <span class='neutral'>        </span>
 452 |     | <span class='unexecuted'>        emit PositionTicks(pos.lower, pos.upper);</span>
 453 |     | <span class='unexecuted'>        (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);</span>
 454 |     | <span class='unexecuted'>        emit BurnTicks(lower, upper, positionExists);</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>        // ACTION</span>
 457 |     | <span class='unexecuted'>        pool.burnLimit(params);</span>
 458 |     | <span class='unexecuted'>        if (!positionExists) {</span>
 459 |     | <span class='unexecuted'>            positions[positionIndex] = positions[positions.length - 1];</span>
 460 |     | <span class='unexecuted'>            delete positions[positions.length - 1];</span>
 461 |     | <span class='neutral'>        }</span>
 462 |     | <span class='neutral'>        else {</span>
 463 |     | <span class='neutral'>            // Update position data in array if not fully burned</span>
 464 |     | <span class='unexecuted'>            positions[positionIndex] = Position(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);</span>
 465 |     | <span class='neutral'>            // Ensure positions ticks arent crossed</span>
 466 |     | <span class='unexecuted'>            assert(lower &lt; upper);</span>
 467 |     | <span class='neutral'>            // Ensure minted ticks on proper tick spacing</span>
 468 |     | <span class='unexecuted'>            assert((lower % tickSpacing == 0) &amp;&amp; (upper % tickSpacing == 0));</span>
 469 |     | <span class='neutral'>        }</span>
 470 |     | <span class='neutral'></span>
 471 |     | <span class='neutral'>        // POST CONDITIONS</span>
 472 |     | <span class='unexecuted'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 473 |     | <span class='unexecuted'>        uint160 price0 = pool0.price;</span>
 474 |     | <span class='unexecuted'>        uint160 price1 = pool1.price;</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>        // Ensure prices never cross</span>
 477 |     | <span class='unexecuted'>        emit Prices(price0, price1);</span>
 478 |     | <span class='unexecuted'>        assert(price0 &gt;= price1);</span>
 479 |     | <span class='neutral'>    }</span>
 480 |     | <span class='neutral'></span>
 481 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
 482 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 483 | *   | <span class='executed'>        mintAndApprove();</span>
 484 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 485 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,,) = pool.globalState();</span>
 486 |     | <span class='neutral'></span>
 487 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 488 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 489 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 490 |     | <span class='neutral'></span>
 491 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 492 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 493 |     | <span class='neutral'></span>
 494 |     | <span class='neutral'>        // ACTION </span>
 495 | *   | <span class='executed'>        mintVariable(amount, zeroForOne, lower, upper, mintPercent);</span>
 496 |     | <span class='unexecuted'>        emit PassedMint();</span>
 497 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 498 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>        // POST CONDITIONS</span>
 501 |     | <span class='unexecuted'>        (, lowerTick) = pool.ticks(lower);</span>
 502 |     | <span class='unexecuted'>        (, upperTick) = pool.ticks(upper);</span>
 503 |     | <span class='neutral'></span>
 504 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 505 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 506 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 507 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 508 |     | <span class='neutral'>        </span>
 509 |     | <span class='unexecuted'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 510 |     | <span class='unexecuted'>        uint160 price0After = pool0.price;</span>
 511 |     | <span class='unexecuted'>        uint160 price1After = pool1.price;</span>
 512 |     | <span class='neutral'></span>
 513 |     | <span class='neutral'>        // POST CONDITIONS</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='neutral'>        // Ensure prices never cross</span>
 516 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 517 |     | <span class='unexecuted'>        assert(price0After &gt;= price1After);</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 520 |     | <span class='unexecuted'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 521 |     | <span class='unexecuted'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 522 |     | <span class='neutral'>    }</span>
 523 |     | <span class='neutral'></span>
 524 | *   | <span class='executed'>    function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {</span>
 525 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 526 | *   | <span class='executed'>        mintAndApprove();</span>
 527 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 528 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,,) = pool.globalState();</span>
 529 |     | <span class='neutral'></span>
 530 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 531 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 532 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 533 |     | <span class='neutral'></span>
 534 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 535 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 536 |     | <span class='neutral'></span>
 537 |     | <span class='neutral'>        // ACTION </span>
 538 | *   | <span class='executed'>        mint(amount, zeroForOne, lower, upper);</span>
 539 |     | <span class='unexecuted'>        emit PassedMint();</span>
 540 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 541 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='unexecuted'>        (, lowerTick) = pool.ticks(lower);</span>
 544 |     | <span class='unexecuted'>        (, upperTick) = pool.ticks(upper);</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 547 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 548 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 549 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='neutral'></span>
 552 |     | <span class='unexecuted'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 553 |     | <span class='unexecuted'>        uint160 price0After = pool0.price;</span>
 554 |     | <span class='unexecuted'>        uint160 price1After = pool1.price;</span>
 555 |     | <span class='neutral'>        </span>
 556 |     | <span class='neutral'>        // POST CONDITIONS</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='neutral'>        // Ensure prices never cross</span>
 559 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 560 |     | <span class='unexecuted'>        assert(price0After &gt;= price1After);</span>
 561 |     | <span class='neutral'></span>
 562 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 563 |     | <span class='unexecuted'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 564 |     | <span class='unexecuted'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 565 |     | <span class='neutral'>    }</span>
 566 |     | <span class='neutral'></span>
 567 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {</span>
 568 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 569 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 570 | *   | <span class='executed'>        mintAndApprove();</span>
 571 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 572 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,,) = pool.globalState();</span>
 573 |     | <span class='neutral'></span>
 574 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 575 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 576 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 577 |     | <span class='neutral'></span>
 578 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 579 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 580 |     | <span class='neutral'></span>
 581 |     | <span class='neutral'>        // ACTION </span>
 582 | *   | <span class='executed'>        mint(amount, zeroForOne, lower, upper);</span>
 583 |     | <span class='unexecuted'>        emit PassedMint();</span>
 584 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, percent);</span>
 585 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 586 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 587 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='unexecuted'>        (, lowerTick) = pool.ticks(lower);</span>
 590 |     | <span class='unexecuted'>        (, upperTick) = pool.ticks(upper);</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 593 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 594 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 595 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 596 |     | <span class='neutral'></span>
 597 |     | <span class='unexecuted'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 598 |     | <span class='unexecuted'>        uint160 price0After = pool0.price;</span>
 599 |     | <span class='unexecuted'>        uint160 price1After = pool1.price;</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='neutral'>        // POST CONDITIONS</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>        // Ensure prices never cross</span>
 604 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 605 |     | <span class='unexecuted'>        assert(price0After &gt;= price1After);</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 608 |     | <span class='unexecuted'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 609 |     | <span class='unexecuted'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 610 |     | <span class='neutral'>    }</span>
 611 |     | <span class='neutral'></span>
 612 | *   | <span class='executed'>    function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent, uint96 mintPercent) public tickPreconditions(lower, upper) {</span>
 613 |     | <span class='neutral'>        // PRE CONDITIONS</span>
 614 | *   | <span class='executed'>        percent = 1 + (percent % (1e38 - 1));</span>
 615 | *   | <span class='executed'>        mintAndApprove();</span>
 616 | *   | <span class='executed'>        PoolValues memory poolValues;</span>
 617 | *   | <span class='executed'>        (,PoolsharkStructs.LimitPoolState memory pool0, PoolsharkStructs.LimitPoolState memory pool1, uint128 liquidityGlobalBefore,,,) = pool.globalState();</span>
 618 |     | <span class='neutral'></span>
 619 | *   | <span class='executed'>        LiquidityDeltaValues memory values;</span>
 620 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory lowerTick) = pool.ticks(lower);</span>
 621 | *   | <span class='executed'>        (, PoolsharkStructs.LimitTick memory upperTick) = pool.ticks(upper);</span>
 622 |     | <span class='neutral'></span>
 623 | *   | <span class='executed'>        poolValues.liquidityAbsoluteLowerBefore = lowerTick.liquidityAbsolute;</span>
 624 | *   | <span class='executed'>        poolValues.liquidityAbsoluteUpperBefore = upperTick.liquidityAbsolute;</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='neutral'>        // ACTION </span>
 627 | *   | <span class='executed'>        mintVariable(amount, zeroForOne, lower, upper, mintPercent);</span>
 628 |     | <span class='unexecuted'>        emit PassedMint();</span>
 629 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, percent);</span>
 630 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 631 |     | <span class='unexecuted'>        burn(zeroForOne ? lower : upper, positions.length - 1, 1e38);</span>
 632 |     | <span class='unexecuted'>        emit PassedBurn();</span>
 633 |     | <span class='neutral'></span>
 634 |     | <span class='unexecuted'>        (, lowerTick) = pool.ticks(lower);</span>
 635 |     | <span class='unexecuted'>        (, upperTick) = pool.ticks(upper);</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='unexecuted'>        values.liquidityDeltaLowerAfter = lowerTick.liquidityDelta;</span>
 638 |     | <span class='unexecuted'>        values.liquidityDeltaUpperAfter = upperTick.liquidityDelta;</span>
 639 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteLowerAfter = lowerTick.liquidityAbsolute;</span>
 640 |     | <span class='unexecuted'>        poolValues.liquidityAbsoluteUpperAfter = upperTick.liquidityAbsolute;</span>
 641 |     | <span class='neutral'></span>
 642 |     | <span class='unexecuted'>        (,pool0, pool1, poolValues.liquidityGlobalAfter,,,) = pool.globalState();</span>
 643 |     | <span class='unexecuted'>        uint160 price0After = pool0.price;</span>
 644 |     | <span class='unexecuted'>        uint160 price1After = pool1.price;</span>
 645 |     | <span class='neutral'>        </span>
 646 |     | <span class='neutral'>        // POST CONDITIONS</span>
 647 |     | <span class='neutral'></span>
 648 |     | <span class='neutral'>        // Ensure prices never cross</span>
 649 |     | <span class='unexecuted'>        emit Prices(price0After, price1After);</span>
 650 |     | <span class='unexecuted'>        assert(price0After &gt;= price1After);</span>
 651 |     | <span class='neutral'></span>
 652 |     | <span class='neutral'>        // Ensure liquidityGlobal is decremented after burn</span>
 653 |     | <span class='unexecuted'>        emit LiquidityGlobal(liquidityGlobalBefore, poolValues.liquidityGlobalAfter);</span>
 654 |     | <span class='unexecuted'>        assert(poolValues.liquidityGlobalAfter == liquidityGlobalBefore);</span>
 655 |     | <span class='neutral'>    }</span>
 656 |     | <span class='neutral'></span>
 657 | *   | <span class='executed'>    function poolsharkSwapCallback(</span>
 658 |     | <span class='neutral'>        int256 amount0Delta,</span>
 659 |     | <span class='neutral'>        int256 amount1Delta,</span>
 660 |     | <span class='neutral'>        bytes calldata data</span>
 661 | *   | <span class='executed'>    ) external {</span>
 662 | *   | <span class='executed'>        address token0 = LimitPool(pool).token0();</span>
 663 | *   | <span class='executed'>        address token1 = LimitPool(pool).token1();</span>
 664 | *   | <span class='executed'>        if (amount0Delta &lt; 0) {</span>
 665 | *   | <span class='executed'>            SafeTransfers.transferInto(token0, address(pool), uint256(-amount0Delta));</span>
 666 |     | <span class='neutral'>        } else {</span>
 667 | *   | <span class='executed'>            SafeTransfers.transferInto(token1, address(pool), uint256(-amount1Delta));</span>
 668 |     | <span class='neutral'>        }</span>
 669 |     | <span class='neutral'>    }</span>
 670 |     | <span class='neutral'></span>
 671 | *   | <span class='executed'>    function mintAndApprove() internal {</span>
 672 | *   | <span class='executed'>        tokenIn.mint(msg.sender, 100000000000 ether);</span>
 673 | *   | <span class='executed'>        tokenOut.mint(msg.sender, 100000000000 ether);</span>
 674 | *   | <span class='executed'>        tokenIn.mint(address(this), 100000000000 ether);</span>
 675 | *   | <span class='executed'>        tokenOut.mint(address(this), 100000000000 ether);</span>
 676 | *   | <span class='executed'>        tokenIn.approve(address(pool), type(uint256).max);</span>
 677 | *   | <span class='executed'>        tokenOut.approve(address(pool), type(uint256).max);</span>
 678 |     | <span class='neutral'>    }</span>
 679 |     | <span class='neutral'></span>
 680 |     | <span class='unexecuted'>    function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {</span>
 681 |     | <span class='unexecuted'>        return uint128(low + (val % (high-low +1))); </span>
 682 |     | <span class='neutral'>    }</span>
 683 |     | <span class='neutral'></span>
 684 |     | <span class='neutral'>    function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {</span>
 685 |     | <span class='neutral'>        // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation</span>
 686 |     | <span class='neutral'>        amount = amount + 1e5 + 1;</span>
 687 |     | <span class='neutral'>        LimitPoolStructs.Immutables memory immutables = pool.immutables();</span>
 688 |     | <span class='neutral'>        uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);</span>
 689 |     | <span class='neutral'>        uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);</span>
 690 |     | <span class='neutral'></span>
 691 |     | <span class='neutral'>        uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 692 |     | <span class='neutral'>            priceLower,</span>
 693 |     | <span class='neutral'>            priceUpper,</span>
 694 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 695 |     | <span class='neutral'>            zeroForOne ? 0 : uint256(amount),</span>
 696 |     | <span class='neutral'>            zeroForOne ? uint256(amount) : 0</span>
 697 |     | <span class='neutral'>        );</span>
 698 |     | <span class='neutral'></span>
 699 |     | <span class='neutral'>        (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(</span>
 700 |     | <span class='neutral'>            priceLower,</span>
 701 |     | <span class='neutral'>            priceUpper,</span>
 702 |     | <span class='neutral'>            zeroForOne ? priceLower : priceUpper,</span>
 703 |     | <span class='neutral'>            liquidityMinted,</span>
 704 |     | <span class='neutral'>            true</span>
 705 |     | <span class='neutral'>        );</span>
 706 |     | <span class='neutral'></span>
 707 |     | <span class='neutral'>        if(zeroForOne) {</span>
 708 |     | <span class='neutral'>            emit LiquidityMinted(amount, token0Amount, zeroForOne);</span>
 709 |     | <span class='neutral'>            assert(token0Amount &lt;= amount);</span>
 710 |     | <span class='neutral'>            </span>
 711 |     | <span class='neutral'>        }</span>
 712 |     | <span class='neutral'>        else {</span>
 713 |     | <span class='neutral'>            emit LiquidityMinted(amount, token1Amount, zeroForOne);</span>
 714 |     | <span class='neutral'>            assert(token1Amount &lt;= amount);</span>
 715 |     | <span class='neutral'>        }</span>
 716 |     | <span class='neutral'>    }</span>
 717 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/LimitPool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/range/IRangePool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./interfaces/IPool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolStorage.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./base/storage/LimitPoolImmutables.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/structs/LimitPoolFactoryStructs.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./utils/LimitPoolErrors.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/pool/SwapCall.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/pool/QuoteCall.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./libraries/pool/FeesCall.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./libraries/pool/SampleCall.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./libraries/range/pool/MintRangeCall.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./libraries/range/pool/BurnRangeCall.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./libraries/range/pool/SnapshotRangeCall.sol&#39;;</span>
  19 |     | <span class='neutral'>import &#39;./libraries/limit/pool/MintLimitCall.sol&#39;;</span>
  20 |     | <span class='neutral'>import &#39;./test/echidna/EchidnaMintLimitCall.sol&#39;;</span>
  21 |     | <span class='neutral'>import &#39;./libraries/limit/pool/BurnLimitCall.sol&#39;;</span>
  22 |     | <span class='neutral'>import &#39;./test/echidna/EchidnaBurnLimitCall.sol&#39;;</span>
  23 |     | <span class='neutral'>import &#39;./libraries/limit/pool/SnapshotLimitCall.sol&#39;;</span>
  24 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  25 |     | <span class='neutral'>import &#39;./libraries/solady/LibClone.sol&#39;;</span>
  26 |     | <span class='neutral'>import &#39;./external/openzeppelin/security/ReentrancyGuard.sol&#39;;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>/// @notice Poolshark Limit Pool Implementation</span>
  30 | *   | <span class='executed'>contract LimitPool is</span>
  31 |     | <span class='neutral'>    ILimitPool,</span>
  32 |     | <span class='neutral'>    IRangePool,</span>
  33 |     | <span class='neutral'>    LimitPoolStorage,</span>
  34 |     | <span class='neutral'>    LimitPoolImmutables,</span>
  35 |     | <span class='neutral'>    ReentrancyGuard</span>
  36 |     | <span class='neutral'>{</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    event SimulateMint(bytes b);</span>
  39 |     | <span class='neutral'>    event SimulateMint(bytes4 b);</span>
  40 |     | <span class='neutral'>    event SimulateMint(bool b);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    modifier ownerOnly() {</span>
  43 |     | <span class='unexecuted'>        _onlyOwner();</span>
  44 |     | <span class='unexecuted'>        _;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    modifier factoryOnly() {</span>
  48 |     | <span class='unexecuted'>        _onlyFactory();</span>
  49 |     | <span class='neutral'>        _;</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    modifier canoncialOnly() {</span>
  53 |     | <span class='unexecuted'>        _onlyCanoncialClones();</span>
  54 |     | <span class='neutral'>        _;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    address public immutable original;</span>
  58 |     | <span class='unexecuted'>    address public immutable factory;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>    constructor(</span>
  61 |     | <span class='neutral'>        address factory_</span>
  62 |     | <span class='neutral'>    ) {</span>
  63 |     | <span class='unexecuted'>        original = address(this);</span>
  64 |     | <span class='unexecuted'>        factory = factory_;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>    function initialize(</span>
  68 |     | <span class='neutral'>        uint160 startPrice</span>
  69 |     | <span class='neutral'>    ) external override </span>
  70 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
  71 |     | <span class='neutral'>        factoryOnly</span>
  72 |     | <span class='neutral'>        canoncialOnly</span>
  73 |     | <span class='neutral'>    {</span>
  74 |     | <span class='neutral'>        // initialize state</span>
  75 |     | <span class='unexecuted'>        globalState = Ticks.initialize(</span>
  76 |     | <span class='unexecuted'>            rangeTickMap,</span>
  77 |     | <span class='unexecuted'>            limitTickMap,</span>
  78 |     | <span class='unexecuted'>            samples,</span>
  79 |     | <span class='unexecuted'>            globalState,</span>
  80 |     | <span class='unexecuted'>            immutables(),</span>
  81 |     | <span class='unexecuted'>            startPrice</span>
  82 |     | <span class='neutral'>        );</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>    function mintRange(</span>
  86 |     | <span class='neutral'>        MintRangeParams memory params</span>
  87 |     | <span class='neutral'>    ) external override</span>
  88 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
  89 |     | <span class='neutral'>        canoncialOnly</span>
  90 |     | <span class='unexecuted'>    {</span>
  91 |     | <span class='unexecuted'>        MintRangeCache memory cache;</span>
  92 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
  93 |     | <span class='unexecuted'>        MintRangeCall.perform(</span>
  94 |     | <span class='unexecuted'>            positions,</span>
  95 |     | <span class='unexecuted'>            ticks,</span>
  96 |     | <span class='unexecuted'>            rangeTickMap,</span>
  97 |     | <span class='unexecuted'>            samples,</span>
  98 |     | <span class='unexecuted'>            globalState,</span>
  99 |     | <span class='unexecuted'>            cache,</span>
 100 |     | <span class='unexecuted'>            params</span>
 101 |     | <span class='neutral'>        );</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function burnRange(</span>
 105 |     | <span class='neutral'>        BurnRangeParams memory params</span>
 106 |     | <span class='neutral'>    ) external override</span>
 107 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 108 |     | <span class='neutral'>        canoncialOnly</span>
 109 |     | <span class='unexecuted'>    {</span>
 110 |     | <span class='unexecuted'>        BurnRangeCache memory cache;</span>
 111 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 112 |     | <span class='unexecuted'>        BurnRangeCall.perform(</span>
 113 |     | <span class='unexecuted'>            positions,</span>
 114 |     | <span class='unexecuted'>            ticks,</span>
 115 |     | <span class='unexecuted'>            rangeTickMap,</span>
 116 |     | <span class='unexecuted'>            samples,</span>
 117 |     | <span class='unexecuted'>            globalState,</span>
 118 |     | <span class='unexecuted'>            cache,</span>
 119 |     | <span class='unexecuted'>            params</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    //limitSwap</span>
 124 |     | <span class='unexecuted'>    function mintLimit(</span>
 125 |     | <span class='neutral'>        MintLimitParams memory params</span>
 126 |     | <span class='neutral'>    ) external override</span>
 127 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 128 |     | <span class='neutral'>        canoncialOnly</span>
 129 |     | <span class='unexecuted'>    {</span>
 130 |     | <span class='unexecuted'>        MintLimitCache memory cache;</span>
 131 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 132 |     | <span class='unexecuted'>        MintLimitCall.perform(</span>
 133 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 134 |     | <span class='unexecuted'>            ticks,</span>
 135 |     | <span class='unexecuted'>            samples,</span>
 136 |     | <span class='unexecuted'>            rangeTickMap,</span>
 137 |     | <span class='unexecuted'>            limitTickMap,</span>
 138 |     | <span class='unexecuted'>            globalState,</span>
 139 |     | <span class='unexecuted'>            params,</span>
 140 |     | <span class='unexecuted'>            cache</span>
 141 |     | <span class='neutral'>        );</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function burnLimit(</span>
 145 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 146 |     | <span class='neutral'>    ) external override</span>
 147 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 148 |     | <span class='neutral'>        canoncialOnly</span>
 149 |     | <span class='unexecuted'>    {</span>
 150 |     | <span class='unexecuted'>        BurnLimitCache memory cache;</span>
 151 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 152 |     | <span class='unexecuted'>        BurnLimitCall.perform(</span>
 153 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 154 |     | <span class='unexecuted'>            ticks,</span>
 155 |     | <span class='unexecuted'>            limitTickMap,</span>
 156 |     | <span class='unexecuted'>            globalState,</span>
 157 |     | <span class='unexecuted'>            params, </span>
 158 |     | <span class='unexecuted'>            cache</span>
 159 |     | <span class='neutral'>        );</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function swap(</span>
 163 |     | <span class='neutral'>        SwapParams memory params</span>
 164 |     | <span class='neutral'>    ) external override</span>
 165 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 166 |     | <span class='neutral'>        canoncialOnly</span>
 167 |     | <span class='neutral'>    returns (</span>
 168 |     | <span class='unexecuted'>        int256,</span>
 169 |     | <span class='unexecuted'>        int256</span>
 170 |     | <span class='neutral'>    ) </span>
 171 |     | <span class='neutral'>    {</span>
 172 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 173 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 174 |     | <span class='unexecuted'>        return SwapCall.perform(</span>
 175 |     | <span class='unexecuted'>            ticks,</span>
 176 |     | <span class='unexecuted'>            samples,</span>
 177 |     | <span class='unexecuted'>            rangeTickMap,</span>
 178 |     | <span class='unexecuted'>            limitTickMap,</span>
 179 |     | <span class='unexecuted'>            globalState,</span>
 180 |     | <span class='unexecuted'>            params,</span>
 181 |     | <span class='unexecuted'>            cache</span>
 182 |     | <span class='neutral'>        );</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='unexecuted'>    function increaseSampleLength(</span>
 186 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
 187 |     | <span class='neutral'>    ) external override</span>
 188 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 189 |     | <span class='neutral'>        canoncialOnly </span>
 190 |     | <span class='neutral'>    {</span>
 191 |     | <span class='unexecuted'>        Samples.expand(</span>
 192 |     | <span class='unexecuted'>            samples,</span>
 193 |     | <span class='unexecuted'>            globalState.pool,</span>
 194 |     | <span class='unexecuted'>            sampleLengthNext</span>
 195 |     | <span class='neutral'>        );</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function fees(</span>
 199 |     | <span class='neutral'>        FeesParams memory params</span>
 200 |     | <span class='neutral'>    ) external override</span>
 201 |     | <span class='neutral'>        ownerOnly</span>
 202 |     | <span class='unexecuted'>        nonReentrant(globalState)</span>
 203 |     | <span class='neutral'>        canoncialOnly </span>
 204 |     | <span class='neutral'>    returns (</span>
 205 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 206 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 207 |     | <span class='neutral'>    ) {</span>
 208 |     | <span class='unexecuted'>        return FeesCall.perform(</span>
 209 |     | <span class='unexecuted'>            globalState,</span>
 210 |     | <span class='unexecuted'>            params,</span>
 211 |     | <span class='unexecuted'>            immutables()</span>
 212 |     | <span class='neutral'>        );</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function quote(</span>
 216 |     | <span class='neutral'>        QuoteParams memory params</span>
 217 |     | <span class='neutral'>    ) external override</span>
 218 |     | <span class='neutral'>    returns (</span>
 219 |     | <span class='unexecuted'>        uint256,</span>
 220 |     | <span class='unexecuted'>        uint256,</span>
 221 |     | <span class='unexecuted'>        uint160</span>
 222 |     | <span class='neutral'>    ) {</span>
 223 |     | <span class='unexecuted'>        SwapCache memory cache;</span>
 224 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 225 |     | <span class='unexecuted'>        return QuoteCall.perform(</span>
 226 |     | <span class='unexecuted'>            ticks,</span>
 227 |     | <span class='unexecuted'>            rangeTickMap,</span>
 228 |     | <span class='unexecuted'>            limitTickMap,</span>
 229 |     | <span class='unexecuted'>            globalState,</span>
 230 |     | <span class='unexecuted'>            params,</span>
 231 |     | <span class='unexecuted'>            cache</span>
 232 |     | <span class='neutral'>        );</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>    function sample(</span>
 236 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 237 |     | <span class='neutral'>    ) external view</span>
 238 |     | <span class='neutral'>    returns(</span>
 239 |     | <span class='unexecuted'>        int56[]   memory tickSecondsAccum,</span>
 240 |     | <span class='unexecuted'>        uint160[] memory secondsPerLiquidityAccum,</span>
 241 |     | <span class='unexecuted'>        uint160 averagePrice,</span>
 242 |     | <span class='unexecuted'>        uint128 averageLiquidity,</span>
 243 |     | <span class='unexecuted'>        int24 averageTick</span>
 244 |     | <span class='neutral'>    ) </span>
 245 |     | <span class='neutral'>    {</span>
 246 |     | <span class='unexecuted'>        return SampleCall.perform(</span>
 247 |     | <span class='unexecuted'>            globalState,</span>
 248 |     | <span class='unexecuted'>            immutables(),</span>
 249 |     | <span class='unexecuted'>            secondsAgo</span>
 250 |     | <span class='neutral'>        );</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='neutral'></span>
 253 |     | <span class='unexecuted'>    function snapshotRange(</span>
 254 |     | <span class='neutral'>        uint32 positionId </span>
 255 |     | <span class='neutral'>    ) external view override returns (</span>
 256 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 257 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum,</span>
 258 |     | <span class='unexecuted'>        uint128 feesOwed0,</span>
 259 |     | <span class='unexecuted'>        uint128 feesOwed1</span>
 260 |     | <span class='neutral'>    ) {</span>
 261 |     | <span class='unexecuted'>        return SnapshotRangeCall.perform(</span>
 262 |     | <span class='unexecuted'>            positions,</span>
 263 |     | <span class='unexecuted'>            ticks,</span>
 264 |     | <span class='unexecuted'>            globalState,</span>
 265 |     | <span class='unexecuted'>            immutables(),</span>
 266 |     | <span class='unexecuted'>            positionId</span>
 267 |     | <span class='neutral'>        );</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>    function snapshotLimit(</span>
 271 |     | <span class='neutral'>        SnapshotLimitParams memory params</span>
 272 |     | <span class='neutral'>    ) external view override returns(</span>
 273 |     | <span class='unexecuted'>        uint128,</span>
 274 |     | <span class='unexecuted'>        uint128</span>
 275 |     | <span class='neutral'>    ) {</span>
 276 |     | <span class='unexecuted'>        return SnapshotLimitCall.perform(</span>
 277 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 278 |     | <span class='unexecuted'>            ticks,</span>
 279 |     | <span class='unexecuted'>            limitTickMap,</span>
 280 |     | <span class='unexecuted'>            globalState,</span>
 281 |     | <span class='unexecuted'>            immutables(),</span>
 282 |     | <span class='unexecuted'>            params</span>
 283 |     | <span class='neutral'>        );</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>    function immutables() public view returns (</span>
 287 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables memory</span>
 288 |     | <span class='neutral'>    ) {</span>
 289 |     | <span class='unexecuted'>        return Immutables(</span>
 290 |     | <span class='unexecuted'>            owner(),</span>
 291 |     | <span class='unexecuted'>            original,</span>
 292 |     | <span class='unexecuted'>            factory,</span>
 293 |     | <span class='unexecuted'>            PriceBounds(minPrice(), maxPrice()),</span>
 294 |     | <span class='unexecuted'>            token0(),</span>
 295 |     | <span class='unexecuted'>            token1(),</span>
 296 |     | <span class='unexecuted'>            poolToken(),</span>
 297 |     | <span class='unexecuted'>            genesisTime(),</span>
 298 |     | <span class='unexecuted'>            tickSpacing(),</span>
 299 |     | <span class='unexecuted'>            swapFee()</span>
 300 |     | <span class='neutral'>        );</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='neutral'></span>
 303 |     | <span class='unexecuted'>    function getResizedTicksForMint(</span>
 304 |     | <span class='neutral'>        MintLimitParams memory params</span>
 305 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionCreated){</span>
 306 |     | <span class='unexecuted'>        MintLimitCache memory cache;</span>
 307 |     | <span class='neutral'>        {</span>
 308 |     | <span class='unexecuted'>            cache.state = globalState;</span>
 309 |     | <span class='unexecuted'>            cache.constants = immutables();</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='unexecuted'>        try EchidnaMintLimitCall.getResizedTicks(</span>
 313 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 314 |     | <span class='unexecuted'>            ticks,</span>
 315 |     | <span class='unexecuted'>            samples,</span>
 316 |     | <span class='unexecuted'>            rangeTickMap,</span>
 317 |     | <span class='unexecuted'>            limitTickMap,</span>
 318 |     | <span class='unexecuted'>            globalState,</span>
 319 |     | <span class='unexecuted'>            params,</span>
 320 |     | <span class='unexecuted'>            cache</span>
 321 |     | <span class='neutral'>        ) {</span>
 322 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 323 |     | <span class='unexecuted'>            emit SimulateMint(data);</span>
 324 |     | <span class='unexecuted'>            bytes4 sig;</span>
 325 |     | <span class='neutral'>            assembly {</span>
 326 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='neutral'>            </span>
 329 |     | <span class='neutral'>            // SimulateMint error</span>
 330 |     | <span class='unexecuted'>            if (sig == hex&quot;5cc1f67b&quot;) {</span>
 331 |     | <span class='unexecuted'>                (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 332 |     | <span class='neutral'>            }</span>
 333 |     | <span class='neutral'>            else {</span>
 334 |     | <span class='unexecuted'>                lower = -8388608;</span>
 335 |     | <span class='unexecuted'>                upper = -8388608;</span>
 336 |     | <span class='unexecuted'>                positionCreated = false;</span>
 337 |     | <span class='neutral'>            }</span>
 338 |     | <span class='neutral'>        }</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='unexecuted'>    function getResizedTicksForBurn(</span>
 342 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 343 |     | <span class='unexecuted'>    ) external returns (int24 lower, int24 upper, bool positionExists){</span>
 344 |     | <span class='unexecuted'>        if (params.to == address(0)) revert CollectToZeroAddress();</span>
 345 |     | <span class='unexecuted'>        BurnLimitCache memory cache;</span>
 346 |     | <span class='unexecuted'>        cache.constants = immutables();</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='unexecuted'>        try EchidnaBurnLimitCall.getResizedTicks(</span>
 349 |     | <span class='unexecuted'>            params.zeroForOne ? positions0 : positions1,</span>
 350 |     | <span class='unexecuted'>            ticks,</span>
 351 |     | <span class='unexecuted'>            limitTickMap,</span>
 352 |     | <span class='unexecuted'>            globalState,</span>
 353 |     | <span class='unexecuted'>            params, </span>
 354 |     | <span class='unexecuted'>            cache</span>
 355 |     | <span class='neutral'>        ) {</span>
 356 |     | <span class='unexecuted'>        } catch (bytes memory data) {</span>
 357 |     | <span class='unexecuted'>            bytes4 sig;</span>
 358 |     | <span class='neutral'>            assembly {</span>
 359 |     | <span class='unexecuted'>                sig := mload(add(data, 0x20))</span>
 360 |     | <span class='neutral'>            }</span>
 361 |     | <span class='neutral'>            // SimulateBurn error</span>
 362 |     | <span class='unexecuted'>            if (sig == hex&quot;97dd6e0a&quot;) {</span>
 363 |     | <span class='unexecuted'>                (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));</span>
 364 |     | <span class='neutral'>            }</span>
 365 |     | <span class='neutral'>             else {</span>
 366 |     | <span class='unexecuted'>                lower = -8388608;</span>
 367 |     | <span class='unexecuted'>                upper = -8388608;</span>
 368 |     | <span class='unexecuted'>                positionExists = false;</span>
 369 |     | <span class='neutral'>            }</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>    function priceBounds(</span>
 374 |     | <span class='neutral'>        int16 tickSpacing</span>
 375 |     | <span class='unexecuted'>    ) external pure returns (uint160, uint160) {</span>
 376 |     | <span class='unexecuted'>        return ConstantProduct.priceBounds(tickSpacing);</span>
 377 |     | <span class='neutral'>    }</span>
 378 |     | <span class='neutral'></span>
 379 |     | <span class='unexecuted'>    function _onlyOwner() private view {</span>
 380 |     | <span class='unexecuted'>        if (msg.sender != owner()) revert OwnerOnly();</span>
 381 |     | <span class='neutral'>    }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>    function _onlyCanoncialClones() private view {</span>
 384 |     | <span class='neutral'>        // compute pool key</span>
 385 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(original, token0(), token1(), swapFee()));</span>
 386 |     | <span class='neutral'>        </span>
 387 |     | <span class='neutral'>        // compute canonical pool address</span>
 388 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 389 |     | <span class='unexecuted'>            original,</span>
 390 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 391 |     | <span class='unexecuted'>                owner(),</span>
 392 |     | <span class='unexecuted'>                token0(),</span>
 393 |     | <span class='unexecuted'>                token1(),</span>
 394 |     | <span class='unexecuted'>                poolToken(),</span>
 395 |     | <span class='unexecuted'>                minPrice(),</span>
 396 |     | <span class='unexecuted'>                maxPrice(),</span>
 397 |     | <span class='unexecuted'>                genesisTime(),</span>
 398 |     | <span class='unexecuted'>                tickSpacing(),</span>
 399 |     | <span class='unexecuted'>                swapFee()</span>
 400 |     | <span class='neutral'>            ),</span>
 401 |     | <span class='unexecuted'>            key,</span>
 402 |     | <span class='unexecuted'>            factory</span>
 403 |     | <span class='neutral'>        );</span>
 404 |     | <span class='neutral'>        // only allow delegateCall from canonical clones</span>
 405 |     | <span class='unexecuted'>        if (address(this) != predictedAddress) require(false, &#39;NoDelegateCall()&#39;);</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='unexecuted'>    function _onlyFactory() private view {</span>
 409 |     | <span class='unexecuted'>        if (msg.sender != factory) revert FactoryOnly();</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'>}</span>
 412 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/LimitPoolFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LimitPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./base/events/LimitPoolFactoryEvents.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./utils/LimitPoolErrors.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./libraries/solady/LibClone.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/math/ConstantProduct.sol&#39;;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>contract LimitPoolFactory is </span>
  13 |     | <span class='neutral'>    ILimitPoolFactory,</span>
  14 |     | <span class='neutral'>    PoolsharkStructs,</span>
  15 |     | <span class='neutral'>    LimitPoolFactoryEvents,</span>
  16 |     | <span class='neutral'>    LimitPoolFactoryErrors</span>
  17 |     | <span class='neutral'>{</span>
  18 |     | <span class='neutral'>    using LibClone for address;</span>
  19 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    address immutable public owner;</span>
  22 |     | <span class='unexecuted'>    address immutable public original;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    constructor(</span>
  25 |     | <span class='neutral'>        address owner_</span>
  26 |     | <span class='neutral'>    ) {</span>
  27 |     | <span class='unexecuted'>        owner = owner_;</span>
  28 |     | <span class='unexecuted'>        original = address(this);</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function createLimitPool(</span>
  32 |     | <span class='neutral'>        bytes32 poolType,</span>
  33 |     | <span class='neutral'>        address tokenIn,</span>
  34 |     | <span class='neutral'>        address tokenOut,</span>
  35 |     | <span class='neutral'>        uint16  swapFee,</span>
  36 |     | <span class='neutral'>        uint160 startPrice</span>
  37 |     | <span class='neutral'>    ) external override returns (</span>
  38 |     | <span class='unexecuted'>        address pool,</span>
  39 |     | <span class='unexecuted'>        address poolToken</span>
  40 |     | <span class='neutral'>    ) {</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // validate token pair</span>
  43 |     | <span class='unexecuted'>        if (tokenIn == tokenOut || tokenIn == address(0) || tokenOut == address(0)) {</span>
  44 |     | <span class='unexecuted'>            revert InvalidTokenAddress();</span>
  45 |     | <span class='neutral'>        }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // sort tokens by address</span>
  48 |     | <span class='unexecuted'>        Immutables memory constants;</span>
  49 |     | <span class='unexecuted'>        (constants.token0, constants.token1) = tokenIn &lt; tokenOut ? (tokenIn,  tokenOut) </span>
  50 |     | <span class='unexecuted'>                                                                  : (tokenOut, tokenIn);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>        // check if tick spacing supported</span>
  53 |     | <span class='unexecuted'>        constants.swapFee = swapFee;</span>
  54 |     | <span class='unexecuted'>        constants.tickSpacing = ILimitPoolManager(owner).feeTiers(swapFee);</span>
  55 |     | <span class='unexecuted'>        if (constants.tickSpacing == 0) revert FeeTierNotSupported();</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // check if pool type supported</span>
  58 |     | <span class='unexecuted'>        (</span>
  59 |     | <span class='unexecuted'>            address poolImpl,</span>
  60 |     | <span class='unexecuted'>            address tokenImpl</span>
  61 |     | <span class='unexecuted'>         ) = ILimitPoolManager(owner).implementations(poolType);</span>
  62 |     | <span class='unexecuted'>        if (poolImpl == address(0) || tokenImpl == address(0)) revert PoolTypeNotSupported();</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // generate key for pool</span>
  65 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
  66 |     | <span class='unexecuted'>            poolImpl,</span>
  67 |     | <span class='unexecuted'>            constants.token0,</span>
  68 |     | <span class='unexecuted'>            constants.token1,</span>
  69 |     | <span class='unexecuted'>            constants.swapFee</span>
  70 |     | <span class='neutral'>        ));</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        // check if pool already exists</span>
  73 |     | <span class='unexecuted'>        if (pools[key] != address(0)) revert PoolAlreadyExists();</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // set immutables</span>
  76 |     | <span class='unexecuted'>        constants.owner = owner;</span>
  77 |     | <span class='unexecuted'>        constants.factory = original;</span>
  78 |     | <span class='unexecuted'>        constants.genesisTime = block.timestamp.toUint32();</span>
  79 |     | <span class='unexecuted'>        (</span>
  80 |     | <span class='unexecuted'>            constants.bounds.min,</span>
  81 |     | <span class='unexecuted'>            constants.bounds.max</span>
  82 |     | <span class='unexecuted'>        ) = ILimitPool(poolImpl).priceBounds(constants.tickSpacing);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // take that ERC1155 contract address and pass that into pool</span>
  85 |     | <span class='neutral'>        // launch pool token</span>
  86 |     | <span class='unexecuted'>        constants.poolToken = tokenImpl.cloneDeterministic({</span>
  87 |     | <span class='unexecuted'>            salt: key,</span>
  88 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
  89 |     | <span class='unexecuted'>                poolImpl</span>
  90 |     | <span class='neutral'>            )</span>
  91 |     | <span class='neutral'>        });</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        // launch pool</span>
  94 |     | <span class='unexecuted'>        pool = poolImpl.cloneDeterministic({</span>
  95 |     | <span class='unexecuted'>            salt: key,</span>
  96 |     | <span class='unexecuted'>            data: abi.encodePacked(</span>
  97 |     | <span class='unexecuted'>                constants.owner,</span>
  98 |     | <span class='unexecuted'>                constants.token0,</span>
  99 |     | <span class='unexecuted'>                constants.token1,</span>
 100 |     | <span class='unexecuted'>                constants.poolToken,</span>
 101 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 102 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 103 |     | <span class='unexecuted'>                constants.genesisTime,</span>
 104 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 105 |     | <span class='unexecuted'>                constants.swapFee</span>
 106 |     | <span class='neutral'>            )</span>
 107 |     | <span class='neutral'>        });</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // initialize pool storage</span>
 110 |     | <span class='unexecuted'>        ILimitPool(pool).initialize(startPrice);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // save pool in mapping</span>
 113 |     | <span class='unexecuted'>        pools[key] = pool;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        emit PoolCreated(</span>
 116 |     | <span class='unexecuted'>            pool,</span>
 117 |     | <span class='unexecuted'>            poolToken,</span>
 118 |     | <span class='unexecuted'>            poolImpl,</span>
 119 |     | <span class='unexecuted'>            tokenImpl,</span>
 120 |     | <span class='unexecuted'>            constants.token0,</span>
 121 |     | <span class='unexecuted'>            constants.token1,</span>
 122 |     | <span class='unexecuted'>            constants.swapFee,</span>
 123 |     | <span class='unexecuted'>            constants.tickSpacing</span>
 124 |     | <span class='neutral'>        );</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>        return (pool, constants.poolToken);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>    function getLimitPool(</span>
 130 |     | <span class='neutral'>        bytes32 poolType,</span>
 131 |     | <span class='neutral'>        address tokenIn,</span>
 132 |     | <span class='neutral'>        address tokenOut,</span>
 133 |     | <span class='neutral'>        uint16 swapFee</span>
 134 |     | <span class='neutral'>    ) external view override returns (</span>
 135 |     | <span class='unexecuted'>        address pool,</span>
 136 |     | <span class='unexecuted'>        address poolToken</span>
 137 |     | <span class='neutral'>    ) {</span>
 138 |     | <span class='neutral'>        // set lexographical token address ordering</span>
 139 |     | <span class='unexecuted'>        address token0 = tokenIn &lt; tokenOut ? tokenIn : tokenOut;</span>
 140 |     | <span class='unexecuted'>        address token1 = tokenIn &lt; tokenOut ? tokenOut : tokenIn;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>        // check if tick spacing supported</span>
 143 |     | <span class='unexecuted'>        int16 tickSpacing = ILimitPoolManager(owner).feeTiers(swapFee);</span>
 144 |     | <span class='unexecuted'>        if (tickSpacing == 0) revert FeeTierNotSupported();</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // check if pool type supported</span>
 147 |     | <span class='unexecuted'>        (</span>
 148 |     | <span class='unexecuted'>            address poolImpl,</span>
 149 |     | <span class='unexecuted'>            address tokenImpl</span>
 150 |     | <span class='unexecuted'>         ) = ILimitPoolManager(owner).implementations(poolType);</span>
 151 |     | <span class='unexecuted'>        if (poolImpl == address(0) || tokenImpl == address(0)) revert PoolTypeNotSupported();</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>        // generate key for pool</span>
 154 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 155 |     | <span class='unexecuted'>            poolImpl,</span>
 156 |     | <span class='unexecuted'>            token0,</span>
 157 |     | <span class='unexecuted'>            token1,</span>
 158 |     | <span class='unexecuted'>            swapFee</span>
 159 |     | <span class='neutral'>        ));</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>        pool = pools[key];</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>        poolToken = LibClone.predictDeterministicAddress(</span>
 164 |     | <span class='unexecuted'>            tokenImpl,</span>
 165 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 166 |     | <span class='unexecuted'>                poolImpl</span>
 167 |     | <span class='neutral'>            ),</span>
 168 |     | <span class='unexecuted'>            key,</span>
 169 |     | <span class='unexecuted'>            address(this)</span>
 170 |     | <span class='neutral'>        );</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>        return (pool, poolToken);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'>}</span>
 175 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/base/events/LimitPoolFactoryEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryEvents {</span>
  5 |     | <span class='neutral'>    event PoolCreated(</span>
  6 |     | <span class='neutral'>        address pool,</span>
  7 |     | <span class='neutral'>        address token,</span>
  8 |     | <span class='neutral'>        address poolImpl,</span>
  9 |     | <span class='neutral'>        address tokenImpl,</span>
 10 |     | <span class='neutral'>        address indexed token0,</span>
 11 |     | <span class='neutral'>        address indexed token1,</span>
 12 |     | <span class='neutral'>        uint16 indexed swapFee,</span>
 13 |     | <span class='neutral'>        int16 tickSpacing</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/base/events/LimitPoolManagerEvents.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract LimitPoolManagerEvents is PoolsharkStructs {</span>
  7 |     | <span class='neutral'>    event FactoryChanged(address indexed previousFactory, address indexed newFactory);</span>
  8 |     | <span class='neutral'>    event ImplementationEnabled(</span>
  9 |     | <span class='neutral'>        bytes32 key,</span>
 10 |     | <span class='neutral'>        address poolImpl,</span>
 11 |     | <span class='neutral'>        address tokenImpl</span>
 12 |     | <span class='neutral'>    );</span>
 13 |     | <span class='neutral'>    event FeeTierEnabled(</span>
 14 |     | <span class='neutral'>        uint16 swapFee,</span>
 15 |     | <span class='neutral'>        int16 tickSpacing</span>
 16 |     | <span class='neutral'>    );</span>
 17 |     | <span class='neutral'>    event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);</span>
 18 |     | <span class='neutral'>    event OwnerTransfer(address indexed previousOwner, address indexed newOwner);</span>
 19 |     | <span class='neutral'>    event ProtocolSwapFeesModified(</span>
 20 |     | <span class='neutral'>        address[] pools,</span>
 21 |     | <span class='neutral'>        uint16[] protocolSwapFees0,</span>
 22 |     | <span class='neutral'>        uint16[] protocolSwapFees1</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'>    event ProtocolFillFeesModified(</span>
 25 |     | <span class='neutral'>        address[] pools,</span>
 26 |     | <span class='neutral'>        uint16[] protocolFillFees0,</span>
 27 |     | <span class='neutral'>        uint16[] protocolFillFees1</span>
 28 |     | <span class='neutral'>    );</span>
 29 |     | <span class='neutral'>    event ProtocolFeesCollected(</span>
 30 |     | <span class='neutral'>        address[] pools,</span>
 31 |     | <span class='neutral'>        uint128[] token0FeesCollected,</span>
 32 |     | <span class='neutral'>        uint128[] token1FeesCollected</span>
 33 |     | <span class='neutral'>    );</span>
 34 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/base/storage/LimitPoolFactoryStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolFactoryStorage {</span>
  5 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; address) public pools;</span>
  6 |     | <span class='neutral'>}</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/base/storage/LimitPoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../libraries/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract LimitPoolImmutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function owner() public pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function token0() public pure returns (address) {</span>
 12 |     | <span class='unexecuted'>        return _getArgAddress(20);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function token1() public pure returns (address) {</span>
 16 |     | <span class='unexecuted'>        return _getArgAddress(40);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function poolToken() public pure returns (address) {</span>
 20 |     | <span class='unexecuted'>        return _getArgAddress(60);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function minPrice() public pure returns (uint160) {</span>
 24 |     | <span class='unexecuted'>        return _getArgUint160(80);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function maxPrice() public pure returns (uint160) {</span>
 28 |     | <span class='unexecuted'>        return _getArgUint160(100);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function genesisTime() public pure returns (uint32) {</span>
 32 |     | <span class='unexecuted'>        return _getArgUint32(120);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function tickSpacing() public pure returns (int16) {</span>
 36 |     | <span class='unexecuted'>        return int16(_getArgUint16(124));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function swapFee() public pure returns (uint16) {</span>
 40 |     | <span class='unexecuted'>        return _getArgUint16(126);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/base/storage/LimitPoolStorage.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../../utils/LimitPoolErrors.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>abstract contract LimitPoolStorage is LimitPoolStructs, RangePoolStructs, LimitPoolErrors {</span>
 10 |     | <span class='unexecuted'>    GlobalState public globalState;</span>
 11 |     | <span class='unexecuted'>    TickMap public rangeTickMap;</span>
 12 |     | <span class='unexecuted'>    TickMap public limitTickMap;</span>
 13 |     | <span class='unexecuted'>    Sample[65535] public samples;</span>
 14 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick) public ticks;</span>
 15 |     | <span class='unexecuted'>    mapping(uint256 =&gt; RangePosition) public positions; /// @dev - positions owned by the pool</span>
 16 |     | <span class='unexecuted'>    mapping(uint256 =&gt; LimitPosition) public positions0; //positions with token0 deposited</span>
 17 |     | <span class='unexecuted'>    mapping(uint256 =&gt; LimitPosition) public positions1; //positions with token1 deposited</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/base/storage/PositionERC1155Immutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BSD</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { Clone } from &quot;../../libraries/solady/Clone.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract PositionERC1155Immutables is Clone {</span>
  7 |     | <span class='unexecuted'>    function poolImpl() public pure returns (address) {</span>
  8 |     | <span class='unexecuted'>        return _getArgAddress(0);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  22 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  23 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  24 |     | <span class='neutral'> * applications.</span>
  25 |     | <span class='neutral'> *</span>
  26 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  27 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  28 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  29 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  32 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  33 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  36 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    string private _name;</span>
  43 |     | <span class='neutral'>    string private _symbol;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /**</span>
  46 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  47 |     | <span class='neutral'>     *</span>
  48 |     | <span class='neutral'>     * The default value of {decimals} is 18. To select a different value for</span>
  49 |     | <span class='neutral'>     * {decimals} you should overload it.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the value {ERC20} uses, unless this function is</span>
  81 |     | <span class='neutral'>     * overridden;</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 |     | <span class='unexecuted'>    function decimals() public view virtual override returns (uint8) {</span>
  88 |     | <span class='unexecuted'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 |     | <span class='unexecuted'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='unexecuted'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 | *   | <span class='executed'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(</span>
 159 |     | <span class='neutral'>        address from,</span>
 160 |     | <span class='neutral'>        address to,</span>
 161 |     | <span class='neutral'>        uint256 amount</span>
 162 | *   | <span class='executed'>    ) public virtual override returns (bool) {</span>
 163 | *   | <span class='executed'>        address spender = _msgSender();</span>
 164 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 165 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 166 | *   | <span class='executed'>        return true;</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /**</span>
 170 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 173 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 176 |     | <span class='neutral'>     *</span>
 177 |     | <span class='neutral'>     * Requirements:</span>
 178 |     | <span class='neutral'>     *</span>
 179 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 180 |     | <span class='neutral'>     */</span>
 181 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 182 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 183 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 184 |     | <span class='unexecuted'>        return true;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /**</span>
 188 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 189 |     | <span class='neutral'>     *</span>
 190 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 191 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * Requirements:</span>
 196 |     | <span class='neutral'>     *</span>
 197 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 198 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 199 |     | <span class='neutral'>     * `subtractedValue`.</span>
 200 |     | <span class='neutral'>     */</span>
 201 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 202 |     | <span class='unexecuted'>        address owner = _msgSender();</span>
 203 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 204 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 205 |     | <span class='neutral'>        unchecked {</span>
 206 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='unexecuted'>        return true;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /**</span>
 213 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 216 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 219 |     | <span class='neutral'>     *</span>
 220 |     | <span class='neutral'>     * Requirements:</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 223 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 224 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 225 |     | <span class='neutral'>     */</span>
 226 | *   | <span class='executed'>    function _transfer(</span>
 227 |     | <span class='neutral'>        address from,</span>
 228 |     | <span class='neutral'>        address to,</span>
 229 |     | <span class='neutral'>        uint256 amount</span>
 230 | *   | <span class='executed'>    ) internal virtual {</span>
 231 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 232 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 233 |     | <span class='neutral'></span>
 234 | *   | <span class='executed'>        _beforeTokenTransfer(from, to, amount);</span>
 235 |     | <span class='neutral'></span>
 236 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 237 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 238 |     | <span class='neutral'>        unchecked {</span>
 239 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 240 |     | <span class='neutral'>        }</span>
 241 | *   | <span class='executed'>        _balances[to] += amount;</span>
 242 |     | <span class='neutral'></span>
 243 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 244 |     | <span class='neutral'></span>
 245 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 249 |     | <span class='neutral'>     * the total supply.</span>
 250 |     | <span class='neutral'>     *</span>
 251 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 252 |     | <span class='neutral'>     *</span>
 253 |     | <span class='neutral'>     * Requirements:</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 256 |     | <span class='neutral'>     */</span>
 257 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 258 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 259 |     | <span class='neutral'></span>
 260 | *   | <span class='executed'>        _beforeTokenTransfer(address(0), account, amount);</span>
 261 |     | <span class='neutral'></span>
 262 | *   | <span class='executed'>        _totalSupply += amount;</span>
 263 | *   | <span class='executed'>        _balances[account] += amount;</span>
 264 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 265 |     | <span class='neutral'></span>
 266 | *   | <span class='executed'>        _afterTokenTransfer(address(0), account, amount);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /**</span>
 270 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 271 |     | <span class='neutral'>     * total supply.</span>
 272 |     | <span class='neutral'>     *</span>
 273 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 274 |     | <span class='neutral'>     *</span>
 275 |     | <span class='neutral'>     * Requirements:</span>
 276 |     | <span class='neutral'>     *</span>
 277 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 278 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 279 |     | <span class='neutral'>     */</span>
 280 |     | <span class='unexecuted'>    function _burn(address account, uint256 amount) internal virtual {</span>
 281 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        _beforeTokenTransfer(account, address(0), amount);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 286 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 287 |     | <span class='neutral'>        unchecked {</span>
 288 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 289 |     | <span class='neutral'>        }</span>
 290 |     | <span class='unexecuted'>        _totalSupply -= amount;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        _afterTokenTransfer(account, address(0), amount);</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 299 |     | <span class='neutral'>     *</span>
 300 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 301 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * Requirements:</span>
 306 |     | <span class='neutral'>     *</span>
 307 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 308 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 309 |     | <span class='neutral'>     */</span>
 310 | *   | <span class='executed'>    function _approve(</span>
 311 |     | <span class='neutral'>        address owner,</span>
 312 |     | <span class='neutral'>        address spender,</span>
 313 |     | <span class='neutral'>        uint256 amount</span>
 314 |     | <span class='neutral'>    ) internal virtual {</span>
 315 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 316 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 317 |     | <span class='neutral'></span>
 318 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 319 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 324 |     | <span class='neutral'>     *</span>
 325 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 326 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 329 |     | <span class='neutral'>     */</span>
 330 | *   | <span class='executed'>    function _spendAllowance(</span>
 331 |     | <span class='neutral'>        address owner,</span>
 332 |     | <span class='neutral'>        address spender,</span>
 333 |     | <span class='neutral'>        uint256 amount</span>
 334 | *   | <span class='executed'>    ) internal virtual {</span>
 335 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 336 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 337 | *   | <span class='executed'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 338 |     | <span class='neutral'>            unchecked {</span>
 339 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 340 |     | <span class='neutral'>            }</span>
 341 |     | <span class='neutral'>        }</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    /**</span>
 345 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 346 |     | <span class='neutral'>     * minting and burning.</span>
 347 |     | <span class='neutral'>     *</span>
 348 |     | <span class='neutral'>     * Calling conditions:</span>
 349 |     | <span class='neutral'>     *</span>
 350 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 351 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 352 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 353 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 354 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 357 |     | <span class='neutral'>     */</span>
 358 | *   | <span class='executed'>    function _beforeTokenTransfer(</span>
 359 |     | <span class='neutral'>        address from,</span>
 360 |     | <span class='neutral'>        address to,</span>
 361 |     | <span class='neutral'>        uint256 amount</span>
 362 |     | <span class='neutral'>    ) internal virtual {}</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    /**</span>
 365 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 366 |     | <span class='neutral'>     * minting and burning.</span>
 367 |     | <span class='neutral'>     *</span>
 368 |     | <span class='neutral'>     * Calling conditions:</span>
 369 |     | <span class='neutral'>     *</span>
 370 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 371 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 372 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 373 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 374 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 375 |     | <span class='neutral'>     *</span>
 376 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 377 |     | <span class='neutral'>     */</span>
 378 | *   | <span class='executed'>    function _afterTokenTransfer(</span>
 379 |     | <span class='neutral'>        address from,</span>
 380 |     | <span class='neutral'>        address to,</span>
 381 |     | <span class='neutral'>        uint256 amount</span>
 382 |     | <span class='neutral'>    ) internal virtual {}</span>
 383 |     | <span class='neutral'>}</span>
 384 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(</span>
 78 |     | <span class='neutral'>        address from,</span>
 79 |     | <span class='neutral'>        address to,</span>
 80 |     | <span class='neutral'>        uint256 amount</span>
 81 |     | <span class='neutral'>    ) external returns (bool);</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../../utils/Context.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev Extension of {ERC20} that allows token holders to destroy both their own</span>
 11 |     | <span class='neutral'> * tokens and those that they have an allowance for, in a way that can be</span>
 12 |     | <span class='neutral'> * recognized off-chain (via event analysis).</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='neutral'>abstract contract ERC20Burnable is Context, ERC20 {</span>
 15 |     | <span class='neutral'>    /**</span>
 16 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from the caller.</span>
 17 |     | <span class='neutral'>     *</span>
 18 |     | <span class='neutral'>     * See {ERC20-_burn}.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='unexecuted'>    function burn(uint256 amount) public virtual {</span>
 21 |     | <span class='unexecuted'>        _burn(_msgSender(), amount);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, deducting from the caller&#39;s</span>
 26 |     | <span class='neutral'>     * allowance.</span>
 27 |     | <span class='neutral'>     *</span>
 28 |     | <span class='neutral'>     * See {ERC20-_burn} and {ERC20-allowance}.</span>
 29 |     | <span class='neutral'>     *</span>
 30 |     | <span class='neutral'>     * Requirements:</span>
 31 |     | <span class='neutral'>     *</span>
 32 |     | <span class='neutral'>     * - the caller must have allowance for ``accounts``&#39;s tokens of at least</span>
 33 |     | <span class='neutral'>     * `amount`.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function burnFrom(address account, uint256 amount) public virtual {</span>
 36 |     | <span class='unexecuted'>        _spendAllowance(account, _msgSender(), amount);</span>
 37 |     | <span class='unexecuted'>        _burn(account, amount);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IERC20} from &quot;../IERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/**</span>
  8 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
  9 |     | <span class='neutral'> */</span>
 10 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 11 |     | <span class='neutral'>    /**</span>
 12 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 13 |     | <span class='neutral'>     */</span>
 14 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /**</span>
 22 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 25 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 | *   | <span class='executed'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/external/openzeppelin/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &#39;../../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 12 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 13 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 14 |     | <span class='neutral'> *</span>
 15 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 16 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 17 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 18 |     | <span class='neutral'> * points to them.</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 21 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 22 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 23 |     | <span class='neutral'> */</span>
 24 |     | <span class='neutral'>abstract contract ReentrancyGuard is PoolsharkStructs {</span>
 25 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 26 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 27 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 28 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 29 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 32 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 33 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 34 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 35 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 36 |     | <span class='unexecuted'>    uint8 private constant _NOT_ENTERED = 1;</span>
 37 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Unauthorized reentrant call.</span>
 41 |     | <span class='neutral'>     */</span>
 42 |     | <span class='neutral'>    error ReentrancyGuardReentrantCall();</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /**</span>
 45 |     | <span class='neutral'>     * @dev Unauthorized read-only reentrant call.</span>
 46 |     | <span class='neutral'>     */</span>
 47 |     | <span class='neutral'>    error ReentrancyGuardReadOnlyReentrantCall();</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev Reentrant state invalid.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='neutral'>    error ReentrancyGuardInvalidState();</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 56 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 57 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 58 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 59 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='neutral'>    modifier nonReentrant(GlobalState storage state) {</span>
 62 |     | <span class='unexecuted'>        _nonReentrantBefore(state);</span>
 63 |     | <span class='neutral'>        _;</span>
 64 |     | <span class='unexecuted'>        _nonReentrantAfter(state);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function _nonReentrantBefore(GlobalState storage state) private {</span>
 68 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 69 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED) {</span>
 70 |     | <span class='unexecuted'>            revert ReentrancyGuardReentrantCall();</span>
 71 |     | <span class='neutral'>        }</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 74 |     | <span class='unexecuted'>        state.unlocked = _ENTERED;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='unexecuted'>    function _nonReentrantAfter(GlobalState storage state) private {</span>
 78 |     | <span class='unexecuted'>        if (state.unlocked != _ENTERED) revert ReentrancyGuardInvalidState();</span>
 79 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 80 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 81 |     | <span class='unexecuted'>        state.unlocked = _NOT_ENTERED;</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'></span>
 84 |     | <span class='neutral'>    /**</span>
 85 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 86 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    function _reentrancyGuardEntered(GlobalState storage state) internal view returns (bool) {</span>
 89 |     | <span class='neutral'>        return state.unlocked == _ENTERED;</span>
 90 |     | <span class='neutral'>    }</span>
 91 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC20Minimal {</span>
  5 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  6 |     | <span class='neutral'>    /// @param account The address for which to look up the balance for</span>
  7 |     | <span class='neutral'>    /// @return amount of tokens held by the account</span>
  8 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  9 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/IPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IPool is PoolsharkStructs {</span>
  7 |     | <span class='neutral'>    function immutables() external view returns (Immutables memory);</span>
  8 |     | <span class='neutral'>    </span>
  9 |     | <span class='neutral'>    function swap(</span>
 10 |     | <span class='neutral'>        SwapParams memory params</span>
 11 |     | <span class='neutral'>    ) external returns (</span>
 12 |     | <span class='neutral'>        int256 amount0,</span>
 13 |     | <span class='neutral'>        int256 amount1</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function quote(</span>
 17 |     | <span class='neutral'>        QuoteParams memory params</span>
 18 |     | <span class='neutral'>    ) external view returns (</span>
 19 |     | <span class='neutral'>        int256 inAmount,</span>
 20 |     | <span class='neutral'>        int256 outAmount,</span>
 21 |     | <span class='neutral'>        uint160 priceAfter</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function fees(</span>
 25 |     | <span class='neutral'>        FeesParams memory params</span>
 26 |     | <span class='neutral'>    ) external returns (</span>
 27 |     | <span class='neutral'>        uint128 token0Fees,</span>
 28 |     | <span class='neutral'>        uint128 token1Fees</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function sample(</span>
 32 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 33 |     | <span class='neutral'>    ) external view returns (</span>
 34 |     | <span class='neutral'>        int56[]   memory tickSecondsAccum,</span>
 35 |     | <span class='neutral'>        uint160[] memory secondsPerLiquidityAccum,</span>
 36 |     | <span class='neutral'>        uint160 averagePrice,</span>
 37 |     | <span class='neutral'>        uint128 averageLiquidity,</span>
 38 |     | <span class='neutral'>        int24 averageTick</span>
 39 |     | <span class='neutral'>    );</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function snapshotRange(</span>
 42 |     | <span class='neutral'>        uint32 positionId</span>
 43 |     | <span class='neutral'>    ) external view returns(</span>
 44 |     | <span class='neutral'>        int56   tickSecondsAccum,</span>
 45 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum,</span>
 46 |     | <span class='neutral'>        uint128 feesOwed0,</span>
 47 |     | <span class='neutral'>        uint128 feesOwed1</span>
 48 |     | <span class='neutral'>    );</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function snapshotLimit(</span>
 51 |     | <span class='neutral'>        SnapshotLimitParams memory params</span>
 52 |     | <span class='neutral'>    ) external view returns(</span>
 53 |     | <span class='neutral'>        uint128,</span>
 54 |     | <span class='neutral'>        uint128</span>
 55 |     | <span class='neutral'>    );</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function globalState() external view returns (</span>
 58 |     | <span class='neutral'>        RangePoolState memory pool,</span>
 59 |     | <span class='neutral'>        LimitPoolState memory pool0,</span>
 60 |     | <span class='neutral'>        LimitPoolState memory pool1,</span>
 61 |     | <span class='neutral'>        uint128 liquidityGlobal,</span>
 62 |     | <span class='neutral'>        uint32 epoch,</span>
 63 |     | <span class='neutral'>        uint8 unlocked</span>
 64 |     | <span class='neutral'>    );</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    function samples(uint256) external view returns (</span>
 67 |     | <span class='neutral'>        uint32,</span>
 68 |     | <span class='neutral'>        int56,</span>
 69 |     | <span class='neutral'>        uint160</span>
 70 |     | <span class='neutral'>    );</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    function ticks(int24) external view returns (</span>
 73 |     | <span class='neutral'>        RangeTick memory,</span>
 74 |     | <span class='neutral'>        LimitTick memory</span>
 75 |     | <span class='neutral'>    );</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    function positions(uint32) external view returns (</span>
 78 |     | <span class='neutral'>        uint256 feeGrowthInside0Last,</span>
 79 |     | <span class='neutral'>        uint256 feeGrowthInside1Last,</span>
 80 |     | <span class='neutral'>        uint128 liquidity,</span>
 81 |     | <span class='neutral'>        int24 lower,</span>
 82 |     | <span class='neutral'>        int24 upper</span>
 83 |     | <span class='neutral'>    );</span>
 84 |     | <span class='neutral'>}</span>
 85 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/IPositionERC1155.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &quot;../external/openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>interface IPositionERC1155 is IERC165, PoolsharkStructs {</span>
  9 |     | <span class='neutral'>    event TransferSingle(</span>
 10 |     | <span class='neutral'>        address indexed sender,</span>
 11 |     | <span class='neutral'>        address indexed from,</span>
 12 |     | <span class='neutral'>        address indexed to,</span>
 13 |     | <span class='neutral'>        uint256 id,</span>
 14 |     | <span class='neutral'>        uint256 amount</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    event TransferBatch(</span>
 18 |     | <span class='neutral'>        address indexed sender,</span>
 19 |     | <span class='neutral'>        address indexed from,</span>
 20 |     | <span class='neutral'>        address indexed to,</span>
 21 |     | <span class='neutral'>        uint256[] ids,</span>
 22 |     | <span class='neutral'>        uint256[] amounts</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    event ApprovalForAll(</span>
 26 |     | <span class='neutral'>        address indexed account,</span>
 27 |     | <span class='neutral'>        address indexed sender,</span>
 28 |     | <span class='neutral'>        bool approve</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function balanceOf(address account, uint256 id) external view returns (uint256);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function balanceOfBatch(</span>
 38 |     | <span class='neutral'>        address[] calldata accounts,</span>
 39 |     | <span class='neutral'>        uint256[] calldata ids</span>
 40 |     | <span class='neutral'>    ) external view returns (</span>
 41 |     | <span class='neutral'>        uint256[] memory batchBalances</span>
 42 |     | <span class='neutral'>    );</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function totalSupply(uint256 id) external view returns (uint256);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function isApprovedForAll(address owner, address spender) external view returns (bool);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function setApprovalForAll(address sender, bool approved) external;</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function mint(</span>
 51 |     | <span class='neutral'>        address account,</span>
 52 |     | <span class='neutral'>        uint256 id,</span>
 53 |     | <span class='neutral'>        uint256 amount,</span>
 54 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 55 |     | <span class='neutral'>    ) external;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    function burn(</span>
 58 |     | <span class='neutral'>        address account,</span>
 59 |     | <span class='neutral'>        uint256 id,</span>
 60 |     | <span class='neutral'>        uint256 amount,</span>
 61 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 62 |     | <span class='neutral'>    ) external;</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function safeTransferFrom(</span>
 65 |     | <span class='neutral'>        address from,</span>
 66 |     | <span class='neutral'>        address to,</span>
 67 |     | <span class='neutral'>        uint256 id,</span>
 68 |     | <span class='neutral'>        uint256 amount</span>
 69 |     | <span class='neutral'>    ) external;</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>    function safeBatchTransferFrom(</span>
 72 |     | <span class='neutral'>        address from,</span>
 73 |     | <span class='neutral'>        address to,</span>
 74 |     | <span class='neutral'>        uint256[] calldata id,</span>
 75 |     | <span class='neutral'>        uint256[] calldata amount</span>
 76 |     | <span class='neutral'>    ) external;</span>
 77 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/callbacks/ILimitPoolSwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for swaps</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls the `swap` function must implement this interface.</span>
  6 |     | <span class='neutral'>interface ILimitPoolSwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 10 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 11 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 12 |     | <span class='neutral'>    function limitPoolSwapCallback(</span>
 13 |     | <span class='neutral'>        int256 amount0Delta,</span>
 14 |     | <span class='neutral'>        int256 amount1Delta,</span>
 15 |     | <span class='neutral'>        bytes calldata data</span>
 16 |     | <span class='neutral'>    ) external;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // /// @notice Called to `msg.sender` after executing a swap.</span>
 19 |     | <span class='neutral'>    // /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
 20 |     | <span class='neutral'>    // /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 21 |     | <span class='neutral'>    // /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.</span>
 22 |     | <span class='neutral'>    // /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.</span>
 23 |     | <span class='neutral'>    // function coverPoolSwapCallback(</span>
 24 |     | <span class='neutral'>    //     int256 amount0Delta,</span>
 25 |     | <span class='neutral'>    //     int256 amount1Delta,</span>
 26 |     | <span class='neutral'>    //     bytes calldata data</span>
 27 |     | <span class='neutral'>    // ) external;</span>
 28 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/limit/ILimitPool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../structs/LimitPoolFactoryStructs.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface ILimitPool is LimitPoolStructs {</span>
  8 |     | <span class='neutral'>    function initialize(</span>
  9 |     | <span class='neutral'>        uint160 startPrice</span>
 10 |     | <span class='neutral'>    ) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function mintLimit(</span>
 13 |     | <span class='neutral'>        MintLimitParams memory params</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function burnLimit(</span>
 17 |     | <span class='neutral'>        BurnLimitParams memory params</span>
 18 |     | <span class='neutral'>    ) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function snapshotLimit(</span>
 21 |     | <span class='neutral'>        SnapshotLimitParams memory params</span>
 22 |     | <span class='neutral'>    ) external view returns(</span>
 23 |     | <span class='neutral'>        uint128,</span>
 24 |     | <span class='neutral'>        uint128</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function fees(</span>
 28 |     | <span class='neutral'>        FeesParams memory params</span>
 29 |     | <span class='neutral'>    ) external returns (</span>
 30 |     | <span class='neutral'>        uint128 token0Fees,</span>
 31 |     | <span class='neutral'>        uint128 token1Fees</span>
 32 |     | <span class='neutral'>    );</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    function priceBounds(</span>
 35 |     | <span class='neutral'>        int16 tickSpacing</span>
 36 |     | <span class='neutral'>    ) external pure returns (</span>
 37 |     | <span class='neutral'>        uint160 minPrice,</span>
 38 |     | <span class='neutral'>        uint160 maxPrice</span>
 39 |     | <span class='neutral'>    );</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/limit/ILimitPoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'>import &#39;../../base/storage/LimitPoolFactoryStorage.sol&#39;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>abstract contract ILimitPoolFactory is LimitPoolFactoryStorage {</span>
  6 |     | <span class='neutral'>    function createLimitPool(</span>
  7 |     | <span class='neutral'>        bytes32 poolType,</span>
  8 |     | <span class='neutral'>        address tokenIn,</span>
  9 |     | <span class='neutral'>        address tokenOut,</span>
 10 |     | <span class='neutral'>        uint16  swapFee,</span>
 11 |     | <span class='neutral'>        uint160 startPrice</span>
 12 |     | <span class='neutral'>    ) external virtual returns (</span>
 13 |     | <span class='neutral'>        address pool,</span>
 14 |     | <span class='neutral'>        address poolToken</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function getLimitPool(</span>
 18 |     | <span class='neutral'>        bytes32 poolType,</span>
 19 |     | <span class='neutral'>        address tokenIn,</span>
 20 |     | <span class='neutral'>        address tokenOut,</span>
 21 |     | <span class='neutral'>        uint16  swapFee</span>
 22 |     | <span class='neutral'>    ) external view virtual returns (</span>
 23 |     | <span class='neutral'>        address pool,</span>
 24 |     | <span class='neutral'>        address poolToken</span>
 25 |     | <span class='neutral'>    );</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/limit/ILimitPoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @notice LimitPoolManager interface</span>
  5 |     | <span class='neutral'>interface ILimitPoolManager {</span>
  6 |     | <span class='neutral'>    </span>
  7 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  8 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  9 |     | <span class='neutral'>    function implementations(</span>
 10 |     | <span class='neutral'>        bytes32 poolType</span>
 11 |     | <span class='neutral'>    ) external view returns (</span>
 12 |     | <span class='neutral'>        address poolImpl,</span>
 13 |     | <span class='neutral'>        address tokenImpl</span>
 14 |     | <span class='neutral'>    );</span>
 15 |     | <span class='neutral'>    function feeTiers(</span>
 16 |     | <span class='neutral'>        uint16 swapFee</span>
 17 |     | <span class='neutral'>    ) external view returns (</span>
 18 |     | <span class='neutral'>        int16 tickSpacing</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/range/IRangePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./IRangePoolManager.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IRangePool is RangePoolStructs {</span>
  8 |     | <span class='neutral'>    function mintRange(</span>
  9 |     | <span class='neutral'>        MintRangeParams memory mintParams</span>
 10 |     | <span class='neutral'>    ) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function burnRange(</span>
 13 |     | <span class='neutral'>        BurnRangeParams memory burnParams</span>
 14 |     | <span class='neutral'>    ) external;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function swap(</span>
 17 |     | <span class='neutral'>        SwapParams memory params</span>
 18 |     | <span class='neutral'>    ) external returns (</span>
 19 |     | <span class='neutral'>        int256 amount0,</span>
 20 |     | <span class='neutral'>        int256 amount1</span>
 21 |     | <span class='neutral'>    );</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function quote(</span>
 24 |     | <span class='neutral'>        QuoteParams memory params</span>
 25 |     | <span class='neutral'>    ) external returns (</span>
 26 |     | <span class='neutral'>        uint256 inAmount,</span>
 27 |     | <span class='neutral'>        uint256 outAmount,</span>
 28 |     | <span class='neutral'>        uint160 priceAfter</span>
 29 |     | <span class='neutral'>    );</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function snapshotRange(</span>
 32 |     | <span class='neutral'>        uint32 positionId</span>
 33 |     | <span class='neutral'>    ) external view returns(</span>
 34 |     | <span class='neutral'>        int56   tickSecondsAccum,</span>
 35 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum,</span>
 36 |     | <span class='neutral'>        uint128 feesOwed0,</span>
 37 |     | <span class='neutral'>        uint128 feesOwed1</span>
 38 |     | <span class='neutral'>    );</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function increaseSampleLength(</span>
 41 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
 42 |     | <span class='neutral'>    ) external;</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/range/IRangePoolFactory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IRangePoolFactory {</span>
  5 |     | <span class='neutral'>    function createRangePool(</span>
  6 |     | <span class='neutral'>        address fromToken,</span>
  7 |     | <span class='neutral'>        address destToken,</span>
  8 |     | <span class='neutral'>        uint16 fee,</span>
  9 |     | <span class='neutral'>        uint160 startPrice</span>
 10 |     | <span class='neutral'>    ) external returns (address book);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function getRangePool(</span>
 13 |     | <span class='neutral'>        address fromToken,</span>
 14 |     | <span class='neutral'>        address destToken,</span>
 15 |     | <span class='neutral'>        uint256 fee</span>
 16 |     | <span class='neutral'>    ) external view returns (address);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function owner() external view returns(address);</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/range/IRangePoolManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IRangePoolManager {</span>
  7 |     | <span class='neutral'>    function owner() external view returns (address);</span>
  8 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  9 |     | <span class='neutral'>    function protocolFees(address pool) external view returns (uint16);</span>
 10 |     | <span class='neutral'>    function feeTiers(uint16 swapFee) external view returns (int24);</span>
 11 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/structs/LimitPoolFactoryStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface LimitPoolFactoryStructs {</span>
  5 |     | <span class='neutral'>    struct LimitPoolParams {</span>
  6 |     | <span class='neutral'>        address owner;</span>
  7 |     | <span class='neutral'>        address token0;</span>
  8 |     | <span class='neutral'>        address token1;</span>
  9 |     | <span class='neutral'>        uint160 minPrice;</span>
 10 |     | <span class='neutral'>        uint160 maxPrice;</span>
 11 |     | <span class='neutral'>        uint160 startPrice;</span>
 12 |     | <span class='neutral'>        int16   tickSpacing;</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/structs/LimitPoolStructs.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface LimitPoolStructs is PoolsharkStructs {</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    struct LimitPosition {</span>
  9 |     | <span class='neutral'>        uint128 liquidity; // expected amount to be used not actual</span>
 10 |     | <span class='neutral'>        uint32 epochLast;  // epoch when this position was created at</span>
 11 |     | <span class='neutral'>        int24 lower;       // lower price tick of position range</span>
 12 |     | <span class='neutral'>        int24 upper;       // upper price tick of position range</span>
 13 |     | <span class='neutral'>        bool crossedInto;  // whether the position was crossed into already</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    struct MintLimitParams {</span>
 17 |     | <span class='neutral'>        address to;</span>
 18 |     | <span class='neutral'>        uint128 amount;</span>
 19 |     | <span class='neutral'>        uint96 mintPercent;</span>
 20 |     | <span class='neutral'>        uint32 positionId;</span>
 21 |     | <span class='neutral'>        int24 lower;</span>
 22 |     | <span class='neutral'>        int24 upper;</span>
 23 |     | <span class='neutral'>        bool zeroForOne;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    struct BurnLimitParams {</span>
 27 |     | <span class='neutral'>        address to;</span>
 28 |     | <span class='neutral'>        uint128 burnPercent;</span>
 29 |     | <span class='neutral'>        uint32 positionId;</span>
 30 |     | <span class='neutral'>        int24 claim;</span>
 31 |     | <span class='neutral'>        bool zeroForOne;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    struct MintLimitCache {</span>
 35 |     | <span class='neutral'>        GlobalState state;</span>
 36 |     | <span class='neutral'>        LimitPosition position;</span>
 37 |     | <span class='neutral'>        Immutables constants;</span>
 38 |     | <span class='neutral'>        LimitPoolState pool;</span>
 39 |     | <span class='neutral'>        SwapCache swapCache;</span>
 40 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
 41 |     | <span class='neutral'>        uint256 mintSize;</span>
 42 |     | <span class='neutral'>        uint256 priceLimit;</span>
 43 |     | <span class='neutral'>        int256 amountIn;</span>
 44 |     | <span class='neutral'>        uint256 amountOut;</span>
 45 |     | <span class='neutral'>        uint256 priceLower;</span>
 46 |     | <span class='neutral'>        uint256 priceUpper;</span>
 47 |     | <span class='neutral'>        int24 tickLimit;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    struct BurnLimitCache {</span>
 51 |     | <span class='neutral'>        GlobalState state;</span>
 52 |     | <span class='neutral'>        LimitPoolState pool;</span>
 53 |     | <span class='neutral'>        LimitTick claimTick;</span>
 54 |     | <span class='neutral'>        LimitPosition position;</span>
 55 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
 56 |     | <span class='neutral'>        uint160 priceLower;</span>
 57 |     | <span class='neutral'>        uint160 priceClaim;</span>
 58 |     | <span class='neutral'>        uint160 priceUpper;</span>
 59 |     | <span class='neutral'>        uint128 liquidityBurned;</span>
 60 |     | <span class='neutral'>        uint128 amountIn;</span>
 61 |     | <span class='neutral'>        uint128 amountOut;</span>
 62 |     | <span class='neutral'>        int24 claim;</span>
 63 |     | <span class='neutral'>        bool removeLower;</span>
 64 |     | <span class='neutral'>        bool removeUpper;</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='neutral'>    struct InsertSingleLocals {</span>
 68 |     | <span class='neutral'>        int24 previousFullTick;</span>
 69 |     | <span class='neutral'>        int24 nextFullTick;</span>
 70 |     | <span class='neutral'>        uint256 priceNext;</span>
 71 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 72 |     | <span class='neutral'>        uint256 amountInExact;</span>
 73 |     | <span class='neutral'>        uint256 amountOutExact;</span>
 74 |     | <span class='neutral'>        uint256 amountToCross;</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    struct GetDeltasLocals {</span>
 78 |     | <span class='neutral'>        int24 previousFullTick;</span>
 79 |     | <span class='neutral'>        uint256 pricePrevious;</span>
 80 |     | <span class='neutral'>        uint256 priceNext;</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'>}</span>
 83 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/structs/PoolsharkStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface PoolsharkStructs {</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>    struct GlobalState {</span>
   7 |     | <span class='neutral'>        RangePoolState pool;</span>
   8 |     | <span class='neutral'>        LimitPoolState pool0;</span>
   9 |     | <span class='neutral'>        LimitPoolState pool1;</span>
  10 |     | <span class='neutral'>        uint128 liquidityGlobal;</span>
  11 |     | <span class='neutral'>        uint32  positionIdNext;</span>
  12 |     | <span class='neutral'>        uint32 epoch;</span>
  13 |     | <span class='neutral'>        uint8 unlocked;</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    struct LimitPoolState {</span>
  17 |     | <span class='neutral'>        uint160 price; /// @dev Starting price current</span>
  18 |     | <span class='neutral'>        uint128 liquidity; /// @dev Liquidity currently active</span>
  19 |     | <span class='neutral'>        uint128 protocolFees;</span>
  20 |     | <span class='neutral'>        uint16 protocolFillFee;</span>
  21 |     | <span class='neutral'>        int24 tickAtPrice;</span>
  22 |     | <span class='neutral'>    }</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    struct RangePoolState {</span>
  25 |     | <span class='neutral'>        SampleState  samples;</span>
  26 |     | <span class='neutral'>        uint200 feeGrowthGlobal0;</span>
  27 |     | <span class='neutral'>        uint200 feeGrowthGlobal1;</span>
  28 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  29 |     | <span class='neutral'>        uint160 price;               /// @dev Starting price current</span>
  30 |     | <span class='neutral'>        uint128 liquidity;           /// @dev Liquidity currently active</span>
  31 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
  32 |     | <span class='neutral'>        int24   tickAtPrice;</span>
  33 |     | <span class='neutral'>        uint16 protocolSwapFee0;</span>
  34 |     | <span class='neutral'>        uint16 protocolSwapFee1;</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    struct Tick {</span>
  38 |     | <span class='neutral'>        RangeTick range;</span>
  39 |     | <span class='neutral'>        LimitTick limit;</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    struct LimitTick {</span>
  43 |     | <span class='neutral'>        uint160 priceAt;</span>
  44 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  45 |     | <span class='neutral'>        uint128 liquidityAbsolute;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    struct RangeTick {</span>
  49 |     | <span class='neutral'>        uint200 feeGrowthOutside0;</span>
  50 |     | <span class='neutral'>        uint200 feeGrowthOutside1;</span>
  51 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumOutside;</span>
  52 |     | <span class='neutral'>        int56 tickSecondsAccumOutside;</span>
  53 |     | <span class='neutral'>        int128 liquidityDelta;</span>
  54 |     | <span class='neutral'>        uint128 liquidityAbsolute;</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    struct Sample {</span>
  58 |     | <span class='neutral'>        uint32  blockTimestamp;</span>
  59 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
  60 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    struct SampleState {</span>
  64 |     | <span class='neutral'>        uint16  index;</span>
  65 |     | <span class='neutral'>        uint16  length;</span>
  66 |     | <span class='neutral'>        uint16  lengthNext;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    struct SwapParams {</span>
  70 |     | <span class='neutral'>        address to;</span>
  71 |     | <span class='neutral'>        uint160 priceLimit;</span>
  72 |     | <span class='neutral'>        uint128  amount;</span>
  73 |     | <span class='neutral'>        bool exactIn;</span>
  74 |     | <span class='neutral'>        bool zeroForOne;</span>
  75 |     | <span class='neutral'>        bytes callbackData;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    struct QuoteParams {</span>
  79 |     | <span class='neutral'>        uint160 priceLimit;</span>
  80 |     | <span class='neutral'>        uint128 amount;</span>
  81 |     | <span class='neutral'>        bool exactIn;</span>
  82 |     | <span class='neutral'>        bool zeroForOne;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    struct FeesParams {</span>
  86 |     | <span class='neutral'>        uint16 protocolSwapFee0;</span>
  87 |     | <span class='neutral'>        uint16 protocolSwapFee1;</span>
  88 |     | <span class='neutral'>        uint16 protocolFillFee0;</span>
  89 |     | <span class='neutral'>        uint16 protocolFillFee1;</span>
  90 |     | <span class='neutral'>        uint8 setFeesFlags;</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    struct SnapshotLimitParams {</span>
  94 |     | <span class='neutral'>        address owner;</span>
  95 |     | <span class='neutral'>        uint128 burnPercent;</span>
  96 |     | <span class='neutral'>        uint32 positionId;</span>
  97 |     | <span class='neutral'>        int24 claim;</span>
  98 |     | <span class='neutral'>        bool zeroForOne;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    struct QuoteResults {</span>
 102 |     | <span class='neutral'>        address pool;</span>
 103 |     | <span class='neutral'>        int256 amountIn;</span>
 104 |     | <span class='neutral'>        int256 amountOut;</span>
 105 |     | <span class='neutral'>        uint160 priceAfter;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'>    </span>
 108 |     | <span class='neutral'>    struct Immutables {</span>
 109 |     | <span class='neutral'>        address owner;</span>
 110 |     | <span class='neutral'>        address poolImpl;</span>
 111 |     | <span class='neutral'>        address factory;</span>
 112 |     | <span class='neutral'>        PriceBounds bounds;</span>
 113 |     | <span class='neutral'>        address token0;</span>
 114 |     | <span class='neutral'>        address token1;</span>
 115 |     | <span class='neutral'>        address poolToken;</span>
 116 |     | <span class='neutral'>        uint32 genesisTime;</span>
 117 |     | <span class='neutral'>        int16 tickSpacing;</span>
 118 |     | <span class='neutral'>        uint16 swapFee;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    struct PriceBounds {</span>
 122 |     | <span class='neutral'>        uint160 min;</span>
 123 |     | <span class='neutral'>        uint160 max;</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    struct TickMap {</span>
 127 |     | <span class='neutral'>        uint256 blocks;                     /// @dev - sets of words</span>
 128 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) words;  /// @dev - sets to words</span>
 129 |     | <span class='neutral'>        mapping(uint256 =&gt; uint256) ticks;  /// @dev - words to ticks</span>
 130 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs0; /// @dev - ticks to epochs</span>
 131 |     | <span class='neutral'>        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; uint256))) epochs1; /// @dev - ticks to epochs</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    struct SwapCache {</span>
 135 |     | <span class='neutral'>        GlobalState state;</span>
 136 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
 137 |     | <span class='neutral'>        uint256 price;</span>
 138 |     | <span class='neutral'>        uint256 liquidity;</span>
 139 |     | <span class='neutral'>        uint256 amountLeft;</span>
 140 |     | <span class='neutral'>        uint256 input;</span>
 141 |     | <span class='neutral'>        uint256 output;</span>
 142 |     | <span class='neutral'>        uint160 crossPrice;</span>
 143 |     | <span class='neutral'>        uint160 averagePrice;</span>
 144 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
 145 |     | <span class='neutral'>        uint128 feeAmount;</span>
 146 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
 147 |     | <span class='neutral'>        int56   tickSecondsAccumBase;</span>
 148 |     | <span class='neutral'>        int24   crossTick;</span>
 149 |     | <span class='neutral'>        uint8   crossStatus;</span>
 150 |     | <span class='neutral'>        bool    limitActive;</span>
 151 |     | <span class='neutral'>        bool    exactIn;</span>
 152 |     | <span class='neutral'>        bool    cross;</span>
 153 |     | <span class='neutral'>    }  </span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    enum CrossStatus {</span>
 156 |     | <span class='neutral'>        RANGE,</span>
 157 |     | <span class='neutral'>        LIMIT,</span>
 158 |     | <span class='neutral'>        BOTH</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/interfaces/structs/RangePoolStructs.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface RangePoolStructs is PoolsharkStructs {</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>    struct RangePosition {</span>
   9 |     | <span class='neutral'>        uint256 feeGrowthInside0Last;</span>
  10 |     | <span class='neutral'>        uint256 feeGrowthInside1Last;</span>
  11 |     | <span class='neutral'>        uint128 liquidity;</span>
  12 |     | <span class='neutral'>        int24 lower;</span>
  13 |     | <span class='neutral'>        int24 upper;</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    struct MintRangeParams {</span>
  17 |     | <span class='neutral'>        address to;</span>
  18 |     | <span class='neutral'>        int24 lower;</span>
  19 |     | <span class='neutral'>        int24 upper;</span>
  20 |     | <span class='neutral'>        uint32 positionId;</span>
  21 |     | <span class='neutral'>        uint128 amount0;</span>
  22 |     | <span class='neutral'>        uint128 amount1;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    struct BurnRangeParams {</span>
  26 |     | <span class='neutral'>        address to;</span>
  27 |     | <span class='neutral'>        uint32 positionId;</span>
  28 |     | <span class='neutral'>        uint128 burnPercent;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    struct CompoundRangeParams {</span>
  32 |     | <span class='neutral'>        uint160 priceLower;</span>
  33 |     | <span class='neutral'>        uint160 priceUpper;</span>
  34 |     | <span class='neutral'>        uint128 amount0;</span>
  35 |     | <span class='neutral'>        uint128 amount1;</span>
  36 |     | <span class='neutral'>        uint32 positionId;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct SampleParams {</span>
  40 |     | <span class='neutral'>        uint16 sampleIndex;</span>
  41 |     | <span class='neutral'>        uint16 sampleLength;</span>
  42 |     | <span class='neutral'>        uint32 time;</span>
  43 |     | <span class='neutral'>        uint32[] secondsAgo;</span>
  44 |     | <span class='neutral'>        int24 tick;</span>
  45 |     | <span class='neutral'>        uint128 liquidity;</span>
  46 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    struct UpdateParams {</span>
  50 |     | <span class='neutral'>        int24 lower;</span>
  51 |     | <span class='neutral'>        int24 upper;</span>
  52 |     | <span class='neutral'>        uint32 positionId;</span>
  53 |     | <span class='neutral'>        uint128 burnPercent;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct MintRangeCache {</span>
  57 |     | <span class='neutral'>        GlobalState state;</span>
  58 |     | <span class='neutral'>        RangePosition position;</span>
  59 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  60 |     | <span class='neutral'>        uint256 liquidityMinted;</span>
  61 |     | <span class='neutral'>        uint160 priceLower;</span>
  62 |     | <span class='neutral'>        uint160 priceUpper;</span>
  63 |     | <span class='neutral'>        int128 amount0;</span>
  64 |     | <span class='neutral'>        int128 amount1;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    struct BurnRangeCache {</span>
  68 |     | <span class='neutral'>        GlobalState state;</span>
  69 |     | <span class='neutral'>        RangePosition position;</span>
  70 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  71 |     | <span class='neutral'>        uint256 liquidityBurned;</span>
  72 |     | <span class='neutral'>        uint160 priceLower;</span>
  73 |     | <span class='neutral'>        uint160 priceUpper;</span>
  74 |     | <span class='neutral'>        int128 amount0;</span>
  75 |     | <span class='neutral'>        int128 amount1;</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    struct RangePositionCache {</span>
  79 |     | <span class='neutral'>        uint256 liquidityAmount;</span>
  80 |     | <span class='neutral'>        uint256 rangeFeeGrowth0;</span>
  81 |     | <span class='neutral'>        uint256 rangeFeeGrowth1;</span>
  82 |     | <span class='neutral'>        uint128 amountFees0;</span>
  83 |     | <span class='neutral'>        uint128 amountFees1;</span>
  84 |     | <span class='neutral'>        uint128 feesBurned0;</span>
  85 |     | <span class='neutral'>        uint128 feesBurned1;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    struct SnapshotRangeCache {</span>
  89 |     | <span class='neutral'>        RangePosition position;</span>
  90 |     | <span class='neutral'>        SampleState samples;</span>
  91 |     | <span class='neutral'>        PoolsharkStructs.Immutables constants;</span>
  92 |     | <span class='neutral'>        uint160 price;</span>
  93 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum;</span>
  94 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumLower;</span>
  95 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccumUpper;</span>
  96 |     | <span class='neutral'>        uint128 liquidity;</span>
  97 |     | <span class='neutral'>        uint128 amount0;</span>
  98 |     | <span class='neutral'>        uint128 amount1;</span>
  99 |     | <span class='neutral'>        int56   tickSecondsAccum;</span>
 100 |     | <span class='neutral'>        int56   tickSecondsAccumLower;</span>
 101 |     | <span class='neutral'>        int56   tickSecondsAccumUpper;</span>
 102 |     | <span class='neutral'>        uint32  secondsOutsideLower;</span>
 103 |     | <span class='neutral'>        uint32  secondsOutsideUpper;</span>
 104 |     | <span class='neutral'>        uint32  blockTimestamp;</span>
 105 |     | <span class='neutral'>        int24   tick;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'>}</span>
 108 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/Samples.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/range/IRangePool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library Samples {</span>
  11 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    uint8 internal constant TIME_DELTA_MAX = 6;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    error InvalidSampleLength();</span>
  16 |     | <span class='neutral'>    error SampleArrayUninitialized();</span>
  17 |     | <span class='neutral'>    error SampleLengthNotAvailable();</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    event SampleRecorded(</span>
  20 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
  21 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event SampleLengthIncreased(</span>
  25 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
  26 |     | <span class='neutral'>    );</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>    function initialize(</span>
  29 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState memory state</span>
  31 |     | <span class='neutral'>    ) internal returns (</span>
  32 |     | <span class='unexecuted'>        PoolsharkStructs.RangePoolState memory</span>
  33 |     | <span class='neutral'>    )</span>
  34 |     | <span class='neutral'>    {</span>
  35 |     | <span class='unexecuted'>        samples[0] = PoolsharkStructs.Sample({</span>
  36 |     | <span class='unexecuted'>            blockTimestamp: uint32(block.timestamp),</span>
  37 |     | <span class='unexecuted'>            tickSecondsAccum: 0,</span>
  38 |     | <span class='unexecuted'>            secondsPerLiquidityAccum: 0</span>
  39 |     | <span class='neutral'>        });</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>        state.samples.length = 1;</span>
  42 |     | <span class='unexecuted'>        state.samples.lengthNext = 5;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>        return state;</span>
  45 |     | <span class='neutral'>        /// @dev - TWAP length of 5 is safer for oracle manipulation</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>    function save(</span>
  49 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  50 |     | <span class='neutral'>        PoolsharkStructs.SampleState memory sampleState,</span>
  51 |     | <span class='neutral'>        uint128 startLiquidity, /// @dev - liquidity from start of block</span>
  52 |     | <span class='neutral'>        int24  tick</span>
  53 |     | <span class='neutral'>    ) internal returns (</span>
  54 |     | <span class='unexecuted'>        uint16 sampleIndexNew,</span>
  55 |     | <span class='unexecuted'>        uint16 sampleLengthNew</span>
  56 |     | <span class='unexecuted'>    ) {</span>
  57 |     | <span class='neutral'>        // grab the latest sample</span>
  58 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory newSample = samples[sampleState.index];</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>        // early return if timestamp has not advanced 2 seconds</span>
  61 |     | <span class='unexecuted'>        if (newSample.blockTimestamp + 2 &gt; uint32(block.timestamp))</span>
  62 |     | <span class='unexecuted'>            return (sampleState.index, sampleState.length);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>        if (sampleState.lengthNext &gt; sampleState.length</span>
  65 |     | <span class='unexecuted'>            &amp;&amp; sampleState.index == (sampleState.length - 1)) {</span>
  66 |     | <span class='neutral'>            // increase sampleLengthNew if old size exceeded</span>
  67 |     | <span class='unexecuted'>            sampleLengthNew = sampleState.lengthNext;</span>
  68 |     | <span class='neutral'>        } else {</span>
  69 |     | <span class='unexecuted'>            sampleLengthNew = sampleState.length;</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='unexecuted'>        sampleIndexNew = (sampleState.index + 1) % sampleLengthNew;</span>
  72 |     | <span class='unexecuted'>        samples[sampleIndexNew] = _build(newSample, uint32(block.timestamp), tick, startLiquidity);</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>        emit SampleRecorded(</span>
  75 |     | <span class='unexecuted'>            samples[sampleIndexNew].tickSecondsAccum,</span>
  76 |     | <span class='unexecuted'>            samples[sampleIndexNew].secondsPerLiquidityAccum</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function expand(</span>
  81 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  82 |     | <span class='neutral'>        PoolsharkStructs.RangePoolState storage pool,</span>
  83 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
  84 |     | <span class='neutral'>    ) internal {</span>
  85 |     | <span class='unexecuted'>        if (sampleLengthNext &lt;= pool.samples.lengthNext) return ;</span>
  86 |     | <span class='unexecuted'>        for (uint16 i = pool.samples.lengthNext; i &lt; sampleLengthNext; i++) {</span>
  87 |     | <span class='unexecuted'>            samples[i].blockTimestamp = 1;</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='unexecuted'>        pool.samples.lengthNext = sampleLengthNext;</span>
  90 |     | <span class='unexecuted'>        emit SampleLengthIncreased(sampleLengthNext);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function get(</span>
  94 |     | <span class='neutral'>        address pool,</span>
  95 |     | <span class='neutral'>        RangePoolStructs.SampleParams memory params</span>
  96 |     | <span class='neutral'>    ) internal view returns (</span>
  97 |     | <span class='unexecuted'>        int56[]   memory tickSecondsAccum,</span>
  98 |     | <span class='unexecuted'>        uint160[] memory secondsPerLiquidityAccum,</span>
  99 |     | <span class='unexecuted'>        uint160 averagePrice,</span>
 100 |     | <span class='unexecuted'>        uint128 averageLiquidity,</span>
 101 |     | <span class='unexecuted'>        int24 averageTick</span>
 102 |     | <span class='unexecuted'>    ) {</span>
 103 |     | <span class='unexecuted'>        if (params.sampleLength == 0) require(false, &#39;InvalidSampleLength()&#39;);</span>
 104 |     | <span class='unexecuted'>        if (params.secondsAgo.length == 0) require(false, &#39;SecondsAgoArrayEmpty()&#39;);</span>
 105 |     | <span class='unexecuted'>        uint256 size = params.secondsAgo.length &gt; 1 ? params.secondsAgo.length : 2;</span>
 106 |     | <span class='unexecuted'>        uint32[] memory secondsAgo = new uint32[](size);</span>
 107 |     | <span class='unexecuted'>        if (params.secondsAgo.length == 1) {</span>
 108 |     | <span class='unexecuted'>            secondsAgo = new uint32[](2);</span>
 109 |     | <span class='unexecuted'>            secondsAgo[0] = params.secondsAgo[0];</span>
 110 |     | <span class='unexecuted'>            secondsAgo[1] = params.secondsAgo[0] + 2;</span>
 111 |     | <span class='neutral'>        }</span>
 112 |     | <span class='unexecuted'>        else secondsAgo = params.secondsAgo;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        if (secondsAgo[0] == secondsAgo[secondsAgo.length - 1]) require(false, &#39;SecondsAgoArrayValuesEqual()&#39;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        tickSecondsAccum = new int56[](secondsAgo.length);</span>
 117 |     | <span class='unexecuted'>        secondsPerLiquidityAccum = new uint160[](secondsAgo.length);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; secondsAgo.length; i++) {</span>
 120 |     | <span class='unexecuted'>            (</span>
 121 |     | <span class='unexecuted'>                tickSecondsAccum[i],</span>
 122 |     | <span class='unexecuted'>                secondsPerLiquidityAccum[i]</span>
 123 |     | <span class='unexecuted'>            ) = getSingle(</span>
 124 |     | <span class='unexecuted'>                IPool(pool),</span>
 125 |     | <span class='unexecuted'>                params,</span>
 126 |     | <span class='unexecuted'>                secondsAgo[i]</span>
 127 |     | <span class='neutral'>            );</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='unexecuted'>        if (secondsAgo[secondsAgo.length - 1] &gt; secondsAgo[0]) {</span>
 130 |     | <span class='unexecuted'>            averageTick = int24((tickSecondsAccum[0] - tickSecondsAccum[secondsAgo.length - 1]) </span>
 131 |     | <span class='unexecuted'>                                / int32(secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));</span>
 132 |     | <span class='unexecuted'>            averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);</span>
 133 |     | <span class='unexecuted'>            averageLiquidity = uint128((secondsPerLiquidityAccum[0] - secondsPerLiquidityAccum[secondsAgo.length - 1]) </span>
 134 |     | <span class='unexecuted'>                                    * (secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));</span>
 135 |     | <span class='neutral'>        } else {</span>
 136 |     | <span class='unexecuted'>            averageTick = int24((tickSecondsAccum[secondsAgo.length - 1] - tickSecondsAccum[0]) </span>
 137 |     | <span class='unexecuted'>                                / int32(secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));</span>
 138 |     | <span class='unexecuted'>            averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);</span>
 139 |     | <span class='unexecuted'>            averageLiquidity = uint128((secondsPerLiquidityAccum[secondsAgo.length - 1] - secondsPerLiquidityAccum[0]) </span>
 140 |     | <span class='unexecuted'>                                    * (secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function _poolSample(</span>
 145 |     | <span class='neutral'>        IPool pool,</span>
 146 |     | <span class='neutral'>        uint256 sampleIndex</span>
 147 |     | <span class='neutral'>    ) internal view returns (</span>
 148 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory</span>
 149 |     | <span class='neutral'>    ) {</span>
 150 |     | <span class='unexecuted'>        (</span>
 151 |     | <span class='unexecuted'>            uint32 blockTimestamp,</span>
 152 |     | <span class='unexecuted'>            int56 tickSecondsAccum,</span>
 153 |     | <span class='unexecuted'>            uint160 liquidityPerSecondsAccum</span>
 154 |     | <span class='unexecuted'>        ) = pool.samples(sampleIndex);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='unexecuted'>        return PoolsharkStructs.Sample(</span>
 157 |     | <span class='unexecuted'>            blockTimestamp,</span>
 158 |     | <span class='unexecuted'>            tickSecondsAccum,</span>
 159 |     | <span class='unexecuted'>            liquidityPerSecondsAccum</span>
 160 |     | <span class='neutral'>        );</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>    function getSingle(</span>
 164 |     | <span class='neutral'>        IPool pool,</span>
 165 |     | <span class='neutral'>        RangePoolStructs.SampleParams memory params,</span>
 166 |     | <span class='neutral'>        uint32 secondsAgo</span>
 167 |     | <span class='neutral'>    ) internal view returns (</span>
 168 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 169 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum</span>
 170 |     | <span class='neutral'>    ) {</span>
 171 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory latest = _poolSample(pool, params.sampleIndex);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='unexecuted'>        if (secondsAgo == 0) {</span>
 174 |     | <span class='unexecuted'>            if (latest.blockTimestamp != uint32(block.timestamp)) {</span>
 175 |     | <span class='unexecuted'>                latest = _build(</span>
 176 |     | <span class='unexecuted'>                    latest,</span>
 177 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 178 |     | <span class='unexecuted'>                    params.tick,</span>
 179 |     | <span class='unexecuted'>                    params.liquidity</span>
 180 |     | <span class='neutral'>                );</span>
 181 |     | <span class='neutral'>            } </span>
 182 |     | <span class='unexecuted'>            return (</span>
 183 |     | <span class='unexecuted'>                latest.tickSecondsAccum,</span>
 184 |     | <span class='unexecuted'>                latest.secondsPerLiquidityAccum</span>
 185 |     | <span class='neutral'>            );</span>
 186 |     | <span class='neutral'>        }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='unexecuted'>        uint32 targetTime = uint32(block.timestamp) - secondsAgo;</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>        // should be getting samples</span>
 191 |     | <span class='unexecuted'>        (</span>
 192 |     | <span class='unexecuted'>            RangePoolStructs.Sample memory firstSample,</span>
 193 |     | <span class='unexecuted'>            RangePoolStructs.Sample memory secondSample</span>
 194 |     | <span class='unexecuted'>        ) = _getAdjacentSamples(</span>
 195 |     | <span class='unexecuted'>                pool,</span>
 196 |     | <span class='unexecuted'>                latest,</span>
 197 |     | <span class='unexecuted'>                params,</span>
 198 |     | <span class='unexecuted'>                targetTime</span>
 199 |     | <span class='neutral'>        );</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>        if (targetTime == firstSample.blockTimestamp) {</span>
 202 |     | <span class='neutral'>            // first sample</span>
 203 |     | <span class='unexecuted'>            return (</span>
 204 |     | <span class='unexecuted'>                firstSample.tickSecondsAccum,</span>
 205 |     | <span class='unexecuted'>                firstSample.secondsPerLiquidityAccum</span>
 206 |     | <span class='neutral'>            );</span>
 207 |     | <span class='unexecuted'>        } else if (targetTime == secondSample.blockTimestamp) {</span>
 208 |     | <span class='neutral'>            // second sample</span>
 209 |     | <span class='unexecuted'>            return (</span>
 210 |     | <span class='unexecuted'>                secondSample.tickSecondsAccum,</span>
 211 |     | <span class='unexecuted'>                secondSample.secondsPerLiquidityAccum</span>
 212 |     | <span class='neutral'>            );</span>
 213 |     | <span class='neutral'>        } else {</span>
 214 |     | <span class='neutral'>            // average two samples</span>
 215 |     | <span class='unexecuted'>            int32 sampleTimeDelta = int32(secondSample.blockTimestamp - firstSample.blockTimestamp);</span>
 216 |     | <span class='unexecuted'>            int56 targetDelta = int56(int32(targetTime - firstSample.blockTimestamp));</span>
 217 |     | <span class='unexecuted'>            return (</span>
 218 |     | <span class='unexecuted'>                firstSample.tickSecondsAccum +</span>
 219 |     | <span class='unexecuted'>                    ((secondSample.tickSecondsAccum - firstSample.tickSecondsAccum) </span>
 220 |     | <span class='unexecuted'>                    / sampleTimeDelta)</span>
 221 |     | <span class='unexecuted'>                    * targetDelta,</span>
 222 |     | <span class='unexecuted'>                firstSample.secondsPerLiquidityAccum +</span>
 223 |     | <span class='neutral'>                    uint160(</span>
 224 |     | <span class='unexecuted'>                        (uint256(</span>
 225 |     | <span class='unexecuted'>                            secondSample.secondsPerLiquidityAccum - firstSample.secondsPerLiquidityAccum</span>
 226 |     | <span class='neutral'>                        ) </span>
 227 |     | <span class='unexecuted'>                        * uint256(uint56(targetDelta))) </span>
 228 |     | <span class='unexecuted'>                        / uint32(sampleTimeDelta)</span>
 229 |     | <span class='neutral'>                    )</span>
 230 |     | <span class='neutral'>            );</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>    function getLatest(</span>
 235 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 236 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 237 |     | <span class='neutral'>        uint256 liquidity</span>
 238 |     | <span class='neutral'>    ) internal view returns (</span>
 239 |     | <span class='unexecuted'>        uint160 latestPrice,</span>
 240 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum,</span>
 241 |     | <span class='unexecuted'>        int56 tickSecondsAccum</span>
 242 |     | <span class='unexecuted'>    ) {</span>
 243 |     | <span class='unexecuted'>        uint32 timeDelta = timeElapsed(constants);</span>
 244 |     | <span class='unexecuted'>        (</span>
 245 |     | <span class='neutral'>            tickSecondsAccum,</span>
 246 |     | <span class='neutral'>            secondsPerLiquidityAccum</span>
 247 |     | <span class='unexecuted'>        ) = getSingle(</span>
 248 |     | <span class='unexecuted'>                IPool(address(this)), </span>
 249 |     | <span class='unexecuted'>                RangePoolStructs.SampleParams(</span>
 250 |     | <span class='unexecuted'>                    state.pool.samples.index,</span>
 251 |     | <span class='unexecuted'>                    state.pool.samples.length,</span>
 252 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 253 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 254 |     | <span class='unexecuted'>                    state.pool.tickAtPrice,</span>
 255 |     | <span class='unexecuted'>                    liquidity.toUint128(),</span>
 256 |     | <span class='unexecuted'>                    constants</span>
 257 |     | <span class='neutral'>                ),</span>
 258 |     | <span class='unexecuted'>                0</span>
 259 |     | <span class='neutral'>        );</span>
 260 |     | <span class='neutral'>        // grab older sample for dynamic fee calculation</span>
 261 |     | <span class='unexecuted'>        (</span>
 262 |     | <span class='unexecuted'>            int56 tickSecondsAccumBase,</span>
 263 |     | <span class='unexecuted'>        ) = Samples.getSingle(</span>
 264 |     | <span class='unexecuted'>                IPool(address(this)), </span>
 265 |     | <span class='unexecuted'>                RangePoolStructs.SampleParams(</span>
 266 |     | <span class='unexecuted'>                    state.pool.samples.index,</span>
 267 |     | <span class='unexecuted'>                    state.pool.samples.length,</span>
 268 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 269 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 270 |     | <span class='unexecuted'>                    state.pool.tickAtPrice,</span>
 271 |     | <span class='unexecuted'>                    liquidity.toUint128(),</span>
 272 |     | <span class='unexecuted'>                    constants</span>
 273 |     | <span class='neutral'>                ),</span>
 274 |     | <span class='unexecuted'>                timeDelta</span>
 275 |     | <span class='neutral'>        );</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        latestPrice = calculateLatestPrice(</span>
 278 |     | <span class='unexecuted'>            tickSecondsAccum,</span>
 279 |     | <span class='unexecuted'>            tickSecondsAccumBase,</span>
 280 |     | <span class='unexecuted'>            timeDelta,</span>
 281 |     | <span class='neutral'>            TIME_DELTA_MAX,</span>
 282 |     | <span class='unexecuted'>            constants</span>
 283 |     | <span class='neutral'>        );</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>    function calculateLatestPrice(</span>
 287 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
 288 |     | <span class='neutral'>        int56 tickSecondsAccumBase,</span>
 289 |     | <span class='neutral'>        uint32 timeDelta,</span>
 290 |     | <span class='neutral'>        uint32 timeDeltaMax,</span>
 291 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 292 |     | <span class='neutral'>    ) private pure returns (</span>
 293 |     | <span class='unexecuted'>        uint160 averagePrice</span>
 294 |     | <span class='unexecuted'>    ) {</span>
 295 |     | <span class='unexecuted'>        int56 tickSecondsAccumDiff = tickSecondsAccum - tickSecondsAccumBase;</span>
 296 |     | <span class='unexecuted'>        int24 averageTick;</span>
 297 |     | <span class='unexecuted'>        if (timeDelta == timeDeltaMax) {</span>
 298 |     | <span class='unexecuted'>            averageTick = int24(tickSecondsAccumDiff / int32(timeDelta));</span>
 299 |     | <span class='neutral'>        } else {</span>
 300 |     | <span class='unexecuted'>            averageTick = int24(tickSecondsAccum / int32(timeDelta));</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='unexecuted'>        averagePrice = ConstantProduct.getPriceAtTick(averageTick, constants);</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>    function timeElapsed(</span>
 307 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 308 |     | <span class='neutral'>    ) private view returns (</span>
 309 |     | <span class='unexecuted'>        uint32</span>
 310 |     | <span class='neutral'>    )    </span>
 311 |     | <span class='neutral'>    {</span>
 312 |     | <span class='unexecuted'>        return  uint32(block.timestamp) - constants.genesisTime &gt;= TIME_DELTA_MAX</span>
 313 |     | <span class='neutral'>                    ? TIME_DELTA_MAX</span>
 314 |     | <span class='unexecuted'>                    : uint32(block.timestamp - constants.genesisTime);</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='unexecuted'>    function _lte(</span>
 318 |     | <span class='neutral'>        uint32 timeA,</span>
 319 |     | <span class='neutral'>        uint32 timeB</span>
 320 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 321 |     | <span class='unexecuted'>        uint32 currentTime = uint32(block.timestamp);</span>
 322 |     | <span class='unexecuted'>        if (timeA &lt;= currentTime &amp;&amp; timeB &lt;= currentTime) return timeA &lt;= timeB;</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='unexecuted'>        uint256 timeAOverflow = timeA;</span>
 325 |     | <span class='unexecuted'>        uint256 timeBOverflow = timeB;</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>        if (timeA &lt;= currentTime) {</span>
 328 |     | <span class='unexecuted'>            timeAOverflow = timeA + 2**32;</span>
 329 |     | <span class='neutral'>        }</span>
 330 |     | <span class='unexecuted'>        if (timeB &lt;= currentTime) {</span>
 331 |     | <span class='unexecuted'>            timeBOverflow = timeB + 2**32;</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>        return timeAOverflow &lt;= timeBOverflow;</span>
 335 |     | <span class='neutral'>    }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>    function _build(</span>
 338 |     | <span class='neutral'>        RangePoolStructs.Sample memory newSample,</span>
 339 |     | <span class='neutral'>        uint32  blockTimestamp,</span>
 340 |     | <span class='neutral'>        int24   tick,</span>
 341 |     | <span class='neutral'>        uint128 liquidity</span>
 342 |     | <span class='neutral'>    ) internal pure returns (</span>
 343 |     | <span class='unexecuted'>         RangePoolStructs.Sample memory</span>
 344 |     | <span class='neutral'>    ) {</span>
 345 |     | <span class='unexecuted'>        int56 timeDelta = int56(uint56(blockTimestamp - newSample.blockTimestamp));</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='unexecuted'>        return</span>
 348 |     | <span class='unexecuted'>            PoolsharkStructs.Sample({</span>
 349 |     | <span class='unexecuted'>                blockTimestamp: blockTimestamp,</span>
 350 |     | <span class='unexecuted'>                tickSecondsAccum: newSample.tickSecondsAccum + int56(tick) * int32(timeDelta),</span>
 351 |     | <span class='unexecuted'>                secondsPerLiquidityAccum: newSample.secondsPerLiquidityAccum +</span>
 352 |     | <span class='unexecuted'>                    ((uint160(uint56(timeDelta)) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1))</span>
 353 |     | <span class='neutral'>            });</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>    function _binarySearch(</span>
 357 |     | <span class='neutral'>        IPool pool,</span>
 358 |     | <span class='neutral'>        uint32 targetTime,</span>
 359 |     | <span class='neutral'>        uint16 sampleIndex,</span>
 360 |     | <span class='neutral'>        uint16 sampleLength</span>
 361 |     | <span class='neutral'>    ) private view returns (</span>
 362 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory firstSample,</span>
 363 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory secondSample</span>
 364 |     | <span class='unexecuted'>    ) {</span>
 365 |     | <span class='unexecuted'>        uint256 oldIndex = (sampleIndex + 1) % sampleLength;</span>
 366 |     | <span class='unexecuted'>        uint256 newIndex = oldIndex + sampleLength - 1;             </span>
 367 |     | <span class='unexecuted'>        uint256 index;</span>
 368 |     | <span class='unexecuted'>        while (true) {</span>
 369 |     | <span class='neutral'>            // start in the middle</span>
 370 |     | <span class='unexecuted'>            index = (oldIndex + newIndex) / 2;</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>            // get the first sample</span>
 373 |     | <span class='unexecuted'>            firstSample = _poolSample(pool, index % sampleLength);</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>            // if sample is uninitialized</span>
 376 |     | <span class='unexecuted'>            if (firstSample.blockTimestamp == 0) {</span>
 377 |     | <span class='neutral'>                // skip this index and continue</span>
 378 |     | <span class='unexecuted'>                oldIndex = index + 1;</span>
 379 |     | <span class='unexecuted'>                continue;</span>
 380 |     | <span class='neutral'>            }</span>
 381 |     | <span class='neutral'>            // else grab second sample</span>
 382 |     | <span class='unexecuted'>            secondSample = _poolSample(pool, (index + 1) % sampleLength);</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>            // check if target time within first and second sample</span>
 385 |     | <span class='unexecuted'>            bool targetAfterFirst   = _lte(firstSample.blockTimestamp, targetTime);</span>
 386 |     | <span class='unexecuted'>            bool targetBeforeSecond = _lte(targetTime, secondSample.blockTimestamp);</span>
 387 |     | <span class='unexecuted'>            if (targetAfterFirst &amp;&amp; targetBeforeSecond) break;</span>
 388 |     | <span class='unexecuted'>            if (!targetAfterFirst) newIndex = index - 1;</span>
 389 |     | <span class='unexecuted'>            else oldIndex = index + 1;</span>
 390 |     | <span class='neutral'>        }</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='unexecuted'>    function _getAdjacentSamples(</span>
 394 |     | <span class='neutral'>        IPool pool,</span>
 395 |     | <span class='neutral'>        RangePoolStructs.Sample memory firstSample,</span>
 396 |     | <span class='neutral'>        RangePoolStructs.SampleParams memory params,</span>
 397 |     | <span class='neutral'>        uint32 targetTime</span>
 398 |     | <span class='neutral'>    ) private view returns (</span>
 399 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory,</span>
 400 |     | <span class='unexecuted'>        RangePoolStructs.Sample memory</span>
 401 |     | <span class='neutral'>    ) {</span>
 402 |     | <span class='unexecuted'>        if (_lte(firstSample.blockTimestamp, targetTime)) {</span>
 403 |     | <span class='unexecuted'>            if (firstSample.blockTimestamp == targetTime) {</span>
 404 |     | <span class='unexecuted'>                return (firstSample, PoolsharkStructs.Sample(0,0,0));</span>
 405 |     | <span class='neutral'>            } else {</span>
 406 |     | <span class='unexecuted'>                return (firstSample, _build(firstSample, targetTime, params.tick, params.liquidity));</span>
 407 |     | <span class='neutral'>            }</span>
 408 |     | <span class='neutral'>        }</span>
 409 |     | <span class='unexecuted'>        firstSample = _poolSample(pool, (params.sampleIndex + 1) % params.sampleLength);</span>
 410 |     | <span class='unexecuted'>        if (firstSample.blockTimestamp == 0) {</span>
 411 |     | <span class='unexecuted'>            firstSample = _poolSample(pool, 0);</span>
 412 |     | <span class='neutral'>        }</span>
 413 |     | <span class='unexecuted'>        if(!_lte(firstSample.blockTimestamp, targetTime)) require(false, &#39;SampleLengthNotAvailable()&#39;);</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='unexecuted'>        return _binarySearch(</span>
 416 |     | <span class='unexecuted'>            pool,</span>
 417 |     | <span class='unexecuted'>            targetTime,</span>
 418 |     | <span class='unexecuted'>            params.sampleIndex,</span>
 419 |     | <span class='unexecuted'>            params.sampleLength</span>
 420 |     | <span class='neutral'>        );</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/TickMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library TickMap {</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    error TickIndexOverflow();</span>
  10 |     | <span class='neutral'>    error TickIndexUnderflow();</span>
  11 |     | <span class='neutral'>    error TickIndexBadSpacing();</span>
  12 |     | <span class='neutral'>    error BlockIndexOverflow();</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function get(</span>
  15 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  16 |     | <span class='neutral'>        int24 tick,</span>
  17 |     | <span class='neutral'>        int24 tickSpacing</span>
  18 |     | <span class='neutral'>    ) internal view returns (</span>
  19 |     | <span class='unexecuted'>        bool exists</span>
  20 |     | <span class='neutral'>    ) {</span>
  21 |     | <span class='unexecuted'>        (</span>
  22 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  23 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  24 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // check if bit is already set</span>
  27 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  28 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  29 |     | <span class='unexecuted'>            return true;</span>
  30 |     | <span class='neutral'>        }</span>
  31 |     | <span class='unexecuted'>        return false;</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>    function set(</span>
  35 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  36 |     | <span class='neutral'>        int24 tick,</span>
  37 |     | <span class='neutral'>        int24 tickSpacing</span>
  38 |     | <span class='neutral'>    ) internal returns (</span>
  39 |     | <span class='unexecuted'>        bool exists</span>
  40 |     | <span class='neutral'>    ) {</span>
  41 |     | <span class='unexecuted'>        (</span>
  42 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  43 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  44 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  45 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>        // check if bit is already set</span>
  48 |     | <span class='unexecuted'>        uint256 word = tickMap.ticks[wordIndex] | 1 &lt;&lt; (tickIndex &amp; 0xFF);</span>
  49 |     | <span class='unexecuted'>        if (word == tickMap.ticks[wordIndex]) {</span>
  50 |     | <span class='unexecuted'>            return true;</span>
  51 |     | <span class='neutral'>        }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex]     = word; </span>
  54 |     | <span class='unexecuted'>        tickMap.words[blockIndex]   |= 1 &lt;&lt; (wordIndex &amp; 0xFF); // same as modulus 255</span>
  55 |     | <span class='unexecuted'>        tickMap.blocks              |= 1 &lt;&lt; blockIndex;</span>
  56 |     | <span class='unexecuted'>        return false;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>    function unset(</span>
  60 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  61 |     | <span class='neutral'>        int24 tick,</span>
  62 |     | <span class='neutral'>        int16 tickSpacing</span>
  63 |     | <span class='unexecuted'>    ) internal {</span>
  64 |     | <span class='unexecuted'>        (</span>
  65 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  66 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  67 |     | <span class='unexecuted'>            uint256 blockIndex</span>
  68 |     | <span class='unexecuted'>        ) = getIndices(tick, tickSpacing);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>        tickMap.ticks[wordIndex] &amp;= ~(1 &lt;&lt; (tickIndex &amp; 0xFF));</span>
  71 |     | <span class='unexecuted'>        if (tickMap.ticks[wordIndex] == 0) {</span>
  72 |     | <span class='unexecuted'>            tickMap.words[blockIndex] &amp;= ~(1 &lt;&lt; (wordIndex &amp; 0xFF));</span>
  73 |     | <span class='unexecuted'>            if (tickMap.words[blockIndex] == 0) {</span>
  74 |     | <span class='unexecuted'>                tickMap.blocks &amp;= ~(1 &lt;&lt; blockIndex);</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function previous(</span>
  80 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  81 |     | <span class='neutral'>        int24 tick,</span>
  82 |     | <span class='neutral'>        int16 tickSpacing,</span>
  83 |     | <span class='neutral'>        bool inclusive</span>
  84 |     | <span class='neutral'>    ) internal view returns (</span>
  85 |     | <span class='unexecuted'>        int24 previousTick</span>
  86 |     | <span class='neutral'>    ) {</span>
  87 |     | <span class='unexecuted'>        unchecked {</span>
  88 |     | <span class='neutral'>            // rounds up to ensure relative position</span>
  89 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0 || inclusive) {</span>
  90 |     | <span class='unexecuted'>                if (tick &lt; (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {</span>
  91 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick &gt;= 0</span>
  92 |     | <span class='unexecuted'>                    if (tick &gt;= 0) {</span>
  93 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  94 |     | <span class='unexecuted'>                    } else if (inclusive &amp;&amp; tick % (tickSpacing / 2) == 0) {</span>
  95 |     | <span class='neutral'>                    /// @dev - ensures we cross when tick == tickAtPrice</span>
  96 |     | <span class='unexecuted'>                        tick += tickSpacing / 2;</span>
  97 |     | <span class='neutral'>                    }</span>
  98 |     | <span class='neutral'>                }</span>
  99 |     | <span class='neutral'>            }</span>
 100 |     | <span class='unexecuted'>            (</span>
 101 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 102 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 103 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 104 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>            uint256 word = tickMap.ticks[wordIndex] &amp; ((1 &lt;&lt; (tickIndex &amp; 0xFF)) - 1);</span>
 107 |     | <span class='unexecuted'>            if (word == 0) {</span>
 108 |     | <span class='unexecuted'>                uint256 block_ = tickMap.words[blockIndex] &amp; ((1 &lt;&lt; (wordIndex &amp; 0xFF)) - 1);</span>
 109 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 110 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ((1 &lt;&lt; blockIndex) - 1);</span>
 111 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>                    blockIndex = _msb(blockMap);</span>
 114 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 115 |     | <span class='neutral'>                }</span>
 116 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _msb(block_);</span>
 117 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 118 |     | <span class='neutral'>            }</span>
 119 |     | <span class='unexecuted'>            previousTick = _tick((wordIndex &lt;&lt; 8) | _msb(word), tickSpacing);</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function next(</span>
 124 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 125 |     | <span class='neutral'>        int24 tick,</span>
 126 |     | <span class='neutral'>        int16 tickSpacing,</span>
 127 |     | <span class='neutral'>        bool inclusive</span>
 128 |     | <span class='neutral'>    ) internal view returns (</span>
 129 |     | <span class='unexecuted'>        int24 nextTick</span>
 130 |     | <span class='neutral'>    ) {</span>
 131 |     | <span class='unexecuted'>        unchecked {</span>
 132 |     | <span class='neutral'>            /// @dev - handles tickAtPrice being past tickSpacing / 2</span>
 133 |     | <span class='unexecuted'>            if (inclusive &amp;&amp; tick % tickSpacing != 0) {</span>
 134 |     | <span class='neutral'>                // e.g. tick is 5 we subtract 1 to look ahead at 5</span>
 135 |     | <span class='unexecuted'>                if (tick &gt; 0 &amp;&amp; (tick % tickSpacing &lt;= (tickSpacing / 2)))</span>
 136 |     | <span class='unexecuted'>                    tick -= 1;</span>
 137 |     | <span class='neutral'>                // e.g. tick is -5 we subtract 1 to look ahead at -5</span>
 138 |     | <span class='unexecuted'>                else if (tick &lt; 0 &amp;&amp; (tick % tickSpacing &lt;= -(tickSpacing / 2)))</span>
 139 |     | <span class='unexecuted'>                    tick -= 1;</span>
 140 |     | <span class='neutral'>                // e.g. tick = 7 and tickSpacing = 10 we sub 5 to look ahead at 5</span>
 141 |     | <span class='neutral'>                // e.g. tick = -2 and tickSpacing = 10 we sub 5 to look ahead at -5</span>
 142 |     | <span class='neutral'>                else</span>
 143 |     | <span class='unexecuted'>                    tick -= tickSpacing / 2;</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>            /// @dev - handles negative ticks rounding up</span>
 146 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) {</span>
 147 |     | <span class='unexecuted'>                if (tick &lt; 0)</span>
 148 |     | <span class='unexecuted'>                    if (tick &gt; (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))</span>
 149 |     | <span class='unexecuted'>                        tick -= tickSpacing / 2;</span>
 150 |     | <span class='neutral'>            }</span>
 151 |     | <span class='unexecuted'>            (</span>
 152 |     | <span class='unexecuted'>              uint256 tickIndex,</span>
 153 |     | <span class='unexecuted'>              uint256 wordIndex,</span>
 154 |     | <span class='unexecuted'>              uint256 blockIndex</span>
 155 |     | <span class='unexecuted'>            ) = getIndices(tick, tickSpacing);</span>
 156 |     | <span class='unexecuted'>            uint256 word;</span>
 157 |     | <span class='unexecuted'>            if ((tickIndex &amp; 0xFF) != 255) {</span>
 158 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex] &amp; ~((1 &lt;&lt; ((tickIndex &amp; 0xFF) + 1)) - 1);</span>
 159 |     | <span class='neutral'>            }</span>
 160 |     | <span class='unexecuted'>            if (word == 0) {</span>
 161 |     | <span class='unexecuted'>                uint256 block_;</span>
 162 |     | <span class='unexecuted'>                if ((blockIndex &amp; 0xFF) != 255) {</span>
 163 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex] &amp; ~((1 &lt;&lt; ((wordIndex &amp; 0xFF) + 1)) - 1);</span>
 164 |     | <span class='neutral'>                }</span>
 165 |     | <span class='unexecuted'>                if (block_ == 0) {</span>
 166 |     | <span class='unexecuted'>                    uint256 blockMap = tickMap.blocks &amp; ~((1 &lt;&lt; blockIndex + 1) - 1);</span>
 167 |     | <span class='unexecuted'>                    if (blockMap == 0) return tick;</span>
 168 |     | <span class='unexecuted'>                    blockIndex = _lsb(blockMap);</span>
 169 |     | <span class='unexecuted'>                    block_ = tickMap.words[blockIndex];</span>
 170 |     | <span class='neutral'>                }</span>
 171 |     | <span class='unexecuted'>                wordIndex = (blockIndex &lt;&lt; 8) | _lsb(block_);</span>
 172 |     | <span class='unexecuted'>                word = tickMap.ticks[wordIndex];</span>
 173 |     | <span class='neutral'>            }</span>
 174 |     | <span class='unexecuted'>            nextTick = _tick((wordIndex &lt;&lt; 8) | _lsb(word), tickSpacing);</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function getIndices(</span>
 179 |     | <span class='neutral'>        int24 tick,</span>
 180 |     | <span class='neutral'>        int24 tickSpacing</span>
 181 |     | <span class='neutral'>    ) public pure returns (</span>
 182 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
 183 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
 184 |     | <span class='unexecuted'>            uint256 blockIndex</span>
 185 |     | <span class='neutral'>        )</span>
 186 |     | <span class='neutral'>    {</span>
 187 |     | <span class='neutral'>        unchecked {</span>
 188 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.MAX_TICK) require(false, &#39; TickIndexOverflow()&#39;);</span>
 189 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.MIN_TICK) require(false, &#39;TickIndexUnderflow()&#39;);</span>
 190 |     | <span class='unexecuted'>            if (tick % (tickSpacing / 2) != 0) tick = round(tick, tickSpacing / 2);</span>
 191 |     | <span class='unexecuted'>            tickIndex = uint256(int256((round(tick, tickSpacing / 2) </span>
 192 |     | <span class='unexecuted'>                                        - round(ConstantProduct.MIN_TICK, tickSpacing / 2)) </span>
 193 |     | <span class='unexecuted'>                                        / (tickSpacing / 2)));</span>
 194 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 8;   // 2^8 ticks per word</span>
 195 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 16; // 2^8 words per block</span>
 196 |     | <span class='unexecuted'>            if (blockIndex &gt; 255) require(false, &#39;BlockIndexOverflow()&#39;);</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>    function _tick (</span>
 203 |     | <span class='neutral'>        uint256 tickIndex,</span>
 204 |     | <span class='neutral'>        int24 tickSpacing</span>
 205 |     | <span class='neutral'>    ) internal pure returns (</span>
 206 |     | <span class='unexecuted'>        int24 tick</span>
 207 |     | <span class='neutral'>    ) {</span>
 208 |     | <span class='neutral'>        unchecked {</span>
 209 |     | <span class='unexecuted'>            if (tickIndex &gt; uint24(round(ConstantProduct.MAX_TICK, tickSpacing) * 2) * 2) </span>
 210 |     | <span class='unexecuted'>                require(false, &#39;TickIndexOverflow()&#39;);</span>
 211 |     | <span class='unexecuted'>            tick = int24(int256(tickIndex) * (tickSpacing / 2) + round(ConstantProduct.MIN_TICK, tickSpacing / 2));</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function _msb(</span>
 216 |     | <span class='neutral'>        uint256 x</span>
 217 |     | <span class='neutral'>    ) internal pure returns (</span>
 218 |     | <span class='unexecuted'>        uint8 r</span>
 219 |     | <span class='neutral'>    ) {</span>
 220 |     | <span class='neutral'>        unchecked {</span>
 221 |     | <span class='unexecuted'>            assert(x &gt; 0);</span>
 222 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000000000000000000000000000) {</span>
 223 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 224 |     | <span class='unexecuted'>                r += 128;</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='unexecuted'>            if (x &gt;= 0x10000000000000000) {</span>
 227 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 228 |     | <span class='unexecuted'>                r += 64;</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='unexecuted'>            if (x &gt;= 0x100000000) {</span>
 231 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 232 |     | <span class='unexecuted'>                r += 32;</span>
 233 |     | <span class='neutral'>            }</span>
 234 |     | <span class='unexecuted'>            if (x &gt;= 0x10000) {</span>
 235 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 236 |     | <span class='unexecuted'>                r += 16;</span>
 237 |     | <span class='neutral'>            }</span>
 238 |     | <span class='unexecuted'>            if (x &gt;= 0x100) {</span>
 239 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 240 |     | <span class='unexecuted'>                r += 8;</span>
 241 |     | <span class='neutral'>            }</span>
 242 |     | <span class='unexecuted'>            if (x &gt;= 0x10) {</span>
 243 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 244 |     | <span class='unexecuted'>                r += 4;</span>
 245 |     | <span class='neutral'>            }</span>
 246 |     | <span class='unexecuted'>            if (x &gt;= 0x4) {</span>
 247 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 248 |     | <span class='unexecuted'>                r += 2;</span>
 249 |     | <span class='neutral'>            }</span>
 250 |     | <span class='unexecuted'>            if (x &gt;= 0x2) r += 1;</span>
 251 |     | <span class='neutral'>        }</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='unexecuted'>    function _lsb(</span>
 255 |     | <span class='neutral'>        uint256 x</span>
 256 |     | <span class='neutral'>    ) internal pure returns (</span>
 257 |     | <span class='unexecuted'>        uint8 r</span>
 258 |     | <span class='neutral'>    ) {</span>
 259 |     | <span class='neutral'>        unchecked {</span>
 260 |     | <span class='unexecuted'>            assert(x &gt; 0); // if x is 0 return 0</span>
 261 |     | <span class='unexecuted'>            r = 255;</span>
 262 |     | <span class='unexecuted'>            if (x &amp; type(uint128).max &gt; 0) {</span>
 263 |     | <span class='unexecuted'>                r -= 128;</span>
 264 |     | <span class='neutral'>            } else {</span>
 265 |     | <span class='unexecuted'>                x &gt;&gt;= 128;</span>
 266 |     | <span class='neutral'>            }</span>
 267 |     | <span class='unexecuted'>            if (x &amp; type(uint64).max &gt; 0) {</span>
 268 |     | <span class='unexecuted'>                r -= 64;</span>
 269 |     | <span class='neutral'>            } else {</span>
 270 |     | <span class='unexecuted'>                x &gt;&gt;= 64;</span>
 271 |     | <span class='neutral'>            }</span>
 272 |     | <span class='unexecuted'>            if (x &amp; type(uint32).max &gt; 0) {</span>
 273 |     | <span class='unexecuted'>                r -= 32;</span>
 274 |     | <span class='neutral'>            } else {</span>
 275 |     | <span class='unexecuted'>                x &gt;&gt;= 32;</span>
 276 |     | <span class='neutral'>            }</span>
 277 |     | <span class='unexecuted'>            if (x &amp; type(uint16).max &gt; 0) {</span>
 278 |     | <span class='unexecuted'>                r -= 16;</span>
 279 |     | <span class='neutral'>            } else {</span>
 280 |     | <span class='unexecuted'>                x &gt;&gt;= 16;</span>
 281 |     | <span class='neutral'>            }</span>
 282 |     | <span class='unexecuted'>            if (x &amp; type(uint8).max &gt; 0) {</span>
 283 |     | <span class='unexecuted'>                r -= 8;</span>
 284 |     | <span class='neutral'>            } else {</span>
 285 |     | <span class='unexecuted'>                x &gt;&gt;= 8;</span>
 286 |     | <span class='neutral'>            }</span>
 287 |     | <span class='unexecuted'>            if (x &amp; 0xf &gt; 0) {</span>
 288 |     | <span class='unexecuted'>                r -= 4;</span>
 289 |     | <span class='neutral'>            } else {</span>
 290 |     | <span class='unexecuted'>                x &gt;&gt;= 4;</span>
 291 |     | <span class='neutral'>            }</span>
 292 |     | <span class='unexecuted'>            if (x &amp; 0x3 &gt; 0) {</span>
 293 |     | <span class='unexecuted'>                r -= 2;</span>
 294 |     | <span class='neutral'>            } else {</span>
 295 |     | <span class='unexecuted'>                x &gt;&gt;= 2;</span>
 296 |     | <span class='neutral'>            }</span>
 297 |     | <span class='unexecuted'>            if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 298 |     | <span class='neutral'>        }</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>    function round(</span>
 302 |     | <span class='neutral'>        int24 tick,</span>
 303 |     | <span class='neutral'>        int24 tickSpacing</span>
 304 |     | <span class='neutral'>    ) internal pure returns (</span>
 305 |     | <span class='unexecuted'>        int24 roundedTick</span>
 306 |     | <span class='neutral'>    ) {</span>
 307 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='unexecuted'>    function roundHalf(</span>
 311 |     | <span class='neutral'>        int24 tick,</span>
 312 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 313 |     | <span class='neutral'>        uint256 price</span>
 314 |     | <span class='neutral'>    ) internal pure returns (</span>
 315 |     | <span class='unexecuted'>        int24 roundedTick,</span>
 316 |     | <span class='unexecuted'>        uint160 roundedTickPrice</span>
 317 |     | <span class='neutral'>    ) {</span>
 318 |     | <span class='neutral'>        //pool.tickAtPrice -99.5</span>
 319 |     | <span class='neutral'>        //pool.tickAtPrice -100</span>
 320 |     | <span class='neutral'>        //-105</span>
 321 |     | <span class='neutral'>        //-95</span>
 322 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 323 |     | <span class='unexecuted'>        roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 324 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 325 |     | <span class='unexecuted'>            return (roundedTick, roundedTickPrice);</span>
 326 |     | <span class='unexecuted'>        if (roundedTick &gt; 0) {</span>
 327 |     | <span class='unexecuted'>            roundedTick += constants.tickSpacing / 2;</span>
 328 |     | <span class='unexecuted'>        } else if (roundedTick &lt; 0) {</span>
 329 |     | <span class='unexecuted'>            if (roundedTickPrice &lt; price)</span>
 330 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 331 |     | <span class='neutral'>            else</span>
 332 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 333 |     | <span class='neutral'>        } else {</span>
 334 |     | <span class='unexecuted'>            if (price &gt; roundedTickPrice) {</span>
 335 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing / 2;</span>
 336 |     | <span class='unexecuted'>            } else if (price &lt; roundedTickPrice) {</span>
 337 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing / 2;</span>
 338 |     | <span class='neutral'>            }</span>
 339 |     | <span class='neutral'>        }</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='unexecuted'>    function roundAhead(</span>
 343 |     | <span class='neutral'>        int24 tick,</span>
 344 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 345 |     | <span class='neutral'>        bool zeroForOne,</span>
 346 |     | <span class='neutral'>        uint256 price</span>
 347 |     | <span class='neutral'>    ) internal pure returns (</span>
 348 |     | <span class='unexecuted'>        int24 roundedTick</span>
 349 |     | <span class='unexecuted'>    ) {</span>
 350 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 351 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 352 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 353 |     | <span class='unexecuted'>            return roundedTick;</span>
 354 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 355 |     | <span class='neutral'>            // round up if positive</span>
 356 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 357 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 358 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 359 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 360 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 361 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 362 |     | <span class='neutral'>                }</span>
 363 |     | <span class='neutral'>            }</span>
 364 |     | <span class='neutral'>        } else {</span>
 365 |     | <span class='neutral'>            // round down if negative</span>
 366 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 367 |     | <span class='neutral'>            /// @dev - strictly less due to TickMath always rounding to lesser values</span>
 368 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 369 |     | <span class='neutral'>        }</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='unexecuted'>    function roundBack(</span>
 373 |     | <span class='neutral'>        int24 tick,</span>
 374 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 375 |     | <span class='neutral'>        bool zeroForOne,</span>
 376 |     | <span class='neutral'>        uint256 price</span>
 377 |     | <span class='neutral'>    ) internal pure returns (</span>
 378 |     | <span class='unexecuted'>        int24 roundedTick</span>
 379 |     | <span class='unexecuted'>    ) {</span>
 380 |     | <span class='unexecuted'>        roundedTick = tick / constants.tickSpacing * constants.tickSpacing;</span>
 381 |     | <span class='unexecuted'>        uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);</span>
 382 |     | <span class='unexecuted'>        if (price == roundedTickPrice)</span>
 383 |     | <span class='unexecuted'>            return roundedTick;</span>
 384 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 385 |     | <span class='neutral'>            // round down if negative</span>
 386 |     | <span class='unexecuted'>            if (roundedTick &lt; 0 || (roundedTick == 0 &amp;&amp; tick &lt; 0))</span>
 387 |     | <span class='unexecuted'>                roundedTick -= constants.tickSpacing;</span>
 388 |     | <span class='neutral'>        } else {</span>
 389 |     | <span class='neutral'>            // round up if positive</span>
 390 |     | <span class='unexecuted'>            if (roundedTick &gt; 0 || (roundedTick == 0 &amp;&amp; tick &gt;= 0))</span>
 391 |     | <span class='unexecuted'>                roundedTick += constants.tickSpacing;</span>
 392 |     | <span class='unexecuted'>            else if (tick % constants.tickSpacing == 0) {</span>
 393 |     | <span class='neutral'>                // handle price at -99.5 and tickAtPrice == -100</span>
 394 |     | <span class='unexecuted'>                if (tick &lt; 0 &amp;&amp; roundedTickPrice &lt; price) {</span>
 395 |     | <span class='unexecuted'>                    roundedTick += constants.tickSpacing;</span>
 396 |     | <span class='neutral'>                }</span>
 397 |     | <span class='neutral'>            }</span>
 398 |     | <span class='neutral'>        }</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/Ticks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./range/math/FeeMath.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;./math/OverflowMath.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./math/ConstantProduct.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./TickMap.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./utils/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./range/math/FeeMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./Samples.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./limit/EpochMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./limit/LimitTicks.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../test/echidna/EchidnaAssertions.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>library Ticks {</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    // cross flags</span>
  21 |     | <span class='unexecuted'>    uint8 internal constant RANGE_TICK = 2**0;</span>
  22 |     | <span class='unexecuted'>    uint8 internal constant LIMIT_TICK = 2**1;</span>
  23 |     | <span class='unexecuted'>    uint8 internal constant LIMIT_POOL = 2**2;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    // for Q64.96 numbers</span>
  26 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    event Initialize(</span>
  29 |     | <span class='neutral'>        int24 minTick,</span>
  30 |     | <span class='neutral'>        int24 maxTick,</span>
  31 |     | <span class='neutral'>        uint160 startPrice,</span>
  32 |     | <span class='neutral'>        int24 startTick</span>
  33 |     | <span class='neutral'>    );</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    event Swap(</span>
  36 |     | <span class='neutral'>        address indexed recipient,</span>
  37 |     | <span class='neutral'>        uint256 amountIn,</span>
  38 |     | <span class='neutral'>        uint256 amountOut,</span>
  39 |     | <span class='neutral'>        uint200 feeGrowthGlobal0,</span>
  40 |     | <span class='neutral'>        uint200 feeGrowthGlobal1,</span>
  41 |     | <span class='neutral'>        uint160 price,</span>
  42 |     | <span class='neutral'>        uint128 liquidity,</span>
  43 |     | <span class='neutral'>        uint128 feeAmount,</span>
  44 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  45 |     | <span class='neutral'>        bool indexed zeroForOne,</span>
  46 |     | <span class='neutral'>        bool indexed exactIn</span>
  47 |     | <span class='neutral'>    );</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    event SyncRangeTick(</span>
  50 |     | <span class='neutral'>        uint200 feeGrowthOutside0,</span>
  51 |     | <span class='neutral'>        uint200 feeGrowthOutside1,</span>
  52 |     | <span class='neutral'>        int24 tick</span>
  53 |     | <span class='neutral'>    );</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    function initialize(</span>
  56 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  57 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  58 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  59 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
  60 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
  61 |     | <span class='neutral'>        uint160 startPrice</span>
  62 |     | <span class='neutral'>    ) internal returns (</span>
  63 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory  </span>
  64 |     | <span class='neutral'>    )</span>
  65 |     | <span class='neutral'>    {</span>
  66 |     | <span class='neutral'>        // state should only be initialized once</span>
  67 |     | <span class='unexecuted'>        if (state.pool0.price &gt; 0) require (false, &#39;PoolAlreadyInitialized()&#39;);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // initialize state</span>
  70 |     | <span class='unexecuted'>        state.epoch = 1;</span>
  71 |     | <span class='unexecuted'>        state.positionIdNext = 1;</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>        // check price bounds</span>
  74 |     | <span class='unexecuted'>        if (startPrice &lt; constants.bounds.min || startPrice &gt;= constants.bounds.max) require(false, &#39;StartPriceInvalid()&#39;);</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>        // initialize range ticks</span>
  77 |     | <span class='unexecuted'>        TickMap.set(rangeTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  78 |     | <span class='unexecuted'>        TickMap.set(rangeTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  79 |     | <span class='neutral'>        </span>
  80 |     | <span class='neutral'>        // initialize limit ticks</span>
  81 |     | <span class='unexecuted'>        TickMap.set(limitTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);</span>
  82 |     | <span class='unexecuted'>        TickMap.set(limitTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>        // initialize price</span>
  85 |     | <span class='unexecuted'>        state.pool.price = startPrice;</span>
  86 |     | <span class='unexecuted'>        state.pool0.price = startPrice;</span>
  87 |     | <span class='unexecuted'>        state.pool1.price = startPrice;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        int24 startTick = ConstantProduct.getTickAtPrice(startPrice, constants);</span>
  90 |     | <span class='unexecuted'>        state.pool.tickAtPrice = startTick;</span>
  91 |     | <span class='unexecuted'>        state.pool0.tickAtPrice = startTick;</span>
  92 |     | <span class='unexecuted'>        state.pool1.tickAtPrice = startTick;</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // intialize samples</span>
  95 |     | <span class='unexecuted'>        state.pool = Samples.initialize(samples, state.pool);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // emit event</span>
  98 |     | <span class='unexecuted'>        emit Initialize(</span>
  99 |     | <span class='unexecuted'>            ConstantProduct.minTick(constants.tickSpacing),</span>
 100 |     | <span class='unexecuted'>            ConstantProduct.maxTick(constants.tickSpacing),</span>
 101 |     | <span class='unexecuted'>            state.pool0.price,</span>
 102 |     | <span class='unexecuted'>            state.pool0.tickAtPrice</span>
 103 |     | <span class='neutral'>        );</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='unexecuted'>        return state;</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'>    </span>
 108 |     | <span class='unexecuted'>    function swap(</span>
 109 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 110 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 111 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 112 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 113 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
 114 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 115 |     | <span class='neutral'>    ) internal returns (</span>
 116 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 117 |     | <span class='neutral'>    )</span>
 118 |     | <span class='neutral'>    {   </span>
 119 |     | <span class='neutral'>        // if price == priceAtTick</span>
 120 |     | <span class='neutral'>        // cross range tick if present</span>
 121 |     | <span class='neutral'>        // in _cross if price == priceAtTick &amp;&amp; amountLeft == 0</span>
 122 |     | <span class='neutral'>        // don&#39;t cross the range tick</span>
 123 |     | <span class='neutral'>        // start with range price</span>
 124 |     | <span class='unexecuted'>        cache.price = cache.state.pool.price;</span>
 125 |     | <span class='unexecuted'>        cache.crossTick = cache.state.pool.tickAtPrice;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        uint128 startLiquidity = cache.liquidity.toUint128();</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>        // set crossTick/crossPrice based on the best between limit and range</span>
 132 |     | <span class='neutral'>        // grab sample for accumulators</span>
 133 |     | <span class='unexecuted'>        cache = PoolsharkStructs.SwapCache({</span>
 134 |     | <span class='unexecuted'>            state: cache.state,</span>
 135 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 136 |     | <span class='unexecuted'>            price: cache.price,</span>
 137 |     | <span class='unexecuted'>            liquidity: cache.liquidity,</span>
 138 |     | <span class='unexecuted'>            amountLeft: params.amount,</span>
 139 |     | <span class='unexecuted'>            input:  0,</span>
 140 |     | <span class='unexecuted'>            output: 0,</span>
 141 |     | <span class='unexecuted'>            crossPrice: cache.crossPrice,</span>
 142 |     | <span class='unexecuted'>            secondsPerLiquidityAccum: 0,</span>
 143 |     | <span class='unexecuted'>            feeAmount: 0,</span>
 144 |     | <span class='unexecuted'>            tickSecondsAccum: 0,</span>
 145 |     | <span class='unexecuted'>            tickSecondsAccumBase: 0,</span>
 146 |     | <span class='unexecuted'>            crossTick: cache.crossTick,</span>
 147 |     | <span class='unexecuted'>            crossStatus: cache.crossStatus,</span>
 148 |     | <span class='unexecuted'>            limitActive: cache.limitActive,</span>
 149 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 150 |     | <span class='unexecuted'>            cross: true,</span>
 151 |     | <span class='unexecuted'>            averagePrice: 0</span>
 152 |     | <span class='neutral'>        });</span>
 153 |     | <span class='neutral'>        // grab latest price and sample</span>
 154 |     | <span class='unexecuted'>        (</span>
 155 |     | <span class='unexecuted'>            cache.averagePrice,</span>
 156 |     | <span class='unexecuted'>            cache.secondsPerLiquidityAccum,</span>
 157 |     | <span class='unexecuted'>            cache.tickSecondsAccum</span>
 158 |     | <span class='unexecuted'>         ) = Samples.getLatest(cache.state, cache.constants, cache.liquidity);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // grab latest sample and store in cache for _cross</span>
 161 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 162 |     | <span class='neutral'>            // handle price being at cross tick</span>
 163 |     | <span class='unexecuted'>            cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);</span>
 164 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 165 |     | <span class='unexecuted'>                cache = _cross(</span>
 166 |     | <span class='unexecuted'>                    ticks,</span>
 167 |     | <span class='unexecuted'>                    rangeTickMap,</span>
 168 |     | <span class='unexecuted'>                    limitTickMap,</span>
 169 |     | <span class='unexecuted'>                    cache,</span>
 170 |     | <span class='unexecuted'>                    params</span>
 171 |     | <span class='neutral'>                );</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>        /// @dev - write oracle entry after start of block</span>
 175 |     | <span class='unexecuted'>        (</span>
 176 |     | <span class='unexecuted'>            cache.state.pool.samples.index,</span>
 177 |     | <span class='unexecuted'>            cache.state.pool.samples.length</span>
 178 |     | <span class='unexecuted'>        ) = Samples.save(</span>
 179 |     | <span class='unexecuted'>            samples,</span>
 180 |     | <span class='unexecuted'>            cache.state.pool.samples,</span>
 181 |     | <span class='unexecuted'>            startLiquidity,</span>
 182 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice</span>
 183 |     | <span class='neutral'>        );</span>
 184 |     | <span class='neutral'>        // pool liquidity should be updated along the way</span>
 185 |     | <span class='unexecuted'>        cache.state.pool.price = cache.price.toUint160();</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        if (cache.price != cache.crossPrice) {</span>
 188 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice = ConstantProduct.getTickAtPrice(cache.price.toUint160(), cache.constants);</span>
 189 |     | <span class='neutral'>        } else {</span>
 190 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice = cache.crossTick;</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='unexecuted'>        if (cache.limitActive) {</span>
 193 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 194 |     | <span class='unexecuted'>                cache.state.pool1.price = cache.state.pool.price;</span>
 195 |     | <span class='unexecuted'>                cache.state.pool1.tickAtPrice = cache.state.pool.tickAtPrice;</span>
 196 |     | <span class='neutral'>            } else {</span>
 197 |     | <span class='unexecuted'>                cache.state.pool0.price = cache.state.pool.price;</span>
 198 |     | <span class='unexecuted'>                cache.state.pool0.tickAtPrice = cache.state.pool.tickAtPrice;</span>
 199 |     | <span class='neutral'>            }</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='unexecuted'>        emit Swap(</span>
 202 |     | <span class='unexecuted'>            params.to,</span>
 203 |     | <span class='unexecuted'>            cache.input,</span>
 204 |     | <span class='unexecuted'>            cache.output,</span>
 205 |     | <span class='unexecuted'>            cache.state.pool.feeGrowthGlobal0,</span>
 206 |     | <span class='unexecuted'>            cache.state.pool.feeGrowthGlobal1,</span>
 207 |     | <span class='unexecuted'>            cache.price.toUint160(),</span>
 208 |     | <span class='unexecuted'>            cache.liquidity.toUint128(),</span>
 209 |     | <span class='unexecuted'>            cache.feeAmount,</span>
 210 |     | <span class='unexecuted'>            cache.state.pool.tickAtPrice,</span>
 211 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 212 |     | <span class='unexecuted'>            params.exactIn</span>
 213 |     | <span class='neutral'>        );</span>
 214 |     | <span class='unexecuted'>        return cache;</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='unexecuted'>    function quote(</span>
 218 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 219 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 220 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 221 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params,</span>
 222 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 223 |     | <span class='neutral'>    ) internal returns (</span>
 224 |     | <span class='unexecuted'>        uint256,</span>
 225 |     | <span class='unexecuted'>        uint256,</span>
 226 |     | <span class='unexecuted'>        uint160</span>
 227 |     | <span class='neutral'>    ) {</span>
 228 |     | <span class='neutral'>        // start with range price</span>
 229 |     | <span class='unexecuted'>        cache.price = cache.state.pool.price;</span>
 230 |     | <span class='unexecuted'>        cache.crossTick = cache.state.pool.tickAtPrice;</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>        cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);</span>
 233 |     | <span class='neutral'>        </span>
 234 |     | <span class='neutral'>        // set crossTick/crossPrice based on the best between limit and range</span>
 235 |     | <span class='neutral'>        // grab sample for accumulators</span>
 236 |     | <span class='unexecuted'>        cache = PoolsharkStructs.SwapCache({</span>
 237 |     | <span class='unexecuted'>            state: cache.state,</span>
 238 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 239 |     | <span class='unexecuted'>            price: cache.price,</span>
 240 |     | <span class='unexecuted'>            liquidity: cache.liquidity,</span>
 241 |     | <span class='unexecuted'>            amountLeft: params.amount,</span>
 242 |     | <span class='unexecuted'>            input:  0,</span>
 243 |     | <span class='unexecuted'>            output: 0,</span>
 244 |     | <span class='unexecuted'>            crossPrice: cache.crossPrice,</span>
 245 |     | <span class='unexecuted'>            secondsPerLiquidityAccum: 0,</span>
 246 |     | <span class='unexecuted'>            feeAmount: 0,</span>
 247 |     | <span class='unexecuted'>            tickSecondsAccum: 0,</span>
 248 |     | <span class='unexecuted'>            tickSecondsAccumBase: 0,</span>
 249 |     | <span class='unexecuted'>            crossTick: cache.crossTick,</span>
 250 |     | <span class='unexecuted'>            crossStatus: cache.crossStatus,</span>
 251 |     | <span class='unexecuted'>            limitActive: cache.limitActive,</span>
 252 |     | <span class='unexecuted'>            exactIn: params.exactIn,</span>
 253 |     | <span class='unexecuted'>            cross: true,</span>
 254 |     | <span class='unexecuted'>            averagePrice: 0</span>
 255 |     | <span class='neutral'>        });</span>
 256 |     | <span class='neutral'>        // grab latest price and sample</span>
 257 |     | <span class='unexecuted'>        (</span>
 258 |     | <span class='unexecuted'>            cache.averagePrice,</span>
 259 |     | <span class='unexecuted'>            cache.secondsPerLiquidityAccum,</span>
 260 |     | <span class='unexecuted'>            cache.tickSecondsAccum</span>
 261 |     | <span class='unexecuted'>         ) = Samples.getLatest(cache.state, cache.constants, cache.liquidity);</span>
 262 |     | <span class='unexecuted'>        while (cache.cross) {</span>
 263 |     | <span class='unexecuted'>            cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);</span>
 264 |     | <span class='unexecuted'>            if (cache.cross) {</span>
 265 |     | <span class='unexecuted'>                cache = _pass(</span>
 266 |     | <span class='unexecuted'>                    ticks,</span>
 267 |     | <span class='unexecuted'>                    rangeTickMap,</span>
 268 |     | <span class='unexecuted'>                    limitTickMap,</span>
 269 |     | <span class='unexecuted'>                    cache,</span>
 270 |     | <span class='unexecuted'>                    params</span>
 271 |     | <span class='neutral'>                );</span>
 272 |     | <span class='neutral'>            }</span>
 273 |     | <span class='neutral'>        }</span>
 274 |     | <span class='unexecuted'>        return (</span>
 275 |     | <span class='unexecuted'>            cache.input,</span>
 276 |     | <span class='unexecuted'>            cache.output,</span>
 277 |     | <span class='unexecuted'>            cache.price.toUint160()</span>
 278 |     | <span class='neutral'>        );</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>    function _quoteSingle(</span>
 282 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 283 |     | <span class='neutral'>        uint160 priceLimit,</span>
 284 |     | <span class='neutral'>        bool zeroForOne</span>
 285 |     | <span class='neutral'>    ) internal pure returns (</span>
 286 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 287 |     | <span class='neutral'>    ) {</span>
 288 |     | <span class='unexecuted'>        if ((zeroForOne ? priceLimit &gt;= cache.price</span>
 289 |     | <span class='unexecuted'>                        : priceLimit &lt;= cache.price) ||</span>
 290 |     | <span class='unexecuted'>            (zeroForOne &amp;&amp; cache.price == cache.constants.bounds.min) ||</span>
 291 |     | <span class='unexecuted'>            (!zeroForOne &amp;&amp; cache.price == cache.constants.bounds.max) ||</span>
 292 |     | <span class='unexecuted'>            (cache.amountLeft == 0 &amp;&amp; cache.liquidity &gt; 0))</span>
 293 |     | <span class='neutral'>        {</span>
 294 |     | <span class='unexecuted'>            cache.cross = false;</span>
 295 |     | <span class='unexecuted'>            return cache;</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='unexecuted'>        uint256 nextPrice = cache.crossPrice;</span>
 298 |     | <span class='unexecuted'>         uint256 amountIn; uint256 amountOut;</span>
 299 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 300 |     | <span class='neutral'>            // Trading token 0 (x) for token 1 (y).</span>
 301 |     | <span class='neutral'>            // price  is decreasing.</span>
 302 |     | <span class='unexecuted'>            if (nextPrice &lt; priceLimit) {</span>
 303 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 304 |     | <span class='neutral'>            }</span>
 305 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)</span>
 306 |     | <span class='unexecuted'>                                              : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 307 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 308 |     | <span class='neutral'>                // calculate price after swap</span>
 309 |     | <span class='unexecuted'>                uint256 newPrice = ConstantProduct.getNewPrice(</span>
 310 |     | <span class='unexecuted'>                    cache.price,</span>
 311 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 312 |     | <span class='unexecuted'>                    cache.amountLeft,</span>
 313 |     | <span class='unexecuted'>                    zeroForOne,</span>
 314 |     | <span class='unexecuted'>                    cache.exactIn</span>
 315 |     | <span class='neutral'>                );</span>
 316 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 317 |     | <span class='unexecuted'>                    amountIn = cache.amountLeft;</span>
 318 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, newPrice, uint256(cache.price), false);</span>
 319 |     | <span class='neutral'>                } else {</span>
 320 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDx(cache.liquidity, newPrice, uint256(cache.price), true);</span>
 321 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 322 |     | <span class='neutral'>                }</span>
 323 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 324 |     | <span class='unexecuted'>                cache.cross = false;</span>
 325 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 326 |     | <span class='neutral'>            } else {</span>
 327 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 328 |     | <span class='unexecuted'>                    amountIn = amountMax;</span>
 329 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>                } else {</span>
 332 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true);</span>
 333 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 334 |     | <span class='neutral'>                }</span>
 335 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 336 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) cache.cross = true;</span>
 337 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 338 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 339 |     | <span class='neutral'>            }</span>
 340 |     | <span class='unexecuted'>        } else {</span>
 341 |     | <span class='neutral'>            // Price is increasing.</span>
 342 |     | <span class='unexecuted'>            if (nextPrice &gt; priceLimit) {</span>
 343 |     | <span class='unexecuted'>                nextPrice = priceLimit;</span>
 344 |     | <span class='neutral'>            }</span>
 345 |     | <span class='unexecuted'>            uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, uint256(cache.price), nextPrice, true)</span>
 346 |     | <span class='unexecuted'>                                              : ConstantProduct.getDx(cache.liquidity, uint256(cache.price), nextPrice, false);</span>
 347 |     | <span class='unexecuted'>            if (cache.amountLeft &lt; amountMax) {</span>
 348 |     | <span class='unexecuted'>                uint256 newPrice = ConstantProduct.getNewPrice(</span>
 349 |     | <span class='unexecuted'>                    cache.price,</span>
 350 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 351 |     | <span class='unexecuted'>                    cache.amountLeft,</span>
 352 |     | <span class='unexecuted'>                    zeroForOne,</span>
 353 |     | <span class='unexecuted'>                    cache.exactIn</span>
 354 |     | <span class='neutral'>                );</span>
 355 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 356 |     | <span class='unexecuted'>                    amountIn = cache.amountLeft;</span>
 357 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);</span>
 358 |     | <span class='neutral'>                } else {</span>
 359 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true);</span>
 360 |     | <span class='unexecuted'>                    amountOut = cache.amountLeft;</span>
 361 |     | <span class='neutral'>                }</span>
 362 |     | <span class='unexecuted'>                cache.amountLeft = 0;</span>
 363 |     | <span class='unexecuted'>                cache.cross = false;</span>
 364 |     | <span class='unexecuted'>                cache.price = uint160(newPrice);</span>
 365 |     | <span class='neutral'>            } else {</span>
 366 |     | <span class='unexecuted'>                if (cache.exactIn) {</span>
 367 |     | <span class='unexecuted'>                    amountIn = amountMax;</span>
 368 |     | <span class='unexecuted'>                    amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);</span>
 369 |     | <span class='neutral'>                } else {</span>
 370 |     | <span class='unexecuted'>                    amountIn = ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true);</span>
 371 |     | <span class='unexecuted'>                    amountOut = amountMax;</span>
 372 |     | <span class='neutral'>                }</span>
 373 |     | <span class='unexecuted'>                cache.amountLeft -= amountMax;</span>
 374 |     | <span class='unexecuted'>                if (nextPrice == cache.crossPrice) cache.cross = true;</span>
 375 |     | <span class='unexecuted'>                else cache.cross = false;</span>
 376 |     | <span class='unexecuted'>                cache.price = uint160(nextPrice);</span>
 377 |     | <span class='neutral'>            }</span>
 378 |     | <span class='neutral'>        }</span>
 379 |     | <span class='unexecuted'>        cache = FeeMath.calculate(cache, amountIn, amountOut, zeroForOne);</span>
 380 |     | <span class='unexecuted'>        return cache;</span>
 381 |     | <span class='neutral'>    }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>    function _cross(</span>
 384 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 385 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 386 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 387 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 388 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params</span>
 389 |     | <span class='neutral'>    ) internal returns (</span>
 390 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 391 |     | <span class='neutral'>    ) {</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>        // crossing range ticks</span>
 394 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; RANGE_TICK) &gt; 0) {</span>
 395 |     | <span class='unexecuted'>            if (!params.zeroForOne || (cache.amountLeft &gt; 0 &amp;&amp; params.priceLimit &lt; cache.crossPrice)) {</span>
 396 |     | <span class='unexecuted'>                PoolsharkStructs.RangeTick memory crossTick = ticks[cache.crossTick].range;</span>
 397 |     | <span class='unexecuted'>                crossTick.feeGrowthOutside0       = cache.state.pool.feeGrowthGlobal0 - crossTick.feeGrowthOutside0;</span>
 398 |     | <span class='unexecuted'>                crossTick.feeGrowthOutside1       = cache.state.pool.feeGrowthGlobal1 - crossTick.feeGrowthOutside1;</span>
 399 |     | <span class='unexecuted'>                crossTick.tickSecondsAccumOutside = cache.tickSecondsAccum - crossTick.tickSecondsAccumOutside;</span>
 400 |     | <span class='unexecuted'>                crossTick.secondsPerLiquidityAccumOutside = cache.secondsPerLiquidityAccum - crossTick.secondsPerLiquidityAccumOutside;</span>
 401 |     | <span class='unexecuted'>                ticks[cache.crossTick].range = crossTick;</span>
 402 |     | <span class='unexecuted'>                int128 liquidityDelta = crossTick.liquidityDelta;</span>
 403 |     | <span class='unexecuted'>                emit SyncRangeTick(</span>
 404 |     | <span class='unexecuted'>                    crossTick.feeGrowthOutside0,</span>
 405 |     | <span class='unexecuted'>                    crossTick.feeGrowthOutside1,</span>
 406 |     | <span class='unexecuted'>                    cache.crossTick</span>
 407 |     | <span class='neutral'>                );</span>
 408 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 409 |     | <span class='neutral'>                    unchecked {</span>
 410 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0){</span>
 411 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-1&quot;);</span>
 412 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(liquidityDelta);</span>
 413 |     | <span class='neutral'>                        } else {</span>
 414 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-2&quot;);</span>
 415 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(-liquidityDelta); </span>
 416 |     | <span class='neutral'>                        }</span>
 417 |     | <span class='neutral'>                    }</span>
 418 |     | <span class='neutral'>                } else {</span>
 419 |     | <span class='neutral'>                    unchecked {</span>
 420 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0) {</span>
 421 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-3&quot;);</span>
 422 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(liquidityDelta);</span>
 423 |     | <span class='neutral'>                        } else {</span>
 424 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-4&quot;);</span>
 425 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(-liquidityDelta);</span>
 426 |     | <span class='neutral'>                        }</span>
 427 |     | <span class='neutral'>                    }</span>
 428 |     | <span class='neutral'>                }</span>
 429 |     | <span class='neutral'>            } else {</span>
 430 |     | <span class='neutral'>                // if zeroForOne &amp;&amp; amountLeft == 0 skip crossing the tick</span>
 431 |     | <span class='neutral'>                /// @dev - this is so users can safely add liquidity with lower or upper at the pool price </span>
 432 |     | <span class='unexecuted'>                cache.cross = false;</span>
 433 |     | <span class='neutral'>            }</span>
 434 |     | <span class='neutral'>            /// @dev - price and tickAtPrice updated at end of loop</span>
 435 |     | <span class='neutral'>        }</span>
 436 |     | <span class='neutral'>        // crossing limit tick</span>
 437 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_TICK) &gt; 0) {</span>
 438 |     | <span class='neutral'>            // cross limit tick</span>
 439 |     | <span class='unexecuted'>            EpochMap.set(cache.crossTick, !params.zeroForOne, cache.state.epoch, limitTickMap, cache.constants);</span>
 440 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='unexecuted'>            if (liquidityDelta &gt;= 0) {</span>
 443 |     | <span class='unexecuted'>                cache.liquidity += uint128(liquidityDelta);</span>
 444 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity += uint128(liquidityDelta);</span>
 445 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity += uint128(liquidityDelta);</span>
 446 |     | <span class='neutral'>            }</span>
 447 |     | <span class='neutral'>            else {</span>
 448 |     | <span class='unexecuted'>                cache.liquidity -= uint128(-liquidityDelta);</span>
 449 |     | <span class='unexecuted'>                if (params.zeroForOne) cache.state.pool1.liquidity -= uint128(-liquidityDelta);</span>
 450 |     | <span class='unexecuted'>                else cache.state.pool0.liquidity -= uint128(-liquidityDelta);</span>
 451 |     | <span class='neutral'>            }</span>
 452 |     | <span class='neutral'>            // zero out liquidityDelta and priceAt</span>
 453 |     | <span class='unexecuted'>            ticks[cache.crossTick].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 454 |     | <span class='unexecuted'>            LimitTicks.clear(ticks, cache.constants, limitTickMap, cache.crossTick);</span>
 455 |     | <span class='neutral'>            /// @dev - price and tickAtPrice updated at end of loop</span>
 456 |     | <span class='neutral'>        }</span>
 457 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_POOL) &gt; 0) {</span>
 458 |     | <span class='neutral'>            // add limit pool</span>
 459 |     | <span class='unexecuted'>            uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity</span>
 460 |     | <span class='unexecuted'>                                                    : cache.state.pool0.liquidity;</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) cache.liquidity += liquidityDelta;</span>
 463 |     | <span class='neutral'>        }</span>
 464 |     | <span class='unexecuted'>        if (cache.cross)</span>
 465 |     | <span class='unexecuted'>            cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='unexecuted'>        return cache;</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='unexecuted'>    function _pass(</span>
 471 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 472 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 473 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 474 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 475 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params</span>
 476 |     | <span class='neutral'>    ) internal returns (</span>
 477 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
 478 |     | <span class='neutral'>    ) {</span>
 479 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; RANGE_TICK) &gt; 0) {</span>
 480 |     | <span class='unexecuted'>            if (!params.zeroForOne || cache.amountLeft &gt; 0) {</span>
 481 |     | <span class='unexecuted'>                int128 liquidityDelta = ticks[cache.crossTick].range.liquidityDelta;</span>
 482 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 483 |     | <span class='neutral'>                    unchecked {</span>
 484 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0){</span>
 485 |     | <span class='neutral'>                            // start of position boundary</span>
 486 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-1&quot;);</span>
 487 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(liquidityDelta);</span>
 488 |     | <span class='neutral'>                        } else {</span>
 489 |     | <span class='neutral'>                            // end of position boundary</span>
 490 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-2&quot;);</span>
 491 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(-liquidityDelta); </span>
 492 |     | <span class='neutral'>                        }</span>
 493 |     | <span class='neutral'>                    }</span>
 494 |     | <span class='neutral'>                } else {</span>
 495 |     | <span class='neutral'>                    unchecked {</span>
 496 |     | <span class='unexecuted'>                        if (liquidityDelta &gt;= 0) {</span>
 497 |     | <span class='neutral'>                            // start of position boundary</span>
 498 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(liquidityDelta), &quot;TKS-3&quot;);</span>
 499 |     | <span class='unexecuted'>                            cache.state.pool.liquidity += uint128(liquidityDelta);</span>
 500 |     | <span class='neutral'>                        } else {</span>
 501 |     | <span class='neutral'>                            // end of position boundary</span>
 502 |     | <span class='unexecuted'>                            EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(-liquidityDelta), &quot;TKS-4&quot;);</span>
 503 |     | <span class='unexecuted'>                            cache.state.pool.liquidity -= uint128(-liquidityDelta);</span>
 504 |     | <span class='neutral'>                        }</span>
 505 |     | <span class='neutral'>                    }</span>
 506 |     | <span class='neutral'>                }</span>
 507 |     | <span class='neutral'>            } else {</span>
 508 |     | <span class='unexecuted'>                cache.cross = false;</span>
 509 |     | <span class='neutral'>            }</span>
 510 |     | <span class='neutral'>        }</span>
 511 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_TICK) &gt; 0) {</span>
 512 |     | <span class='neutral'>            // cross limit tick</span>
 513 |     | <span class='unexecuted'>            int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) {</span>
 516 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 517 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityOverflows(cache.state.pool1.liquidity, uint128(liquidityDelta), &quot;TKS-5&quot;);</span>
 518 |     | <span class='unexecuted'>                    cache.state.pool1.liquidity += uint128(liquidityDelta);</span>
 519 |     | <span class='neutral'>                } else {</span>
 520 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityOverflows(cache.state.pool0.liquidity, uint128(liquidityDelta), &quot;TKS-6&quot;);</span>
 521 |     | <span class='unexecuted'>                    cache.state.pool0.liquidity += uint128(liquidityDelta);</span>
 522 |     | <span class='neutral'>                }</span>
 523 |     | <span class='neutral'>            } </span>
 524 |     | <span class='neutral'>            else {</span>
 525 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 526 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool1.liquidity, uint128(-liquidityDelta), &quot;TKS-7&quot;);</span>
 527 |     | <span class='unexecuted'>                    cache.state.pool1.liquidity -= uint128(-liquidityDelta);</span>
 528 |     | <span class='neutral'>                } else {</span>
 529 |     | <span class='unexecuted'>                    EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool0.liquidity, uint128(-liquidityDelta), &quot;TKS-8&quot;);</span>
 530 |     | <span class='unexecuted'>                    cache.state.pool0.liquidity -= uint128(-liquidityDelta);</span>
 531 |     | <span class='neutral'>                }</span>
 532 |     | <span class='neutral'>            }</span>
 533 |     | <span class='neutral'>        }</span>
 534 |     | <span class='unexecuted'>        if ((cache.crossStatus &amp; LIMIT_POOL) &gt; 0) {</span>
 535 |     | <span class='neutral'>            // add limit pool</span>
 536 |     | <span class='unexecuted'>            uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity</span>
 537 |     | <span class='unexecuted'>                                                    : cache.state.pool0.liquidity;</span>
 538 |     | <span class='neutral'></span>
 539 |     | <span class='unexecuted'>            if (liquidityDelta &gt; 0) {</span>
 540 |     | <span class='unexecuted'>                cache.liquidity += liquidityDelta;</span>
 541 |     | <span class='neutral'>            }</span>
 542 |     | <span class='neutral'>        }</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='unexecuted'>        if (cache.cross)</span>
 545 |     | <span class='unexecuted'>            cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='unexecuted'>        return cache;</span>
 548 |     | <span class='neutral'>    }</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='unexecuted'>    function _iterate(</span>
 551 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 552 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 553 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 554 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
 555 |     | <span class='neutral'>        bool zeroForOne,</span>
 556 |     | <span class='neutral'>        bool inclusive</span>
 557 |     | <span class='neutral'>    ) internal view returns (</span>
 558 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory </span>
 559 |     | <span class='neutral'>    )    </span>
 560 |     | <span class='neutral'>    {</span>
 561 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 562 |     | <span class='unexecuted'>            if (cache.price &gt; cache.state.pool1.price) {</span>
 563 |     | <span class='neutral'>                // load range pool</span>
 564 |     | <span class='unexecuted'>                cache.limitActive = false;</span>
 565 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity;</span>
 566 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 567 |     | <span class='neutral'>                // next range tick vs. limit pool price</span>
 568 |     | <span class='unexecuted'>                cache.crossTick = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 569 |     | <span class='unexecuted'>                cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 570 |     | <span class='unexecuted'>                if (cache.state.pool1.price &gt;= cache.crossPrice) {</span>
 571 |     | <span class='neutral'>                    // cross into limit pool</span>
 572 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_POOL;</span>
 573 |     | <span class='unexecuted'>                    if (cache.state.pool1.price == cache.crossPrice)</span>
 574 |     | <span class='neutral'>                        // also cross range tick</span>
 575 |     | <span class='unexecuted'>                        cache.crossStatus |= RANGE_TICK;</span>
 576 |     | <span class='neutral'>                    else {</span>
 577 |     | <span class='unexecuted'>                        cache.crossTick = cache.state.pool1.tickAtPrice;</span>
 578 |     | <span class='unexecuted'>                        cache.crossPrice = cache.state.pool1.price;</span>
 579 |     | <span class='neutral'>                    }</span>
 580 |     | <span class='neutral'>                }</span>
 581 |     | <span class='neutral'>                else {</span>
 582 |     | <span class='neutral'>                    // cross only range tick</span>
 583 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 584 |     | <span class='neutral'>                }</span>
 585 |     | <span class='unexecuted'>            } else {</span>
 586 |     | <span class='neutral'>                // load range and limit pools</span>
 587 |     | <span class='unexecuted'>                cache.limitActive = true;</span>
 588 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity + cache.state.pool1.liquidity;</span>
 589 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 590 |     | <span class='unexecuted'>                int24 rangeTickAhead; int24 limitTickAhead;</span>
 591 |     | <span class='unexecuted'>                if (cache.crossStatus == LIMIT_POOL &amp;&amp;</span>
 592 |     | <span class='unexecuted'>                        cache.crossTick % cache.constants.tickSpacing != 0 &amp;&amp;</span>
 593 |     | <span class='unexecuted'>                        TickMap.get(limitTickMap, cache.crossTick, cache.constants.tickSpacing))</span>
 594 |     | <span class='neutral'>                {</span>
 595 |     | <span class='unexecuted'>                    limitTickAhead = cache.crossTick;</span>
 596 |     | <span class='unexecuted'>                    rangeTickAhead = cache.crossTick - cache.constants.tickSpacing / 2;</span>
 597 |     | <span class='neutral'>                } else {</span>
 598 |     | <span class='unexecuted'>                    rangeTickAhead = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 599 |     | <span class='unexecuted'>                    limitTickAhead = TickMap.previous(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 600 |     | <span class='neutral'>                }</span>
 601 |     | <span class='neutral'>                // next range tick vs. next limit tick</span>
 602 |     | <span class='neutral'>                </span>
 603 |     | <span class='unexecuted'>                if (rangeTickAhead &gt;= limitTickAhead) {</span>
 604 |     | <span class='unexecuted'>                    cache.crossTick = rangeTickAhead;</span>
 605 |     | <span class='neutral'>                    // cross range tick</span>
 606 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 607 |     | <span class='unexecuted'>                    if (rangeTickAhead == limitTickAhead)</span>
 608 |     | <span class='neutral'>                        // also cross limit tick</span>
 609 |     | <span class='unexecuted'>                        cache.crossStatus |= LIMIT_TICK;</span>
 610 |     | <span class='unexecuted'>                    cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 611 |     | <span class='neutral'>                } else {</span>
 612 |     | <span class='neutral'>                    // only cross limit tick</span>
 613 |     | <span class='unexecuted'>                    cache.crossTick = limitTickAhead;</span>
 614 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_TICK;</span>
 615 |     | <span class='unexecuted'>                    cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 616 |     | <span class='unexecuted'>                                                                                 : ticks[cache.crossTick].limit.priceAt;</span>
 617 |     | <span class='neutral'>                }</span>
 618 |     | <span class='neutral'>            }</span>
 619 |     | <span class='neutral'>        } else {</span>
 620 |     | <span class='unexecuted'>            if (cache.price &lt; cache.state.pool0.price) {</span>
 621 |     | <span class='neutral'>                // load range pool</span>
 622 |     | <span class='unexecuted'>                cache.limitActive = false;</span>
 623 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity;</span>
 624 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 625 |     | <span class='neutral'>                // next range tick vs. limit pool price</span>
 626 |     | <span class='unexecuted'>                cache.crossTick = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 627 |     | <span class='unexecuted'>                cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 628 |     | <span class='unexecuted'>                if (cache.state.pool0.price &lt;= cache.crossPrice) {</span>
 629 |     | <span class='neutral'>                    // cross into limit pool</span>
 630 |     | <span class='unexecuted'>                    cache.crossStatus = LIMIT_POOL;</span>
 631 |     | <span class='unexecuted'>                    if (cache.state.pool0.price == cache.crossPrice)</span>
 632 |     | <span class='neutral'>                        // also cross range tick</span>
 633 |     | <span class='unexecuted'>                        cache.crossStatus |= RANGE_TICK;</span>
 634 |     | <span class='neutral'>                    else {</span>
 635 |     | <span class='unexecuted'>                        cache.crossTick = cache.state.pool0.tickAtPrice;</span>
 636 |     | <span class='unexecuted'>                        cache.crossPrice = cache.state.pool0.price;</span>
 637 |     | <span class='neutral'>                    }</span>
 638 |     | <span class='neutral'>                }</span>
 639 |     | <span class='neutral'>                else {</span>
 640 |     | <span class='neutral'>                    // cross only range tick</span>
 641 |     | <span class='unexecuted'>                    cache.crossStatus = RANGE_TICK;</span>
 642 |     | <span class='neutral'>                }</span>
 643 |     | <span class='unexecuted'>            } else {</span>
 644 |     | <span class='neutral'>                // load range and limit pools</span>
 645 |     | <span class='unexecuted'>                cache.limitActive = true;</span>
 646 |     | <span class='unexecuted'>                cache.liquidity = cache.state.pool.liquidity + cache.state.pool0.liquidity;</span>
 647 |     | <span class='unexecuted'>                (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);</span>
 648 |     | <span class='neutral'>                // next range tick vs. next limit tick</span>
 649 |     | <span class='unexecuted'>                int24 rangeTickAhead; int24 limitTickAhead;</span>
 650 |     | <span class='unexecuted'>                if (cache.crossStatus == LIMIT_POOL &amp;&amp;</span>
 651 |     | <span class='unexecuted'>                        cache.crossTick % cache.constants.tickSpacing != 0 &amp;&amp;</span>
 652 |     | <span class='unexecuted'>                        TickMap.get(limitTickMap, cache.crossTick, cache.constants.tickSpacing))</span>
 653 |     | <span class='neutral'>                {</span>
 654 |     | <span class='unexecuted'>                    limitTickAhead = cache.crossTick;</span>
 655 |     | <span class='unexecuted'>                    rangeTickAhead = cache.crossTick + cache.constants.tickSpacing / 2;</span>
 656 |     | <span class='neutral'>                } else {</span>
 657 |     | <span class='unexecuted'>                    rangeTickAhead = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 658 |     | <span class='unexecuted'>                    limitTickAhead = TickMap.next(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);</span>
 659 |     | <span class='neutral'>                }</span>
 660 |     | <span class='unexecuted'>                if (rangeTickAhead &lt;= limitTickAhead) {</span>
 661 |     | <span class='unexecuted'>                    cache.crossTick = rangeTickAhead;</span>
 662 |     | <span class='neutral'>                    // cross range tick</span>
 663 |     | <span class='unexecuted'>                    cache.crossStatus |= RANGE_TICK;</span>
 664 |     | <span class='unexecuted'>                    if (rangeTickAhead == limitTickAhead)</span>
 665 |     | <span class='neutral'>                        // also cross limit tick</span>
 666 |     | <span class='unexecuted'>                        cache.crossStatus |= LIMIT_TICK;</span>
 667 |     | <span class='unexecuted'>                    cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);</span>
 668 |     | <span class='neutral'>                } else {</span>
 669 |     | <span class='neutral'>                    // only cross limit tick</span>
 670 |     | <span class='unexecuted'>                    cache.crossTick = limitTickAhead;</span>
 671 |     | <span class='unexecuted'>                    cache.crossStatus |= LIMIT_TICK;</span>
 672 |     | <span class='unexecuted'>                    cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)</span>
 673 |     | <span class='unexecuted'>                                                                                 : ticks[cache.crossTick].limit.priceAt;</span>
 674 |     | <span class='neutral'>                }</span>
 675 |     | <span class='neutral'>            }</span>
 676 |     | <span class='neutral'>        }</span>
 677 |     | <span class='unexecuted'>        return cache;</span>
 678 |     | <span class='neutral'>    }</span>
 679 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/Claims.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../utils/String.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library Claims {</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function validate(</span>
  15 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  16 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  17 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
  18 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
  19 |     | <span class='neutral'>    ) internal view returns (</span>
  20 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitParams memory,</span>
  21 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
  22 |     | <span class='neutral'>    ) {</span>
  23 |     | <span class='neutral'>        // validate position liquidity</span>
  24 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; cache.position.liquidity) require (false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
  25 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
  26 |     | <span class='unexecuted'>            require(false, &#39;NoPositionLiquidityFound()&#39;);</span>
  27 |     | <span class='neutral'>        }</span>
  28 |     | <span class='neutral'>        </span>
  29 |     | <span class='unexecuted'>        if (params.claim &lt; cache.position.lower ||</span>
  30 |     | <span class='unexecuted'>                params.claim &gt; cache.position.upper)</span>
  31 |     | <span class='unexecuted'>            require (false, &#39;InvalidClaimTick()&#39;);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>        uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, cache.constants);</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>        if (params.zeroForOne){</span>
  36 |     | <span class='unexecuted'>            if (cache.pool.price &gt;= cache.priceClaim) {</span>
  37 |     | <span class='unexecuted'>                if (cache.pool.price &lt;= cache.priceUpper) {</span>
  38 |     | <span class='unexecuted'>                    cache.priceClaim = cache.pool.price;</span>
  39 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(cache.pool.tickAtPrice, cache.constants, params.zeroForOne, cache.priceClaim);</span>
  40 |     | <span class='unexecuted'>                    claimTickEpoch = cache.state.epoch;</span>
  41 |     | <span class='neutral'>                } else {</span>
  42 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  43 |     | <span class='unexecuted'>                    params.claim = cache.position.upper;</span>
  44 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.upper].limit;</span>
  45 |     | <span class='neutral'>                }</span>
  46 |     | <span class='unexecuted'>                claimTickEpoch = cache.state.epoch;</span>
  47 |     | <span class='unexecuted'>            } else if (params.claim % cache.constants.tickSpacing != 0) {</span>
  48 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  49 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt1()&#39;);</span>
  50 |     | <span class='neutral'>                }</span>
  51 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  52 |     | <span class='neutral'>            }</span>
  53 |     | <span class='neutral'>        } else {</span>
  54 |     | <span class='unexecuted'>            if (cache.pool.price &lt;= cache.priceClaim) {</span>
  55 |     | <span class='unexecuted'>                if (cache.pool.price &gt;= cache.priceLower) {</span>
  56 |     | <span class='unexecuted'>                    cache.priceClaim = cache.pool.price;</span>
  57 |     | <span class='unexecuted'>                    params.claim = TickMap.roundBack(cache.pool.tickAtPrice, cache.constants, params.zeroForOne, cache.priceClaim);</span>
  58 |     | <span class='unexecuted'>                    claimTickEpoch = cache.state.epoch;</span>
  59 |     | <span class='neutral'>                } else {</span>
  60 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
  61 |     | <span class='unexecuted'>                    params.claim = cache.position.lower;</span>
  62 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.upper].limit;</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>                }</span>
  65 |     | <span class='unexecuted'>                claimTickEpoch = cache.state.epoch;</span>
  66 |     | <span class='unexecuted'>            } else if (params.claim % cache.constants.tickSpacing != 0) {</span>
  67 |     | <span class='unexecuted'>                if (cache.claimTick.priceAt == 0) {</span>
  68 |     | <span class='unexecuted'>                    require (false, &#39;WrongTickClaimedAt2()&#39;);</span>
  69 |     | <span class='neutral'>                }</span>
  70 |     | <span class='unexecuted'>                cache.priceClaim = cache.claimTick.priceAt;</span>
  71 |     | <span class='neutral'>            }</span>
  72 |     | <span class='neutral'>        }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>        // validate claim tick</span>
  75 |     | <span class='unexecuted'>        if (params.claim == (params.zeroForOne ? cache.position.upper : cache.position.lower)) {</span>
  76 |     | <span class='neutral'>            // set params.amount to 0 for event emitted at end</span>
  77 |     | <span class='unexecuted'>            cache.liquidityBurned = 0;</span>
  78 |     | <span class='unexecuted'>             if (claimTickEpoch &lt;= cache.position.epochLast)</span>
  79 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt3()&#39;);</span>
  80 |     | <span class='unexecuted'>        } else if (cache.liquidityBurned &gt; 0) {</span>
  81 |     | <span class='neutral'>            /// @dev - partway claim is valid as long as liquidity is not being removed</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // if we cleared the final tick of their position, this is the wrong claim tick</span>
  84 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  85 |     | <span class='unexecuted'>                uint32 endTickEpoch = EpochMap.get(cache.position.upper, params.zeroForOne, tickMap, cache.constants);</span>
  86 |     | <span class='unexecuted'>                if (endTickEpoch &gt; cache.position.epochLast) {</span>
  87 |     | <span class='unexecuted'>                    params.claim = cache.position.upper;</span>
  88 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceUpper;</span>
  89 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.upper].limit;</span>
  90 |     | <span class='unexecuted'>                    cache.liquidityBurned = cache.position.liquidity;</span>
  91 |     | <span class='unexecuted'>                } else {</span>
  92 |     | <span class='unexecuted'>                    int24 claimTickNext = TickMap.next(tickMap, params.claim, cache.constants.tickSpacing, false);</span>
  93 |     | <span class='unexecuted'>                    uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, cache.constants);</span>
  94 |     | <span class='neutral'>                    ///@dev - next swapEpoch should not be greater</span>
  95 |     | <span class='unexecuted'>                    if (claimTickNextEpoch &gt; cache.position.epochLast) {</span>
  96 |     | <span class='unexecuted'>                        require (false, &#39;WrongTickClaimedAt5()&#39;);</span>
  97 |     | <span class='neutral'>                    }</span>
  98 |     | <span class='neutral'>                }</span>
  99 |     | <span class='unexecuted'>            } else {</span>
 100 |     | <span class='unexecuted'>                uint32 endTickEpoch = EpochMap.get(cache.position.lower, params.zeroForOne, tickMap, cache.constants);</span>
 101 |     | <span class='unexecuted'>                if (endTickEpoch &gt; cache.position.epochLast) {</span>
 102 |     | <span class='unexecuted'>                    params.claim = cache.position.lower;</span>
 103 |     | <span class='unexecuted'>                    cache.priceClaim = cache.priceLower;</span>
 104 |     | <span class='unexecuted'>                    cache.claimTick = ticks[cache.position.lower].limit;</span>
 105 |     | <span class='unexecuted'>                    cache.liquidityBurned = cache.position.liquidity;</span>
 106 |     | <span class='unexecuted'>                } else {</span>
 107 |     | <span class='unexecuted'>                    int24 claimTickNext = TickMap.previous(tickMap, params.claim, cache.constants.tickSpacing, false);</span>
 108 |     | <span class='unexecuted'>                    uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, cache.constants);</span>
 109 |     | <span class='neutral'>                    ///@dev - next swapEpoch should not be greater</span>
 110 |     | <span class='unexecuted'>                    if (claimTickNextEpoch &gt; cache.position.epochLast) {</span>
 111 |     | <span class='unexecuted'>                        require (false, &#39;WrongTickClaimedAt5()&#39;);</span>
 112 |     | <span class='neutral'>                    }</span>
 113 |     | <span class='neutral'>                }</span>
 114 |     | <span class='neutral'>            }</span>
 115 |     | <span class='neutral'>        }</span>
 116 |     | <span class='neutral'>        /// @dev - start tick does not overwrite position and final tick clears position</span>
 117 |     | <span class='unexecuted'>        if (params.claim != cache.position.upper &amp;&amp; params.claim != cache.position.lower) {</span>
 118 |     | <span class='neutral'>            // check epochLast on claim tick</span>
 119 |     | <span class='unexecuted'>            if (claimTickEpoch &lt;= cache.position.epochLast)</span>
 120 |     | <span class='unexecuted'>                require (false, &#39;WrongTickClaimedAt7()&#39;);</span>
 121 |     | <span class='neutral'>        }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        // early return if no update and amount burned is 0</span>
 124 |     | <span class='neutral'>        //TODO: after we&#39;ve cycled through claim ticks and there are no position updates just revert - DONE</span>
 125 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == cache.position.lower</span>
 126 |     | <span class='unexecuted'>                              : params.claim == cache.position.upper) {</span>
 127 |     | <span class='unexecuted'>            if (cache.liquidityBurned == 0)</span>
 128 |     | <span class='unexecuted'>                require(false, &#39;NoPositionUpdates()&#39;);</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>        return (params, cache);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function getDeltas(</span>
 135 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
 136 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 137 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 138 |     | <span class='neutral'>    ) internal pure returns (</span>
 139 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 140 |     | <span class='neutral'>    ) {</span>
 141 |     | <span class='neutral'>        // if half tick priceAt &gt; 0 add amountOut to amountOutClaimed</span>
 142 |     | <span class='neutral'>        // set claimPriceLast if zero</span>
 143 |     | <span class='unexecuted'>        if (!cache.position.crossedInto) {</span>
 144 |     | <span class='unexecuted'>            cache.position.crossedInto = true;</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='unexecuted'>        LimitPoolStructs.GetDeltasLocals memory locals;</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>        if (params.claim % constants.tickSpacing != 0)</span>
 149 |     | <span class='neutral'>        // this should pass price at the claim tick</span>
 150 |     | <span class='unexecuted'>            locals.previousFullTick = TickMap.roundBack(params.claim, constants, params.zeroForOne, ConstantProduct.getPriceAtTick(params.claim, constants));</span>
 151 |     | <span class='neutral'>        else</span>
 152 |     | <span class='unexecuted'>            locals.previousFullTick = params.claim;</span>
 153 |     | <span class='unexecuted'>        locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 154 |     | <span class='unexecuted'>        if (params.zeroForOne ? locals.previousFullTick &gt; cache.position.lower</span>
 155 |     | <span class='unexecuted'>                              : locals.previousFullTick &lt; cache.position.upper) {</span>
 156 |     | <span class='neutral'>            </span>
 157 |     | <span class='neutral'>            // claim amounts up to latest full tick crossed</span>
 158 |     | <span class='unexecuted'>            cache.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.position.liquidity, cache.priceLower, locals.pricePrevious, false)</span>
 159 |     | <span class='unexecuted'>                                                        : ConstantProduct.getDx(cache.position.liquidity, locals.pricePrevious, cache.priceUpper, false));</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; 0) {</span>
 162 |     | <span class='neutral'>           // if tick hasn&#39;t been set back calculate amountIn</span>
 163 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &gt; locals.pricePrevious</span>
 164 |     | <span class='unexecuted'>                                  : cache.priceClaim &lt; locals.pricePrevious) {</span>
 165 |     | <span class='neutral'>                // allow partial tick claim if removing liquidity</span>
 166 |     | <span class='unexecuted'>                cache.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.liquidityBurned, locals.pricePrevious, cache.priceClaim, false)</span>
 167 |     | <span class='unexecuted'>                                                            : ConstantProduct.getDx(cache.liquidityBurned, cache.priceClaim, locals.pricePrevious, false));</span>
 168 |     | <span class='neutral'>            }</span>
 169 |     | <span class='neutral'>            // use priceClaim if tick hasn&#39;t been set back</span>
 170 |     | <span class='neutral'>            // else use claimPriceLast to calculate amountOut</span>
 171 |     | <span class='unexecuted'>            if (params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower)) {</span>
 172 |     | <span class='unexecuted'>                cache.amountOut += uint128(params.zeroForOne ? ConstantProduct.getDx(cache.liquidityBurned, cache.priceClaim, cache.priceUpper, false)</span>
 173 |     | <span class='unexecuted'>                                                             : ConstantProduct.getDy(cache.liquidityBurned, cache.priceLower, cache.priceClaim, false));</span>
 174 |     | <span class='neutral'>            }</span>
 175 |     | <span class='neutral'>        }</span>
 176 |     | <span class='neutral'>        // take protocol fee if needed</span>
 177 |     | <span class='unexecuted'>        if (cache.pool.protocolFillFee &gt; 0 &amp;&amp; cache.amountIn &gt; 0) {</span>
 178 |     | <span class='unexecuted'>            uint128 protocolFeeAmount = OverflowMath.mulDiv(cache.amountIn, cache.pool.protocolFillFee, 1e4).toUint128();</span>
 179 |     | <span class='unexecuted'>            cache.amountIn -= protocolFeeAmount;</span>
 180 |     | <span class='unexecuted'>            cache.pool.protocolFees += protocolFeeAmount;</span>
 181 |     | <span class='neutral'>        }</span>
 182 |     | <span class='unexecuted'>        return cache;</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/EpochMap.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='unexecuted'>library EpochMap {</span>
   8 |     | <span class='neutral'>    event SyncLimitTick(</span>
   9 |     | <span class='neutral'>        uint32 epoch,</span>
  10 |     | <span class='neutral'>        int24 tick,</span>
  11 |     | <span class='neutral'>        bool zeroForOne</span>
  12 |     | <span class='neutral'>    );</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function set(</span>
  15 |     | <span class='neutral'>        int24  tick,</span>
  16 |     | <span class='neutral'>        bool zeroForOne,</span>
  17 |     | <span class='neutral'>        uint256 epoch,</span>
  18 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  19 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  20 |     | <span class='unexecuted'>    ) internal {</span>
  21 |     | <span class='unexecuted'>        (</span>
  22 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  23 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  24 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  25 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  26 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  27 |     | <span class='neutral'>        // assert epoch isn&#39;t bigger than max uint32</span>
  28 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
  29 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
  30 |     | <span class='neutral'>        // clear previous value</span>
  31 |     | <span class='unexecuted'>        epochValue &amp;=  ~(((1 &lt;&lt; 9) - 1) &lt;&lt; ((tickIndex &amp; 0x7) * 32));</span>
  32 |     | <span class='neutral'>        // add new value to word</span>
  33 |     | <span class='unexecuted'>        epochValue |= epoch &lt;&lt; ((tickIndex &amp; 0x7) * 32);</span>
  34 |     | <span class='neutral'>        // store word in map</span>
  35 |     | <span class='unexecuted'>        zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue</span>
  36 |     | <span class='unexecuted'>                   : tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        emit SyncLimitTick(uint32(epoch), tick, zeroForOne);</span>
  39 |     | <span class='neutral'>    }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function get(</span>
  42 |     | <span class='neutral'>        int24 tick,</span>
  43 |     | <span class='neutral'>        bool zeroForOne,</span>
  44 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  45 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  46 |     | <span class='neutral'>    ) internal view returns (</span>
  47 |     | <span class='unexecuted'>        uint32 epoch</span>
  48 |     | <span class='neutral'>    ) {</span>
  49 |     | <span class='unexecuted'>        (</span>
  50 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  51 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  52 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  53 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  54 |     | <span class='unexecuted'>        ) = getIndices(tick, constants);</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>        uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]</span>
  57 |     | <span class='unexecuted'>                                        : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];</span>
  58 |     | <span class='neutral'>        // right shift so first 8 bits are epoch value</span>
  59 |     | <span class='unexecuted'>        epochValue &gt;&gt;= ((tickIndex &amp; 0x7) * 32);</span>
  60 |     | <span class='neutral'>        // clear other bits</span>
  61 |     | <span class='unexecuted'>        epochValue &amp;= ((1 &lt;&lt; 32) - 1);</span>
  62 |     | <span class='unexecuted'>        return uint32(epochValue);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function getIndices(</span>
  66 |     | <span class='neutral'>        int24 tick,</span>
  67 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  68 |     | <span class='neutral'>    ) internal pure returns (</span>
  69 |     | <span class='unexecuted'>            uint256 tickIndex,</span>
  70 |     | <span class='unexecuted'>            uint256 wordIndex,</span>
  71 |     | <span class='unexecuted'>            uint256 blockIndex,</span>
  72 |     | <span class='unexecuted'>            uint256 volumeIndex</span>
  73 |     | <span class='neutral'>        )</span>
  74 |     | <span class='neutral'>    {</span>
  75 |     | <span class='neutral'>        unchecked {</span>
  76 |     | <span class='unexecuted'>            if (tick &gt; ConstantProduct.maxTick(constants.tickSpacing)) require (false, &#39;TickIndexOverflow()&#39;);</span>
  77 |     | <span class='unexecuted'>            if (tick &lt; ConstantProduct.minTick(constants.tickSpacing)) require (false, &#39;TickIndexUnderflow()&#39;);</span>
  78 |     | <span class='unexecuted'>            if (tick % (constants.tickSpacing / 2) != 0) {</span>
  79 |     | <span class='unexecuted'>                require (false, &#39;TickIndexInvalid()&#39;);</span>
  80 |     | <span class='neutral'>            } </span>
  81 |     | <span class='unexecuted'>            tickIndex = uint256(int256((_round(tick, constants.tickSpacing / 2) </span>
  82 |     | <span class='unexecuted'>                                        - _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2)) </span>
  83 |     | <span class='unexecuted'>                                        / (constants.tickSpacing / 2)));</span>
  84 |     | <span class='unexecuted'>            wordIndex = tickIndex &gt;&gt; 3;        // 2^3 epochs per word</span>
  85 |     | <span class='unexecuted'>            blockIndex = tickIndex &gt;&gt; 11;      // 2^8 words per block</span>
  86 |     | <span class='unexecuted'>            volumeIndex = tickIndex &gt;&gt; 19;     // 2^8 blocks per volume</span>
  87 |     | <span class='unexecuted'>            if (blockIndex &gt; 2046) require (false, &#39;BlockIndexOverflow()&#39;);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    function _round(</span>
  92 |     | <span class='neutral'>        int24 tick,</span>
  93 |     | <span class='neutral'>        int24 tickSpacing</span>
  94 |     | <span class='neutral'>    ) internal pure returns (</span>
  95 |     | <span class='unexecuted'>        int24 roundedTick</span>
  96 |     | <span class='neutral'>    ) {</span>
  97 |     | <span class='unexecuted'>        return tick / tickSpacing * tickSpacing;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/LimitPositions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LimitTicks.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./Claims.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../../test/echidna/EchidnaAssertions.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  16 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  17 |     | <span class='unexecuted'>library LimitPositions {</span>
  18 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event BurnLimit(</span>
  21 |     | <span class='neutral'>        address indexed to,</span>
  22 |     | <span class='neutral'>        uint32 positionId,</span>
  23 |     | <span class='neutral'>        int24 lower,</span>
  24 |     | <span class='neutral'>        int24 upper,</span>
  25 |     | <span class='neutral'>        int24 oldClaim,</span>
  26 |     | <span class='neutral'>        int24 newClaim,</span>
  27 |     | <span class='neutral'>        bool zeroForOne,</span>
  28 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  29 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  30 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  31 |     | <span class='neutral'>    );</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>    function resize(</span>
  34 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  35 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  38 |     | <span class='neutral'>        LimitPoolStructs.MintLimitParams memory params,</span>
  39 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
  40 |     | <span class='neutral'>    ) internal returns (</span>
  41 |     | <span class='unexecuted'>        LimitPoolStructs.MintLimitParams memory,</span>
  42 |     | <span class='unexecuted'>        LimitPoolStructs.MintLimitCache memory</span>
  43 |     | <span class='neutral'>    )</span>
  44 |     | <span class='neutral'>    {</span>
  45 |     | <span class='unexecuted'>        ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
  48 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
  49 |     | <span class='unexecuted'>        cache.mintSize = uint256(params.mintPercent) * uint256(params.amount) / 1e28;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>        // calculate L constant</span>
  52 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  53 |     | <span class='unexecuted'>            cache.priceLower,</span>
  54 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  55 |     | <span class='unexecuted'>            params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
  56 |     | <span class='unexecuted'>            params.zeroForOne ? 0 : uint256(params.amount),</span>
  57 |     | <span class='unexecuted'>            params.zeroForOne ? uint256(params.amount) : 0</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) require (false, &#39;PositionLiquidityZero()&#39;);</span>
  61 |     | <span class='neutral'>        // calculate price limit by using half of input</span>
  62 |     | <span class='neutral'>        {</span>
  63 |     | <span class='unexecuted'>            cache.priceLimit = params.zeroForOne ? ConstantProduct.getNewPrice(cache.priceUpper, cache.liquidityMinted, params.amount / 2, true, true)</span>
  64 |     | <span class='unexecuted'>                                                 : ConstantProduct.getNewPrice(cache.priceLower, cache.liquidityMinted, params.amount / 2, false, true);</span>
  65 |     | <span class='unexecuted'>            if (cache.priceLimit == 0) require (false, &#39;PriceLimitZero()&#39;);</span>
  66 |     | <span class='neutral'>            // get tick at price</span>
  67 |     | <span class='unexecuted'>            cache.tickLimit = ConstantProduct.getTickAtPrice(cache.priceLimit.toUint160(), cache.constants);</span>
  68 |     | <span class='neutral'>            // round to nearest tick spacing</span>
  69 |     | <span class='unexecuted'>            cache.priceLimit = ConstantProduct.getPriceAtTick(cache.tickLimit, cache.constants);</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory swapCache;</span>
  73 |     | <span class='unexecuted'>        swapCache.state = cache.state;</span>
  74 |     | <span class='unexecuted'>        swapCache.constants = cache.constants;</span>
  75 |     | <span class='unexecuted'>        swapCache.price = cache.state.pool.price;</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>        // swap zero if no liquidity near market price</span>
  78 |     | <span class='unexecuted'>        if (cache.state.pool.liquidity == 0 &amp;&amp; </span>
  79 |     | <span class='unexecuted'>            (params.zeroForOne ? swapCache.price &gt; cache.priceLower</span>
  80 |     | <span class='unexecuted'>                               : swapCache.price &lt; cache.priceUpper)) {</span>
  81 |     | <span class='unexecuted'>            swapCache = Ticks.swap(</span>
  82 |     | <span class='unexecuted'>                ticks,</span>
  83 |     | <span class='unexecuted'>                samples,</span>
  84 |     | <span class='unexecuted'>                rangeTickMap,</span>
  85 |     | <span class='unexecuted'>                limitTickMap,</span>
  86 |     | <span class='unexecuted'>                PoolsharkStructs.SwapParams({</span>
  87 |     | <span class='unexecuted'>                    to: params.to,</span>
  88 |     | <span class='unexecuted'>                    priceLimit: (params.zeroForOne ? cache.priceLower </span>
  89 |     | <span class='unexecuted'>                                                   : cache.priceUpper).toUint160(),</span>
  90 |     | <span class='unexecuted'>                    amount: 0,</span>
  91 |     | <span class='neutral'>                    //TODO: handle exactOut</span>
  92 |     | <span class='unexecuted'>                    exactIn: true,</span>
  93 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
  94 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
  95 |     | <span class='neutral'>                }),</span>
  96 |     | <span class='unexecuted'>                swapCache</span>
  97 |     | <span class='neutral'>            );</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>        // only swap if priceLimit is beyond current pool price</span>
 101 |     | <span class='unexecuted'>        if (params.zeroForOne ? cache.priceLimit &lt; swapCache.price</span>
 102 |     | <span class='unexecuted'>                              : cache.priceLimit &gt; swapCache.price) {</span>
 103 |     | <span class='neutral'>            // swap and save the pool state</span>
 104 |     | <span class='unexecuted'>            swapCache = Ticks.swap(</span>
 105 |     | <span class='unexecuted'>                ticks,</span>
 106 |     | <span class='unexecuted'>                samples,</span>
 107 |     | <span class='unexecuted'>                rangeTickMap,</span>
 108 |     | <span class='unexecuted'>                limitTickMap,</span>
 109 |     | <span class='unexecuted'>                PoolsharkStructs.SwapParams({</span>
 110 |     | <span class='unexecuted'>                    to: params.to,</span>
 111 |     | <span class='unexecuted'>                    priceLimit: cache.priceLimit.toUint160(),</span>
 112 |     | <span class='unexecuted'>                    amount: params.amount,</span>
 113 |     | <span class='neutral'>                    //TODO: handle exactOut</span>
 114 |     | <span class='unexecuted'>                    exactIn: true,</span>
 115 |     | <span class='unexecuted'>                    zeroForOne: params.zeroForOne,</span>
 116 |     | <span class='unexecuted'>                    callbackData: abi.encodePacked(bytes1(0x0))</span>
 117 |     | <span class='neutral'>                }),</span>
 118 |     | <span class='unexecuted'>                swapCache</span>
 119 |     | <span class='neutral'>            );</span>
 120 |     | <span class='neutral'>            // subtract from remaining input amount</span>
 121 |     | <span class='unexecuted'>            params.amount -= uint128(swapCache.input);</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        }</span>
 124 |     | <span class='neutral'>        // save to cache</span>
 125 |     | <span class='unexecuted'>        cache.swapCache = swapCache;</span>
 126 |     | <span class='unexecuted'>        cache.state = swapCache.state;</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        if (params.amount &lt; cache.mintSize) params.amount = 0;</span>
 129 |     | <span class='neutral'>        // move start tick based on amount filled in swap</span>
 130 |     | <span class='unexecuted'>        if ((params.amount &gt; 0 &amp;&amp; swapCache.input &gt; 0) ||</span>
 131 |     | <span class='unexecuted'>            (params.zeroForOne ? cache.priceLower &lt; swapCache.price</span>
 132 |     | <span class='unexecuted'>                               : cache.priceUpper &gt; swapCache.price)</span>
 133 |     | <span class='neutral'>        ) {</span>
 134 |     | <span class='neutral'>            // move the tick limit based on pool.tickAtPrice</span>
 135 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceLower &lt; swapCache.price</span>
 136 |     | <span class='unexecuted'>                                  : cache.priceUpper &gt; swapCache.price) {</span>
 137 |     | <span class='unexecuted'>                cache.tickLimit = swapCache.state.pool.tickAtPrice;</span>
 138 |     | <span class='neutral'>            }</span>
 139 |     | <span class='neutral'>            // round ahead tickLimit to avoid crossing epochs</span>
 140 |     | <span class='unexecuted'>            cache.tickLimit = TickMap.roundAhead(cache.tickLimit, cache.constants, params.zeroForOne, swapCache.price);</span>
 141 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 142 |     | <span class='unexecuted'>                if (cache.priceLower &lt; swapCache.price) {</span>
 143 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 144 |     | <span class='neutral'>                    /// @dev - if swap didn&#39;t go to limit user would be 100% filled</span>
 145 |     | <span class='unexecuted'>                    params.lower = cache.tickLimit;</span>
 146 |     | <span class='unexecuted'>                    cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 147 |     | <span class='neutral'>                }</span>
 148 |     | <span class='unexecuted'>                if (params.lower &gt;= params.upper &amp;&amp; </span>
 149 |     | <span class='unexecuted'>                    params.lower &lt; ConstantProduct.maxTick(cache.constants.tickSpacing) - cache.constants.tickSpacing</span>
 150 |     | <span class='neutral'>                ) {</span>
 151 |     | <span class='unexecuted'>                    params.upper = params.lower + cache.constants.tickSpacing;</span>
 152 |     | <span class='neutral'>                }</span>
 153 |     | <span class='unexecuted'>                cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 154 |     | <span class='neutral'>            } else {</span>
 155 |     | <span class='unexecuted'>                if (cache.priceUpper &gt; swapCache.price) {</span>
 156 |     | <span class='neutral'>                    // if rounding goes past limit trim position</span>
 157 |     | <span class='unexecuted'>                    params.upper = cache.tickLimit;</span>
 158 |     | <span class='unexecuted'>                    cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 159 |     | <span class='neutral'>                }</span>
 160 |     | <span class='unexecuted'>                if (params.upper &lt;= params.lower &amp;&amp; </span>
 161 |     | <span class='unexecuted'>                    params.lower &gt; ConstantProduct.minTick(cache.constants.tickSpacing) + cache.constants.tickSpacing</span>
 162 |     | <span class='neutral'>                ) {</span>
 163 |     | <span class='unexecuted'>                    params.lower = params.upper - cache.constants.tickSpacing;</span>
 164 |     | <span class='neutral'>                }</span>
 165 |     | <span class='unexecuted'>                cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 166 |     | <span class='neutral'>            }</span>
 167 |     | <span class='unexecuted'>            if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper)</span>
 168 |     | <span class='unexecuted'>                cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
 169 |     | <span class='unexecuted'>                    cache.priceLower,</span>
 170 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
 171 |     | <span class='unexecuted'>                    params.zeroForOne ? cache.priceLower : cache.priceUpper,</span>
 172 |     | <span class='unexecuted'>                    params.zeroForOne ? 0 : uint256(params.amount),</span>
 173 |     | <span class='unexecuted'>                    params.zeroForOne ? uint256(params.amount) : 0</span>
 174 |     | <span class='neutral'>                );</span>
 175 |     | <span class='neutral'>            else</span>
 176 |     | <span class='neutral'>                /// @auditor unnecessary since params.amount is 0</span>
 177 |     | <span class='unexecuted'>                cache.liquidityMinted = 0;</span>
 178 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>        /// @dev - for safety</span>
 182 |     | <span class='unexecuted'>        if (params.lower &gt;= params.upper) {</span>
 183 |     | <span class='neutral'>            // zero out amount transferred in</span>
 184 |     | <span class='unexecuted'>            params.amount = 0;</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>        return (</span>
 188 |     | <span class='unexecuted'>            params,</span>
 189 |     | <span class='unexecuted'>            cache</span>
 190 |     | <span class='neutral'>        );</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>    function add(</span>
 194 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 195 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 196 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 197 |     | <span class='neutral'>        LimitPoolStructs.MintLimitParams memory params</span>
 198 |     | <span class='neutral'>    ) internal returns (</span>
 199 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory,</span>
 200 |     | <span class='unexecuted'>        LimitPoolStructs.LimitPosition memory</span>
 201 |     | <span class='neutral'>    ) {</span>
 202 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) return (cache.pool, cache.position);</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 205 |     | <span class='unexecuted'>            cache.position.epochLast = cache.state.epoch;</span>
 206 |     | <span class='unexecuted'>            cache.state.epoch += 1; // increment for future swaps</span>
 207 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).mint(msg.sender, params.positionId, 1, cache.constants);</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='neutral'>            // safety check in case we somehow get here</span>
 210 |     | <span class='unexecuted'>            if (</span>
 211 |     | <span class='unexecuted'>                params.zeroForOne</span>
 212 |     | <span class='unexecuted'>                    ? EpochMap.get(params.lower, params.zeroForOne, tickMap, cache.constants)</span>
 213 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 214 |     | <span class='unexecuted'>                    : EpochMap.get(params.upper, params.zeroForOne, tickMap, cache.constants)</span>
 215 |     | <span class='unexecuted'>                            &gt; cache.position.epochLast</span>
 216 |     | <span class='neutral'>            ) {</span>
 217 |     | <span class='unexecuted'>                require (false, &#39;PositionAlreadyEntered()&#39;);</span>
 218 |     | <span class='neutral'>            }</span>
 219 |     | <span class='neutral'>            /// @auditor maybe this shouldn&#39;t be a revert but rather just not mint the position?</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='neutral'>        </span>
 222 |     | <span class='neutral'>        // add liquidity to ticks</span>
 223 |     | <span class='unexecuted'>        LimitTicks.insert(</span>
 224 |     | <span class='unexecuted'>            ticks,</span>
 225 |     | <span class='unexecuted'>            tickMap,</span>
 226 |     | <span class='unexecuted'>            cache,</span>
 227 |     | <span class='unexecuted'>            params</span>
 228 |     | <span class='neutral'>        );</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>        // update liquidity global</span>
 231 |     | <span class='unexecuted'>        cache.state.liquidityGlobal += uint128(cache.liquidityMinted);</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(cache.liquidityMinted);</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='unexecuted'>        return (cache.pool, cache.position);</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>    function update(</span>
 239 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 240 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 241 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 242 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params</span>
 243 |     | <span class='neutral'>    ) internal returns (</span>
 244 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitParams memory,</span>
 245 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 246 |     | <span class='neutral'>    )</span>
 247 |     | <span class='neutral'>    {</span>
 248 |     | <span class='unexecuted'>        (</span>
 249 |     | <span class='neutral'>            params,</span>
 250 |     | <span class='neutral'>            cache</span>
 251 |     | <span class='unexecuted'>        ) = _deltas(</span>
 252 |     | <span class='unexecuted'>            ticks,</span>
 253 |     | <span class='unexecuted'>            tickMap,</span>
 254 |     | <span class='unexecuted'>            params,</span>
 255 |     | <span class='unexecuted'>            cache</span>
 256 |     | <span class='neutral'>        );</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>        // update pool liquidity</span>
 259 |     | <span class='unexecuted'>        if (cache.priceClaim == cache.pool.price &amp;&amp; cache.liquidityBurned &gt; 0) {</span>
 260 |     | <span class='neutral'>            // handle pool.price at edge of range</span>
 261 |     | <span class='unexecuted'>            if (params.zeroForOne ? cache.priceClaim &lt; cache.priceUpper</span>
 262 |     | <span class='unexecuted'>                                  : cache.priceClaim &gt; cache.priceLower)</span>
 263 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityUnderflows(cache.pool.liquidity, cache.liquidityBurned, &quot;PLU-3&quot;);</span>
 264 |     | <span class='unexecuted'>                cache.pool.liquidity -= cache.liquidityBurned;</span>
 265 |     | <span class='neutral'>        }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; 0) {</span>
 268 |     | <span class='unexecuted'>            if (params.claim == (params.zeroForOne ? cache.position.upper : cache.position.lower)) {</span>
 269 |     | <span class='neutral'>                // if claim is final tick no liquidity to remove</span>
 270 |     | <span class='unexecuted'>                cache.removeLower = false;</span>
 271 |     | <span class='unexecuted'>                cache.removeUpper = false;</span>
 272 |     | <span class='neutral'>            } else {</span>
 273 |     | <span class='neutral'>                // else remove liquidity from final tick</span>
 274 |     | <span class='unexecuted'>                params.zeroForOne ? cache.removeUpper = true </span>
 275 |     | <span class='unexecuted'>                                  : cache.removeLower = true;</span>
 276 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>                    if (params.claim == cache.position.lower &amp;&amp; </span>
 279 |     | <span class='unexecuted'>                        cache.pool.price &lt; cache.priceLower</span>
 280 |     | <span class='neutral'>                    ) {</span>
 281 |     | <span class='neutral'>                        // full tick price was touched</span>
 282 |     | <span class='unexecuted'>                        cache.removeLower = true;</span>
 283 |     | <span class='unexecuted'>                    } else if (params.claim % cache.constants.tickSpacing != 0 &amp;&amp; </span>
 284 |     | <span class='unexecuted'>                                    cache.pool.price &lt; cache.priceClaim)</span>
 285 |     | <span class='neutral'>                        // half tick was created</span>
 286 |     | <span class='unexecuted'>                        cache.removeLower = true;</span>
 287 |     | <span class='neutral'>                } else {</span>
 288 |     | <span class='unexecuted'>                    if (params.claim == cache.position.upper &amp;&amp;</span>
 289 |     | <span class='unexecuted'>                        cache.pool.price &gt; cache.priceUpper</span>
 290 |     | <span class='neutral'>                    )</span>
 291 |     | <span class='neutral'>                        // full tick price was touched</span>
 292 |     | <span class='unexecuted'>                        cache.removeUpper = true;</span>
 293 |     | <span class='unexecuted'>                    else if (params.claim % cache.constants.tickSpacing != 0 &amp;&amp;</span>
 294 |     | <span class='unexecuted'>                                    cache.pool.price &gt; cache.priceClaim)</span>
 295 |     | <span class='neutral'>                        // half tick was created</span>
 296 |     | <span class='unexecuted'>                        cache.removeUpper = true;</span>
 297 |     | <span class='neutral'>                }</span>
 298 |     | <span class='neutral'>            }</span>
 299 |     | <span class='unexecuted'>            LimitTicks.remove(</span>
 300 |     | <span class='unexecuted'>                ticks,</span>
 301 |     | <span class='unexecuted'>                tickMap,</span>
 302 |     | <span class='unexecuted'>                params,</span>
 303 |     | <span class='unexecuted'>                cache,</span>
 304 |     | <span class='unexecuted'>                cache.constants</span>
 305 |     | <span class='neutral'>            );</span>
 306 |     | <span class='neutral'>            // update position liquidity</span>
 307 |     | <span class='unexecuted'>            cache.position.liquidity -= uint128(cache.liquidityBurned);</span>
 308 |     | <span class='neutral'>            // update global liquidity</span>
 309 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.liquidityBurned, &quot;LGU-2&quot;);</span>
 310 |     | <span class='unexecuted'>            cache.state.liquidityGlobal -= cache.liquidityBurned;</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim == cache.position.upper</span>
 313 |     | <span class='unexecuted'>                              : params.claim == cache.position.lower) {</span>
 314 |     | <span class='unexecuted'>            EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.position.liquidity, &quot;LGU-3&quot;);</span>
 315 |     | <span class='unexecuted'>            cache.state.liquidityGlobal -= cache.position.liquidity;</span>
 316 |     | <span class='unexecuted'>            cache.position.liquidity = 0;</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>        // clear out old position</span>
 319 |     | <span class='unexecuted'>        if (params.zeroForOne ? params.claim != cache.position.lower </span>
 320 |     | <span class='unexecuted'>                              : params.claim != cache.position.upper) {</span>
 321 |     | <span class='neutral'>            /// @dev - this also clears out position end claims</span>
 322 |     | <span class='unexecuted'>            if (params.zeroForOne ? params.claim == cache.position.lower </span>
 323 |     | <span class='unexecuted'>                                  : params.claim == cache.position.upper) {</span>
 324 |     | <span class='neutral'>                // subtract remaining position liquidity out from global</span>
 325 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.position.liquidity, &quot;LGU-4&quot;);</span>
 326 |     | <span class='unexecuted'>                cache.state.liquidityGlobal -= cache.position.liquidity;</span>
 327 |     | <span class='neutral'>            }</span>
 328 |     | <span class='neutral'>        }</span>
 329 |     | <span class='neutral'>        // clear position if empty</span>
 330 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 331 |     | <span class='unexecuted'>            cache.position.epochLast = 0;</span>
 332 |     | <span class='unexecuted'>            cache.position.crossedInto = false;</span>
 333 |     | <span class='neutral'>        }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>        // round back claim tick for storage</span>
 336 |     | <span class='unexecuted'>        if (params.claim % cache.constants.tickSpacing != 0) {</span>
 337 |     | <span class='unexecuted'>            cache.claim = params.claim;</span>
 338 |     | <span class='unexecuted'>            params.claim = TickMap.roundBack(params.claim, cache.constants, params.zeroForOne, cache.priceClaim);</span>
 339 |     | <span class='neutral'>        }</span>
 340 |     | <span class='neutral'>        </span>
 341 |     | <span class='unexecuted'>        emit BurnLimit(</span>
 342 |     | <span class='unexecuted'>            params.to,</span>
 343 |     | <span class='unexecuted'>            params.positionId,</span>
 344 |     | <span class='unexecuted'>            cache.position.lower,</span>
 345 |     | <span class='unexecuted'>            cache.position.upper,</span>
 346 |     | <span class='unexecuted'>            cache.claim,</span>
 347 |     | <span class='unexecuted'>            params.claim,</span>
 348 |     | <span class='unexecuted'>            params.zeroForOne,</span>
 349 |     | <span class='unexecuted'>            cache.liquidityBurned,</span>
 350 |     | <span class='unexecuted'>            cache.amountIn,</span>
 351 |     | <span class='unexecuted'>            cache.amountOut</span>
 352 |     | <span class='neutral'>        );</span>
 353 |     | <span class='neutral'></span>
 354 |     | <span class='neutral'>        // save pool to state in memory</span>
 355 |     | <span class='unexecuted'>        if (params.zeroForOne) cache.state.pool0 = cache.pool;</span>
 356 |     | <span class='unexecuted'>        else cache.state.pool1 = cache.pool;</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>        return (params, cache);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='unexecuted'>    function snapshot(</span>
 362 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 363 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 364 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 365 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params</span>
 366 |     | <span class='neutral'>    ) internal view returns (</span>
 367 |     | <span class='unexecuted'>        uint128 amountIn,</span>
 368 |     | <span class='unexecuted'>        uint128 amountOut</span>
 369 |     | <span class='neutral'>    ) {</span>
 370 |     | <span class='unexecuted'>        (</span>
 371 |     | <span class='neutral'>            params,</span>
 372 |     | <span class='neutral'>            cache</span>
 373 |     | <span class='unexecuted'>        ) = _deltas(</span>
 374 |     | <span class='unexecuted'>            ticks,</span>
 375 |     | <span class='unexecuted'>            tickMap,</span>
 376 |     | <span class='unexecuted'>            params,</span>
 377 |     | <span class='unexecuted'>            cache</span>
 378 |     | <span class='neutral'>        );</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='unexecuted'>        return (cache.amountIn, cache.amountOut);</span>
 381 |     | <span class='neutral'>    }</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='unexecuted'>    function _deltas(</span>
 384 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 385 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 386 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
 387 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
 388 |     | <span class='neutral'>    ) internal view returns (</span>
 389 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitParams memory,</span>
 390 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 391 |     | <span class='neutral'>    ) {</span>
 392 |     | <span class='unexecuted'>        cache = LimitPoolStructs.BurnLimitCache({</span>
 393 |     | <span class='unexecuted'>            state: cache.state,</span>
 394 |     | <span class='unexecuted'>            pool: params.zeroForOne ? cache.state.pool0 : cache.state.pool1,</span>
 395 |     | <span class='unexecuted'>            claimTick: ticks[params.claim].limit,</span>
 396 |     | <span class='unexecuted'>            position: cache.position,</span>
 397 |     | <span class='unexecuted'>            constants: cache.constants,</span>
 398 |     | <span class='unexecuted'>            priceLower: ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants),</span>
 399 |     | <span class='unexecuted'>            priceClaim: ticks[params.claim].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(params.claim, cache.constants)</span>
 400 |     | <span class='unexecuted'>                                                               : ticks[params.claim].limit.priceAt,</span>
 401 |     | <span class='unexecuted'>            priceUpper: ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants),</span>
 402 |     | <span class='unexecuted'>            liquidityBurned: _convert(cache.position.liquidity, params.burnPercent),</span>
 403 |     | <span class='unexecuted'>            amountIn: 0,</span>
 404 |     | <span class='unexecuted'>            amountOut: 0,</span>
 405 |     | <span class='unexecuted'>            claim: params.claim,</span>
 406 |     | <span class='unexecuted'>            removeLower: false,</span>
 407 |     | <span class='unexecuted'>            removeUpper: false</span>
 408 |     | <span class='neutral'>        });</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>        // check claim is valid</span>
 411 |     | <span class='unexecuted'>        (params, cache) = Claims.validate(</span>
 412 |     | <span class='unexecuted'>            ticks,</span>
 413 |     | <span class='unexecuted'>            tickMap,</span>
 414 |     | <span class='unexecuted'>            params,</span>
 415 |     | <span class='unexecuted'>            cache</span>
 416 |     | <span class='neutral'>        );</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='neutral'>        // calculate position deltas</span>
 419 |     | <span class='unexecuted'>        cache = Claims.getDeltas(params, cache, cache.constants);</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        return (params, cache);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='unexecuted'>    function _convert(</span>
 425 |     | <span class='neutral'>        uint128 liquidity,</span>
 426 |     | <span class='neutral'>        uint128 percent</span>
 427 |     | <span class='neutral'>    ) internal pure returns (</span>
 428 |     | <span class='unexecuted'>        uint128</span>
 429 |     | <span class='neutral'>    ) {</span>
 430 |     | <span class='neutral'>        // convert percentage to liquidity amount</span>
 431 |     | <span class='unexecuted'>        if (percent &gt; 1e38) percent = 1e38;</span>
 432 |     | <span class='unexecuted'>        if (liquidity == 0 &amp;&amp; percent &gt; 0) require (false, &#39;PositionNotFound()&#39;);</span>
 433 |     | <span class='unexecuted'>        return uint128(uint256(liquidity) * uint256(percent) / 1e38);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/LimitTicks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolFactoryStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./LimitPositions.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./EpochMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>/// @notice Tick management library for limit pools</span>
  17 |     | <span class='unexecuted'>library LimitTicks {</span>
  18 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  19 |     | <span class='neutral'>    error LiquidityUnderflow();</span>
  20 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  21 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  22 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  23 |     | <span class='neutral'>    error InvalidPositionBounds();</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event SyncLimitLiquidity(</span>
  30 |     | <span class='neutral'>        uint128 liquidityAdded,</span>
  31 |     | <span class='neutral'>        int24 tick,</span>
  32 |     | <span class='neutral'>        bool zeroForOne</span>
  33 |     | <span class='neutral'>    );</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function validate(</span>
  36 |     | <span class='neutral'>        int24 lower,</span>
  37 |     | <span class='neutral'>        int24 upper,</span>
  38 |     | <span class='neutral'>        int24 tickSpacing</span>
  39 |     | <span class='neutral'>    ) internal pure {</span>
  40 |     | <span class='neutral'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  41 |     | <span class='neutral'>        if (lower &lt;= ConstantProduct.MIN_TICK) require(false, &#39;InvalidLowerTick()&#39;);</span>
  42 |     | <span class='neutral'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  43 |     | <span class='neutral'>        if (upper &gt;= ConstantProduct.MAX_TICK) require(false, &#39;InvalidUpperTick()&#39;);</span>
  44 |     | <span class='neutral'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>    function insert(</span>
  48 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  49 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  50 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
  51 |     | <span class='neutral'>        LimitPoolStructs.MintLimitParams memory params</span>
  52 |     | <span class='unexecuted'>    ) internal {</span>
  53 |     | <span class='neutral'>        /// @auditor - validation of ticks is in Positions.validate</span>
  54 |     | <span class='unexecuted'>        if (cache.liquidityMinted &gt; (uint128(type(int128).max) - cache.state.liquidityGlobal) )</span>
  55 |     | <span class='unexecuted'>            require (false, &#39;LiquidityOverflow()&#39;);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>        int256 liquidityMinted = int256(cache.liquidityMinted);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        // check if adding liquidity necessary</span>
  60 |     | <span class='unexecuted'>        if (!params.zeroForOne || cache.priceLower &gt; cache.pool.price) {</span>
  61 |     | <span class='neutral'>            // sets bit in map</span>
  62 |     | <span class='unexecuted'>            if(!TickMap.set(tickMap, params.lower, cache.constants.tickSpacing)){</span>
  63 |     | <span class='neutral'>                // inherit epoch </span>
  64 |     | <span class='unexecuted'>                int24 tickAhead;</span>
  65 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  66 |     | <span class='unexecuted'>                    tickAhead  = TickMap.next(tickMap, params.lower, cache.constants.tickSpacing, false);</span>
  67 |     | <span class='neutral'>                } else {</span>
  68 |     | <span class='unexecuted'>                    tickAhead  = TickMap.previous(tickMap, params.lower, cache.constants.tickSpacing, false);</span>
  69 |     | <span class='neutral'>                }</span>
  70 |     | <span class='unexecuted'>                uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);</span>
  71 |     | <span class='unexecuted'>                EpochMap.set(params.lower, params.zeroForOne, epochAhead, tickMap, cache.constants);</span>
  72 |     | <span class='neutral'>            }</span>
  73 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickLower = ticks[params.lower].limit;</span>
  74 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
  75 |     | <span class='unexecuted'>                tickLower.liquidityDelta += int128(liquidityMinted);</span>
  76 |     | <span class='neutral'>            } else {</span>
  77 |     | <span class='unexecuted'>                tickLower.liquidityDelta -= int128(liquidityMinted);</span>
  78 |     | <span class='neutral'>            }</span>
  79 |     | <span class='unexecuted'>            tickLower.liquidityAbsolute += cache.liquidityMinted.toUint128();</span>
  80 |     | <span class='unexecuted'>            ticks[params.lower].limit = tickLower;</span>
  81 |     | <span class='neutral'>        } else {</span>
  82 |     | <span class='neutral'>            /// @dev - i.e. if zeroForOne &amp;&amp; cache.priceLower &lt;= cache.pool.price</span>
  83 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
  84 |     | <span class='neutral'>            // mark epoch on undercut tick</span>
  85 |     | <span class='unexecuted'>            EpochMap.set(params.lower, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        if (params.zeroForOne || cache.priceUpper &lt; cache.pool.price) {</span>
  89 |     | <span class='unexecuted'>            if(!TickMap.set(tickMap, params.upper, cache.constants.tickSpacing)) {</span>
  90 |     | <span class='unexecuted'>                int24 tickAhead;</span>
  91 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  92 |     | <span class='unexecuted'>                    tickAhead  = TickMap.next(tickMap, params.upper, cache.constants.tickSpacing, false);</span>
  93 |     | <span class='neutral'>                } else {</span>
  94 |     | <span class='unexecuted'>                    tickAhead  = TickMap.previous(tickMap, params.upper, cache.constants.tickSpacing, false);</span>
  95 |     | <span class='neutral'>                }</span>
  96 |     | <span class='unexecuted'>                uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);</span>
  97 |     | <span class='unexecuted'>                EpochMap.set(params.upper, params.zeroForOne, epochAhead, tickMap, cache.constants);</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickUpper = ticks[params.upper].limit;</span>
 100 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 101 |     | <span class='unexecuted'>                tickUpper.liquidityDelta -= int128(liquidityMinted);</span>
 102 |     | <span class='neutral'>            } else {</span>
 103 |     | <span class='unexecuted'>                tickUpper.liquidityDelta += int128(liquidityMinted);</span>
 104 |     | <span class='neutral'>            }</span>
 105 |     | <span class='unexecuted'>            tickUpper.liquidityAbsolute += cache.liquidityMinted.toUint128();</span>
 106 |     | <span class='unexecuted'>            ticks[params.upper].limit = tickUpper;</span>
 107 |     | <span class='neutral'>        } else {</span>
 108 |     | <span class='neutral'>            /// @dev - i.e. if !zeroForOne &amp;&amp; cache.priceUpper &gt;= cache.pool.price</span>
 109 |     | <span class='unexecuted'>            cache.state.epoch += 1;</span>
 110 |     | <span class='neutral'>            // mark epoch on undercut tick</span>
 111 |     | <span class='unexecuted'>            EpochMap.set(params.upper, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 112 |     | <span class='neutral'>        }</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    function insertSingle(</span>
 116 |     | <span class='neutral'>        LimitPoolStructs.MintLimitParams memory params,</span>
 117 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 118 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 119 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 120 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState memory pool,</span>
 121 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 122 |     | <span class='neutral'>    ) internal returns (</span>
 123 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory</span>
 124 |     | <span class='neutral'>    ){</span>
 125 |     | <span class='neutral'>        /// @auditor - would be smart to protect against the case of epochs crossing</span>
 126 |     | <span class='unexecuted'>        (</span>
 127 |     | <span class='unexecuted'>            int24 tickToSave,</span>
 128 |     | <span class='unexecuted'>            uint160 roundedPrice</span>
 129 |     | <span class='unexecuted'>        ) = TickMap.roundHalf(pool.tickAtPrice, constants, pool.price);</span>
 130 |     | <span class='neutral'>        // update tick to save</span>
 131 |     | <span class='unexecuted'>        LimitPoolStructs.LimitTick memory tick = ticks[tickToSave].limit;</span>
 132 |     | <span class='neutral'>        /// @auditor - tick.priceAt will be zero for tick % tickSpacing == 0</span>
 133 |     | <span class='unexecuted'>        if (tick.priceAt == 0) {</span>
 134 |     | <span class='unexecuted'>            if (pool.price != (params.zeroForOne ? cache.priceLower : cache.priceUpper)) {</span>
 135 |     | <span class='unexecuted'>                TickMap.set(tickMap, tickToSave, constants.tickSpacing);</span>
 136 |     | <span class='neutral'>            }</span>
 137 |     | <span class='unexecuted'>            EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 138 |     | <span class='neutral'>        }</span>
 139 |     | <span class='neutral'>        // skip if we are at the nearest full tick</span>
 140 |     | <span class='unexecuted'>        if(pool.price != roundedPrice) {</span>
 141 |     | <span class='neutral'>            // if empty just save the pool price</span>
 142 |     | <span class='unexecuted'>            if (tick.priceAt == 0) {</span>
 143 |     | <span class='unexecuted'>                tick.priceAt = pool.price;</span>
 144 |     | <span class='unexecuted'>                EchidnaAssertions.assertTickAtPriceDivisibleByTickSpacing(tickToSave, ticks[tickToSave].limit.priceAt, constants.tickSpacing);</span>
 145 |     | <span class='neutral'>            }</span>
 146 |     | <span class='unexecuted'>            else {</span>
 147 |     | <span class='neutral'>                // we need to blend the two partial fills into a single tick</span>
 148 |     | <span class='unexecuted'>                LimitPoolStructs.InsertSingleLocals memory locals;</span>
 149 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 150 |     | <span class='neutral'>                    // 0 -&gt; 1 positions price moves up so nextFullTick is greater</span>
 151 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave - constants.tickSpacing / 2;</span>
 152 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 153 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 154 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDy(pool.liquidity, locals.pricePrevious, pool.price, false);</span>
 155 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDy(uint128(tick.liquidityDelta), locals.pricePrevious, tick.priceAt, false);</span>
 156 |     | <span class='neutral'>                    // add current pool liquidity to partial tick</span>
 157 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 158 |     | <span class='neutral'>                    // advance price based on combined fill</span>
 159 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, false, true).toUint160();</span>
 160 |     | <span class='neutral'>                    // dx to the next tick is less than before the tick blend</span>
 161 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 162 |     | <span class='unexecuted'>                } else {</span>
 163 |     | <span class='neutral'>                    // 0 -&gt; 1 positions price moves up so nextFullTick is lesser</span>
 164 |     | <span class='unexecuted'>                    locals.previousFullTick = tickToSave + constants.tickSpacing / 2;</span>
 165 |     | <span class='unexecuted'>                    locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);</span>
 166 |     | <span class='neutral'>                    // calculate amountOut filled across both partial fills</span>
 167 |     | <span class='unexecuted'>                    locals.amountOutExact = ConstantProduct.getDx(pool.liquidity, pool.price, locals.pricePrevious, false);</span>
 168 |     | <span class='unexecuted'>                    locals.amountOutExact += ConstantProduct.getDx(uint128(tick.liquidityDelta), tick.priceAt, locals.pricePrevious, false);</span>
 169 |     | <span class='neutral'>                    // add current pool liquidity to partial tick</span>
 170 |     | <span class='unexecuted'>                    uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);</span>
 171 |     | <span class='neutral'>                    // advance price based on combined fill</span>
 172 |     | <span class='unexecuted'>                    tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, true, true).toUint160();</span>
 173 |     | <span class='neutral'>                    // mark epoch for second partial fill positions</span>
 174 |     | <span class='unexecuted'>                    EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);</span>
 175 |     | <span class='neutral'>                }</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>        // invariant =&gt; if we save liquidity to tick clear pool liquidity</span>
 179 |     | <span class='unexecuted'>        if ((tickToSave != (params.zeroForOne ? params.lower : params.upper))) {</span>
 180 |     | <span class='unexecuted'>            tick.liquidityDelta += int128(pool.liquidity);</span>
 181 |     | <span class='unexecuted'>            tick.liquidityAbsolute += pool.liquidity;</span>
 182 |     | <span class='unexecuted'>            emit SyncLimitLiquidity(pool.liquidity, tickToSave, params.zeroForOne);</span>
 183 |     | <span class='unexecuted'>            pool.liquidity = 0;</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='unexecuted'>        ticks[tickToSave].limit = tick;</span>
 186 |     | <span class='unexecuted'>        return pool;</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>    function remove(</span>
 190 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 191 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 192 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
 193 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 194 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 195 |     | <span class='unexecuted'>    ) internal {</span>
 196 |     | <span class='neutral'>        // set ticks based on claim and zeroForOne</span>
 197 |     | <span class='unexecuted'>        int24 lower = params.zeroForOne ? params.claim : cache.position.lower;</span>
 198 |     | <span class='unexecuted'>        int24 upper = params.zeroForOne ? cache.position.upper : params.claim;</span>
 199 |     | <span class='unexecuted'>        {    </span>
 200 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickLower = ticks[lower].limit;</span>
 201 |     | <span class='neutral'>            </span>
 202 |     | <span class='unexecuted'>            if (cache.removeLower) {</span>
 203 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 204 |     | <span class='unexecuted'>                    tickLower.liquidityDelta -= int128(cache.liquidityBurned);</span>
 205 |     | <span class='neutral'>                } else {</span>
 206 |     | <span class='unexecuted'>                    tickLower.liquidityDelta += int128(cache.liquidityBurned);</span>
 207 |     | <span class='neutral'>                }</span>
 208 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, cache.liquidityBurned, &#39;TSL-1&#39;);</span>
 209 |     | <span class='unexecuted'>                tickLower.liquidityAbsolute -= cache.liquidityBurned;</span>
 210 |     | <span class='unexecuted'>                ticks[lower].limit = tickLower;</span>
 211 |     | <span class='unexecuted'>                clear(ticks, constants, tickMap, lower);</span>
 212 |     | <span class='neutral'>            }</span>
 213 |     | <span class='neutral'>        }</span>
 214 |     | <span class='unexecuted'>        {</span>
 215 |     | <span class='unexecuted'>            PoolsharkStructs.LimitTick memory tickUpper = ticks[upper].limit;</span>
 216 |     | <span class='unexecuted'>            if (cache.removeUpper) {</span>
 217 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
 218 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta += int128(cache.liquidityBurned);</span>
 219 |     | <span class='neutral'>                } else {</span>
 220 |     | <span class='unexecuted'>                    tickUpper.liquidityDelta -= int128(cache.liquidityBurned);</span>
 221 |     | <span class='neutral'>                }</span>
 222 |     | <span class='unexecuted'>                EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickUpper.liquidityAbsolute, cache.liquidityBurned, &#39;TSL-2&#39;);</span>
 223 |     | <span class='unexecuted'>                tickUpper.liquidityAbsolute -= cache.liquidityBurned;</span>
 224 |     | <span class='unexecuted'>                ticks[upper].limit = tickUpper;</span>
 225 |     | <span class='unexecuted'>                clear(ticks, constants, tickMap, upper);</span>
 226 |     | <span class='neutral'>            }</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='unexecuted'>     function unlock(</span>
 231 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 232 |     | <span class='neutral'>        PoolsharkStructs.LimitPoolState memory pool,</span>
 233 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 234 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 235 |     | <span class='neutral'>        bool zeroForOne</span>
 236 |     | <span class='neutral'>    ) internal returns (</span>
 237 |     | <span class='unexecuted'>        LimitPoolStructs.MintLimitCache memory,</span>
 238 |     | <span class='unexecuted'>        PoolsharkStructs.LimitPoolState memory</span>
 239 |     | <span class='neutral'>    )</span>
 240 |     | <span class='neutral'>    {</span>
 241 |     | <span class='unexecuted'>        if (pool.liquidity &gt; 0) return (cache, pool);</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>        (int24 startTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);</span>
 244 |     | <span class='neutral'></span>
 245 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 246 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.next(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 247 |     | <span class='unexecuted'>            if (pool.tickAtPrice &lt; ConstantProduct.maxTick(cache.constants.tickSpacing)) {</span>
 248 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 249 |     | <span class='neutral'>            }</span>
 250 |     | <span class='neutral'>        } else {</span>
 251 |     | <span class='neutral'>            /// @dev - roundedUp true since liquidity could be equal to the current pool tickAtPrice</span>
 252 |     | <span class='unexecuted'>            pool.tickAtPrice = TickMap.previous(tickMap, startTick, cache.constants.tickSpacing, true);</span>
 253 |     | <span class='unexecuted'>            if (pool.tickAtPrice &gt; ConstantProduct.minTick(cache.constants.tickSpacing)) {</span>
 254 |     | <span class='unexecuted'>                EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);</span>
 255 |     | <span class='neutral'>            }</span>
 256 |     | <span class='neutral'>        }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>        // increment pool liquidity</span>
 259 |     | <span class='unexecuted'>        EchidnaAssertions.assertPositiveLiquidityOnUnlock(ticks[pool.tickAtPrice].limit.liquidityDelta);</span>
 260 |     | <span class='unexecuted'>        pool.liquidity += uint128(ticks[pool.tickAtPrice].limit.liquidityDelta);</span>
 261 |     | <span class='unexecuted'>        int24 tickToClear = pool.tickAtPrice;</span>
 262 |     | <span class='unexecuted'>        uint160 tickPriceAt = ticks[pool.tickAtPrice].limit.priceAt;</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>        if (tickPriceAt == 0) {</span>
 265 |     | <span class='neutral'>            // if full tick crossed</span>
 266 |     | <span class='unexecuted'>            pool.price = ConstantProduct.getPriceAtTick(pool.tickAtPrice, cache.constants);</span>
 267 |     | <span class='neutral'>        } else {</span>
 268 |     | <span class='neutral'>            // if half tick crossed</span>
 269 |     | <span class='unexecuted'>            pool.price = tickPriceAt;</span>
 270 |     | <span class='unexecuted'>            pool.tickAtPrice = ConstantProduct.getTickAtPrice(tickPriceAt, cache.constants);</span>
 271 |     | <span class='neutral'>        }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>        // zero out tick</span>
 274 |     | <span class='unexecuted'>        ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 275 |     | <span class='unexecuted'>        clear(ticks, cache.constants, tickMap, tickToClear);</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>        return (cache, pool);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>    function clear(</span>
 281 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 282 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 283 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 284 |     | <span class='neutral'>        int24 tickToClear</span>
 285 |     | <span class='neutral'>    ) internal {</span>
 286 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 287 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 288 |     | <span class='unexecuted'>                tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 289 |     | <span class='unexecuted'>                ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);</span>
 290 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 291 |     | <span class='neutral'>            }</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='unexecuted'>    function _empty(</span>
 296 |     | <span class='neutral'>        LimitPoolStructs.Tick memory tick</span>
 297 |     | <span class='neutral'>    ) internal pure returns (</span>
 298 |     | <span class='unexecuted'>        bool</span>
 299 |     | <span class='neutral'>    ) {</span>
 300 |     | <span class='unexecuted'>        if (tick.limit.liquidityAbsolute != 0) {</span>
 301 |     | <span class='unexecuted'>            return false;</span>
 302 |     | <span class='neutral'>        }</span>
 303 |     | <span class='unexecuted'>        return true;</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'>}</span>
 306 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/pool/BurnLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../LimitPositions.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library BurnLimitCall {</span>
  11 |     | <span class='neutral'>    event BurnLimit(</span>
  12 |     | <span class='neutral'>        address indexed to,</span>
  13 |     | <span class='neutral'>        uint32 positionId,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        int24 oldClaim,</span>
  17 |     | <span class='neutral'>        int24 newClaim,</span>
  18 |     | <span class='neutral'>        bool zeroForOne,</span>
  19 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  20 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  21 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>    function perform(</span>
  25 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  26 |     | <span class='neutral'>            storage positions,</span>
  27 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  28 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  29 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  30 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
  31 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
  32 |     | <span class='neutral'>    ) internal {</span>
  33 |     | <span class='neutral'>        // check for invalid receiver</span>
  34 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  35 |     | <span class='unexecuted'>            require(false, &#39;CollectToZeroAddress()&#39;);</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        // initialize cache</span>
  38 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  39 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // check positionId owner</span>
  42 |     | <span class='unexecuted'>        if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  43 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  44 |     | <span class='neutral'>        </span>
  45 |     | <span class='neutral'>        // update position</span>
  46 |     | <span class='unexecuted'>        (</span>
  47 |     | <span class='neutral'>            params,</span>
  48 |     | <span class='neutral'>            cache</span>
  49 |     | <span class='unexecuted'>        ) = LimitPositions.update(</span>
  50 |     | <span class='unexecuted'>            ticks,</span>
  51 |     | <span class='unexecuted'>            tickMap,</span>
  52 |     | <span class='unexecuted'>            cache,</span>
  53 |     | <span class='unexecuted'>            params</span>
  54 |     | <span class='neutral'>        );</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>        // save position before transfer</span>
  57 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != cache.position.upper</span>
  58 |     | <span class='unexecuted'>                               : params.claim != cache.position.lower)) {</span>
  59 |     | <span class='unexecuted'>            if (cache.position.liquidity &gt; 0) {</span>
  60 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  61 |     | <span class='unexecuted'>                    cache.position.lower = params.claim;</span>
  62 |     | <span class='neutral'>                } else {</span>
  63 |     | <span class='unexecuted'>                    cache.position.upper = params.claim;</span>
  64 |     | <span class='neutral'>                }</span>
  65 |     | <span class='unexecuted'>                positions[params.positionId] = cache.position;</span>
  66 |     | <span class='neutral'>            } else {</span>
  67 |     | <span class='unexecuted'>                IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  68 |     | <span class='unexecuted'>                delete positions[params.positionId];</span>
  69 |     | <span class='neutral'>            }</span>
  70 |     | <span class='neutral'>        } else {</span>
  71 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  72 |     | <span class='unexecuted'>            delete positions[params.positionId];</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // save state before transfer call</span>
  76 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
  77 |     | <span class='neutral'>        </span>
  78 |     | <span class='unexecuted'>        cache = Collect.burnLimit(</span>
  79 |     | <span class='unexecuted'>            cache,</span>
  80 |     | <span class='unexecuted'>            params</span>
  81 |     | <span class='neutral'>        );</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>    function save(</span>
  85 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
  86 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  87 |     | <span class='neutral'>        bool zeroForOne</span>
  88 |     | <span class='neutral'>    ) internal {</span>
  89 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  90 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
  91 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  92 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  93 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
  94 |     | <span class='neutral'>        } else {</span>
  95 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  96 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/pool/MintLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../LimitPositions.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>library MintLimitCall {</span>
  10 |     | <span class='neutral'>    event MintLimit(</span>
  11 |     | <span class='neutral'>        address indexed to,</span>
  12 |     | <span class='neutral'>        int24 lower,</span>
  13 |     | <span class='neutral'>        int24 upper,</span>
  14 |     | <span class='neutral'>        bool zeroForOne,</span>
  15 |     | <span class='neutral'>        uint32 positionId,</span>
  16 |     | <span class='neutral'>        uint32 epochLast,</span>
  17 |     | <span class='neutral'>        uint128 amountIn,</span>
  18 |     | <span class='neutral'>        uint128 amountFilled,</span>
  19 |     | <span class='neutral'>        uint128 liquidityMinted</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    event SyncLimitPool(</span>
  23 |     | <span class='neutral'>        uint160 price,</span>
  24 |     | <span class='neutral'>        uint128 liquidity,</span>
  25 |     | <span class='neutral'>        uint32 epoch,</span>
  26 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  27 |     | <span class='neutral'>        bool isPool0</span>
  28 |     | <span class='neutral'>    );</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    function perform(</span>
  31 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  32 |     | <span class='neutral'>            storage positions,</span>
  33 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  34 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  35 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  36 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  38 |     | <span class='neutral'>        LimitPoolStructs.MintLimitParams memory params,</span>
  39 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
  40 |     | <span class='neutral'>    ) internal {</span>
  41 |     | <span class='unexecuted'>        if (params.positionId &gt; 0) {</span>
  42 |     | <span class='unexecuted'>            if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  43 |     | <span class='neutral'>                // check for balance held</span>
  44 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
  45 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
  46 |     | <span class='neutral'>        }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // resize position if necessary</span>
  51 |     | <span class='unexecuted'>        (params, cache) = LimitPositions.resize(</span>
  52 |     | <span class='unexecuted'>            ticks,</span>
  53 |     | <span class='unexecuted'>            samples,</span>
  54 |     | <span class='unexecuted'>            rangeTickMap,</span>
  55 |     | <span class='unexecuted'>            limitTickMap,</span>
  56 |     | <span class='unexecuted'>            params,</span>
  57 |     | <span class='unexecuted'>            cache</span>
  58 |     | <span class='neutral'>        );</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>        if (params.positionId == 0 ||                       // new position</span>
  61 |     | <span class='unexecuted'>                params.lower != cache.position.lower ||     // lower mismatch</span>
  62 |     | <span class='unexecuted'>                params.upper != cache.position.upper) {     // upper mismatch</span>
  63 |     | <span class='unexecuted'>            LimitPoolStructs.LimitPosition memory newPosition;</span>
  64 |     | <span class='unexecuted'>            newPosition.lower = params.lower;</span>
  65 |     | <span class='unexecuted'>            newPosition.upper = params.upper;</span>
  66 |     | <span class='neutral'>            // use new position in cache</span>
  67 |     | <span class='unexecuted'>            cache.position = newPosition;</span>
  68 |     | <span class='unexecuted'>            params.positionId = cache.state.positionIdNext;</span>
  69 |     | <span class='unexecuted'>            cache.state.positionIdNext += 1;</span>
  70 |     | <span class='neutral'>        }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        // save state for reentrancy safety</span>
  73 |     | <span class='unexecuted'>        save(cache, globalState, !params.zeroForOne);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>        // transfer in token amount</span>
  76 |     | <span class='unexecuted'>        SafeTransfers.transferIn(</span>
  77 |     | <span class='unexecuted'>                                 params.zeroForOne ? cache.constants.token0 </span>
  78 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
  79 |     | <span class='unexecuted'>                                 params.amount + cache.swapCache.input</span>
  80 |     | <span class='neutral'>                                );</span>
  81 |     | <span class='neutral'>        // transfer out if swap output </span>
  82 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0) {</span>
  83 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
  84 |     | <span class='unexecuted'>                (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  85 |     | <span class='unexecuted'>                cache.swapCache.output</span>
  86 |     | <span class='neutral'>            );</span>
  87 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
  88 |     | <span class='unexecuted'>                params.to,</span>
  89 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
  90 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
  91 |     | <span class='unexecuted'>                cache.swapCache.output</span>
  92 |     | <span class='neutral'>            );</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>        // mint position if amount is left</span>
  96 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
  97 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
  98 |     | <span class='neutral'>            // bump to the next tick if there is no liquidity</span>
  99 |     | <span class='unexecuted'>            if (cache.pool.liquidity == 0) {</span>
 100 |     | <span class='neutral'>                /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
 101 |     | <span class='unexecuted'>                (cache, cache.pool) = LimitTicks.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);</span>
 102 |     | <span class='neutral'>            }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 105 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 106 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
 107 |     | <span class='neutral'>                    // save liquidity if active</span>
 108 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 109 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 110 |     | <span class='neutral'>                    }</span>
 111 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
 112 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
 113 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
 114 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 115 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 116 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 117 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 118 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 119 |     | <span class='neutral'>                }</span>
 120 |     | <span class='unexecuted'>            } else {</span>
 121 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 122 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 123 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 124 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 125 |     | <span class='neutral'>                    }</span>
 126 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 127 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 128 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 129 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 130 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 131 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 132 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 133 |     | <span class='neutral'>                }</span>
 134 |     | <span class='neutral'>            }</span>
 135 |     | <span class='unexecuted'>            (cache.pool, cache.position) = LimitPositions.add(</span>
 136 |     | <span class='unexecuted'>                cache,</span>
 137 |     | <span class='unexecuted'>                ticks,</span>
 138 |     | <span class='unexecuted'>                limitTickMap,</span>
 139 |     | <span class='unexecuted'>                params</span>
 140 |     | <span class='neutral'>            );</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>            // save position to storage</span>
 143 |     | <span class='unexecuted'>            positions[params.positionId] = cache.position;</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='unexecuted'>            params.zeroForOne ? cache.state.pool0 = cache.pool : cache.state.pool1 = cache.pool;</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>            emit MintLimit(</span>
 148 |     | <span class='unexecuted'>                params.to,</span>
 149 |     | <span class='unexecuted'>                params.lower,</span>
 150 |     | <span class='unexecuted'>                params.upper,</span>
 151 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 152 |     | <span class='unexecuted'>                params.positionId,</span>
 153 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 154 |     | <span class='unexecuted'>                uint128(params.amount + cache.swapCache.input),</span>
 155 |     | <span class='unexecuted'>                uint128(cache.swapCache.output),</span>
 156 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 157 |     | <span class='neutral'>            );</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        // save lp side for safe reentrancy</span>
 161 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function balance(</span>
 165 |     | <span class='neutral'>        address token</span>
 166 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 167 |     | <span class='unexecuted'>        (</span>
 168 |     | <span class='unexecuted'>            bool success,</span>
 169 |     | <span class='unexecuted'>            bytes memory data</span>
 170 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 171 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 172 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 173 |     | <span class='unexecuted'>                                        address(this)</span>
 174 |     | <span class='neutral'>                                    )</span>
 175 |     | <span class='neutral'>                                );</span>
 176 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 177 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    function save(</span>
 181 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
 182 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 183 |     | <span class='neutral'>        bool zeroForOne</span>
 184 |     | <span class='neutral'>    ) internal {</span>
 185 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
 186 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 187 |     | <span class='unexecuted'>        globalState.positionIdNext = cache.state.positionIdNext;</span>
 188 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 189 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
 190 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
 191 |     | <span class='neutral'>        } else {</span>
 192 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
 193 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
 194 |     | <span class='neutral'>        }</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'>}</span>
 197 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/limit/pool/SnapshotLimitCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../LimitPositions.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library SnapshotLimitCall {</span>
  9 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event BurnLimit(</span>
 12 |     | <span class='neutral'>        address indexed to,</span>
 13 |     | <span class='neutral'>        uint32 positionId,</span>
 14 |     | <span class='neutral'>        int24 lower,</span>
 15 |     | <span class='neutral'>        int24 upper,</span>
 16 |     | <span class='neutral'>        int24 oldClaim,</span>
 17 |     | <span class='neutral'>        int24 newClaim,</span>
 18 |     | <span class='neutral'>        bool zeroForOne,</span>
 19 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 20 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
 21 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    function perform(</span>
 25 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
 26 |     | <span class='neutral'>            storage positions,</span>
 27 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 28 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 29 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 30 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 31 |     | <span class='neutral'>        LimitPoolStructs.SnapshotLimitParams memory params</span>
 32 |     | <span class='neutral'>    ) internal view returns (</span>
 33 |     | <span class='unexecuted'>        uint128,</span>
 34 |     | <span class='unexecuted'>        uint128</span>
 35 |     | <span class='neutral'>    )</span>
 36 |     | <span class='neutral'>    {</span>
 37 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED)</span>
 38 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 39 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory cache;</span>
 40 |     | <span class='unexecuted'>        cache.state = state;</span>
 41 |     | <span class='unexecuted'>        cache.constants = constants;</span>
 42 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
 43 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitParams memory burnParams = LimitPoolStructs.BurnLimitParams ({</span>
 44 |     | <span class='unexecuted'>            to: params.owner,</span>
 45 |     | <span class='unexecuted'>            burnPercent: params.burnPercent,</span>
 46 |     | <span class='unexecuted'>            positionId: params.positionId,</span>
 47 |     | <span class='unexecuted'>            claim: params.claim,</span>
 48 |     | <span class='unexecuted'>            zeroForOne: params.zeroForOne</span>
 49 |     | <span class='neutral'>        });</span>
 50 |     | <span class='unexecuted'>        if (cache.position.epochLast == 0) require(false, &#39;PositionNotFound()&#39;);</span>
 51 |     | <span class='unexecuted'>        return LimitPositions.snapshot(</span>
 52 |     | <span class='unexecuted'>            ticks,</span>
 53 |     | <span class='unexecuted'>            tickMap,</span>
 54 |     | <span class='unexecuted'>            cache,</span>
 55 |     | <span class='unexecuted'>            burnParams</span>
 56 |     | <span class='neutral'>        );</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/math/ConstantProduct.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./OverflowMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @notice Math library that facilitates ranged liquidity calculations.</span>
   9 |     | <span class='unexecuted'>library ConstantProduct {</span>
  10 |     | <span class='unexecuted'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct PriceBounds {</span>
  13 |     | <span class='neutral'>        uint160 min;</span>
  14 |     | <span class='neutral'>        uint160 max;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  18 |     | <span class='neutral'>    ///////////////////////// DYDX MATH /////////////////////////</span>
  19 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function getDy(</span>
  22 |     | <span class='neutral'>        uint256 liquidity,</span>
  23 |     | <span class='neutral'>        uint256 priceLower,</span>
  24 |     | <span class='neutral'>        uint256 priceUpper,</span>
  25 |     | <span class='neutral'>        bool roundUp</span>
  26 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dy) {</span>
  27 |     | <span class='neutral'>        unchecked {</span>
  28 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  29 |     | <span class='unexecuted'>            if (roundUp) {</span>
  30 |     | <span class='unexecuted'>                dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);</span>
  31 |     | <span class='neutral'>            } else {</span>
  32 |     | <span class='unexecuted'>                dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);</span>
  33 |     | <span class='neutral'>            }</span>
  34 |     | <span class='neutral'>        }</span>
  35 |     | <span class='neutral'>    }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>    function getDx(</span>
  38 |     | <span class='neutral'>        uint256 liquidity,</span>
  39 |     | <span class='neutral'>        uint256 priceLower,</span>
  40 |     | <span class='neutral'>        uint256 priceUpper,</span>
  41 |     | <span class='neutral'>        bool roundUp</span>
  42 |     | <span class='unexecuted'>    ) internal pure returns (uint256 dx) {</span>
  43 |     | <span class='neutral'>        unchecked {</span>
  44 |     | <span class='unexecuted'>            if (liquidity == 0) return 0;</span>
  45 |     | <span class='unexecuted'>            if (roundUp) {</span>
  46 |     | <span class='unexecuted'>                dx = OverflowMath.divRoundingUp(</span>
  47 |     | <span class='unexecuted'>                        OverflowMath.mulDivRoundingUp(</span>
  48 |     | <span class='unexecuted'>                            liquidity &lt;&lt; 96, </span>
  49 |     | <span class='unexecuted'>                            priceUpper - priceLower,</span>
  50 |     | <span class='unexecuted'>                            priceUpper</span>
  51 |     | <span class='neutral'>                        ),</span>
  52 |     | <span class='unexecuted'>                        priceLower</span>
  53 |     | <span class='neutral'>                );</span>
  54 |     | <span class='neutral'>            } else {</span>
  55 |     | <span class='unexecuted'>                dx = OverflowMath.mulDiv(</span>
  56 |     | <span class='unexecuted'>                        liquidity &lt;&lt; 96,</span>
  57 |     | <span class='unexecuted'>                        priceUpper - priceLower,</span>
  58 |     | <span class='unexecuted'>                        priceUpper</span>
  59 |     | <span class='unexecuted'>                ) / priceLower;</span>
  60 |     | <span class='neutral'>            }</span>
  61 |     | <span class='neutral'>        }</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>    function getLiquidityForAmounts(</span>
  65 |     | <span class='neutral'>        uint256 priceLower,</span>
  66 |     | <span class='neutral'>        uint256 priceUpper,</span>
  67 |     | <span class='neutral'>        uint256 currentPrice,</span>
  68 |     | <span class='neutral'>        uint256 dy,</span>
  69 |     | <span class='neutral'>        uint256 dx</span>
  70 |     | <span class='unexecuted'>    ) internal pure returns (uint256 liquidity) {</span>
  71 |     | <span class='neutral'>        unchecked {</span>
  72 |     | <span class='unexecuted'>            if (priceUpper &lt;= currentPrice) {</span>
  73 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);</span>
  74 |     | <span class='unexecuted'>            } else if (currentPrice &lt;= priceLower) {</span>
  75 |     | <span class='unexecuted'>                liquidity = OverflowMath.mulDiv(</span>
  76 |     | <span class='unexecuted'>                    dx,</span>
  77 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceLower, priceUpper, Q96),</span>
  78 |     | <span class='unexecuted'>                    priceUpper - priceLower</span>
  79 |     | <span class='neutral'>                );</span>
  80 |     | <span class='unexecuted'>            } else {</span>
  81 |     | <span class='unexecuted'>                uint256 liquidity0 = OverflowMath.mulDiv(</span>
  82 |     | <span class='unexecuted'>                    dx,</span>
  83 |     | <span class='unexecuted'>                    OverflowMath.mulDiv(priceUpper, currentPrice, Q96),</span>
  84 |     | <span class='unexecuted'>                    priceUpper - currentPrice</span>
  85 |     | <span class='neutral'>                );</span>
  86 |     | <span class='unexecuted'>                uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);</span>
  87 |     | <span class='unexecuted'>                liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
  88 |     | <span class='neutral'>            }</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    function getAmountsForLiquidity(</span>
  93 |     | <span class='neutral'>        uint256 priceLower,</span>
  94 |     | <span class='neutral'>        uint256 priceUpper,</span>
  95 |     | <span class='neutral'>        uint256 currentPrice,</span>
  96 |     | <span class='neutral'>        uint256 liquidityAmount,</span>
  97 |     | <span class='neutral'>        bool roundUp</span>
  98 |     | <span class='unexecuted'>    ) internal pure returns (uint128 token0amount, uint128 token1amount) {</span>
  99 |     | <span class='unexecuted'>        if (priceUpper &lt;= currentPrice) {</span>
 100 |     | <span class='unexecuted'>            token1amount = uint128(getDy(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 101 |     | <span class='unexecuted'>        } else if (currentPrice &lt;= priceLower) {</span>
 102 |     | <span class='unexecuted'>            token0amount = uint128(getDx(liquidityAmount, priceLower, priceUpper, roundUp));</span>
 103 |     | <span class='neutral'>        } else {</span>
 104 |     | <span class='unexecuted'>            token0amount = uint128(getDx(liquidityAmount, currentPrice, priceUpper, roundUp));</span>
 105 |     | <span class='unexecuted'>            token1amount = uint128(getDy(liquidityAmount, priceLower, currentPrice, roundUp));</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='unexecuted'>        if (token0amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 108 |     | <span class='unexecuted'>        if (token1amount &gt; uint128(type(int128).max)) require(false, &#39;AmountsOutOfBounds()&#39;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function getNewPrice(</span>
 112 |     | <span class='neutral'>        uint256 price,</span>
 113 |     | <span class='neutral'>        uint256 liquidity,</span>
 114 |     | <span class='neutral'>        uint256 amount,</span>
 115 |     | <span class='neutral'>        bool zeroForOne,</span>
 116 |     | <span class='neutral'>        bool exactIn</span>
 117 |     | <span class='neutral'>    ) internal pure returns (</span>
 118 |     | <span class='unexecuted'>        uint256 newPrice</span>
 119 |     | <span class='neutral'>    ) {</span>
 120 |     | <span class='unexecuted'>        if (exactIn) {</span>
 121 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 122 |     | <span class='unexecuted'>                uint256 liquidityPadded = liquidity &lt;&lt; 96;</span>
 123 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 124 |     | <span class='unexecuted'>                        liquidityPadded,</span>
 125 |     | <span class='unexecuted'>                        price,</span>
 126 |     | <span class='unexecuted'>                        liquidityPadded + price * amount</span>
 127 |     | <span class='neutral'>                    );</span>
 128 |     | <span class='neutral'>            } else {</span>
 129 |     | <span class='unexecuted'>                newPrice = price + (amount &lt;&lt; 96) / liquidity;</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'>        } else {</span>
 132 |     | <span class='unexecuted'>            if (zeroForOne) {</span>
 133 |     | <span class='unexecuted'>                newPrice = price - </span>
 134 |     | <span class='unexecuted'>                        OverflowMath.divRoundingUp(amount &lt;&lt; 96, liquidity);</span>
 135 |     | <span class='unexecuted'>            } else {</span>
 136 |     | <span class='unexecuted'>                uint256 liquidityPadded = uint256(liquidity) &lt;&lt; 96;</span>
 137 |     | <span class='unexecuted'>                newPrice = OverflowMath.mulDivRoundingUp(</span>
 138 |     | <span class='unexecuted'>                        liquidityPadded, </span>
 139 |     | <span class='unexecuted'>                        price,</span>
 140 |     | <span class='unexecuted'>                        liquidityPadded - uint256(price) * amount</span>
 141 |     | <span class='neutral'>                );</span>
 142 |     | <span class='neutral'>            }</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function getPrice(</span>
 147 |     | <span class='neutral'>        uint256 sqrtPrice</span>
 148 |     | <span class='unexecuted'>    ) internal pure returns (uint256 price) {</span>
 149 |     | <span class='unexecuted'>        if (sqrtPrice &gt;= 2 ** 48)</span>
 150 |     | <span class='unexecuted'>            price = OverflowMath.mulDiv(sqrtPrice, sqrtPrice, 2 ** 96);</span>
 151 |     | <span class='neutral'>        else</span>
 152 |     | <span class='unexecuted'>            price = sqrtPrice;</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 156 |     | <span class='neutral'>    ///////////////////////// TICK MATH /////////////////////////</span>
 157 |     | <span class='neutral'>    /////////////////////////////////////////////////////////////</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128</span>
 160 |     | <span class='unexecuted'>    int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='unexecuted'>    function minTick(</span>
 163 |     | <span class='neutral'>        int16 tickSpacing</span>
 164 |     | <span class='neutral'>    ) internal pure returns (</span>
 165 |     | <span class='unexecuted'>        int24 tick</span>
 166 |     | <span class='neutral'>    ) {</span>
 167 |     | <span class='unexecuted'>        return MIN_TICK / tickSpacing * tickSpacing;</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='unexecuted'>    function maxTick(</span>
 171 |     | <span class='neutral'>        int16 tickSpacing</span>
 172 |     | <span class='neutral'>    ) internal pure returns (</span>
 173 |     | <span class='unexecuted'>        int24 tick</span>
 174 |     | <span class='neutral'>    ) {</span>
 175 |     | <span class='unexecuted'>        return MAX_TICK / tickSpacing * tickSpacing;</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='unexecuted'>    function priceBounds(</span>
 179 |     | <span class='neutral'>        int16 tickSpacing</span>
 180 |     | <span class='neutral'>    ) internal pure returns (</span>
 181 |     | <span class='unexecuted'>        uint160,</span>
 182 |     | <span class='unexecuted'>        uint160</span>
 183 |     | <span class='neutral'>    ) {</span>
 184 |     | <span class='unexecuted'>        return (minPrice(tickSpacing), maxPrice(tickSpacing));</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    function minPrice(</span>
 188 |     | <span class='neutral'>        int16 tickSpacing</span>
 189 |     | <span class='neutral'>    ) internal pure returns (</span>
 190 |     | <span class='unexecuted'>        uint160 price</span>
 191 |     | <span class='neutral'>    ) {</span>
 192 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables  memory constants;</span>
 193 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 194 |     | <span class='unexecuted'>        return getPriceAtTick(minTick(tickSpacing), constants);</span>
 195 |     | <span class='neutral'>    }</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    function maxPrice(</span>
 198 |     | <span class='neutral'>        int16 tickSpacing</span>
 199 |     | <span class='neutral'>    ) internal pure returns (</span>
 200 |     | <span class='unexecuted'>        uint160 price</span>
 201 |     | <span class='neutral'>    ) {</span>
 202 |     | <span class='unexecuted'>        PoolsharkStructs.Immutables  memory constants;</span>
 203 |     | <span class='unexecuted'>        constants.tickSpacing = tickSpacing;</span>
 204 |     | <span class='unexecuted'>        return getPriceAtTick(maxTick(tickSpacing), constants);</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>    function checkTicks(</span>
 208 |     | <span class='neutral'>        int24 lower,</span>
 209 |     | <span class='neutral'>        int24 upper,</span>
 210 |     | <span class='neutral'>        int16 tickSpacing</span>
 211 |     | <span class='neutral'>    ) internal pure</span>
 212 |     | <span class='neutral'>    {</span>
 213 |     | <span class='unexecuted'>        if (lower &lt; minTick(tickSpacing)) require (false, &#39;LowerTickOutOfBounds()&#39;);</span>
 214 |     | <span class='unexecuted'>        if (upper &gt; maxTick(tickSpacing)) require (false, &#39;UpperTickOutOfBounds()&#39;);</span>
 215 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require (false, &#39;LowerTickOutsideTickSpacing()&#39;);</span>
 216 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require (false, &#39;UpperTickOutsideTickSpacing()&#39;);</span>
 217 |     | <span class='unexecuted'>        if (lower &gt;= upper) require (false, &#39;LowerUpperTickOrderInvalid()&#39;);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function checkPrice(</span>
 221 |     | <span class='neutral'>        uint160 price,</span>
 222 |     | <span class='neutral'>        PriceBounds memory bounds</span>
 223 |     | <span class='neutral'>    ) internal pure {</span>
 224 |     | <span class='neutral'>        if (price &lt; bounds.min || price &gt;= bounds.max) require (false, &#39;PriceOutOfBounds()&#39;);</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96.</span>
 228 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick.</span>
 229 |     | <span class='neutral'>    /// @param tick The input tick for the above formula.</span>
 230 |     | <span class='neutral'>    /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
 231 |     | <span class='neutral'>    /// at the given tick.</span>
 232 |     | <span class='unexecuted'>    function getPriceAtTick(</span>
 233 |     | <span class='neutral'>        int24 tick,</span>
 234 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 235 |     | <span class='neutral'>    ) internal pure returns (</span>
 236 |     | <span class='unexecuted'>        uint160 price</span>
 237 |     | <span class='unexecuted'>    ) {</span>
 238 |     | <span class='unexecuted'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
 239 |     | <span class='unexecuted'>        if (absTick &gt; uint256(uint24(maxTick(constants.tickSpacing)))) require (false, &#39;TickOutOfBounds()&#39;);</span>
 240 |     | <span class='unexecuted'>        unchecked {</span>
 241 |     | <span class='unexecuted'>            uint256 ratio = absTick &amp; 0x1 != 0</span>
 242 |     | <span class='unexecuted'>                ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
 243 |     | <span class='unexecuted'>                : 0x100000000000000000000000000000000;</span>
 244 |     | <span class='unexecuted'>            if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
 245 |     | <span class='unexecuted'>            if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
 246 |     | <span class='unexecuted'>            if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
 247 |     | <span class='unexecuted'>            if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
 248 |     | <span class='unexecuted'>            if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
 249 |     | <span class='unexecuted'>            if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
 250 |     | <span class='unexecuted'>            if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
 251 |     | <span class='unexecuted'>            if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
 252 |     | <span class='unexecuted'>            if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
 253 |     | <span class='unexecuted'>            if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
 254 |     | <span class='unexecuted'>            if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
 255 |     | <span class='unexecuted'>            if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
 256 |     | <span class='unexecuted'>            if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
 257 |     | <span class='unexecuted'>            if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
 258 |     | <span class='unexecuted'>            if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
 259 |     | <span class='unexecuted'>            if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
 260 |     | <span class='unexecuted'>            if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
 261 |     | <span class='unexecuted'>            if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
 262 |     | <span class='unexecuted'>            if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>            if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
 265 |     | <span class='neutral'>            // This divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
 266 |     | <span class='neutral'>            // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.</span>
 267 |     | <span class='neutral'>            // We round up in the division so getTickAtPrice of the output price is always consistent.</span>
 268 |     | <span class='unexecuted'>            price = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
 269 |     | <span class='neutral'>        }</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio.</span>
 273 |     | <span class='neutral'>    /// @param price The sqrt ratio for which to compute the tick as a Q64.96.</span>
 274 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.</span>
 275 |     | <span class='unexecuted'>    function getTickAtPrice(</span>
 276 |     | <span class='neutral'>        uint160 price,</span>
 277 |     | <span class='neutral'>        PoolsharkStructs.Immutables  memory constants</span>
 278 |     | <span class='unexecuted'>    ) internal pure returns (int24 tick) {</span>
 279 |     | <span class='neutral'>        // Second inequality must be &lt; because the price can never reach the price at the max tick.</span>
 280 |     | <span class='unexecuted'>        if (price &lt; constants.bounds.min || price &gt; constants.bounds.max)</span>
 281 |     | <span class='unexecuted'>            require (false, &#39;PriceOutOfBounds()&#39;);</span>
 282 |     | <span class='unexecuted'>        uint256 ratio = uint256(price) &lt;&lt; 32;</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='unexecuted'>        uint256 r = ratio;</span>
 285 |     | <span class='unexecuted'>        uint256 msb = 0;</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>        assembly {</span>
 288 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 289 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 290 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 291 |     | <span class='neutral'>        }</span>
 292 |     | <span class='unexecuted'>        assembly {</span>
 293 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 294 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 295 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 296 |     | <span class='neutral'>        }</span>
 297 |     | <span class='unexecuted'>        assembly {</span>
 298 |     | <span class='unexecuted'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 299 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 300 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 301 |     | <span class='neutral'>        }</span>
 302 |     | <span class='unexecuted'>        assembly {</span>
 303 |     | <span class='unexecuted'>            let f := shl(4, gt(r, 0xFFFF))</span>
 304 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 305 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 306 |     | <span class='neutral'>        }</span>
 307 |     | <span class='unexecuted'>        assembly {</span>
 308 |     | <span class='unexecuted'>            let f := shl(3, gt(r, 0xFF))</span>
 309 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 310 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 311 |     | <span class='neutral'>        }</span>
 312 |     | <span class='unexecuted'>        assembly {</span>
 313 |     | <span class='unexecuted'>            let f := shl(2, gt(r, 0xF))</span>
 314 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 315 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 316 |     | <span class='neutral'>        }</span>
 317 |     | <span class='unexecuted'>        assembly {</span>
 318 |     | <span class='unexecuted'>            let f := shl(1, gt(r, 0x3))</span>
 319 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 320 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='unexecuted'>        assembly {</span>
 323 |     | <span class='unexecuted'>            let f := gt(r, 0x1)</span>
 324 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 328 |     | <span class='unexecuted'>        else r = ratio &lt;&lt; (127 - msb);</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='unexecuted'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='unexecuted'>        assembly {</span>
 333 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 334 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 335 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(63, f))</span>
 336 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='unexecuted'>        assembly {</span>
 339 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 340 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 341 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(62, f))</span>
 342 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 343 |     | <span class='neutral'>        }</span>
 344 |     | <span class='unexecuted'>        assembly {</span>
 345 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 346 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 347 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(61, f))</span>
 348 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='unexecuted'>        assembly {</span>
 351 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 352 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 353 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(60, f))</span>
 354 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 355 |     | <span class='neutral'>        }</span>
 356 |     | <span class='unexecuted'>        assembly {</span>
 357 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 358 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 359 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(59, f))</span>
 360 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 361 |     | <span class='neutral'>        }</span>
 362 |     | <span class='unexecuted'>        assembly {</span>
 363 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 364 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 365 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(58, f))</span>
 366 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 367 |     | <span class='neutral'>        }</span>
 368 |     | <span class='unexecuted'>        assembly {</span>
 369 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 370 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 371 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(57, f))</span>
 372 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 373 |     | <span class='neutral'>        }</span>
 374 |     | <span class='unexecuted'>        assembly {</span>
 375 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 376 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 377 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(56, f))</span>
 378 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 379 |     | <span class='neutral'>        }</span>
 380 |     | <span class='unexecuted'>        assembly {</span>
 381 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 382 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 383 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(55, f))</span>
 384 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 385 |     | <span class='neutral'>        }</span>
 386 |     | <span class='unexecuted'>        assembly {</span>
 387 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 388 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 389 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(54, f))</span>
 390 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='unexecuted'>        assembly {</span>
 393 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 394 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 395 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(53, f))</span>
 396 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 397 |     | <span class='neutral'>        }</span>
 398 |     | <span class='unexecuted'>        assembly {</span>
 399 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 400 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 401 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(52, f))</span>
 402 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 403 |     | <span class='neutral'>        }</span>
 404 |     | <span class='unexecuted'>        assembly {</span>
 405 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 406 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 407 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(51, f))</span>
 408 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 409 |     | <span class='neutral'>        }</span>
 410 |     | <span class='unexecuted'>        assembly {</span>
 411 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 412 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 413 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(50, f))</span>
 414 |     | <span class='neutral'>        }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='unexecuted'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 417 |     | <span class='neutral'></span>
 418 |     | <span class='unexecuted'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 419 |     | <span class='unexecuted'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 420 |     | <span class='neutral'></span>
 421 |     | <span class='unexecuted'>        tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) &lt;= price</span>
 422 |     | <span class='unexecuted'>            ? tickHi</span>
 423 |     | <span class='unexecuted'>            : tickLow;</span>
 424 |     | <span class='neutral'>    }</span>
 425 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/math/OverflowMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.</span>
   5 |     | <span class='unexecuted'>library OverflowMath {</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    // @dev no underflow or overflow checks</span>
   8 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
   9 |     | <span class='neutral'>        assembly {</span>
  10 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
  11 |     | <span class='neutral'>        }</span>
  12 |     | <span class='neutral'>    }</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>    /// @notice Calculates floor(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
  15 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
  16 |     | <span class='neutral'>    /// @param b The multiplier.</span>
  17 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
  18 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
  19 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.</span>
  20 |     | <span class='unexecuted'>    function mulDiv(</span>
  21 |     | <span class='neutral'>        uint256 a,</span>
  22 |     | <span class='neutral'>        uint256 b,</span>
  23 |     | <span class='neutral'>        uint256 denominator</span>
  24 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  25 |     | <span class='neutral'>        unchecked {</span>
  26 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = a * b.</span>
  27 |     | <span class='neutral'>            // Compute the product mod 2**256 and mod 2**256 - 1,</span>
  28 |     | <span class='neutral'>            // then use the Chinese Remainder Theorem to reconstruct</span>
  29 |     | <span class='neutral'>            // the 512 bit result. The result is stored in two 256</span>
  30 |     | <span class='neutral'>            // variables such that product = prod1 * 2**256 + prod0.</span>
  31 |     | <span class='unexecuted'>            uint256 prod0; // Least significant 256 bits of the product.</span>
  32 |     | <span class='unexecuted'>            uint256 prod1; // Most significant 256 bits of the product.</span>
  33 |     | <span class='unexecuted'>            assembly {</span>
  34 |     | <span class='unexecuted'>                let mm := mulmod(a, b, not(0))</span>
  35 |     | <span class='unexecuted'>                prod0 := mul(a, b)</span>
  36 |     | <span class='unexecuted'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  39 |     | <span class='unexecuted'>            if (prod1 == 0) {</span>
  40 |     | <span class='unexecuted'>                require(denominator &gt; 0);</span>
  41 |     | <span class='neutral'>                assembly {</span>
  42 |     | <span class='unexecuted'>                    result := div(prod0, denominator)</span>
  43 |     | <span class='neutral'>                }</span>
  44 |     | <span class='unexecuted'>                return result;</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'>            // Make sure the result is less than 2**256 -</span>
  47 |     | <span class='neutral'>            // also prevents denominator == 0.</span>
  48 |     | <span class='unexecuted'>            require(denominator &gt; prod1);</span>
  49 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  50 |     | <span class='neutral'>            // 512 by 256 division.</span>
  51 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  52 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0] -</span>
  53 |     | <span class='neutral'>            // compute remainder using mulmod.</span>
  54 |     | <span class='unexecuted'>            uint256 remainder;</span>
  55 |     | <span class='neutral'>            assembly {</span>
  56 |     | <span class='unexecuted'>                remainder := mulmod(a, b, denominator)</span>
  57 |     | <span class='neutral'>            }</span>
  58 |     | <span class='neutral'>            // Subtract 256 bit number from 512 bit number.</span>
  59 |     | <span class='neutral'>            assembly {</span>
  60 |     | <span class='unexecuted'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  61 |     | <span class='unexecuted'>                prod0 := sub(prod0, remainder)</span>
  62 |     | <span class='neutral'>            }</span>
  63 |     | <span class='neutral'>            // Factor powers of two out of denominator -</span>
  64 |     | <span class='neutral'>            // compute largest power of two divisor of denominator</span>
  65 |     | <span class='neutral'>            // (always &gt;= 1).</span>
  66 |     | <span class='unexecuted'>            uint256 twos = uint256(-int256(denominator)) &amp; denominator;</span>
  67 |     | <span class='neutral'>            // Divide denominator by power of two.</span>
  68 |     | <span class='neutral'>            assembly {</span>
  69 |     | <span class='unexecuted'>                denominator := div(denominator, twos)</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>            // Divide [prod1 prod0] by the factors of two.</span>
  72 |     | <span class='neutral'>            assembly {</span>
  73 |     | <span class='unexecuted'>                prod0 := div(prod0, twos)</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0. For this we need</span>
  76 |     | <span class='neutral'>            // to flip `twos` such that it is 2**256 / twos -</span>
  77 |     | <span class='neutral'>            // if twos is zero, then it becomes one.</span>
  78 |     | <span class='neutral'>            assembly {</span>
  79 |     | <span class='unexecuted'>                twos := add(div(sub(0, twos), twos), 1)</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='unexecuted'>            prod0 |= prod1 * twos;</span>
  82 |     | <span class='neutral'>            // Invert denominator mod 2**256 -</span>
  83 |     | <span class='neutral'>            // now that denominator is an odd number, it has an inverse</span>
  84 |     | <span class='neutral'>            // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  85 |     | <span class='neutral'>            // Compute the inverse by starting with a seed that is correct</span>
  86 |     | <span class='neutral'>            // for four bits. That is, denominator * inv = 1 mod 2**4.</span>
  87 |     | <span class='unexecuted'>            uint256 inv = (3 * denominator) ^ 2;</span>
  88 |     | <span class='neutral'>            // Now use Newton-Raphson iteration to improve the precision.</span>
  89 |     | <span class='neutral'>            // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  90 |     | <span class='neutral'>            // arithmetic, doubling the correct bits in each step.</span>
  91 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**8.</span>
  92 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**16.</span>
  93 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**32.</span>
  94 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**64.</span>
  95 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**128.</span>
  96 |     | <span class='unexecuted'>            inv *= 2 - denominator * inv; // Inverse mod 2**256.</span>
  97 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying</span>
  98 |     | <span class='neutral'>            // with the modular inverse of denominator. This will give us the</span>
  99 |     | <span class='neutral'>            // correct result modulo 2**256. Since the precoditions guarantee</span>
 100 |     | <span class='neutral'>            // that the outcome is less than 2**256, this is the final result.</span>
 101 |     | <span class='neutral'>            // We don&#39;t need to compute the high bits of the result and prod1</span>
 102 |     | <span class='neutral'>            // is no longer required.</span>
 103 |     | <span class='unexecuted'>            result = prod0 * inv;</span>
 104 |     | <span class='unexecuted'>            return result;</span>
 105 |     | <span class='neutral'>        }</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Calculates ceil(a×b÷denominator) with full precision - throws if result overflows an uint256 or denominator == 0.</span>
 109 |     | <span class='neutral'>    /// @param a The multiplicand.</span>
 110 |     | <span class='neutral'>    /// @param b The multiplier.</span>
 111 |     | <span class='neutral'>    /// @param denominator The divisor.</span>
 112 |     | <span class='neutral'>    /// @return result The 256-bit result.</span>
 113 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 114 |     | <span class='neutral'>        uint256 a,</span>
 115 |     | <span class='neutral'>        uint256 b,</span>
 116 |     | <span class='neutral'>        uint256 denominator</span>
 117 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 118 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 119 |     | <span class='neutral'>        unchecked {</span>
 120 |     | <span class='unexecuted'>            if (mulmod(a, b, denominator) != 0) {</span>
 121 |     | <span class='unexecuted'>                if (result &gt;= type(uint256).max) require (false, &#39;MaxUintExceeded()&#39;);</span>
 122 |     | <span class='unexecuted'>                result++;</span>
 123 |     | <span class='neutral'>            }</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>
 127 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/pool/FeesCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/limit/ILimitPoolManager.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library FeesCall {</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // protocol fee ceilings</span>
 11 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_SWAP_FEE = 1e4; // max protocol swap fee of 100%</span>
 12 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FILL_FEE = 1e2; // max protocol fill fee of 1%</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    // protocol fee flags</span>
 15 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_0 = 2**0;</span>
 16 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_1 = 2**1;</span>
 17 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_0 = 2**2;</span>
 18 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_1 = 2**3;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @dev - LimitPoolManager (i.e. constants.owner) emits events in aggregate</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function perform(</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 24 |     | <span class='neutral'>        PoolsharkStructs.FeesParams memory params,</span>
 25 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 26 |     | <span class='neutral'>    ) internal returns (</span>
 27 |     | <span class='unexecuted'>        uint128 token0Fees,</span>
 28 |     | <span class='unexecuted'>        uint128 token1Fees</span>
 29 |     | <span class='neutral'>    ) {</span>
 30 |     | <span class='neutral'>        // swap fee token0</span>
 31 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_SWAP_FEE_0) &gt; 0) {</span>
 32 |     | <span class='unexecuted'>            if (params.protocolSwapFee0 &gt; MAX_PROTOCOL_SWAP_FEE)</span>
 33 |     | <span class='unexecuted'>                require(false, &#39;ProtocolSwapFeeCeilingExceeded()&#39;);</span>
 34 |     | <span class='unexecuted'>            globalState.pool.protocolSwapFee0 = params.protocolSwapFee0;</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='neutral'>        // swap fee token1</span>
 37 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_SWAP_FEE_1) &gt; 0) {</span>
 38 |     | <span class='unexecuted'>            if (params.protocolSwapFee1 &gt; MAX_PROTOCOL_SWAP_FEE)</span>
 39 |     | <span class='unexecuted'>                require(false, &#39;ProtocolSwapFeeCeilingExceeded()&#39;);</span>
 40 |     | <span class='unexecuted'>            globalState.pool.protocolSwapFee1 = params.protocolSwapFee1;</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>        // fill fee token0</span>
 43 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_FILL_FEE_0) &gt; 0) {</span>
 44 |     | <span class='unexecuted'>            if (params.protocolFillFee0 &gt; MAX_PROTOCOL_FILL_FEE)</span>
 45 |     | <span class='unexecuted'>                require(false, &#39;ProtocolFillFeeCeilingExceeded()&#39;);</span>
 46 |     | <span class='unexecuted'>            globalState.pool1.protocolFillFee = params.protocolFillFee0;</span>
 47 |     | <span class='neutral'>        }</span>
 48 |     | <span class='neutral'>        // fill fee token1</span>
 49 |     | <span class='unexecuted'>        if ((params.setFeesFlags &amp; PROTOCOL_FILL_FEE_1) &gt; 0) {</span>
 50 |     | <span class='unexecuted'>            if (params.protocolFillFee1 &gt; MAX_PROTOCOL_FILL_FEE)</span>
 51 |     | <span class='unexecuted'>                require(false, &#39;ProtocolFillFeeCeilingExceeded()&#39;);</span>
 52 |     | <span class='unexecuted'>            globalState.pool0.protocolFillFee = params.protocolFillFee1;</span>
 53 |     | <span class='neutral'>        }</span>
 54 |     | <span class='unexecuted'>        address feeTo = ILimitPoolManager(constants.owner).feeTo();</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>        // token0 fees stored on pool1 for swaps and fills</span>
 57 |     | <span class='unexecuted'>        token0Fees = globalState.pool1.protocolFees;</span>
 58 |     | <span class='neutral'>        // token1 fees stored on pool0 for swaps and fills</span>
 59 |     | <span class='unexecuted'>        token1Fees = globalState.pool0.protocolFees;</span>
 60 |     | <span class='unexecuted'>        globalState.pool0.protocolFees = 0;</span>
 61 |     | <span class='unexecuted'>        globalState.pool1.protocolFees = 0;</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        if (token0Fees &gt; 0)</span>
 64 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, constants.token0, token0Fees);</span>
 65 |     | <span class='unexecuted'>        if (token1Fees &gt; 0)</span>
 66 |     | <span class='unexecuted'>            SafeTransfers.transferOut(feeTo, constants.token1, token1Fees);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='unexecuted'>        return (token0Fees, token1Fees);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>}</span>
 71 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/pool/QuoteCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library QuoteCall {</span>
  8 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    event Swap(</span>
 11 |     | <span class='neutral'>        address indexed recipient,</span>
 12 |     | <span class='neutral'>        bool zeroForOne,</span>
 13 |     | <span class='neutral'>        uint256 amountIn,</span>
 14 |     | <span class='neutral'>        uint256 amountOut,</span>
 15 |     | <span class='neutral'>        uint160 price,</span>
 16 |     | <span class='neutral'>        uint128 liquidity,</span>
 17 |     | <span class='neutral'>        int24 tickAtPrice</span>
 18 |     | <span class='neutral'>    );</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    function perform(</span>
 21 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
 22 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
 23 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
 24 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 25 |     | <span class='neutral'>        PoolsharkStructs.QuoteParams memory params,</span>
 26 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
 27 |     | <span class='neutral'>    ) internal returns (</span>
 28 |     | <span class='unexecuted'>        uint256,</span>
 29 |     | <span class='unexecuted'>        uint256,</span>
 30 |     | <span class='unexecuted'>        uint160</span>
 31 |     | <span class='neutral'>    ) {</span>
 32 |     | <span class='unexecuted'>        if (cache.state.unlocked == _ENTERED)</span>
 33 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 34 |     | <span class='unexecuted'>        cache.state = globalState;</span>
 35 |     | <span class='unexecuted'>        return Ticks.quote(</span>
 36 |     | <span class='unexecuted'>            ticks,</span>
 37 |     | <span class='unexecuted'>            rangeTickMap,</span>
 38 |     | <span class='unexecuted'>            limitTickMap,</span>
 39 |     | <span class='unexecuted'>            params,</span>
 40 |     | <span class='unexecuted'>            cache</span>
 41 |     | <span class='neutral'>        );</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/pool/SampleCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library SampleCall {</span>
  8 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
  9 |     | <span class='neutral'>    </span>
 10 |     | <span class='neutral'>    event SampleRecorded(</span>
 11 |     | <span class='neutral'>        int56 tickSecondsAccum,</span>
 12 |     | <span class='neutral'>        uint160 secondsPerLiquidityAccum</span>
 13 |     | <span class='neutral'>    );</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    event SampleLengthIncreased(</span>
 16 |     | <span class='neutral'>        uint16 sampleLengthNext</span>
 17 |     | <span class='neutral'>    );</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function perform(</span>
 20 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 21 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 22 |     | <span class='neutral'>        uint32[] memory secondsAgo</span>
 23 |     | <span class='neutral'>    ) internal view returns (</span>
 24 |     | <span class='unexecuted'>        int56[]   memory tickSecondsAccum,</span>
 25 |     | <span class='unexecuted'>        uint160[] memory secondsPerLiquidityAccum,</span>
 26 |     | <span class='unexecuted'>        uint160 averagePrice,</span>
 27 |     | <span class='unexecuted'>        uint128 averageLiquidity,</span>
 28 |     | <span class='unexecuted'>        int24 averageTick</span>
 29 |     | <span class='neutral'>    ) {</span>
 30 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED)</span>
 31 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 32 |     | <span class='unexecuted'>        return Samples.get(</span>
 33 |     | <span class='unexecuted'>            address(this),</span>
 34 |     | <span class='unexecuted'>            RangePoolStructs.SampleParams(</span>
 35 |     | <span class='unexecuted'>                state.pool.samples.index,</span>
 36 |     | <span class='unexecuted'>                state.pool.samples.length,</span>
 37 |     | <span class='unexecuted'>                uint32(block.timestamp),</span>
 38 |     | <span class='unexecuted'>                secondsAgo,</span>
 39 |     | <span class='unexecuted'>                state.pool.tickAtPrice,</span>
 40 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 41 |     | <span class='unexecuted'>                constants</span>
 42 |     | <span class='neutral'>            )</span>
 43 |     | <span class='neutral'>        );</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/pool/SwapCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/callbacks/ILimitPoolSwapCallback.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../Ticks.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../utils/Collect.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library SwapCall {</span>
  12 |     | <span class='neutral'>    event Swap(</span>
  13 |     | <span class='neutral'>        address indexed recipient,</span>
  14 |     | <span class='neutral'>        bool zeroForOne,</span>
  15 |     | <span class='neutral'>        uint256 amountIn,</span>
  16 |     | <span class='neutral'>        uint256 amountOut,</span>
  17 |     | <span class='neutral'>        uint160 price,</span>
  18 |     | <span class='neutral'>        uint128 liquidity,</span>
  19 |     | <span class='neutral'>        uint128 feeAmount,</span>
  20 |     | <span class='neutral'>        int24 tickAtPrice</span>
  21 |     | <span class='neutral'>    );</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function perform(</span>
  24 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  25 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  26 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  27 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  28 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  29 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
  30 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
  31 |     | <span class='neutral'>    ) internal returns (</span>
  32 |     | <span class='unexecuted'>        int256,</span>
  33 |     | <span class='unexecuted'>        int256</span>
  34 |     | <span class='neutral'>    ) {</span>
  35 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  36 |     | <span class='unexecuted'>        cache = Ticks.swap(</span>
  37 |     | <span class='unexecuted'>            ticks,</span>
  38 |     | <span class='unexecuted'>            samples,</span>
  39 |     | <span class='unexecuted'>            rangeTickMap,</span>
  40 |     | <span class='unexecuted'>            limitTickMap,</span>
  41 |     | <span class='unexecuted'>            params,</span>
  42 |     | <span class='unexecuted'>            cache</span>
  43 |     | <span class='neutral'>        );</span>
  44 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
  45 |     | <span class='unexecuted'>        EchidnaAssertions.assertPoolBalanceExceeded(</span>
  46 |     | <span class='unexecuted'>            (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),</span>
  47 |     | <span class='unexecuted'>            cache.output</span>
  48 |     | <span class='neutral'>        );</span>
  49 |     | <span class='neutral'>        // transfer output amount</span>
  50 |     | <span class='unexecuted'>        SafeTransfers.transferOut(</span>
  51 |     | <span class='unexecuted'>            params.to, </span>
  52 |     | <span class='unexecuted'>            params.zeroForOne ? cache.constants.token1</span>
  53 |     | <span class='unexecuted'>                              : cache.constants.token0,</span>
  54 |     | <span class='unexecuted'>            cache.output</span>
  55 |     | <span class='neutral'>        );</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        // check balance and execute callback</span>
  58 |     | <span class='unexecuted'>        uint256 balanceStart = balance(params, cache);</span>
  59 |     | <span class='unexecuted'>        ILimitPoolSwapCallback(msg.sender).limitPoolSwapCallback(</span>
  60 |     | <span class='unexecuted'>            params.zeroForOne ? -int256(cache.input) : int256(cache.output),</span>
  61 |     | <span class='unexecuted'>            params.zeroForOne ? int256(cache.output) : -int256(cache.input),</span>
  62 |     | <span class='unexecuted'>            params.callbackData</span>
  63 |     | <span class='neutral'>        );</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>        // check balance requirements after callback</span>
  66 |     | <span class='unexecuted'>        if (balance(params, cache) &lt; balanceStart + cache.input)</span>
  67 |     | <span class='unexecuted'>            require(false, &#39;SwapInputAmountTooLow()&#39;);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>        return (</span>
  70 |     | <span class='unexecuted'>            params.zeroForOne ? </span>
  71 |     | <span class='neutral'>                (</span>
  72 |     | <span class='unexecuted'>                    -int256(cache.input),</span>
  73 |     | <span class='unexecuted'>                     int256(cache.output)</span>
  74 |     | <span class='neutral'>                )</span>
  75 |     | <span class='neutral'>              : (</span>
  76 |     | <span class='unexecuted'>                     int256(cache.output),</span>
  77 |     | <span class='unexecuted'>                    -int256(cache.input)</span>
  78 |     | <span class='neutral'>                )</span>
  79 |     | <span class='neutral'>        );</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    function save(</span>
  83 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
  84 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  85 |     | <span class='neutral'>        bool zeroForOne</span>
  86 |     | <span class='neutral'>    ) internal {</span>
  87 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  88 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
  89 |     | <span class='unexecuted'>        if (zeroForOne)</span>
  90 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
  91 |     | <span class='neutral'>        else</span>
  92 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>    function balance(</span>
  96 |     | <span class='neutral'>        PoolsharkStructs.SwapParams memory params,</span>
  97 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache</span>
  98 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
  99 |     | <span class='unexecuted'>        (</span>
 100 |     | <span class='unexecuted'>            bool success,</span>
 101 |     | <span class='unexecuted'>            bytes memory data</span>
 102 |     | <span class='unexecuted'>        ) = (params.zeroForOne ? cache.constants.token0</span>
 103 |     | <span class='unexecuted'>                               : cache.constants.token1)</span>
 104 |     | <span class='neutral'>                               .staticcall(</span>
 105 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 106 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 107 |     | <span class='unexecuted'>                                        address(this)</span>
 108 |     | <span class='neutral'>                                    )</span>
 109 |     | <span class='neutral'>                                );</span>
 110 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 111 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>    function balance(</span>
 115 |     | <span class='neutral'>        address token</span>
 116 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 117 |     | <span class='unexecuted'>        (</span>
 118 |     | <span class='unexecuted'>            bool success,</span>
 119 |     | <span class='unexecuted'>            bytes memory data</span>
 120 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 121 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 122 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 123 |     | <span class='unexecuted'>                                        address(this)</span>
 124 |     | <span class='neutral'>                                    )</span>
 125 |     | <span class='neutral'>                                );</span>
 126 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 127 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>}</span>
 130 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/range/RangePositions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/FeeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../utils/SafeCast.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./RangeTicks.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/// @notice Position management library for ranged liquidity.</span>
  15 |     | <span class='unexecuted'>library RangePositions {</span>
  16 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  17 |     | <span class='neutral'>    using SafeCast for uint128;</span>
  18 |     | <span class='neutral'>    using SafeCast for int256;</span>
  19 |     | <span class='neutral'>    using SafeCast for int128;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    error NotEnoughPositionLiquidity();</span>
  22 |     | <span class='neutral'>    error InvalidClaimTick();</span>
  23 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  24 |     | <span class='neutral'>    error WrongTickClaimedAt();</span>
  25 |     | <span class='neutral'>    error NoLiquidityBeingAdded();</span>
  26 |     | <span class='neutral'>    error PositionNotUpdated();</span>
  27 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  28 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  29 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  30 |     | <span class='neutral'>    error InvalidPositionBoundsOrder();</span>
  31 |     | <span class='neutral'>    error NotImplementedYet();</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  34 |     | <span class='unexecuted'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    event BurnRange(</span>
  37 |     | <span class='neutral'>        address indexed recipient,</span>
  38 |     | <span class='neutral'>        uint256 indexed positionId,</span>
  39 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  40 |     | <span class='neutral'>        int128 amount0,</span>
  41 |     | <span class='neutral'>        int128 amount1</span>
  42 |     | <span class='neutral'>    );</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    event CompoundRange(</span>
  45 |     | <span class='neutral'>        uint32 indexed positionId,</span>
  46 |     | <span class='neutral'>        uint128 liquidityCompounded</span>
  47 |     | <span class='neutral'>    );</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function validate(</span>
  50 |     | <span class='neutral'>        RangePoolStructs.MintRangeParams memory params,</span>
  51 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache</span>
  52 |     | <span class='neutral'>    ) internal pure returns (</span>
  53 |     | <span class='unexecuted'>        RangePoolStructs.MintRangeParams memory,</span>
  54 |     | <span class='unexecuted'>        RangePoolStructs.MintRangeCache memory</span>
  55 |     | <span class='neutral'>    ) {</span>
  56 |     | <span class='unexecuted'>        RangeTicks.validate(cache.position.lower, cache.position.upper, cache.constants.tickSpacing);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>        cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(</span>
  59 |     | <span class='unexecuted'>            cache.priceLower,</span>
  60 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  61 |     | <span class='unexecuted'>            cache.state.pool.price,</span>
  62 |     | <span class='unexecuted'>            params.amount1,</span>
  63 |     | <span class='unexecuted'>            params.amount0</span>
  64 |     | <span class='neutral'>        );</span>
  65 |     | <span class='unexecuted'>        if (cache.liquidityMinted == 0) require(false, &#39;NoLiquidityBeingAdded()&#39;);</span>
  66 |     | <span class='unexecuted'>        (params.amount0, params.amount1) = ConstantProduct.getAmountsForLiquidity(</span>
  67 |     | <span class='unexecuted'>            cache.priceLower,</span>
  68 |     | <span class='unexecuted'>            cache.priceUpper,</span>
  69 |     | <span class='unexecuted'>            cache.state.pool.price,</span>
  70 |     | <span class='unexecuted'>            cache.liquidityMinted,</span>
  71 |     | <span class='unexecuted'>            true</span>
  72 |     | <span class='neutral'>        );</span>
  73 |     | <span class='unexecuted'>        if (cache.liquidityMinted &gt; uint128(type(int128).max)) require(false, &#39;LiquidityOverflow()&#39;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        return (params, cache);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>    function add(</span>
  79 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  80 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  81 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  82 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache,</span>
  83 |     | <span class='neutral'>        RangePoolStructs.MintRangeParams memory params</span>
  84 |     | <span class='neutral'>    ) internal returns (</span>
  85 |     | <span class='unexecuted'>        RangePoolStructs.MintRangeCache memory</span>
  86 |     | <span class='neutral'>    ) {</span>
  87 |     | <span class='unexecuted'>        if (params.amount0 == 0 &amp;&amp; params.amount1 == 0) return cache;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>        cache.state = RangeTicks.insert(</span>
  90 |     | <span class='unexecuted'>            ticks,</span>
  91 |     | <span class='unexecuted'>            samples,</span>
  92 |     | <span class='unexecuted'>            tickMap,</span>
  93 |     | <span class='unexecuted'>            cache.state,</span>
  94 |     | <span class='unexecuted'>            cache.constants,</span>
  95 |     | <span class='unexecuted'>            cache.position.lower,</span>
  96 |     | <span class='unexecuted'>            cache.position.upper,</span>
  97 |     | <span class='unexecuted'>            cache.liquidityMinted.toUint128()</span>
  98 |     | <span class='neutral'>        );</span>
  99 |     | <span class='unexecuted'>        (</span>
 100 |     | <span class='unexecuted'>            cache.position.feeGrowthInside0Last,</span>
 101 |     | <span class='unexecuted'>            cache.position.feeGrowthInside1Last</span>
 102 |     | <span class='unexecuted'>        ) = rangeFeeGrowth(</span>
 103 |     | <span class='unexecuted'>            ticks[cache.position.lower].range,</span>
 104 |     | <span class='unexecuted'>            ticks[cache.position.upper].range,</span>
 105 |     | <span class='unexecuted'>            cache.state,</span>
 106 |     | <span class='unexecuted'>            cache.position.lower,</span>
 107 |     | <span class='unexecuted'>            cache.position.upper</span>
 108 |     | <span class='neutral'>        );</span>
 109 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 110 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).mint(</span>
 111 |     | <span class='unexecuted'>                params.to,</span>
 112 |     | <span class='unexecuted'>                params.positionId,</span>
 113 |     | <span class='unexecuted'>                1,</span>
 114 |     | <span class='unexecuted'>                cache.constants</span>
 115 |     | <span class='neutral'>            );</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='unexecuted'>        cache.position.liquidity += uint128(cache.liquidityMinted);</span>
 118 |     | <span class='unexecuted'>        return cache;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>    function remove(</span>
 122 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 123 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 124 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 125 |     | <span class='neutral'>        RangePoolStructs.BurnRangeParams memory params,</span>
 126 |     | <span class='neutral'>        RangePoolStructs.BurnRangeCache memory cache</span>
 127 |     | <span class='neutral'>    ) internal returns (</span>
 128 |     | <span class='unexecuted'>        RangePoolStructs.BurnRangeCache memory</span>
 129 |     | <span class='neutral'>    ) {</span>
 130 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants);</span>
 131 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants);</span>
 132 |     | <span class='unexecuted'>        cache.liquidityBurned = uint256(params.burnPercent) * cache.position.liquidity / 1e38;</span>
 133 |     | <span class='unexecuted'>        if (cache.liquidityBurned  == 0) {</span>
 134 |     | <span class='unexecuted'>            return cache;</span>
 135 |     | <span class='neutral'>        }</span>
 136 |     | <span class='unexecuted'>        if (cache.liquidityBurned &gt; cache.position.liquidity) require(false, &#39;NotEnoughPositionLiquidity()&#39;);</span>
 137 |     | <span class='unexecuted'>        {</span>
 138 |     | <span class='unexecuted'>            uint128 amount0Removed; uint128 amount1Removed;</span>
 139 |     | <span class='unexecuted'>            (amount0Removed, amount1Removed) = ConstantProduct.getAmountsForLiquidity(</span>
 140 |     | <span class='unexecuted'>                cache.priceLower,</span>
 141 |     | <span class='unexecuted'>                cache.priceUpper,</span>
 142 |     | <span class='unexecuted'>                cache.state.pool.price,</span>
 143 |     | <span class='unexecuted'>                cache.liquidityBurned ,</span>
 144 |     | <span class='unexecuted'>                false</span>
 145 |     | <span class='neutral'>            );</span>
 146 |     | <span class='unexecuted'>            cache.amount0 += amount0Removed.toInt128();</span>
 147 |     | <span class='unexecuted'>            cache.amount1 += amount1Removed.toInt128();</span>
 148 |     | <span class='unexecuted'>            cache.position.liquidity -= cache.liquidityBurned.toUint128();</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='unexecuted'>        cache.state = RangeTicks.remove(</span>
 151 |     | <span class='unexecuted'>            ticks,</span>
 152 |     | <span class='unexecuted'>            samples,</span>
 153 |     | <span class='unexecuted'>            tickMap,</span>
 154 |     | <span class='unexecuted'>            cache.state,</span>
 155 |     | <span class='unexecuted'>            cache.constants,</span>
 156 |     | <span class='unexecuted'>            cache.position.lower,</span>
 157 |     | <span class='unexecuted'>            cache.position.upper,</span>
 158 |     | <span class='unexecuted'>            uint128(cache.liquidityBurned)</span>
 159 |     | <span class='neutral'>        );</span>
 160 |     | <span class='unexecuted'>        emit BurnRange(</span>
 161 |     | <span class='unexecuted'>            params.to,</span>
 162 |     | <span class='unexecuted'>            params.positionId,</span>
 163 |     | <span class='unexecuted'>            uint128(cache.liquidityBurned),</span>
 164 |     | <span class='unexecuted'>            cache.amount0,</span>
 165 |     | <span class='unexecuted'>            cache.amount1</span>
 166 |     | <span class='neutral'>        );</span>
 167 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0) {</span>
 168 |     | <span class='unexecuted'>            cache.position.feeGrowthInside0Last = 0;</span>
 169 |     | <span class='unexecuted'>            cache.position.feeGrowthInside1Last = 0;</span>
 170 |     | <span class='unexecuted'>            cache.position.lower = 0;</span>
 171 |     | <span class='unexecuted'>            cache.position.upper = 0;</span>
 172 |     | <span class='neutral'>        }</span>
 173 |     | <span class='unexecuted'>        return cache;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>    function compound(</span>
 177 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 178 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 179 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 180 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 181 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 182 |     | <span class='neutral'>        RangePoolStructs.RangePosition memory position,</span>
 183 |     | <span class='neutral'>        RangePoolStructs.CompoundRangeParams memory params</span>
 184 |     | <span class='neutral'>    ) internal returns (</span>
 185 |     | <span class='unexecuted'>        RangePoolStructs.RangePosition memory,</span>
 186 |     | <span class='unexecuted'>        PoolsharkStructs.GlobalState memory,</span>
 187 |     | <span class='unexecuted'>        int128,</span>
 188 |     | <span class='unexecuted'>        int128</span>
 189 |     | <span class='neutral'>    ) {</span>
 190 |     | <span class='neutral'>        // price tells you the ratio so you need to swap into the correct ratio and add liquidity</span>
 191 |     | <span class='unexecuted'>        uint256 liquidityAmount = ConstantProduct.getLiquidityForAmounts(</span>
 192 |     | <span class='unexecuted'>            params.priceLower,</span>
 193 |     | <span class='unexecuted'>            params.priceUpper,</span>
 194 |     | <span class='unexecuted'>            state.pool.price,</span>
 195 |     | <span class='unexecuted'>            params.amount1,</span>
 196 |     | <span class='unexecuted'>            params.amount0</span>
 197 |     | <span class='neutral'>        );</span>
 198 |     | <span class='unexecuted'>        if (liquidityAmount &gt; 0) {</span>
 199 |     | <span class='unexecuted'>            state = RangeTicks.insert(</span>
 200 |     | <span class='unexecuted'>                ticks,</span>
 201 |     | <span class='unexecuted'>                samples,</span>
 202 |     | <span class='unexecuted'>                tickMap,</span>
 203 |     | <span class='unexecuted'>                state,</span>
 204 |     | <span class='unexecuted'>                constants,</span>
 205 |     | <span class='unexecuted'>                position.lower,</span>
 206 |     | <span class='unexecuted'>                position.upper,</span>
 207 |     | <span class='unexecuted'>                uint128(liquidityAmount)</span>
 208 |     | <span class='neutral'>            );</span>
 209 |     | <span class='unexecuted'>            uint256 amount0; uint256 amount1;</span>
 210 |     | <span class='unexecuted'>            (amount0, amount1) = ConstantProduct.getAmountsForLiquidity(</span>
 211 |     | <span class='unexecuted'>                params.priceLower,</span>
 212 |     | <span class='unexecuted'>                params.priceUpper,</span>
 213 |     | <span class='unexecuted'>                state.pool.price,</span>
 214 |     | <span class='unexecuted'>                liquidityAmount,</span>
 215 |     | <span class='unexecuted'>                true</span>
 216 |     | <span class='neutral'>            );</span>
 217 |     | <span class='unexecuted'>            params.amount0 -= (amount0 &lt;= params.amount0) ? uint128(amount0) : params.amount0;</span>
 218 |     | <span class='unexecuted'>            params.amount1 -= (amount1 &lt;= params.amount1) ? uint128(amount1) : params.amount1;</span>
 219 |     | <span class='unexecuted'>            position.liquidity += uint128(liquidityAmount);</span>
 220 |     | <span class='neutral'>        }</span>
 221 |     | <span class='unexecuted'>        emit CompoundRange(</span>
 222 |     | <span class='unexecuted'>            params.positionId,</span>
 223 |     | <span class='unexecuted'>            uint128(liquidityAmount)</span>
 224 |     | <span class='neutral'>        );</span>
 225 |     | <span class='unexecuted'>        return (position, state, params.amount0.toInt128(), params.amount1.toInt128());</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>    function update(</span>
 229 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 230 |     | <span class='neutral'>        RangePoolStructs.RangePosition memory position,</span>
 231 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 232 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 233 |     | <span class='neutral'>        RangePoolStructs.UpdateParams memory params</span>
 234 |     | <span class='neutral'>    ) internal returns (</span>
 235 |     | <span class='unexecuted'>        RangePoolStructs.RangePosition memory,</span>
 236 |     | <span class='unexecuted'>        int128,</span>
 237 |     | <span class='unexecuted'>        int128</span>
 238 |     | <span class='neutral'>    ) {</span>
 239 |     | <span class='unexecuted'>        RangePoolStructs.RangePositionCache memory cache;</span>
 240 |     | <span class='neutral'>        /// @dev - only true if burn call</span>
 241 |     | <span class='unexecuted'>        if (params.burnPercent &gt; 0) {</span>
 242 |     | <span class='unexecuted'>            cache.liquidityAmount = uint256(params.burnPercent) * position.liquidity / 1e38;</span>
 243 |     | <span class='unexecuted'>            if (position.liquidity == cache.liquidityAmount)</span>
 244 |     | <span class='unexecuted'>                IPositionERC1155(constants.poolToken).burn(msg.sender, params.positionId, 1, constants);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(</span>
 248 |     | <span class='unexecuted'>            ticks[position.lower].range,</span>
 249 |     | <span class='unexecuted'>            ticks[position.upper].range,</span>
 250 |     | <span class='unexecuted'>            state,</span>
 251 |     | <span class='unexecuted'>            position.lower,</span>
 252 |     | <span class='unexecuted'>            position.upper</span>
 253 |     | <span class='neutral'>        );</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>        int128 amount0Fees = OverflowMath.mulDiv(</span>
 256 |     | <span class='unexecuted'>            rangeFeeGrowth0 - position.feeGrowthInside0Last,</span>
 257 |     | <span class='unexecuted'>            uint256(position.liquidity),</span>
 258 |     | <span class='neutral'>            Q128</span>
 259 |     | <span class='neutral'>        ).toInt256().toInt128();</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>        int128 amount1Fees = OverflowMath.mulDiv(</span>
 262 |     | <span class='unexecuted'>            rangeFeeGrowth1 - position.feeGrowthInside1Last,</span>
 263 |     | <span class='unexecuted'>            position.liquidity,</span>
 264 |     | <span class='neutral'>            Q128</span>
 265 |     | <span class='neutral'>        ).toInt256().toInt128();</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>        position.feeGrowthInside0Last = rangeFeeGrowth0;</span>
 268 |     | <span class='unexecuted'>        position.feeGrowthInside1Last = rangeFeeGrowth1;</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='unexecuted'>        return (position, amount0Fees, amount1Fees);</span>
 271 |     | <span class='neutral'>    }</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>    function rangeFeeGrowth(</span>
 274 |     | <span class='neutral'>        PoolsharkStructs.RangeTick memory lowerTick,</span>
 275 |     | <span class='neutral'>        PoolsharkStructs.RangeTick memory upperTick,</span>
 276 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 277 |     | <span class='neutral'>        int24 lower,</span>
 278 |     | <span class='neutral'>        int24 upper</span>
 279 |     | <span class='unexecuted'>    ) internal pure returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>        uint256 feeGrowthGlobal0 = state.pool.feeGrowthGlobal0;</span>
 282 |     | <span class='unexecuted'>        uint256 feeGrowthGlobal1 = state.pool.feeGrowthGlobal1;</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='unexecuted'>        uint256 feeGrowthBelow0;</span>
 285 |     | <span class='unexecuted'>        uint256 feeGrowthBelow1;</span>
 286 |     | <span class='unexecuted'>        if (state.pool.tickAtPrice &gt;= lower) {</span>
 287 |     | <span class='unexecuted'>            feeGrowthBelow0 = lowerTick.feeGrowthOutside0;</span>
 288 |     | <span class='unexecuted'>            feeGrowthBelow1 = lowerTick.feeGrowthOutside1;</span>
 289 |     | <span class='neutral'>        } else {</span>
 290 |     | <span class='unexecuted'>            feeGrowthBelow0 = feeGrowthGlobal0 - lowerTick.feeGrowthOutside0;</span>
 291 |     | <span class='unexecuted'>            feeGrowthBelow1 = feeGrowthGlobal1 - lowerTick.feeGrowthOutside1;</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        uint256 feeGrowthAbove0;</span>
 295 |     | <span class='unexecuted'>        uint256 feeGrowthAbove1;</span>
 296 |     | <span class='unexecuted'>        if (state.pool.tickAtPrice &lt; upper) {</span>
 297 |     | <span class='unexecuted'>            feeGrowthAbove0 = upperTick.feeGrowthOutside0;</span>
 298 |     | <span class='unexecuted'>            feeGrowthAbove1 = upperTick.feeGrowthOutside1;</span>
 299 |     | <span class='neutral'>        } else {</span>
 300 |     | <span class='unexecuted'>            feeGrowthAbove0 = feeGrowthGlobal0 - upperTick.feeGrowthOutside0;</span>
 301 |     | <span class='unexecuted'>            feeGrowthAbove1 = feeGrowthGlobal1 - upperTick.feeGrowthOutside1;</span>
 302 |     | <span class='neutral'>        }</span>
 303 |     | <span class='unexecuted'>        feeGrowthInside0 = feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;</span>
 304 |     | <span class='unexecuted'>        feeGrowthInside1 = feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;</span>
 305 |     | <span class='neutral'>    }</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>    function snapshot(</span>
 308 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 309 |     | <span class='neutral'>            storage positions,</span>
 310 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 311 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 312 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 313 |     | <span class='neutral'>        uint32 positionId</span>
 314 |     | <span class='neutral'>    ) internal view returns (</span>
 315 |     | <span class='unexecuted'>        int56   tickSecondsAccum,</span>
 316 |     | <span class='unexecuted'>        uint160 secondsPerLiquidityAccum,</span>
 317 |     | <span class='unexecuted'>        uint128 feesOwed0,</span>
 318 |     | <span class='unexecuted'>        uint128 feesOwed1</span>
 319 |     | <span class='unexecuted'>    ) {</span>
 320 |     | <span class='unexecuted'>        RangePoolStructs.SnapshotRangeCache memory cache;</span>
 321 |     | <span class='unexecuted'>        cache.position = positions[positionId];</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>        // early return if position empty</span>
 324 |     | <span class='unexecuted'>        if (cache.position.liquidity == 0)</span>
 325 |     | <span class='unexecuted'>            return (0,0,0,0);</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>        cache.price = state.pool.price;</span>
 328 |     | <span class='unexecuted'>        cache.liquidity = state.pool.liquidity;</span>
 329 |     | <span class='unexecuted'>        cache.samples = state.pool.samples;</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='neutral'>        // grab lower tick</span>
 332 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickLower = ticks[cache.position.lower].range;</span>
 333 |     | <span class='neutral'>        </span>
 334 |     | <span class='neutral'>        // grab upper tick</span>
 335 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickUpper = ticks[cache.position.upper].range;</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>        cache.tickSecondsAccumLower =  tickLower.tickSecondsAccumOutside;</span>
 338 |     | <span class='unexecuted'>        cache.secondsPerLiquidityAccumLower = tickLower.secondsPerLiquidityAccumOutside;</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>        // if both have never been crossed into return 0</span>
 341 |     | <span class='unexecuted'>        cache.tickSecondsAccumUpper = tickUpper.tickSecondsAccumOutside;</span>
 342 |     | <span class='unexecuted'>        cache.secondsPerLiquidityAccumUpper = tickUpper.secondsPerLiquidityAccumOutside;</span>
 343 |     | <span class='unexecuted'>        cache.constants = constants;</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>        (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(</span>
 346 |     | <span class='unexecuted'>            tickLower,</span>
 347 |     | <span class='unexecuted'>            tickUpper,</span>
 348 |     | <span class='unexecuted'>            state,</span>
 349 |     | <span class='unexecuted'>            cache.position.lower,</span>
 350 |     | <span class='unexecuted'>            cache.position.upper</span>
 351 |     | <span class='neutral'>        );</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>        // calcuate fees earned</span>
 354 |     | <span class='unexecuted'>        cache.amount0 += uint128(</span>
 355 |     | <span class='unexecuted'>            OverflowMath.mulDiv(</span>
 356 |     | <span class='unexecuted'>                rangeFeeGrowth0 - cache.position.feeGrowthInside0Last,</span>
 357 |     | <span class='unexecuted'>                cache.position.liquidity,</span>
 358 |     | <span class='neutral'>                Q128</span>
 359 |     | <span class='neutral'>            )</span>
 360 |     | <span class='neutral'>        );</span>
 361 |     | <span class='unexecuted'>        cache.amount1 += uint128(</span>
 362 |     | <span class='unexecuted'>            OverflowMath.mulDiv(</span>
 363 |     | <span class='unexecuted'>                rangeFeeGrowth1 - cache.position.feeGrowthInside1Last,</span>
 364 |     | <span class='unexecuted'>                cache.position.liquidity,</span>
 365 |     | <span class='neutral'>                Q128</span>
 366 |     | <span class='neutral'>            )</span>
 367 |     | <span class='neutral'>        );</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='unexecuted'>        cache.tick = state.pool.tickAtPrice;</span>
 370 |     | <span class='unexecuted'>        if (cache.position.lower &gt;= cache.tick) {</span>
 371 |     | <span class='unexecuted'>            return (</span>
 372 |     | <span class='unexecuted'>                cache.tickSecondsAccumLower - cache.tickSecondsAccumUpper,</span>
 373 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccumLower - cache.secondsPerLiquidityAccumUpper,</span>
 374 |     | <span class='unexecuted'>                cache.amount0,</span>
 375 |     | <span class='unexecuted'>                cache.amount1</span>
 376 |     | <span class='neutral'>            );</span>
 377 |     | <span class='unexecuted'>        } else if (cache.position.upper &gt;= cache.tick) {</span>
 378 |     | <span class='unexecuted'>            cache.blockTimestamp = uint32(block.timestamp);</span>
 379 |     | <span class='unexecuted'>            (</span>
 380 |     | <span class='unexecuted'>                cache.tickSecondsAccum,</span>
 381 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccum</span>
 382 |     | <span class='unexecuted'>            ) = Samples.getSingle(</span>
 383 |     | <span class='unexecuted'>                IPool(address(this)), </span>
 384 |     | <span class='unexecuted'>                RangePoolStructs.SampleParams(</span>
 385 |     | <span class='unexecuted'>                    cache.samples.index,</span>
 386 |     | <span class='unexecuted'>                    cache.samples.length,</span>
 387 |     | <span class='unexecuted'>                    uint32(block.timestamp),</span>
 388 |     | <span class='unexecuted'>                    new uint32[](2),</span>
 389 |     | <span class='unexecuted'>                    cache.tick,</span>
 390 |     | <span class='unexecuted'>                    cache.liquidity,</span>
 391 |     | <span class='unexecuted'>                    cache.constants</span>
 392 |     | <span class='neutral'>                ),</span>
 393 |     | <span class='unexecuted'>                0</span>
 394 |     | <span class='neutral'>            );</span>
 395 |     | <span class='unexecuted'>            return (</span>
 396 |     | <span class='unexecuted'>                cache.tickSecondsAccum </span>
 397 |     | <span class='unexecuted'>                  - cache.tickSecondsAccumLower </span>
 398 |     | <span class='unexecuted'>                  - cache.tickSecondsAccumUpper,</span>
 399 |     | <span class='unexecuted'>                cache.secondsPerLiquidityAccum</span>
 400 |     | <span class='unexecuted'>                  - cache.secondsPerLiquidityAccumLower</span>
 401 |     | <span class='unexecuted'>                  - cache.secondsPerLiquidityAccumUpper,</span>
 402 |     | <span class='unexecuted'>                cache.amount0,</span>
 403 |     | <span class='unexecuted'>                cache.amount1</span>
 404 |     | <span class='neutral'>            );</span>
 405 |     | <span class='neutral'>        }</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'>}</span>
 408 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/range/RangeTicks.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../interfaces/range/IRangePool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./math/FeeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./RangePositions.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../math/OverflowMath.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../math/ConstantProduct.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../TickMap.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../Samples.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>/// @notice Tick management library for range pools</span>
  16 |     | <span class='unexecuted'>library RangeTicks {</span>
  17 |     | <span class='neutral'>    error LiquidityOverflow();</span>
  18 |     | <span class='neutral'>    error LiquidityUnderflow();</span>
  19 |     | <span class='neutral'>    error InvalidLowerTick();</span>
  20 |     | <span class='neutral'>    error InvalidUpperTick();</span>
  21 |     | <span class='neutral'>    error InvalidPositionAmount();</span>
  22 |     | <span class='neutral'>    error InvalidPositionBounds();</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    event Initialize(</span>
  25 |     | <span class='neutral'>        uint160 startPrice,</span>
  26 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  27 |     | <span class='neutral'>        int24 minTick,</span>
  28 |     | <span class='neutral'>        int24 maxTick</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    event SyncRangeTick(</span>
  32 |     | <span class='neutral'>        uint200 feeGrowthOutside0,</span>
  33 |     | <span class='neutral'>        uint200 feeGrowthOutside1,</span>
  34 |     | <span class='neutral'>        int24 tick</span>
  35 |     | <span class='neutral'>    );</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
  38 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    function validate(</span>
  41 |     | <span class='neutral'>        int24 lower,</span>
  42 |     | <span class='neutral'>        int24 upper,</span>
  43 |     | <span class='neutral'>        int16 tickSpacing</span>
  44 |     | <span class='neutral'>    ) internal pure {</span>
  45 |     | <span class='unexecuted'>        if (lower % tickSpacing != 0) require(false, &#39;InvalidLowerTick()&#39;);</span>
  46 |     | <span class='unexecuted'>        if (lower &lt; ConstantProduct.minTick(tickSpacing)) require(false, &#39;InvalidLowerTick()&#39;);</span>
  47 |     | <span class='unexecuted'>        if (upper % tickSpacing != 0) require(false, &#39;InvalidUpperTick()&#39;);</span>
  48 |     | <span class='unexecuted'>        if (upper &gt; ConstantProduct.maxTick(tickSpacing)) require(false, &#39;InvalidUpperTick()&#39;);</span>
  49 |     | <span class='unexecuted'>        if (lower &gt;= upper) require(false, &#39;InvalidPositionBounds()&#39;);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    function insert(</span>
  53 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  54 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  55 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  56 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
  57 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
  58 |     | <span class='neutral'>        int24 lower,</span>
  59 |     | <span class='neutral'>        int24 upper,</span>
  60 |     | <span class='neutral'>        uint128 amount</span>
  61 |     | <span class='unexecuted'>    ) internal returns (PoolsharkStructs.GlobalState memory) {</span>
  62 |     | <span class='unexecuted'>        validate(lower, upper, constants.tickSpacing);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        // check for amount to overflow liquidity delta &amp; global</span>
  65 |     | <span class='unexecuted'>        if (amount == 0) return state;</span>
  66 |     | <span class='unexecuted'>        if (amount &gt; uint128(type(int128).max)) require(false, &#39;LiquidityOverflow()&#39;);</span>
  67 |     | <span class='unexecuted'>        if (type(uint128).max - state.liquidityGlobal &lt; amount) require(false, &#39;LiquidityOverflow()&#39;);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        // get tick at price</span>
  70 |     | <span class='unexecuted'>        int24 tickAtPrice = state.pool.tickAtPrice;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>        if(TickMap.set(tickMap, lower, constants.tickSpacing)) {</span>
  73 |     | <span class='unexecuted'>            ticks[lower].range.liquidityDelta += int128(amount);</span>
  74 |     | <span class='unexecuted'>            ticks[lower].range.liquidityAbsolute += amount;</span>
  75 |     | <span class='neutral'>        } else {</span>
  76 |     | <span class='unexecuted'>            if (lower &lt;= tickAtPrice) {</span>
  77 |     | <span class='unexecuted'>                (</span>
  78 |     | <span class='unexecuted'>                    int56 tickSecondsAccum,</span>
  79 |     | <span class='unexecuted'>                    uint160 secondsPerLiquidityAccum</span>
  80 |     | <span class='unexecuted'>                ) = Samples.getSingle(</span>
  81 |     | <span class='unexecuted'>                        IPool(address(this)), </span>
  82 |     | <span class='unexecuted'>                        RangePoolStructs.SampleParams(</span>
  83 |     | <span class='unexecuted'>                            state.pool.samples.index,</span>
  84 |     | <span class='unexecuted'>                            state.pool.samples.length,</span>
  85 |     | <span class='unexecuted'>                            uint32(block.timestamp),</span>
  86 |     | <span class='unexecuted'>                            new uint32[](2),</span>
  87 |     | <span class='unexecuted'>                            state.pool.tickAtPrice,</span>
  88 |     | <span class='unexecuted'>                            state.pool.liquidity,</span>
  89 |     | <span class='unexecuted'>                            constants</span>
  90 |     | <span class='neutral'>                        ),</span>
  91 |     | <span class='unexecuted'>                        0</span>
  92 |     | <span class='neutral'>                );</span>
  93 |     | <span class='unexecuted'>                ticks[lower].range = PoolsharkStructs.RangeTick(</span>
  94 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
  95 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
  96 |     | <span class='unexecuted'>                    secondsPerLiquidityAccum,</span>
  97 |     | <span class='unexecuted'>                    tickSecondsAccum,</span>
  98 |     | <span class='unexecuted'>                    int128(amount),             // liquidityDelta</span>
  99 |     | <span class='unexecuted'>                    amount                      // liquidityAbsolute</span>
 100 |     | <span class='neutral'>                );</span>
 101 |     | <span class='unexecuted'>                emit SyncRangeTick(</span>
 102 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
 103 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
 104 |     | <span class='unexecuted'>                    lower</span>
 105 |     | <span class='neutral'>                );</span>
 106 |     | <span class='neutral'>            } else {</span>
 107 |     | <span class='unexecuted'>                ticks[lower].range.liquidityDelta = int128(amount);</span>
 108 |     | <span class='unexecuted'>                ticks[lower].range.liquidityAbsolute += amount;</span>
 109 |     | <span class='neutral'>            }</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='unexecuted'>        if(TickMap.set(tickMap, upper, constants.tickSpacing)) {</span>
 112 |     | <span class='unexecuted'>            ticks[upper].range.liquidityDelta -= int128(amount);</span>
 113 |     | <span class='unexecuted'>            ticks[upper].range.liquidityAbsolute += amount;</span>
 114 |     | <span class='neutral'>        } else {</span>
 115 |     | <span class='unexecuted'>            if (upper &lt;= tickAtPrice) {</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>                (</span>
 118 |     | <span class='unexecuted'>                    int56 tickSecondsAccum,</span>
 119 |     | <span class='unexecuted'>                    uint160 secondsPerLiquidityAccum</span>
 120 |     | <span class='unexecuted'>                ) = Samples.getSingle(</span>
 121 |     | <span class='unexecuted'>                        IPool(address(this)), </span>
 122 |     | <span class='unexecuted'>                        RangePoolStructs.SampleParams(</span>
 123 |     | <span class='unexecuted'>                            state.pool.samples.index,</span>
 124 |     | <span class='unexecuted'>                            state.pool.samples.length,</span>
 125 |     | <span class='unexecuted'>                            uint32(block.timestamp),</span>
 126 |     | <span class='unexecuted'>                            new uint32[](2),</span>
 127 |     | <span class='unexecuted'>                            state.pool.tickAtPrice,</span>
 128 |     | <span class='unexecuted'>                            state.pool.liquidity,</span>
 129 |     | <span class='unexecuted'>                            constants</span>
 130 |     | <span class='neutral'>                        ),</span>
 131 |     | <span class='unexecuted'>                        0</span>
 132 |     | <span class='neutral'>                );</span>
 133 |     | <span class='unexecuted'>                ticks[upper].range = PoolsharkStructs.RangeTick(</span>
 134 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
 135 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
 136 |     | <span class='unexecuted'>                    secondsPerLiquidityAccum,</span>
 137 |     | <span class='unexecuted'>                    tickSecondsAccum,</span>
 138 |     | <span class='unexecuted'>                    -int128(amount),</span>
 139 |     | <span class='unexecuted'>                    amount</span>
 140 |     | <span class='neutral'>                );</span>
 141 |     | <span class='unexecuted'>                emit SyncRangeTick(</span>
 142 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal0,</span>
 143 |     | <span class='unexecuted'>                    state.pool.feeGrowthGlobal1,</span>
 144 |     | <span class='unexecuted'>                    upper</span>
 145 |     | <span class='neutral'>                );</span>
 146 |     | <span class='neutral'>            } else {</span>
 147 |     | <span class='unexecuted'>                ticks[upper].range.liquidityDelta = -int128(amount);</span>
 148 |     | <span class='unexecuted'>                ticks[upper].range.liquidityAbsolute = amount;</span>
 149 |     | <span class='neutral'>            }</span>
 150 |     | <span class='neutral'>        }</span>
 151 |     | <span class='unexecuted'>        if (tickAtPrice &gt;= lower &amp;&amp; tickAtPrice &lt; upper) {</span>
 152 |     | <span class='neutral'>            // write an oracle entry</span>
 153 |     | <span class='unexecuted'>            (state.pool.samples.index, state.pool.samples.length) = Samples.save(</span>
 154 |     | <span class='unexecuted'>                samples,</span>
 155 |     | <span class='unexecuted'>                state.pool.samples,</span>
 156 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 157 |     | <span class='unexecuted'>                state.pool.tickAtPrice</span>
 158 |     | <span class='neutral'>            );</span>
 159 |     | <span class='neutral'>            // update pool liquidity</span>
 160 |     | <span class='unexecuted'>            state.pool.liquidity += amount;</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'>        // update global liquidity</span>
 163 |     | <span class='unexecuted'>        state.liquidityGlobal += amount;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        return state;</span>
 166 |     | <span class='neutral'>    }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    function remove(</span>
 169 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 170 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
 171 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 172 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 173 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants, </span>
 174 |     | <span class='neutral'>        int24 lower,</span>
 175 |     | <span class='neutral'>        int24 upper,</span>
 176 |     | <span class='neutral'>        uint128 amount</span>
 177 |     | <span class='unexecuted'>    ) internal returns (PoolsharkStructs.GlobalState memory) {</span>
 178 |     | <span class='unexecuted'>        validate(lower, upper, constants.tickSpacing);</span>
 179 |     | <span class='neutral'>        //check for amount to overflow liquidity delta &amp; global</span>
 180 |     | <span class='unexecuted'>        if (amount == 0) return state;</span>
 181 |     | <span class='unexecuted'>        if (amount &gt; uint128(type(int128).max)) require(false, &#39;LiquidityUnderflow()&#39;);</span>
 182 |     | <span class='unexecuted'>        if (amount &gt; state.liquidityGlobal) require(false, &#39;LiquidityUnderflow()&#39;);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        // get pool tick at price</span>
 185 |     | <span class='unexecuted'>        int24 tickAtPrice = state.pool.tickAtPrice;</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>        // update lower liquidity values</span>
 188 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickLower = ticks[lower].range;</span>
 189 |     | <span class='neutral'>        unchecked {</span>
 190 |     | <span class='unexecuted'>            tickLower.liquidityDelta -= int128(amount);</span>
 191 |     | <span class='unexecuted'>            tickLower.liquidityAbsolute -= amount;</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='unexecuted'>        ticks[lower].range = tickLower;</span>
 194 |     | <span class='neutral'>        // try to clear tick if possible</span>
 195 |     | <span class='unexecuted'>        clear(ticks, constants, tickMap, lower);</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        // update upper liquidity values</span>
 198 |     | <span class='unexecuted'>        PoolsharkStructs.RangeTick memory tickUpper = ticks[upper].range;</span>
 199 |     | <span class='neutral'>        unchecked {</span>
 200 |     | <span class='unexecuted'>            tickUpper.liquidityDelta += int128(amount);</span>
 201 |     | <span class='unexecuted'>            tickUpper.liquidityAbsolute -= amount;</span>
 202 |     | <span class='neutral'>        }</span>
 203 |     | <span class='unexecuted'>        ticks[upper].range = tickUpper;</span>
 204 |     | <span class='neutral'>        // try to clear tick if possible</span>
 205 |     | <span class='unexecuted'>        clear(ticks, constants, tickMap, upper);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>        if (tickAtPrice &gt;= lower &amp;&amp; tickAtPrice &lt; upper) {</span>
 208 |     | <span class='neutral'>            // write an oracle entry</span>
 209 |     | <span class='unexecuted'>            (state.pool.samples.index, state.pool.samples.length) = Samples.save(</span>
 210 |     | <span class='unexecuted'>                samples,</span>
 211 |     | <span class='unexecuted'>                state.pool.samples,</span>
 212 |     | <span class='unexecuted'>                state.pool.liquidity,</span>
 213 |     | <span class='unexecuted'>                tickAtPrice</span>
 214 |     | <span class='neutral'>            );</span>
 215 |     | <span class='unexecuted'>            state.pool.liquidity -= amount;  </span>
 216 |     | <span class='neutral'>        }</span>
 217 |     | <span class='unexecuted'>        state.liquidityGlobal -= amount;</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        return state;</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='unexecuted'>    function clear(</span>
 223 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 224 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 225 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
 226 |     | <span class='neutral'>        int24 tickToClear</span>
 227 |     | <span class='neutral'>    ) internal {</span>
 228 |     | <span class='unexecuted'>        if (_empty(ticks[tickToClear])) {</span>
 229 |     | <span class='unexecuted'>            if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &amp;&amp;</span>
 230 |     | <span class='unexecuted'>                    tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {</span>
 231 |     | <span class='unexecuted'>                ticks[tickToClear].range = PoolsharkStructs.RangeTick(0,0,0,0,0,0);</span>
 232 |     | <span class='unexecuted'>                TickMap.unset(tickMap, tickToClear, constants.tickSpacing);</span>
 233 |     | <span class='neutral'>            }</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>    function _empty(</span>
 238 |     | <span class='neutral'>        LimitPoolStructs.Tick memory tick</span>
 239 |     | <span class='neutral'>    ) internal pure returns (</span>
 240 |     | <span class='unexecuted'>        bool</span>
 241 |     | <span class='neutral'>    ) {</span>
 242 |     | <span class='unexecuted'>        if (tick.range.liquidityAbsolute != 0) {</span>
 243 |     | <span class='unexecuted'>            return false;</span>
 244 |     | <span class='neutral'>        }</span>
 245 |     | <span class='unexecuted'>        return true;</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'>}</span>
 248 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/range/math/FeeMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../Samples.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../utils/SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'>import &quot;../../math/OverflowMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import &#39;../../../interfaces/structs/PoolsharkStructs.sol&#39;;</span>
   8 |     | <span class='neutral'>import &quot;../../../interfaces/structs/RangePoolStructs.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @notice Math library that facilitates fee handling.</span>
  11 |     | <span class='unexecuted'>library FeeMath {</span>
  12 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    uint256 internal constant FEE_DELTA_CONST = 0;</span>
  15 |     | <span class='neutral'>    //TODO: change FEE_DELTA_CONST before launch</span>
  16 |     | <span class='neutral'>    // uint256 internal constant FEE_DELTA_CONST = 5000;</span>
  17 |     | <span class='unexecuted'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>    struct CalculateLocals {</span>
  20 |     | <span class='neutral'>        uint256 price;</span>
  21 |     | <span class='neutral'>        uint256 minPrice;</span>
  22 |     | <span class='neutral'>        uint256 lastPrice;</span>
  23 |     | <span class='neutral'>        uint256 swapFee;</span>
  24 |     | <span class='neutral'>        uint256 feeAmount;</span>
  25 |     | <span class='neutral'>        uint256 protocolFee;</span>
  26 |     | <span class='neutral'>        uint256 protocolFeesAccrued;</span>
  27 |     | <span class='neutral'>        uint256 amountRange;</span>
  28 |     | <span class='neutral'>        bool feeDirection;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    function calculate(</span>
  32 |     | <span class='neutral'>        PoolsharkStructs.SwapCache memory cache,</span>
  33 |     | <span class='neutral'>        uint256 amountIn,</span>
  34 |     | <span class='neutral'>        uint256 amountOut,</span>
  35 |     | <span class='neutral'>        bool zeroForOne</span>
  36 |     | <span class='neutral'>    ) internal pure returns (</span>
  37 |     | <span class='unexecuted'>        PoolsharkStructs.SwapCache memory</span>
  38 |     | <span class='neutral'>    )</span>
  39 |     | <span class='neutral'>    {</span>
  40 |     | <span class='unexecuted'>        CalculateLocals memory locals;</span>
  41 |     | <span class='unexecuted'>        if (cache.state.pool.liquidity != 0) {</span>
  42 |     | <span class='neutral'>            // calculate dynamic fee</span>
  43 |     | <span class='unexecuted'>            {</span>
  44 |     | <span class='unexecuted'>                locals.minPrice = ConstantProduct.getPrice(cache.constants.bounds.min);</span>
  45 |     | <span class='neutral'>                // square prices to take delta</span>
  46 |     | <span class='unexecuted'>                locals.price = ConstantProduct.getPrice(cache.price);</span>
  47 |     | <span class='unexecuted'>                locals.lastPrice = ConstantProduct.getPrice(cache.averagePrice);</span>
  48 |     | <span class='unexecuted'>                if (locals.price &lt; locals.minPrice)</span>
  49 |     | <span class='unexecuted'>                    locals.price = locals.minPrice;</span>
  50 |     | <span class='unexecuted'>                if (locals.lastPrice &lt; locals.minPrice)</span>
  51 |     | <span class='unexecuted'>                    locals.lastPrice = locals.minPrice;</span>
  52 |     | <span class='neutral'>                // delta is % modifier on the swapFee</span>
  53 |     | <span class='unexecuted'>                uint256 delta = OverflowMath.mulDiv(</span>
  54 |     | <span class='unexecuted'>                        FEE_DELTA_CONST / uint16(cache.constants.tickSpacing), // higher FEE_DELTA_CONST means</span>
  55 |     | <span class='unexecuted'>                        (                                                      // more aggressive dynamic fee</span>
  56 |     | <span class='unexecuted'>                            locals.price &gt; locals.lastPrice</span>
  57 |     | <span class='unexecuted'>                                ? locals.price - locals.lastPrice</span>
  58 |     | <span class='unexecuted'>                                : locals.lastPrice - locals.price</span>
  59 |     | <span class='unexecuted'>                        ) * 1_000_000,</span>
  60 |     | <span class='unexecuted'>                        locals.lastPrice </span>
  61 |     | <span class='neutral'>                );</span>
  62 |     | <span class='neutral'>                // max fee increase at 5x</span>
  63 |     | <span class='unexecuted'>                if (delta &gt; 4_000_000) delta = 4_000_000;</span>
  64 |     | <span class='neutral'>                // true means increased fee for zeroForOne = true</span>
  65 |     | <span class='unexecuted'>                locals.feeDirection = locals.price &lt; locals.lastPrice;</span>
  66 |     | <span class='neutral'>                // adjust fee based on direction</span>
  67 |     | <span class='unexecuted'>                if (zeroForOne == locals.feeDirection) {</span>
  68 |     | <span class='neutral'>                    // if swapping away from twap price, increase fee</span>
  69 |     | <span class='unexecuted'>                    locals.swapFee = cache.constants.swapFee + OverflowMath.mulDiv(delta,cache.constants.swapFee, 1e6);</span>
  70 |     | <span class='unexecuted'>                } else if (delta &lt; 1e6) {</span>
  71 |     | <span class='neutral'>                    // if swapping towards twap price, decrease fee</span>
  72 |     | <span class='unexecuted'>                    locals.swapFee = cache.constants.swapFee - OverflowMath.mulDiv(delta,cache.constants.swapFee, 1e6);</span>
  73 |     | <span class='neutral'>                } else {</span>
  74 |     | <span class='neutral'>                    // if swapping towards twap price and delta &gt; 100%, set fee to zero</span>
  75 |     | <span class='unexecuted'>                    locals.swapFee = 0;</span>
  76 |     | <span class='neutral'>                }</span>
  77 |     | <span class='neutral'>                // console.log(&#39;price movement&#39;, locals.lastPrice, locals.price);</span>
  78 |     | <span class='neutral'>                // console.log(&#39;swap fee adjustment&#39;,cache.constants.swapFee + delta * cache.constants.swapFee / 1e6);</span>
  79 |     | <span class='neutral'>            }</span>
  80 |     | <span class='unexecuted'>            if (cache.exactIn) {</span>
  81 |     | <span class='neutral'>                // calculate output from range liquidity</span>
  82 |     | <span class='unexecuted'>                locals.amountRange = OverflowMath.mulDiv(amountOut, cache.state.pool.liquidity, cache.liquidity);</span>
  83 |     | <span class='neutral'>                // take enough fees to cover fee growth</span>
  84 |     | <span class='unexecuted'>                locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountRange, locals.swapFee, 1e6);</span>
  85 |     | <span class='unexecuted'>                amountOut -= locals.feeAmount;</span>
  86 |     | <span class='neutral'>            } else {</span>
  87 |     | <span class='neutral'>                // calculate input from range liquidity</span>
  88 |     | <span class='unexecuted'>                locals.amountRange = OverflowMath.mulDiv(amountIn, cache.state.pool.liquidity, cache.liquidity);</span>
  89 |     | <span class='neutral'>                // take enough fees to cover fee growth</span>
  90 |     | <span class='unexecuted'>                locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountRange, locals.swapFee, 1e6);</span>
  91 |     | <span class='unexecuted'>                amountIn += locals.feeAmount;</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'>            // add to total fees paid for swap</span>
  94 |     | <span class='unexecuted'>            cache.feeAmount += locals.feeAmount.toUint128();</span>
  95 |     | <span class='neutral'>            // load protocol fee from cache</span>
  96 |     | <span class='neutral'>            // zeroForOne &amp;&amp; exactIn   = fee on token1</span>
  97 |     | <span class='neutral'>            // zeroForOne &amp;&amp; !exactIn  = fee on token0</span>
  98 |     | <span class='neutral'>            // !zeroForOne &amp;&amp; !exactIn = fee on token1</span>
  99 |     | <span class='neutral'>            // !zeroForOne &amp;&amp; exactIn  = fee on token0</span>
 100 |     | <span class='unexecuted'>            locals.protocolFee = (zeroForOne == cache.exactIn) ? cache.state.pool.protocolSwapFee1 </span>
 101 |     | <span class='unexecuted'>                                                               : cache.state.pool.protocolSwapFee0;</span>
 102 |     | <span class='neutral'>            // calculate fee</span>
 103 |     | <span class='unexecuted'>            locals.protocolFeesAccrued = OverflowMath.mulDiv(locals.feeAmount, locals.protocolFee, 1e4);</span>
 104 |     | <span class='neutral'>            // fees for this swap step</span>
 105 |     | <span class='unexecuted'>            locals.feeAmount -= locals.protocolFeesAccrued;</span>
 106 |     | <span class='neutral'>            // save fee growth and protocol fees</span>
 107 |     | <span class='unexecuted'>            if (zeroForOne == cache.exactIn) {</span>
 108 |     | <span class='unexecuted'>                cache.state.pool0.protocolFees += uint128(locals.protocolFeesAccrued);</span>
 109 |     | <span class='unexecuted'>                cache.state.pool.feeGrowthGlobal1 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));</span>
 110 |     | <span class='neutral'>            } else {</span>
 111 |     | <span class='unexecuted'>                cache.state.pool1.protocolFees += uint128(locals.protocolFeesAccrued);</span>
 112 |     | <span class='unexecuted'>                cache.state.pool.feeGrowthGlobal0 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));</span>
 113 |     | <span class='neutral'>            }</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='unexecuted'>        cache.input  += amountIn;</span>
 116 |     | <span class='unexecuted'>        cache.output += amountOut;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        return cache;</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/range/pool/BurnRangeCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../RangePositions.sol&#39;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>library BurnRangeCall {</span>
  10 |     | <span class='neutral'>    using SafeCast for int128;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    event BurnRange(</span>
  13 |     | <span class='neutral'>        address indexed recipient,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
  17 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  18 |     | <span class='neutral'>        uint128 amount0,</span>
  19 |     | <span class='neutral'>        uint128 amount1</span>
  20 |     | <span class='neutral'>    );</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    function perform(</span>
  23 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
  24 |     | <span class='neutral'>            storage positions,</span>
  25 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  26 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  27 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  28 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  29 |     | <span class='neutral'>        RangePoolStructs.BurnRangeCache memory cache,</span>
  30 |     | <span class='neutral'>        RangePoolStructs.BurnRangeParams memory params</span>
  31 |     | <span class='neutral'>    ) internal {</span>
  32 |     | <span class='neutral'>        // check for invalid receiver</span>
  33 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  34 |     | <span class='unexecuted'>            require(false, &#39;CollectToZeroAddress()&#39;);</span>
  35 |     | <span class='neutral'>        </span>
  36 |     | <span class='neutral'>        // initialize cache</span>
  37 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  38 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>        // check positionId owner</span>
  41 |     | <span class='unexecuted'>        if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  42 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  43 |     | <span class='unexecuted'>        if (params.burnPercent &gt; 1e38) params.burnPercent = 1e38;</span>
  44 |     | <span class='unexecuted'>        ( </span>
  45 |     | <span class='unexecuted'>            cache.position,</span>
  46 |     | <span class='unexecuted'>            cache.amount0,</span>
  47 |     | <span class='unexecuted'>            cache.amount1</span>
  48 |     | <span class='unexecuted'>        ) = RangePositions.update(</span>
  49 |     | <span class='unexecuted'>                ticks,</span>
  50 |     | <span class='unexecuted'>                cache.position,</span>
  51 |     | <span class='unexecuted'>                cache.state,</span>
  52 |     | <span class='unexecuted'>                cache.constants,</span>
  53 |     | <span class='unexecuted'>                RangePoolStructs.UpdateParams(</span>
  54 |     | <span class='unexecuted'>                    cache.position.lower,</span>
  55 |     | <span class='unexecuted'>                    cache.position.upper,</span>
  56 |     | <span class='unexecuted'>                    params.positionId,</span>
  57 |     | <span class='unexecuted'>                    params.burnPercent</span>
  58 |     | <span class='neutral'>                )</span>
  59 |     | <span class='neutral'>        );</span>
  60 |     | <span class='unexecuted'>        cache = RangePositions.remove(</span>
  61 |     | <span class='unexecuted'>            ticks,</span>
  62 |     | <span class='unexecuted'>            samples,</span>
  63 |     | <span class='unexecuted'>            tickMap,</span>
  64 |     | <span class='unexecuted'>            params,</span>
  65 |     | <span class='unexecuted'>            cache</span>
  66 |     | <span class='neutral'>        );</span>
  67 |     | <span class='neutral'>        // only compound if burnPercent is zero</span>
  68 |     | <span class='unexecuted'>        if (params.burnPercent == 0)</span>
  69 |     | <span class='unexecuted'>            if (cache.amount0 &gt; 0 || cache.amount1 &gt; 0) {</span>
  70 |     | <span class='unexecuted'>                (</span>
  71 |     | <span class='unexecuted'>                    cache.position,</span>
  72 |     | <span class='unexecuted'>                    cache.state,</span>
  73 |     | <span class='unexecuted'>                    cache.amount0,</span>
  74 |     | <span class='unexecuted'>                    cache.amount1</span>
  75 |     | <span class='unexecuted'>                ) = RangePositions.compound(</span>
  76 |     | <span class='unexecuted'>                    ticks,</span>
  77 |     | <span class='unexecuted'>                    tickMap,</span>
  78 |     | <span class='unexecuted'>                    samples,</span>
  79 |     | <span class='unexecuted'>                    cache.state,</span>
  80 |     | <span class='unexecuted'>                    cache.constants,</span>
  81 |     | <span class='unexecuted'>                    cache.position,</span>
  82 |     | <span class='unexecuted'>                    RangePoolStructs.CompoundRangeParams(</span>
  83 |     | <span class='unexecuted'>                        cache.priceLower,</span>
  84 |     | <span class='unexecuted'>                        cache.priceUpper,</span>
  85 |     | <span class='unexecuted'>                        cache.amount0.toUint128(),</span>
  86 |     | <span class='unexecuted'>                        cache.amount1.toUint128(),</span>
  87 |     | <span class='unexecuted'>                        params.positionId</span>
  88 |     | <span class='neutral'>                    )</span>
  89 |     | <span class='neutral'>                );</span>
  90 |     | <span class='neutral'>            }</span>
  91 |     | <span class='neutral'>        // save changes to storage</span>
  92 |     | <span class='unexecuted'>        save(positions, globalState, cache, params.positionId);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // transfer amounts to user</span>
  95 |     | <span class='unexecuted'>        if (cache.amount0 &gt; 0 || cache.amount1 &gt; 0)</span>
  96 |     | <span class='unexecuted'>            Collect.range(</span>
  97 |     | <span class='unexecuted'>                cache.constants,</span>
  98 |     | <span class='unexecuted'>                params.to,</span>
  99 |     | <span class='unexecuted'>                cache.amount0,</span>
 100 |     | <span class='unexecuted'>                cache.amount1</span>
 101 |     | <span class='neutral'>            );</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>    function save(</span>
 105 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 106 |     | <span class='neutral'>            storage positions,</span>
 107 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 108 |     | <span class='neutral'>        RangePoolStructs.BurnRangeCache memory cache,</span>
 109 |     | <span class='neutral'>        uint32 positionId</span>
 110 |     | <span class='neutral'>    ) internal {</span>
 111 |     | <span class='unexecuted'>        positions[positionId] = cache.position;</span>
 112 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
 113 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'>}</span>
 116 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/range/pool/MintRangeCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/RangePoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../utils/SafeTransfers.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../utils/PositionTokens.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../RangePositions.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library MintRangeCall {</span>
  11 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  12 |     | <span class='neutral'>    using SafeCast for int128;</span>
  13 |     | <span class='neutral'>    using SafeCast for uint128;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event MintRange(</span>
  16 |     | <span class='neutral'>        address indexed recipient,</span>
  17 |     | <span class='neutral'>        int24 lower,</span>
  18 |     | <span class='neutral'>        int24 upper,</span>
  19 |     | <span class='neutral'>        uint32 indexed positionId,</span>
  20 |     | <span class='neutral'>        uint128 liquidityMinted,</span>
  21 |     | <span class='neutral'>        int128 amount0Delta,</span>
  22 |     | <span class='neutral'>        int128 amount1Delta</span>
  23 |     | <span class='neutral'>    );</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function perform(</span>
  26 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
  27 |     | <span class='neutral'>            storage positions,</span>
  28 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
  29 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  30 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  31 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  32 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache,</span>
  33 |     | <span class='neutral'>        RangePoolStructs.MintRangeParams memory params</span>
  34 |     | <span class='neutral'>    ) internal {</span>
  35 |     | <span class='neutral'>        // initialize cache</span>
  36 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>        // id of 0 can be passed to create new position</span>
  39 |     | <span class='unexecuted'>        if (params.positionId &gt; 0) {</span>
  40 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
  41 |     | <span class='neutral'>            // existing position</span>
  42 |     | <span class='unexecuted'>            if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  43 |     | <span class='neutral'>                // check for balance held</span>
  44 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
  45 |     | <span class='neutral'>            // set bounds as defined by position</span>
  46 |     | <span class='unexecuted'>            params.lower = cache.position.lower;</span>
  47 |     | <span class='unexecuted'>            params.upper = cache.position.upper;</span>
  48 |     | <span class='neutral'>            // update existing position</span>
  49 |     | <span class='unexecuted'>            (</span>
  50 |     | <span class='unexecuted'>                cache.position,</span>
  51 |     | <span class='unexecuted'>                cache.amount0,</span>
  52 |     | <span class='unexecuted'>                cache.amount1</span>
  53 |     | <span class='unexecuted'>            ) = RangePositions.update(</span>
  54 |     | <span class='unexecuted'>                    ticks,</span>
  55 |     | <span class='unexecuted'>                    cache.position,</span>
  56 |     | <span class='unexecuted'>                    cache.state,</span>
  57 |     | <span class='unexecuted'>                    cache.constants,</span>
  58 |     | <span class='unexecuted'>                    RangePoolStructs.UpdateParams(</span>
  59 |     | <span class='unexecuted'>                        params.lower,</span>
  60 |     | <span class='unexecuted'>                        params.upper,</span>
  61 |     | <span class='unexecuted'>                        params.positionId,</span>
  62 |     | <span class='unexecuted'>                        0</span>
  63 |     | <span class='neutral'>                    )</span>
  64 |     | <span class='neutral'>            );</span>
  65 |     | <span class='neutral'>        } else {</span>
  66 |     | <span class='neutral'>            // create a new position</span>
  67 |     | <span class='unexecuted'>            params.positionId = cache.state.positionIdNext;</span>
  68 |     | <span class='neutral'>            // increment for next position</span>
  69 |     | <span class='unexecuted'>            cache.state.positionIdNext += 1;</span>
  70 |     | <span class='neutral'>            // set tick bounds on position</span>
  71 |     | <span class='unexecuted'>            cache.position.lower = params.lower;</span>
  72 |     | <span class='unexecuted'>            cache.position.upper = params.upper;</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>        // set cache based on bounds</span>
  75 |     | <span class='unexecuted'>        cache.priceLower = ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants);</span>
  76 |     | <span class='unexecuted'>        cache.priceUpper = ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>        // compound and transfer remaining back to user</span>
  79 |     | <span class='unexecuted'>        if (cache.amount0 &gt; 0 || cache.amount1 &gt; 0) {</span>
  80 |     | <span class='unexecuted'>            (</span>
  81 |     | <span class='unexecuted'>                cache.position,</span>
  82 |     | <span class='unexecuted'>                cache.state,</span>
  83 |     | <span class='unexecuted'>                cache.amount0,</span>
  84 |     | <span class='unexecuted'>                cache.amount1</span>
  85 |     | <span class='unexecuted'>            ) = RangePositions.compound(</span>
  86 |     | <span class='unexecuted'>                ticks,</span>
  87 |     | <span class='unexecuted'>                tickMap,</span>
  88 |     | <span class='unexecuted'>                samples,</span>
  89 |     | <span class='unexecuted'>                cache.state,</span>
  90 |     | <span class='unexecuted'>                cache.constants,</span>
  91 |     | <span class='unexecuted'>                cache.position,</span>
  92 |     | <span class='unexecuted'>                RangePoolStructs.CompoundRangeParams( </span>
  93 |     | <span class='unexecuted'>                    cache.priceLower,</span>
  94 |     | <span class='unexecuted'>                    cache.priceUpper,</span>
  95 |     | <span class='unexecuted'>                    cache.amount0.toUint128(),</span>
  96 |     | <span class='unexecuted'>                    cache.amount1.toUint128(),</span>
  97 |     | <span class='unexecuted'>                    params.positionId</span>
  98 |     | <span class='neutral'>                )</span>
  99 |     | <span class='neutral'>            );</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>        // validate input amounts</span>
 102 |     | <span class='unexecuted'>        (params, cache) = RangePositions.validate(params, cache);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        // save changes to storage before transfer in</span>
 105 |     | <span class='unexecuted'>        save(positions, globalState, cache, params.positionId);</span>
 106 |     | <span class='unexecuted'>        cache.amount0 -= params.amount0.toInt128();</span>
 107 |     | <span class='unexecuted'>        cache.amount1 -= params.amount1.toInt128();</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        emit MintRange(</span>
 110 |     | <span class='unexecuted'>            params.to,</span>
 111 |     | <span class='unexecuted'>            cache.position.lower,</span>
 112 |     | <span class='unexecuted'>            cache.position.upper,</span>
 113 |     | <span class='unexecuted'>            params.positionId,</span>
 114 |     | <span class='unexecuted'>            cache.liquidityMinted.toUint128(),</span>
 115 |     | <span class='unexecuted'>            -cache.amount0, /// @dev - emit balance delta from pool POV</span>
 116 |     | <span class='unexecuted'>            -cache.amount1</span>
 117 |     | <span class='neutral'>        );</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>        // transfer in amounts</span>
 120 |     | <span class='unexecuted'>        if (cache.amount0 &lt; 0) {</span>
 121 |     | <span class='unexecuted'>            SafeTransfers.transferIn(cache.constants.token0, (-cache.amount0).toUint128());</span>
 122 |     | <span class='unexecuted'>            cache.amount0 = 0;</span>
 123 |     | <span class='neutral'>        } </span>
 124 |     | <span class='unexecuted'>        if (cache.amount1 &lt; 0) {</span>
 125 |     | <span class='unexecuted'>            SafeTransfers.transferIn(cache.constants.token1, (-cache.amount1).toUint128());</span>
 126 |     | <span class='unexecuted'>            cache.amount1 = 0;</span>
 127 |     | <span class='neutral'>        }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>        // update position with latest fees accrued</span>
 130 |     | <span class='unexecuted'>        cache = RangePositions.add(</span>
 131 |     | <span class='unexecuted'>            ticks,</span>
 132 |     | <span class='unexecuted'>            samples,</span>
 133 |     | <span class='unexecuted'>            tickMap,</span>
 134 |     | <span class='unexecuted'>            cache,</span>
 135 |     | <span class='unexecuted'>            params</span>
 136 |     | <span class='neutral'>        );</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // save changes to storage before transfer out</span>
 139 |     | <span class='unexecuted'>        save(positions, globalState, cache, params.positionId);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>        // transfer positive amounts back to user</span>
 142 |     | <span class='unexecuted'>        if (cache.amount0 &gt; 0 || cache.amount1 &gt; 0)</span>
 143 |     | <span class='unexecuted'>            Collect.range(</span>
 144 |     | <span class='unexecuted'>                cache.constants,</span>
 145 |     | <span class='unexecuted'>                params.to,</span>
 146 |     | <span class='unexecuted'>                cache.amount0,</span>
 147 |     | <span class='unexecuted'>                cache.amount1</span>
 148 |     | <span class='neutral'>            );</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>    function save(</span>
 152 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 153 |     | <span class='neutral'>            storage positions,</span>
 154 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
 155 |     | <span class='neutral'>        RangePoolStructs.MintRangeCache memory cache,</span>
 156 |     | <span class='neutral'>        uint32 positionId</span>
 157 |     | <span class='neutral'>    ) internal {</span>
 158 |     | <span class='unexecuted'>        positions[positionId] = cache.position;</span>
 159 |     | <span class='unexecuted'>        globalState.pool = cache.state.pool;</span>
 160 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
 161 |     | <span class='unexecuted'>        globalState.positionIdNext = cache.state.positionIdNext;</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'>}</span>
 164 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/range/pool/SnapshotRangeCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../RangePositions.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../../utils/Collect.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library SnapshotRangeCall {</span>
  9 |     | <span class='unexecuted'>    uint8 private constant _ENTERED = 2;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    event Burn(</span>
 12 |     | <span class='neutral'>        address indexed recipient,</span>
 13 |     | <span class='neutral'>        int24 lower,</span>
 14 |     | <span class='neutral'>        int24 upper,</span>
 15 |     | <span class='neutral'>        uint256 indexed tokenId,</span>
 16 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
 17 |     | <span class='neutral'>        uint128 amount0,</span>
 18 |     | <span class='neutral'>        uint128 amount1</span>
 19 |     | <span class='neutral'>    );</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>    function perform(</span>
 22 |     | <span class='neutral'>        mapping(uint256 =&gt; RangePoolStructs.RangePosition)</span>
 23 |     | <span class='neutral'>            storage positions,</span>
 24 |     | <span class='neutral'>        mapping(int24 =&gt; PoolsharkStructs.Tick) storage ticks,</span>
 25 |     | <span class='neutral'>        PoolsharkStructs.GlobalState memory state,</span>
 26 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 27 |     | <span class='neutral'>        uint32 positionId</span>
 28 |     | <span class='neutral'>    ) internal view returns (</span>
 29 |     | <span class='unexecuted'>        int56,</span>
 30 |     | <span class='unexecuted'>        uint160,</span>
 31 |     | <span class='unexecuted'>        uint128,</span>
 32 |     | <span class='unexecuted'>        uint128</span>
 33 |     | <span class='neutral'>    )</span>
 34 |     | <span class='neutral'>    {</span>
 35 |     | <span class='unexecuted'>        if (state.unlocked == _ENTERED)</span>
 36 |     | <span class='unexecuted'>            require(false, &#39;ReentrancyGuardReadOnlyReentrantCall()&#39;);</span>
 37 |     | <span class='unexecuted'>        return RangePositions.snapshot(</span>
 38 |     | <span class='unexecuted'>            positions,</span>
 39 |     | <span class='unexecuted'>            ticks,</span>
 40 |     | <span class='unexecuted'>            state,</span>
 41 |     | <span class='unexecuted'>            constants,</span>
 42 |     | <span class='unexecuted'>            positionId</span>
 43 |     | <span class='neutral'>        );</span>
 44 |     | <span class='neutral'>    }</span>
 45 |     | <span class='neutral'>}</span>
 46 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/solady/Clone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Class with helper read functions for clone with immutable args.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)</span>
   6 |     | <span class='neutral'>/// @author Adapted from clones with immutable args by zefram.eth, Saw-mon &amp; Natalie</span>
   7 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   8 |     | <span class='neutral'>abstract contract Clone {</span>
   9 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes.</span>
  10 |     | <span class='neutral'>    function _getArgBytes(uint256 argOffset, uint256 length)</span>
  11 |     | <span class='neutral'>        internal</span>
  12 |     | <span class='neutral'>        pure</span>
  13 |     | <span class='neutral'>        returns (bytes memory arg)</span>
  14 |     | <span class='neutral'>    {</span>
  15 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  16 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  17 |     | <span class='neutral'>        assembly {</span>
  18 |     | <span class='neutral'>            arg := mload(0x40)</span>
  19 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  20 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), length)</span>
  21 |     | <span class='neutral'>            let o := add(add(arg, 0x20), length)</span>
  22 |     | <span class='neutral'>            mstore(o, 0) // Zeroize the slot after the bytes.</span>
  23 |     | <span class='neutral'>            mstore(0x40, add(o, 0x20)) // Allocate the memory.</span>
  24 |     | <span class='neutral'>        }</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type address.</span>
  28 |     | <span class='unexecuted'>    function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {</span>
  29 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
  30 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  31 |     | <span class='unexecuted'>        assembly {</span>
  32 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
  33 |     | <span class='neutral'>        }</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev Reads a uint256 array stored in the immutable args.</span>
  37 |     | <span class='neutral'>    function _getArgUint256Array(uint256 argOffset, uint256 length)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='neutral'>        pure</span>
  40 |     | <span class='neutral'>        returns (uint256[] memory arg)</span>
  41 |     | <span class='neutral'>    {</span>
  42 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  43 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  44 |     | <span class='neutral'>        assembly {</span>
  45 |     | <span class='neutral'>            arg := mload(0x40)</span>
  46 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  47 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  48 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @dev Reads a bytes32 array stored in the immutable args.</span>
  53 |     | <span class='neutral'>    function _getArgBytes32Array(uint256 argOffset, uint256 length)</span>
  54 |     | <span class='neutral'>        internal</span>
  55 |     | <span class='neutral'>        pure</span>
  56 |     | <span class='neutral'>        returns (bytes32[] memory arg)</span>
  57 |     | <span class='neutral'>    {</span>
  58 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  59 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  60 |     | <span class='neutral'>        assembly {</span>
  61 |     | <span class='neutral'>            arg := mload(0x40)</span>
  62 |     | <span class='neutral'>            mstore(arg, length) // Store the length.</span>
  63 |     | <span class='neutral'>            calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))</span>
  64 |     | <span class='neutral'>            mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.</span>
  65 |     | <span class='neutral'>        }</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type bytes32.</span>
  69 |     | <span class='neutral'>    function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {</span>
  70 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  71 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint256.</span>
  78 |     | <span class='neutral'>    function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {</span>
  79 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  80 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='neutral'>            arg := calldataload(add(offset, argOffset))</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint248.</span>
  87 |     | <span class='neutral'>    function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {</span>
  88 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  89 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  90 |     | <span class='neutral'>        assembly {</span>
  91 |     | <span class='neutral'>            arg := shr(8, calldataload(add(offset, argOffset)))</span>
  92 |     | <span class='neutral'>        }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint240.</span>
  96 |     | <span class='neutral'>    function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {</span>
  97 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
  98 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 |     | <span class='neutral'>            arg := shr(16, calldataload(add(offset, argOffset)))</span>
 101 |     | <span class='neutral'>        }</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint232.</span>
 105 |     | <span class='neutral'>    function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {</span>
 106 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 107 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 108 |     | <span class='neutral'>        assembly {</span>
 109 |     | <span class='neutral'>            arg := shr(24, calldataload(add(offset, argOffset)))</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'>    }</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint224.</span>
 114 |     | <span class='neutral'>    function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {</span>
 115 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 116 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 117 |     | <span class='neutral'>        assembly {</span>
 118 |     | <span class='neutral'>            arg := shr(0x20, calldataload(add(offset, argOffset)))</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint216.</span>
 123 |     | <span class='neutral'>    function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {</span>
 124 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 125 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='neutral'>            arg := shr(40, calldataload(add(offset, argOffset)))</span>
 128 |     | <span class='neutral'>        }</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint208.</span>
 132 |     | <span class='neutral'>    function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {</span>
 133 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 134 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 135 |     | <span class='neutral'>        assembly {</span>
 136 |     | <span class='neutral'>            arg := shr(48, calldataload(add(offset, argOffset)))</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint200.</span>
 141 |     | <span class='neutral'>    function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {</span>
 142 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 143 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 |     | <span class='neutral'>            arg := shr(56, calldataload(add(offset, argOffset)))</span>
 146 |     | <span class='neutral'>        }</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint192.</span>
 150 |     | <span class='neutral'>    function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {</span>
 151 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 152 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 153 |     | <span class='neutral'>        assembly {</span>
 154 |     | <span class='neutral'>            arg := shr(64, calldataload(add(offset, argOffset)))</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint184.</span>
 159 |     | <span class='neutral'>    function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {</span>
 160 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 161 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='neutral'>            arg := shr(72, calldataload(add(offset, argOffset)))</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint176.</span>
 168 |     | <span class='neutral'>    function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {</span>
 169 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 170 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 171 |     | <span class='neutral'>        assembly {</span>
 172 |     | <span class='neutral'>            arg := shr(80, calldataload(add(offset, argOffset)))</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint168.</span>
 177 |     | <span class='neutral'>    function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {</span>
 178 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 179 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='neutral'>            arg := shr(88, calldataload(add(offset, argOffset)))</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint160.</span>
 186 |     | <span class='unexecuted'>    function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {</span>
 187 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 188 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 189 |     | <span class='unexecuted'>        assembly {</span>
 190 |     | <span class='unexecuted'>            arg := shr(96, calldataload(add(offset, argOffset)))</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint152.</span>
 195 |     | <span class='neutral'>    function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {</span>
 196 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 197 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 198 |     | <span class='neutral'>        assembly {</span>
 199 |     | <span class='neutral'>            arg := shr(104, calldataload(add(offset, argOffset)))</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint144.</span>
 204 |     | <span class='neutral'>    function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {</span>
 205 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 206 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 207 |     | <span class='neutral'>        assembly {</span>
 208 |     | <span class='neutral'>            arg := shr(112, calldataload(add(offset, argOffset)))</span>
 209 |     | <span class='neutral'>        }</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint136.</span>
 213 |     | <span class='neutral'>    function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {</span>
 214 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 215 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 216 |     | <span class='neutral'>        assembly {</span>
 217 |     | <span class='neutral'>            arg := shr(120, calldataload(add(offset, argOffset)))</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint128.</span>
 222 |     | <span class='neutral'>    function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {</span>
 223 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 224 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='neutral'>            arg := shr(128, calldataload(add(offset, argOffset)))</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint120.</span>
 231 |     | <span class='neutral'>    function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {</span>
 232 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 233 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 234 |     | <span class='neutral'>        assembly {</span>
 235 |     | <span class='neutral'>            arg := shr(136, calldataload(add(offset, argOffset)))</span>
 236 |     | <span class='neutral'>        }</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint112.</span>
 240 |     | <span class='neutral'>    function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {</span>
 241 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 242 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 243 |     | <span class='neutral'>        assembly {</span>
 244 |     | <span class='neutral'>            arg := shr(144, calldataload(add(offset, argOffset)))</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint104.</span>
 249 |     | <span class='neutral'>    function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {</span>
 250 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 251 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 252 |     | <span class='neutral'>        assembly {</span>
 253 |     | <span class='neutral'>            arg := shr(152, calldataload(add(offset, argOffset)))</span>
 254 |     | <span class='neutral'>        }</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='neutral'></span>
 257 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint96.</span>
 258 |     | <span class='neutral'>    function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {</span>
 259 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 261 |     | <span class='neutral'>        assembly {</span>
 262 |     | <span class='neutral'>            arg := shr(160, calldataload(add(offset, argOffset)))</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint88.</span>
 267 |     | <span class='neutral'>    function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {</span>
 268 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 269 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 270 |     | <span class='neutral'>        assembly {</span>
 271 |     | <span class='neutral'>            arg := shr(168, calldataload(add(offset, argOffset)))</span>
 272 |     | <span class='neutral'>        }</span>
 273 |     | <span class='neutral'>    }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint80.</span>
 276 |     | <span class='neutral'>    function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {</span>
 277 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 278 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 279 |     | <span class='neutral'>        assembly {</span>
 280 |     | <span class='neutral'>            arg := shr(176, calldataload(add(offset, argOffset)))</span>
 281 |     | <span class='neutral'>        }</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint72.</span>
 285 |     | <span class='neutral'>    function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {</span>
 286 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 287 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 288 |     | <span class='neutral'>        assembly {</span>
 289 |     | <span class='neutral'>            arg := shr(184, calldataload(add(offset, argOffset)))</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint64.</span>
 294 |     | <span class='neutral'>    function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {</span>
 295 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 296 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>        assembly {</span>
 298 |     | <span class='neutral'>            arg := shr(192, calldataload(add(offset, argOffset)))</span>
 299 |     | <span class='neutral'>        }</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint56.</span>
 303 |     | <span class='neutral'>    function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {</span>
 304 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 305 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 306 |     | <span class='neutral'>        assembly {</span>
 307 |     | <span class='neutral'>            arg := shr(200, calldataload(add(offset, argOffset)))</span>
 308 |     | <span class='neutral'>        }</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint48.</span>
 312 |     | <span class='neutral'>    function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {</span>
 313 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 314 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 315 |     | <span class='neutral'>        assembly {</span>
 316 |     | <span class='neutral'>            arg := shr(208, calldataload(add(offset, argOffset)))</span>
 317 |     | <span class='neutral'>        }</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint40.</span>
 321 |     | <span class='neutral'>    function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {</span>
 322 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 323 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 324 |     | <span class='neutral'>        assembly {</span>
 325 |     | <span class='neutral'>            arg := shr(216, calldataload(add(offset, argOffset)))</span>
 326 |     | <span class='neutral'>        }</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint32.</span>
 330 |     | <span class='unexecuted'>    function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {</span>
 331 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 332 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 333 |     | <span class='unexecuted'>        assembly {</span>
 334 |     | <span class='unexecuted'>            arg := shr(224, calldataload(add(offset, argOffset)))</span>
 335 |     | <span class='neutral'>        }</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint24.</span>
 339 |     | <span class='neutral'>    function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {</span>
 340 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 341 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 342 |     | <span class='neutral'>        assembly {</span>
 343 |     | <span class='neutral'>            arg := shr(232, calldataload(add(offset, argOffset)))</span>
 344 |     | <span class='neutral'>        }</span>
 345 |     | <span class='neutral'>    }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint16.</span>
 348 |     | <span class='unexecuted'>    function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {</span>
 349 |     | <span class='unexecuted'>        uint256 offset = _getImmutableArgsOffset();</span>
 350 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 351 |     | <span class='unexecuted'>        assembly {</span>
 352 |     | <span class='unexecuted'>            arg := shr(240, calldataload(add(offset, argOffset)))</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    /// @dev Reads an immutable arg with type uint8.</span>
 357 |     | <span class='neutral'>    function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {</span>
 358 |     | <span class='neutral'>        uint256 offset = _getImmutableArgsOffset();</span>
 359 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 360 |     | <span class='neutral'>        assembly {</span>
 361 |     | <span class='neutral'>            arg := shr(248, calldataload(add(offset, argOffset)))</span>
 362 |     | <span class='neutral'>        }</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    /// @return offset The offset of the packed immutable args in calldata.</span>
 366 |     | <span class='unexecuted'>    function _getImmutableArgsOffset() internal pure returns (uint256 offset) {</span>
 367 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 368 |     | <span class='neutral'>        assembly {</span>
 369 |     | <span class='unexecuted'>            offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))</span>
 370 |     | <span class='neutral'>        }</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/solady/LibClone.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Minimal proxy library.</span>
   5 |     | <span class='neutral'>/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)</span>
   6 |     | <span class='neutral'>/// @author Minimal proxy by 0age (https://github.com/0age)</span>
   7 |     | <span class='neutral'>/// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon &amp; Natalie</span>
   8 |     | <span class='neutral'>/// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)</span>
   9 |     | <span class='neutral'>///</span>
  10 |     | <span class='neutral'>/// @dev Minimal proxy:</span>
  11 |     | <span class='neutral'>/// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,</span>
  12 |     | <span class='neutral'>/// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,</span>
  13 |     | <span class='neutral'>/// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.</span>
  14 |     | <span class='neutral'>///</span>
  15 |     | <span class='neutral'>/// @dev Clones with immutable args (CWIA):</span>
  16 |     | <span class='neutral'>/// The implementation of CWIA here implements a `receive()` method that emits the</span>
  17 |     | <span class='neutral'>/// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,</span>
  18 |     | <span class='neutral'>/// enabling us to accept hard gas-capped `sends` &amp; `transfers` for maximum backwards</span>
  19 |     | <span class='neutral'>/// composability. The minimal proxy implementation does not offer this feature.</span>
  20 |     | <span class='unexecuted'>library LibClone {</span>
  21 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  22 |     | <span class='neutral'>    /*                       CUSTOM ERRORS                        */</span>
  23 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @dev Unable to deploy the clone.</span>
  26 |     | <span class='neutral'>    error DeploymentFailed();</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    /// @dev The salt must start with either the zero address or the caller.</span>
  29 |     | <span class='neutral'>    error SaltDoesNotStartWithCaller();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
  32 |     | <span class='neutral'>    /*                  MINIMAL PROXY OPERATIONS                  */</span>
  33 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @dev Deploys a deterministic clone of `implementation`,</span>
  36 |     | <span class='neutral'>    /// using immutable  arguments encoded in `data`, with `salt`.</span>
  37 |     | <span class='unexecuted'>    function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)</span>
  38 |     | <span class='neutral'>        internal</span>
  39 |     | <span class='unexecuted'>        returns (address instance)</span>
  40 |     | <span class='neutral'>    {</span>
  41 |     | <span class='unexecuted'>        assembly {</span>
  42 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
  43 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
  44 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
  45 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
  46 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
  47 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
  48 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
  51 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
  54 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
  55 |     | <span class='neutral'>            // Write the address of the implementation.</span>
  56 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
  57 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
  58 |     | <span class='unexecuted'>            mstore(</span>
  59 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
  60 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
  61 |     | <span class='neutral'>            )</span>
  62 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
  63 |     | <span class='unexecuted'>            mstore(</span>
  64 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
  65 |     | <span class='neutral'>            )</span>
  66 |     | <span class='unexecuted'>            mstore(</span>
  67 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
  68 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
  69 |     | <span class='neutral'>            )</span>
  70 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>            // Create the instance.</span>
  73 |     | <span class='unexecuted'>            instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            // If `instance` is zero, revert.</span>
  76 |     | <span class='unexecuted'>            if iszero(instance) {</span>
  77 |     | <span class='neutral'>                // Store the function selector of `DeploymentFailed()`.</span>
  78 |     | <span class='unexecuted'>                mstore(0x00, 0x30116425)</span>
  79 |     | <span class='neutral'>                // Revert with (offset, size).</span>
  80 |     | <span class='unexecuted'>                revert(0x1c, 0x04)</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
  84 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
  85 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
  86 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
  87 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
  88 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
  89 |     | <span class='neutral'>        }</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @dev Returns the initialization code hash of the clone of `implementation`</span>
  93 |     | <span class='neutral'>    /// using immutable arguments encoded in `data`.</span>
  94 |     | <span class='neutral'>    /// Used for mining vanity addresses with create2crunch.</span>
  95 |     | <span class='unexecuted'>    function initCodeHash(address implementation, bytes memory data)</span>
  96 |     | <span class='neutral'>        internal</span>
  97 |     | <span class='neutral'>        pure</span>
  98 |     | <span class='unexecuted'>        returns (bytes32 hash)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='unexecuted'>        assembly {</span>
 101 |     | <span class='neutral'>            // Compute the boundaries of the data and cache the memory slots around it.</span>
 102 |     | <span class='unexecuted'>            let mBefore3 := mload(sub(data, 0x60))</span>
 103 |     | <span class='unexecuted'>            let mBefore2 := mload(sub(data, 0x40))</span>
 104 |     | <span class='unexecuted'>            let mBefore1 := mload(sub(data, 0x20))</span>
 105 |     | <span class='unexecuted'>            let dataLength := mload(data)</span>
 106 |     | <span class='unexecuted'>            let dataEnd := add(add(data, 0x20), dataLength)</span>
 107 |     | <span class='unexecuted'>            let mAfter1 := mload(dataEnd)</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>            // +2 bytes for telling how much data there is appended to the call.</span>
 110 |     | <span class='unexecuted'>            let extraLength := add(dataLength, 2)</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>            // Write the bytecode before the data.</span>
 113 |     | <span class='unexecuted'>            mstore(data, 0x5af43d3d93803e606057fd5bf3)</span>
 114 |     | <span class='neutral'>            // Write the address of the implementation.</span>
 115 |     | <span class='unexecuted'>            mstore(sub(data, 0x0d), implementation)</span>
 116 |     | <span class='neutral'>            // Write the rest of the bytecode.</span>
 117 |     | <span class='unexecuted'>            mstore(</span>
 118 |     | <span class='unexecuted'>                sub(data, 0x21),</span>
 119 |     | <span class='unexecuted'>                or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)</span>
 120 |     | <span class='neutral'>            )</span>
 121 |     | <span class='neutral'>            // `keccak256(&quot;ReceiveETH(uint256)&quot;)`</span>
 122 |     | <span class='unexecuted'>            mstore(</span>
 123 |     | <span class='unexecuted'>                sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff</span>
 124 |     | <span class='neutral'>            )</span>
 125 |     | <span class='unexecuted'>            mstore(</span>
 126 |     | <span class='unexecuted'>                sub(data, 0x5a),</span>
 127 |     | <span class='unexecuted'>                or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)</span>
 128 |     | <span class='neutral'>            )</span>
 129 |     | <span class='unexecuted'>            mstore(dataEnd, shl(0xf0, extraLength))</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 132 |     | <span class='unexecuted'>            hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>            // Restore the overwritten memory surrounding `data`.</span>
 135 |     | <span class='unexecuted'>            mstore(dataEnd, mAfter1)</span>
 136 |     | <span class='unexecuted'>            mstore(data, dataLength)</span>
 137 |     | <span class='unexecuted'>            mstore(sub(data, 0x20), mBefore1)</span>
 138 |     | <span class='unexecuted'>            mstore(sub(data, 0x40), mBefore2)</span>
 139 |     | <span class='unexecuted'>            mstore(sub(data, 0x60), mBefore3)</span>
 140 |     | <span class='neutral'>        }</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev Returns the address of the deterministic clone of</span>
 144 |     | <span class='neutral'>    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.</span>
 145 |     | <span class='unexecuted'>    function predictDeterministicAddress(</span>
 146 |     | <span class='neutral'>        address implementation,</span>
 147 |     | <span class='neutral'>        bytes memory data,</span>
 148 |     | <span class='neutral'>        bytes32 salt,</span>
 149 |     | <span class='neutral'>        address deployer</span>
 150 |     | <span class='unexecuted'>    ) internal pure returns (address predicted) {</span>
 151 |     | <span class='unexecuted'>        bytes32 hash = initCodeHash(implementation, data);</span>
 152 |     | <span class='unexecuted'>        predicted = predictDeterministicAddress(hash, salt, deployer);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/</span>
 156 |     | <span class='neutral'>    /*                      OTHER OPERATIONS                      */</span>
 157 |     | <span class='neutral'>    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @dev Returns the address when a contract with initialization code hash,</span>
 160 |     | <span class='neutral'>    /// `hash`, is deployed with `salt`, by `deployer`.</span>
 161 |     | <span class='unexecuted'>    function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)</span>
 162 |     | <span class='neutral'>        internal</span>
 163 |     | <span class='neutral'>        pure</span>
 164 |     | <span class='unexecuted'>        returns (address predicted)</span>
 165 |     | <span class='neutral'>    {</span>
 166 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 167 |     | <span class='neutral'>        assembly {</span>
 168 |     | <span class='neutral'>            // Compute and store the bytecode hash.</span>
 169 |     | <span class='unexecuted'>            mstore8(0x00, 0xff) // Write the prefix.</span>
 170 |     | <span class='unexecuted'>            mstore(0x35, hash)</span>
 171 |     | <span class='unexecuted'>            mstore(0x01, shl(96, deployer))</span>
 172 |     | <span class='unexecuted'>            mstore(0x15, salt)</span>
 173 |     | <span class='unexecuted'>            predicted := keccak256(0x00, 0x55)</span>
 174 |     | <span class='neutral'>            // Restore the part of the free memory pointer that has been overwritten.</span>
 175 |     | <span class='unexecuted'>            mstore(0x35, 0)</span>
 176 |     | <span class='neutral'>        }</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    /// @dev Reverts if `salt` does not start with either the zero address or the caller.</span>
 180 |     | <span class='neutral'>    function checkStartsWithCaller(bytes32 salt) internal view {</span>
 181 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 182 |     | <span class='neutral'>        assembly {</span>
 183 |     | <span class='neutral'>            // If the salt does not start with the zero address or the caller.</span>
 184 |     | <span class='neutral'>            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {</span>
 185 |     | <span class='neutral'>                // Store the function selector of `SaltDoesNotStartWithCaller()`.</span>
 186 |     | <span class='neutral'>                mstore(0x00, 0x2f634836)</span>
 187 |     | <span class='neutral'>                // Revert with (offset, size).</span>
 188 |     | <span class='neutral'>                revert(0x1c, 0x04)</span>
 189 |     | <span class='neutral'>            }</span>
 190 |     | <span class='neutral'>        }</span>
 191 |     | <span class='neutral'>    }</span>
 192 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/utils/Collect.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../limit/LimitPositions.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../utils/SafeTransfers.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>library Collect {</span>
 10 |     | <span class='neutral'>    using SafeCast for int128;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    event CollectRange(</span>
 13 |     | <span class='neutral'>        uint128 amount0,</span>
 14 |     | <span class='neutral'>        uint128 amount1</span>
 15 |     | <span class='neutral'>    );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function range(</span>
 18 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 19 |     | <span class='neutral'>        address recipient,</span>
 20 |     | <span class='neutral'>        int128 amount0,</span>
 21 |     | <span class='neutral'>        int128 amount1</span>
 22 |     | <span class='neutral'>    ) internal {</span>
 23 |     | <span class='neutral'>        /// @dev - negative balances will revert</span>
 24 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 25 |     | <span class='neutral'>            /// @dev - cast to ensure user doesn&#39;t owe the pool balance</span>
 26 |     | <span class='unexecuted'>            SafeTransfers.transferOut(recipient, constants.token0, amount0.toUint128());</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 29 |     | <span class='neutral'>            /// @dev - cast to ensure user doesn&#39;t owe the pool balance</span>
 30 |     | <span class='unexecuted'>            SafeTransfers.transferOut(recipient, constants.token1, amount1.toUint128());</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='unexecuted'>        emit CollectRange(amount0.toUint128(), amount1.toUint128());</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function burnLimit(</span>
 36 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
 37 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params</span>
 38 |     | <span class='neutral'>    ) internal returns (</span>
 39 |     | <span class='unexecuted'>        LimitPoolStructs.BurnLimitCache memory</span>
 40 |     | <span class='neutral'>    )    </span>
 41 |     | <span class='neutral'>    {</span>
 42 |     | <span class='unexecuted'>        uint128 amount0 = params.zeroForOne ? cache.amountOut : cache.amountIn;</span>
 43 |     | <span class='unexecuted'>        uint128 amount1 = params.zeroForOne ? cache.amountIn : cache.amountOut;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>        /// zero out balances and transfer out</span>
 46 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 47 |     | <span class='unexecuted'>            cache.amountIn = 0;</span>
 48 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
 49 |     | <span class='unexecuted'>                balance(cache.constants.token0),</span>
 50 |     | <span class='unexecuted'>                amount0</span>
 51 |     | <span class='neutral'>            );</span>
 52 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, cache.constants.token0, amount0);</span>
 53 |     | <span class='neutral'>        }</span>
 54 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 55 |     | <span class='unexecuted'>            cache.amountOut = 0;</span>
 56 |     | <span class='unexecuted'>            EchidnaAssertions.assertPoolBalanceExceeded(</span>
 57 |     | <span class='unexecuted'>                balance(cache.constants.token1),</span>
 58 |     | <span class='unexecuted'>                amount1</span>
 59 |     | <span class='neutral'>            );</span>
 60 |     | <span class='unexecuted'>            SafeTransfers.transferOut(params.to, cache.constants.token1, amount1);</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='unexecuted'>        return cache;</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>    function balance(</span>
 66 |     | <span class='neutral'>        address token</span>
 67 |     | <span class='unexecuted'>    ) private view returns (uint256) {</span>
 68 |     | <span class='unexecuted'>        (</span>
 69 |     | <span class='unexecuted'>            bool success,</span>
 70 |     | <span class='unexecuted'>            bytes memory data</span>
 71 |     | <span class='unexecuted'>        ) = token.staticcall(</span>
 72 |     | <span class='unexecuted'>                                    abi.encodeWithSelector(</span>
 73 |     | <span class='unexecuted'>                                        IERC20Minimal.balanceOf.selector,</span>
 74 |     | <span class='unexecuted'>                                        address(this)</span>
 75 |     | <span class='neutral'>                                    )</span>
 76 |     | <span class='neutral'>                                );</span>
 77 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 78 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 79 |     | <span class='neutral'>    }</span>
 80 |     | <span class='neutral'>}</span>
 81 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/utils/PositionTokens.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPLv3</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../math/OverflowMath.sol&quot;;</span>
  5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
  6 |     | <span class='neutral'>import &quot;../../interfaces/range/IRangePoolFactory.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../../interfaces/structs/RangePoolStructs.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @notice Token library for ERC-1155 calls.</span>
 10 |     | <span class='unexecuted'>library PositionTokens {</span>
 11 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>    function balanceOf(</span>
 14 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants,</span>
 15 |     | <span class='neutral'>        address owner,</span>
 16 |     | <span class='neutral'>        uint32 positionId</span>
 17 |     | <span class='neutral'>    ) internal view returns (</span>
 18 |     | <span class='unexecuted'>        uint256</span>
 19 |     | <span class='neutral'>    )</span>
 20 |     | <span class='neutral'>    {</span>
 21 |     | <span class='unexecuted'>        return IPositionERC1155(constants.poolToken).balanceOf(owner, positionId);</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/utils/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 10 |     | <span class='unexecuted'>    function toUint128(uint256 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='unexecuted'>        if((z = uint128(y)) != y) require(false, &#39;Uint256ToUint128:Overflow()&#39;);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
 15 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 17 |     | <span class='unexecuted'>    function toUint128(int128 y) internal pure returns (uint128 z) {</span>
 18 |     | <span class='unexecuted'>        if(y &lt; 0) require(false, &#39;Int128ToUint128:Underflow()&#39;);</span>
 19 |     | <span class='unexecuted'>        z = uint128(y);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 23 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 24 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 25 |     | <span class='unexecuted'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 26 |     | <span class='unexecuted'>        if((z = uint160(y)) != y) require(false, &#39;Uint256ToUint160:Overflow()&#39;);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
 30 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 31 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 32 |     | <span class='unexecuted'>    function toUint32(uint256 y) internal pure returns (uint32 z) {</span>
 33 |     | <span class='unexecuted'>        if((z = uint32(y)) != y) require(false, &#39;Uint256ToUint32:Overflow()&#39;);</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 37 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 38 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 39 |     | <span class='unexecuted'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 40 |     | <span class='unexecuted'>        if ((z = int128(y)) != y) require(false, &#39;Int256ToInt128:Overflow()&#39;);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 44 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 45 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 46 |     | <span class='unexecuted'>    function toInt128(uint128 y) internal pure returns (int128 z) {</span>
 47 |     | <span class='unexecuted'>        if(y &gt; uint128(type(int128).max)) require(false, &#39;Uint128ToInt128:Overflow()&#39;);</span>
 48 |     | <span class='unexecuted'>        z = int128(y);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 52 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 53 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 54 |     | <span class='unexecuted'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 55 |     | <span class='unexecuted'>        if(y &gt; uint256(type(int256).max)) require(false, &#39;Uint256ToInt256:Overflow()&#39;);</span>
 56 |     | <span class='unexecuted'>        z = int256(y);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint128, revert on overflow</span>
 60 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
 61 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint128</span>
 62 |     | <span class='neutral'>    function toUint256(int256 y) internal pure returns (uint256 z) {</span>
 63 |     | <span class='neutral'>        if(y &lt; 0) require(false, &#39;Int256ToUint256:Underflow()&#39;);</span>
 64 |     | <span class='neutral'>        z = uint256(y);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/utils/SafeTransfers.sol</b>
<code>
   1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library SafeTransfers {</span>
   7 |     | <span class='neutral'>    /**</span>
   8 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
   9 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
  10 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
  11 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  14 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  17 |     | <span class='unexecuted'>    function transferIn(address token, uint256 amount) internal returns (uint256) {</span>
  18 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  19 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  20 |     | <span class='unexecuted'>            return amount;</span>
  21 |     | <span class='neutral'>        }</span>
  22 |     | <span class='unexecuted'>        if (amount == 0) return 0;</span>
  23 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  24 |     | <span class='unexecuted'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  27 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  28 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  29 |     | <span class='unexecuted'>        erc20Token.transferFrom(msg.sender, address(this), amount);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>        bool success;</span>
  32 |     | <span class='neutral'>        assembly {</span>
  33 |     | <span class='unexecuted'>            switch returndatasize()</span>
  34 |     | <span class='unexecuted'>            case 0 {</span>
  35 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  36 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  37 |     | <span class='neutral'>            }</span>
  38 |     | <span class='unexecuted'>            case 32 {</span>
  39 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
  40 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  41 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  42 |     | <span class='neutral'>            }</span>
  43 |     | <span class='neutral'>            default {</span>
  44 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  45 |     | <span class='unexecuted'>                success := 0</span>
  46 |     | <span class='neutral'>            }</span>
  47 |     | <span class='neutral'>        }</span>
  48 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
  51 |     | <span class='unexecuted'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory</span>
  58 |     | <span class='neutral'>     *      error code rather than reverting. If caller has not called checked protocol&#39;s balance, this may revert due to</span>
  59 |     | <span class='neutral'>     *      insufficient cash held in this contract. If caller has checked protocol&#39;s balance prior to this call, and verified</span>
  60 |     | <span class='neutral'>     *      it is &gt;= amount, this should not revert in normal conditions.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
  63 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
  66 |     | <span class='unexecuted'>    function transferOut(</span>
  67 |     | <span class='neutral'>        address to,</span>
  68 |     | <span class='neutral'>        address token,</span>
  69 |     | <span class='neutral'>        uint256 amount</span>
  70 |     | <span class='unexecuted'>    ) internal {</span>
  71 |     | <span class='unexecuted'>        if (token == address(0)) {</span>
  72 |     | <span class='unexecuted'>            if (address(this).balance &lt; amount) require(false, &#39;TransferFailed(address(this), to&#39;);</span>
  73 |     | <span class='unexecuted'>            payable(to).transfer(amount);</span>
  74 |     | <span class='unexecuted'>            return;</span>
  75 |     | <span class='neutral'>        }</span>
  76 |     | <span class='unexecuted'>        if (amount == 0) return;</span>
  77 |     | <span class='unexecuted'>        IERC20 erc20Token = IERC20(token);</span>
  78 |     | <span class='neutral'>        // ? We are checking the transfer, but since we are doing so in an assembly block</span>
  79 |     | <span class='neutral'>        // ? Slither does not pick up on that and results in a hit</span>
  80 |     | <span class='neutral'>        // slither-disable-next-line unchecked-transfer</span>
  81 |     | <span class='unexecuted'>        erc20Token.transfer(to, amount);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>        bool success;</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='unexecuted'>            switch returndatasize()</span>
  86 |     | <span class='unexecuted'>            case 0 {</span>
  87 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
  88 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
  89 |     | <span class='neutral'>            }</span>
  90 |     | <span class='unexecuted'>            case 32 {</span>
  91 |     | <span class='neutral'>                // This is a complaint ERC-20</span>
  92 |     | <span class='unexecuted'>                returndatacopy(0, 0, 32)</span>
  93 |     | <span class='unexecuted'>                success := mload(0) // Set `success = returndata` of external call</span>
  94 |     | <span class='neutral'>            }</span>
  95 |     | <span class='neutral'>            default {</span>
  96 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
  97 |     | <span class='unexecuted'>                success := 0</span>
  98 |     | <span class='neutral'>            }</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='unexecuted'>        if (!success) require(false, &#39;TransferFailed(address(this), msg.sender&#39;);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /**</span>
 104 |     | <span class='neutral'>     * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.</span>
 105 |     | <span class='neutral'>     *      This will revert due to insufficient balance or insufficient allowance.</span>
 106 |     | <span class='neutral'>     *      This function returns the actual amount received,</span>
 107 |     | <span class='neutral'>     *      which may be less than `amount` if there is a fee attached to the transfer.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.</span>
 110 |     | <span class='neutral'>     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    // slither-disable-next-line assembly</span>
 113 | *   | <span class='executed'>    function transferInto(address token, address sender, uint256 amount) internal returns (uint256) {</span>
 114 | *   | <span class='executed'>        if (token == address(0)) {</span>
 115 |     | <span class='unexecuted'>            if (msg.value &lt; amount) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 116 |     | <span class='unexecuted'>            return amount;</span>
 117 |     | <span class='neutral'>        }</span>
 118 | *   | <span class='executed'>        IERC20 erc20Token = IERC20(token);</span>
 119 | *   | <span class='executed'>        uint256 balanceBefore = IERC20(token).balanceOf(address(this));</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>        /// @dev - msg.sender here is the pool</span>
 122 | *r  | <span class='executed'>        erc20Token.transferFrom(sender, msg.sender, amount);</span>
 123 |     | <span class='neutral'></span>
 124 | *   | <span class='executed'>        bool success;</span>
 125 |     | <span class='neutral'>        assembly {</span>
 126 | *   | <span class='executed'>            switch returndatasize()</span>
 127 | *   | <span class='executed'>            case 0 {</span>
 128 |     | <span class='neutral'>                // This is a non-standard ERC-20</span>
 129 |     | <span class='unexecuted'>                success := 1 // set success to true</span>
 130 |     | <span class='neutral'>            }</span>
 131 | *   | <span class='executed'>            case 32 {</span>
 132 |     | <span class='neutral'>                // This is a compliant ERC-20</span>
 133 | *   | <span class='executed'>                returndatacopy(0, 0, 32)</span>
 134 | *   | <span class='executed'>                success := mload(0) // Set `success = returndata` of external call</span>
 135 |     | <span class='neutral'>            }</span>
 136 |     | <span class='neutral'>            default {</span>
 137 |     | <span class='neutral'>                // This is an excessively non-compliant ERC-20, revert.</span>
 138 |     | <span class='unexecuted'>                success := 0</span>
 139 |     | <span class='neutral'>            }</span>
 140 |     | <span class='neutral'>        }</span>
 141 | *   | <span class='executed'>        if (!success) require(false, &#39;TransferFailed(msg.sender, address(this)&#39;);</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>        // Calculate the amount that was *actually* transferred</span>
 144 | *   | <span class='executed'>        uint256 balanceAfter = IERC20(token).balanceOf(address(this));</span>
 145 |     | <span class='neutral'></span>
 146 | *   | <span class='executed'>        return balanceAfter - balanceBefore; // underflow already checked above, just subtract</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'>}</span>
 149 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/libraries/utils/String.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library String {</span>
  5 |     | <span class='neutral'>    bytes16 private constant alphabet = &quot;0123456789abcdef&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function from(bytes32 value) internal pure returns(string memory) {</span>
  8 |     | <span class='neutral'>        return toString(abi.encodePacked(value));</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function from(address account) internal pure returns(string memory) {</span>
 12 |     | <span class='neutral'>        return toString(abi.encodePacked(account));</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function from(uint256 value) internal pure returns(string memory) {</span>
 16 |     | <span class='neutral'>        unchecked {</span>
 17 |     | <span class='neutral'>            uint256 length = log10(value) + 1;</span>
 18 |     | <span class='neutral'>            string memory buffer = new string(length);</span>
 19 |     | <span class='neutral'>            uint256 ptr;</span>
 20 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 21 |     | <span class='neutral'>            assembly {</span>
 22 |     | <span class='neutral'>                ptr := add(buffer, add(32, length))</span>
 23 |     | <span class='neutral'>            }</span>
 24 |     | <span class='neutral'>            while (true) {</span>
 25 |     | <span class='neutral'>                ptr--;</span>
 26 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 27 |     | <span class='neutral'>                assembly {</span>
 28 |     | <span class='neutral'>                    mstore8(ptr, byte(mod(value, 10), alphabet))</span>
 29 |     | <span class='neutral'>                }</span>
 30 |     | <span class='neutral'>                value /= 10;</span>
 31 |     | <span class='neutral'>                if (value == 0) break;</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='neutral'>            return buffer;</span>
 34 |     | <span class='neutral'>        }</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function from(int256 value) internal pure returns (string memory) {</span>
 38 |     | <span class='neutral'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, from(abs(value))));</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 42 |     | <span class='neutral'>        unchecked {</span>
 43 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 44 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 45 |     | <span class='neutral'>        }</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 49 |     | <span class='neutral'>        uint256 result = 0;</span>
 50 |     | <span class='neutral'>        unchecked {</span>
 51 |     | <span class='neutral'>            if (value &gt;= 10 ** 64) {</span>
 52 |     | <span class='neutral'>                value /= 10 ** 64;</span>
 53 |     | <span class='neutral'>                result += 64;</span>
 54 |     | <span class='neutral'>            }</span>
 55 |     | <span class='neutral'>            if (value &gt;= 10 ** 32) {</span>
 56 |     | <span class='neutral'>                value /= 10 ** 32;</span>
 57 |     | <span class='neutral'>                result += 32;</span>
 58 |     | <span class='neutral'>            }</span>
 59 |     | <span class='neutral'>            if (value &gt;= 10 ** 16) {</span>
 60 |     | <span class='neutral'>                value /= 10 ** 16;</span>
 61 |     | <span class='neutral'>                result += 16;</span>
 62 |     | <span class='neutral'>            }</span>
 63 |     | <span class='neutral'>            if (value &gt;= 10 ** 8) {</span>
 64 |     | <span class='neutral'>                value /= 10 ** 8;</span>
 65 |     | <span class='neutral'>                result += 8;</span>
 66 |     | <span class='neutral'>            }</span>
 67 |     | <span class='neutral'>            if (value &gt;= 10 ** 4) {</span>
 68 |     | <span class='neutral'>                value /= 10 ** 4;</span>
 69 |     | <span class='neutral'>                result += 4;</span>
 70 |     | <span class='neutral'>            }</span>
 71 |     | <span class='neutral'>            if (value &gt;= 10 ** 2) {</span>
 72 |     | <span class='neutral'>                value /= 10 ** 2;</span>
 73 |     | <span class='neutral'>                result += 2;</span>
 74 |     | <span class='neutral'>            }</span>
 75 |     | <span class='neutral'>            if (value &gt;= 10 ** 1) {</span>
 76 |     | <span class='neutral'>                result += 1;</span>
 77 |     | <span class='neutral'>            }</span>
 78 |     | <span class='neutral'>        }</span>
 79 |     | <span class='neutral'>        return result;</span>
 80 |     | <span class='neutral'>    }</span>
 81 |     | <span class='neutral'></span>
 82 |     | <span class='neutral'>    function toString(bytes memory data) internal pure returns(string memory) {</span>
 83 |     | <span class='neutral'>        bytes memory str = new bytes(2 + data.length * 2);</span>
 84 |     | <span class='neutral'>        str[0] = &quot;0&quot;;</span>
 85 |     | <span class='neutral'>        str[1] = &quot;x&quot;;</span>
 86 |     | <span class='neutral'>        for (uint i = 0; i &lt; data.length;) {</span>
 87 |     | <span class='neutral'>            str[2+i*2] = alphabet[uint(uint8(data[i] &gt;&gt; 4))];</span>
 88 |     | <span class='neutral'>            str[3+i*2] = alphabet[uint(uint8(data[i] &amp; 0x0f))];</span>
 89 |     | <span class='neutral'>            unchecked {</span>
 90 |     | <span class='neutral'>                ++i;</span>
 91 |     | <span class='neutral'>            }</span>
 92 |     | <span class='neutral'>        }</span>
 93 |     | <span class='neutral'>        return string(str);</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/test/Token20.sol</b>
<code>
  1 |     | <span class='neutral'>//SPDX-License-Identifier: Unlicense</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../external/openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 | *   | <span class='executed'>contract Token20 is ERC20, ERC20Burnable {</span>
  8 |     | <span class='neutral'>    uint8 _decimals;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    constructor(</span>
 11 |     | <span class='neutral'>        string memory tokenName,</span>
 12 |     | <span class='neutral'>        string memory tokenSymbol,</span>
 13 |     | <span class='neutral'>        uint8 decimals_</span>
 14 |     | <span class='unexecuted'>    ) ERC20(tokenName, tokenSymbol) {</span>
 15 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 | *   | <span class='executed'>    function mint(address to, uint256 amount) external {</span>
 19 | *   | <span class='executed'>        _mint(to, amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function decimals() public view override returns (uint8) {</span>
 23 |     | <span class='unexecuted'>        return _decimals;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='unexecuted'>    function setDecimals(uint8 decimals_) public {</span>
 27 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/test/echidna/EchidnaAssertions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../../libraries/math/ConstantProduct.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>library EchidnaAssertions {</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);</span>
 10 |     | <span class='neutral'>    event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);</span>
 11 |     | <span class='neutral'>    event LiquidityOverflow(uint128 liquidity, uint128 amount, string location);</span>
 12 |     | <span class='neutral'>    event LiquidityUnlock(int128 liquidity);</span>
 13 |     | <span class='neutral'>    event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);</span>
 14 |     | <span class='neutral'>    event LiquidityDelta(int128 liquidityDelta);</span>
 15 |     | <span class='neutral'>    event TickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>    function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {</span>
 18 |     | <span class='unexecuted'>        emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);</span>
 19 |     | <span class='unexecuted'>        assert(liquidityGlobal &gt;= amount);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 23 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 24 |     | <span class='unexecuted'>        assert(liquidity &gt;= amount);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function assertLiquidityOverflows(uint128 liquidity, uint128 amount, string memory location) internal {</span>
 28 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidity, amount, location);</span>
 29 |     | <span class='unexecuted'>        assert(uint256(liquidity) + uint256(amount) &lt;= uint128(type(int128).max));</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function assertLiquidityAbsoluteUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {</span>
 33 |     | <span class='unexecuted'>        emit LiquidityUnderflow(liquidityAbs, amount, location);</span>
 34 |     | <span class='unexecuted'>        assert(liquidityAbs &gt;= amount);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {</span>
 38 |     | <span class='unexecuted'>        emit LiquidityUnlock(liquidity);</span>
 39 |     | <span class='unexecuted'>        assert(liquidity &gt;= 0);</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='unexecuted'>    function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {</span>
 43 |     | <span class='unexecuted'>        emit PoolBalanceExceeded(poolBalance, outputAmount);</span>
 44 |     | <span class='unexecuted'>        assert(poolBalance &gt;= outputAmount);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function assertTickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing) internal {</span>
 48 |     | <span class='unexecuted'>        emit TickAtPriceDivisibleByTickSpacing(tick, priceAt, tickSpacing);</span>
 49 |     | <span class='unexecuted'>        if(tick % tickSpacing == 0) assert(priceAt == 0);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/test/echidna/EchidnaBurnLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../interfaces/IPositionERC1155.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../libraries/limit/LimitPositions.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../libraries/utils/Collect.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../../libraries/utils/PositionTokens.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>library EchidnaBurnLimitCall {</span>
  11 |     | <span class='neutral'>    event BurnLimit(</span>
  12 |     | <span class='neutral'>        address indexed to,</span>
  13 |     | <span class='neutral'>        uint32 positionId,</span>
  14 |     | <span class='neutral'>        int24 lower,</span>
  15 |     | <span class='neutral'>        int24 upper,</span>
  16 |     | <span class='neutral'>        int24 oldClaim,</span>
  17 |     | <span class='neutral'>        int24 newClaim,</span>
  18 |     | <span class='neutral'>        bool zeroForOne,</span>
  19 |     | <span class='neutral'>        uint128 liquidityBurned,</span>
  20 |     | <span class='neutral'>        uint128 tokenInClaimed,</span>
  21 |     | <span class='neutral'>        uint128 tokenOutBurned</span>
  22 |     | <span class='neutral'>    );</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    error SimulateBurn(int24 lower, int24 upper, bool positionExists);</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Echidna funcs</span>
  27 |     | <span class='unexecuted'>    function getResizedTicks(</span>
  28 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  29 |     | <span class='neutral'>            storage positions,</span>
  30 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  31 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage tickMap,</span>
  32 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  33 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitParams memory params,</span>
  34 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache</span>
  35 |     | <span class='neutral'>    ) external {</span>
  36 |     | <span class='neutral'>        // check for invalid receiver</span>
  37 |     | <span class='unexecuted'>        if (params.to == address(0))</span>
  38 |     | <span class='unexecuted'>            require(false, &#39;CollectToZeroAddress()&#39;);</span>
  39 |     | <span class='neutral'>        </span>
  40 |     | <span class='neutral'>        // initialize cache</span>
  41 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  42 |     | <span class='unexecuted'>        cache.position = positions[params.positionId];</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>        // check positionId owner</span>
  45 |     | <span class='unexecuted'>        if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  46 |     | <span class='unexecuted'>            require(false, &#39;PositionNotFound()&#39;);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>        // update position</span>
  49 |     | <span class='unexecuted'>        (</span>
  50 |     | <span class='neutral'>            params,</span>
  51 |     | <span class='neutral'>            cache</span>
  52 |     | <span class='unexecuted'>        ) = LimitPositions.update(</span>
  53 |     | <span class='unexecuted'>            ticks,</span>
  54 |     | <span class='unexecuted'>            tickMap,</span>
  55 |     | <span class='unexecuted'>            cache,</span>
  56 |     | <span class='unexecuted'>            params</span>
  57 |     | <span class='neutral'>        );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>        int24 lower = cache.position.lower;</span>
  60 |     | <span class='unexecuted'>        int24 upper = cache.position.upper;</span>
  61 |     | <span class='unexecuted'>        bool positionExists = cache.position.liquidity != 0;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>        // save position before transfer</span>
  64 |     | <span class='unexecuted'>        if ((params.zeroForOne ? params.claim != cache.position.upper</span>
  65 |     | <span class='unexecuted'>                               : params.claim != cache.position.lower)) {</span>
  66 |     | <span class='unexecuted'>            if (cache.position.liquidity &gt; 0) {</span>
  67 |     | <span class='unexecuted'>                if (params.zeroForOne) {</span>
  68 |     | <span class='unexecuted'>                    cache.position.lower = params.claim;</span>
  69 |     | <span class='neutral'>                } else {</span>
  70 |     | <span class='unexecuted'>                    cache.position.upper = params.claim;</span>
  71 |     | <span class='neutral'>                }</span>
  72 |     | <span class='unexecuted'>                positions[params.positionId] = cache.position;</span>
  73 |     | <span class='neutral'>            } else {</span>
  74 |     | <span class='unexecuted'>                IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  75 |     | <span class='unexecuted'>                delete positions[params.positionId];</span>
  76 |     | <span class='neutral'>            }</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 |     | <span class='unexecuted'>            IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);</span>
  79 |     | <span class='unexecuted'>            delete positions[params.positionId];</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        cache = Collect.burnLimit(</span>
  83 |     | <span class='unexecuted'>            cache,</span>
  84 |     | <span class='unexecuted'>            params</span>
  85 |     | <span class='neutral'>        );</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>        revert SimulateBurn(lower, upper, positionExists);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function save(</span>
  91 |     | <span class='neutral'>        LimitPoolStructs.BurnLimitCache memory cache,</span>
  92 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  93 |     | <span class='neutral'>        bool zeroForOne</span>
  94 |     | <span class='neutral'>    ) internal {</span>
  95 |     | <span class='neutral'>        globalState.epoch = cache.state.epoch;</span>
  96 |     | <span class='neutral'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
  97 |     | <span class='neutral'>        if (zeroForOne) {</span>
  98 |     | <span class='neutral'>            globalState.pool = cache.state.pool;</span>
  99 |     | <span class='neutral'>            globalState.pool0 = cache.state.pool0;</span>
 100 |     | <span class='neutral'>        } else {</span>
 101 |     | <span class='neutral'>            globalState.pool = cache.state.pool;</span>
 102 |     | <span class='neutral'>            globalState.pool1 = cache.state.pool1;</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'>}</span>
 106 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/test/echidna/EchidnaMintLimitCall.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../../interfaces/structs/LimitPoolStructs.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../../libraries/limit/LimitPositions.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../../libraries/utils/Collect.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../../libraries/utils/PositionTokens.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./EchidnaAssertions.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../../interfaces/IERC20Minimal.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 | *   | <span class='executed'>library EchidnaMintLimitCall {</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    error SimulateMint(int24 lower, int24 upper, bool positionCreated);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    event MintLimit(</span>
  16 |     | <span class='neutral'>        address indexed to,</span>
  17 |     | <span class='neutral'>        int24 lower,</span>
  18 |     | <span class='neutral'>        int24 upper,</span>
  19 |     | <span class='neutral'>        bool zeroForOne,</span>
  20 |     | <span class='neutral'>        uint32 positionId,</span>
  21 |     | <span class='neutral'>        uint32 epochLast,</span>
  22 |     | <span class='neutral'>        uint128 amountIn,</span>
  23 |     | <span class='neutral'>        uint128 amountFilled,</span>
  24 |     | <span class='neutral'>        uint128 liquidityMinted</span>
  25 |     | <span class='neutral'>    );</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    event SyncLimitPool(</span>
  28 |     | <span class='neutral'>        uint160 price,</span>
  29 |     | <span class='neutral'>        uint128 liquidity,</span>
  30 |     | <span class='neutral'>        uint32 epoch,</span>
  31 |     | <span class='neutral'>        int24 tickAtPrice,</span>
  32 |     | <span class='neutral'>        bool isPool0</span>
  33 |     | <span class='neutral'>    );</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function save(</span>
  36 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache,</span>
  37 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  38 |     | <span class='neutral'>        bool zeroForOne</span>
  39 |     | <span class='neutral'>    ) internal {</span>
  40 |     | <span class='unexecuted'>        globalState.epoch = cache.state.epoch;</span>
  41 |     | <span class='unexecuted'>        globalState.liquidityGlobal = cache.state.liquidityGlobal;</span>
  42 |     | <span class='unexecuted'>        globalState.positionIdNext = cache.state.positionIdNext;</span>
  43 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
  44 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  45 |     | <span class='unexecuted'>            globalState.pool0 = cache.state.pool0;</span>
  46 |     | <span class='neutral'>        } else {</span>
  47 |     | <span class='unexecuted'>            globalState.pool = cache.state.pool;</span>
  48 |     | <span class='unexecuted'>            globalState.pool1 = cache.state.pool1;</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function balance(</span>
  53 |     | <span class='neutral'>        address token</span>
  54 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
  55 |     | <span class='neutral'>        (</span>
  56 |     | <span class='neutral'>            bool success,</span>
  57 |     | <span class='neutral'>            bytes memory data</span>
  58 |     | <span class='neutral'>        ) = token.staticcall(</span>
  59 |     | <span class='neutral'>                                    abi.encodeWithSelector(</span>
  60 |     | <span class='neutral'>                                        IERC20Minimal.balanceOf.selector,</span>
  61 |     | <span class='neutral'>                                        address(this)</span>
  62 |     | <span class='neutral'>                                    )</span>
  63 |     | <span class='neutral'>                                );</span>
  64 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
  65 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // Echidna funcs</span>
  69 | *   | <span class='executed'>    function getResizedTicks(</span>
  70 |     | <span class='neutral'>        mapping(uint256 =&gt; LimitPoolStructs.LimitPosition)</span>
  71 |     | <span class='neutral'>            storage positions,</span>
  72 |     | <span class='neutral'>        mapping(int24 =&gt; LimitPoolStructs.Tick) storage ticks,</span>
  73 |     | <span class='neutral'>        RangePoolStructs.Sample[65535] storage samples,</span>
  74 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage rangeTickMap,</span>
  75 |     | <span class='neutral'>        PoolsharkStructs.TickMap storage limitTickMap,</span>
  76 |     | <span class='neutral'>        PoolsharkStructs.GlobalState storage globalState,</span>
  77 |     | <span class='neutral'>        LimitPoolStructs.MintLimitParams memory params,</span>
  78 |     | <span class='neutral'>        LimitPoolStructs.MintLimitCache memory cache</span>
  79 |     | <span class='neutral'>    ) external {</span>
  80 | *   | <span class='executed'>        bool positionCreated = false;</span>
  81 | *   | <span class='executed'>        if (params.positionId &gt; 0) {</span>
  82 |     | <span class='unexecuted'>            if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)</span>
  83 |     | <span class='neutral'>                // check for balance held</span>
  84 |     | <span class='unexecuted'>                require(false, &#39;PositionNotFound()&#39;);</span>
  85 |     | <span class='unexecuted'>            cache.position = positions[params.positionId];</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        cache.state = globalState;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>        // resize position if necessary</span>
  91 |     | <span class='unexecuted'>        (params, cache) = LimitPositions.resize(</span>
  92 |     | <span class='unexecuted'>            ticks,</span>
  93 |     | <span class='unexecuted'>            samples,</span>
  94 |     | <span class='unexecuted'>            rangeTickMap,</span>
  95 |     | <span class='unexecuted'>            limitTickMap,</span>
  96 |     | <span class='unexecuted'>            params,</span>
  97 |     | <span class='unexecuted'>            cache</span>
  98 |     | <span class='neutral'>        );</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>        if (params.positionId == 0 ||                       // new position</span>
 101 |     | <span class='unexecuted'>                params.lower != cache.position.lower ||     // lower mismatch</span>
 102 |     | <span class='unexecuted'>                params.upper != cache.position.upper) {     // upper mismatch</span>
 103 |     | <span class='unexecuted'>            LimitPoolStructs.LimitPosition memory newPosition;</span>
 104 |     | <span class='unexecuted'>            newPosition.lower = params.lower;</span>
 105 |     | <span class='unexecuted'>            newPosition.upper = params.upper;</span>
 106 |     | <span class='neutral'>            // use new position in cache</span>
 107 |     | <span class='unexecuted'>            cache.position = newPosition;</span>
 108 |     | <span class='unexecuted'>            params.positionId = cache.state.positionIdNext;</span>
 109 |     | <span class='unexecuted'>            cache.state.positionIdNext += 1;</span>
 110 |     | <span class='neutral'>        }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // save state for reentrancy safety</span>
 113 |     | <span class='unexecuted'>        save(cache, globalState, !params.zeroForOne);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        // transfer in token amount</span>
 116 |     | <span class='unexecuted'>        SafeTransfers.transferIn(</span>
 117 |     | <span class='unexecuted'>                                 params.zeroForOne ? cache.constants.token0 </span>
 118 |     | <span class='unexecuted'>                                                   : cache.constants.token1,</span>
 119 |     | <span class='unexecuted'>                                 params.amount + cache.swapCache.input</span>
 120 |     | <span class='neutral'>                                );</span>
 121 |     | <span class='neutral'>        // transfer out if swap output </span>
 122 |     | <span class='unexecuted'>        if (cache.swapCache.output &gt; 0)</span>
 123 |     | <span class='unexecuted'>            SafeTransfers.transferOut(</span>
 124 |     | <span class='unexecuted'>                params.to,</span>
 125 |     | <span class='unexecuted'>                params.zeroForOne ? cache.constants.token1 </span>
 126 |     | <span class='unexecuted'>                                  : cache.constants.token0,</span>
 127 |     | <span class='unexecuted'>                cache.swapCache.output</span>
 128 |     | <span class='neutral'>            );</span>
 129 |     | <span class='neutral'>        // mint position if amount is left</span>
 130 |     | <span class='unexecuted'>        if (params.amount &gt; 0 &amp;&amp; params.lower &lt; params.upper) {</span>
 131 |     | <span class='unexecuted'>            cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;</span>
 132 |     | <span class='neutral'>            </span>
 133 |     | <span class='neutral'>            // bump to the next tick if there is no liquidity</span>
 134 |     | <span class='unexecuted'>            if (cache.pool.liquidity == 0) {</span>
 135 |     | <span class='neutral'>                /// @dev - this makes sure to have liquidity unlocked if undercutting</span>
 136 |     | <span class='unexecuted'>                (cache, cache.pool) = LimitTicks.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);</span>
 137 |     | <span class='neutral'>            }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>            if (params.zeroForOne) {</span>
 140 |     | <span class='unexecuted'>                uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);</span>
 141 |     | <span class='unexecuted'>                if (priceLower &lt;= cache.pool.price) {</span>
 142 |     | <span class='neutral'>                    // save liquidity if active</span>
 143 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 144 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 145 |     | <span class='neutral'>                    }</span>
 146 |     | <span class='unexecuted'>                    cache.pool.price = priceLower;</span>
 147 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.lower;</span>
 148 |     | <span class='neutral'>                    /// @auditor - double check liquidity is set correctly for this in insertSingle</span>
 149 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 150 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 151 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 152 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 153 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 154 |     | <span class='neutral'>                }</span>
 155 |     | <span class='unexecuted'>            } else {</span>
 156 |     | <span class='unexecuted'>                uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);</span>
 157 |     | <span class='unexecuted'>                if (priceUpper &gt;= cache.pool.price) {</span>
 158 |     | <span class='unexecuted'>                    if (cache.pool.liquidity &gt; 0) {</span>
 159 |     | <span class='unexecuted'>                        cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);</span>
 160 |     | <span class='neutral'>                    }</span>
 161 |     | <span class='unexecuted'>                    cache.pool.price = priceUpper;</span>
 162 |     | <span class='unexecuted'>                    cache.pool.tickAtPrice = params.upper;</span>
 163 |     | <span class='unexecuted'>                    cache.pool.liquidity += uint128(cache.liquidityMinted);</span>
 164 |     | <span class='unexecuted'>                    cache.position.crossedInto = true;</span>
 165 |     | <span class='neutral'>                    // set epoch on start tick to signify position being crossed into</span>
 166 |     | <span class='neutral'>                    /// @auditor - this is safe assuming we have swapped at least this far on the other side</span>
 167 |     | <span class='unexecuted'>                    emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);</span>
 168 |     | <span class='neutral'>                }</span>
 169 |     | <span class='neutral'>            }</span>
 170 |     | <span class='unexecuted'>            (cache.pool, cache.position) = LimitPositions.add(</span>
 171 |     | <span class='unexecuted'>                cache,</span>
 172 |     | <span class='unexecuted'>                ticks,</span>
 173 |     | <span class='unexecuted'>                limitTickMap,</span>
 174 |     | <span class='unexecuted'>                params</span>
 175 |     | <span class='neutral'>            );</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='unexecuted'>            positionCreated = true;</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>            // save position to storage</span>
 180 |     | <span class='unexecuted'>            positions[params.positionId] = cache.position;</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>            // update cache</span>
 183 |     | <span class='unexecuted'>            params.zeroForOne ? cache.state.pool0 = cache.pool </span>
 184 |     | <span class='unexecuted'>                              : cache.state.pool1 = cache.pool;</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>            emit MintLimit(</span>
 187 |     | <span class='unexecuted'>                params.to,</span>
 188 |     | <span class='unexecuted'>                params.lower,</span>
 189 |     | <span class='unexecuted'>                params.upper,</span>
 190 |     | <span class='unexecuted'>                params.zeroForOne,</span>
 191 |     | <span class='unexecuted'>                params.positionId,</span>
 192 |     | <span class='unexecuted'>                cache.position.epochLast,</span>
 193 |     | <span class='unexecuted'>                uint128(params.amount + cache.swapCache.input),</span>
 194 |     | <span class='unexecuted'>                uint128(cache.swapCache.output),</span>
 195 |     | <span class='unexecuted'>                uint128(cache.liquidityMinted)</span>
 196 |     | <span class='neutral'>            );</span>
 197 |     | <span class='neutral'>        }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>        // save lp side for safe reentrancy</span>
 200 |     | <span class='unexecuted'>        save(cache, globalState, params.zeroForOne);</span>
 201 |     | <span class='neutral'>    </span>
 202 |     | <span class='unexecuted'>        revert SimulateMint(params.lower, params.upper, positionCreated);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'>}</span>
 205 |     | <span class='neutral'></span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/utils/LimitPoolErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract LimitPoolErrors {</span>
  5 |     | <span class='neutral'>    error Locked();</span>
  6 |     | <span class='neutral'>    error OwnerOnly();</span>
  7 |     | <span class='neutral'>    error InvalidToken();</span>
  8 |     | <span class='neutral'>    error InvalidPosition();</span>
  9 |     | <span class='neutral'>    error InvalidSwapFee();</span>
 10 |     | <span class='neutral'>    error InvalidTokenDecimals();</span>
 11 |     | <span class='neutral'>    error InvalidTickSpread();</span>
 12 |     | <span class='neutral'>    error LiquidityOverflow();</span>
 13 |     | <span class='neutral'>    error Token0Missing();</span>
 14 |     | <span class='neutral'>    error Token1Missing();</span>
 15 |     | <span class='neutral'>    error InvalidTick();</span>
 16 |     | <span class='neutral'>    error FactoryOnly();</span>
 17 |     | <span class='neutral'>    error LowerNotEvenTick();</span>
 18 |     | <span class='neutral'>    error UpperNotOddTick();</span>
 19 |     | <span class='neutral'>    error MaxTickLiquidity();</span>
 20 |     | <span class='neutral'>    error CollectToZeroAddress();</span>
 21 |     | <span class='neutral'>    error ProtocolFeeCeilingExceeded();</span>
 22 |     | <span class='neutral'>    error Overflow();</span>
 23 |     | <span class='neutral'>    error PoolAlreadyInitialized();</span>
 24 |     | <span class='neutral'>    error NotEnoughOutputLiquidity();</span>
 25 |     | <span class='neutral'>    error WaitUntilEnoughObservations();</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>abstract contract PositionERC1155Errors {</span>
 29 |     | <span class='neutral'>    error SpenderNotApproved(address owner, address spender);</span>
 30 |     | <span class='neutral'>    error TransferFromOrToAddress0();</span>
 31 |     | <span class='neutral'>    error MintToAddress0();</span>
 32 |     | <span class='neutral'>    error BurnFromAddress0();</span>
 33 |     | <span class='neutral'>    error BurnExceedsBalance(address from, uint256 id, uint256 amount);</span>
 34 |     | <span class='neutral'>    error LengthMismatch(uint256 accountsLength, uint256 idsLength);</span>
 35 |     | <span class='neutral'>    error SelfApproval(address owner);</span>
 36 |     | <span class='neutral'>    error TransferExceedsBalance(address from, uint256 id, uint256 amount);</span>
 37 |     | <span class='neutral'>    error TransferToSelf();</span>
 38 |     | <span class='neutral'>    error ERC1155NotSupported();</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>abstract contract LimitPoolFactoryErrors {</span>
 42 |     | <span class='neutral'>    error OwnerOnly();</span>
 43 |     | <span class='neutral'>    error InvalidTokenAddress();</span>
 44 |     | <span class='neutral'>    error PoolAlreadyExists();</span>
 45 |     | <span class='neutral'>    error FeeTierNotSupported();</span>
 46 |     | <span class='neutral'>    error PoolTypeNotSupported();</span>
 47 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/utils/LimitPoolManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolFactory.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/limit/ILimitPoolManager.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../base/events/LimitPoolManagerEvents.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Defines the actions which can be executed by the factory admin.</span>
  12 |     | <span class='neutral'> */</span>
  13 |     | <span class='unexecuted'>contract LimitPoolManager is ILimitPoolManager, LimitPoolManagerEvents {</span>
  14 |     | <span class='unexecuted'>    address public owner;</span>
  15 |     | <span class='unexecuted'>    address public feeTo;</span>
  16 |     | <span class='unexecuted'>    address public factory;</span>
  17 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_SWAP_FEE = 1e4; /// @dev - max protocol swap fee of 100%</span>
  18 |     | <span class='unexecuted'>    uint16  public constant MAX_PROTOCOL_FILL_FEE = 1e2; /// @dev - max protocol fill fee of 1%</span>
  19 |     | <span class='neutral'>    // impl name =&gt; impl address</span>
  20 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _poolImpls;</span>
  21 |     | <span class='neutral'>    mapping(bytes32 =&gt; address) internal _tokenImpls;</span>
  22 |     | <span class='neutral'>    // swap fee =&gt; tick spacing</span>
  23 |     | <span class='neutral'>    mapping(uint16 =&gt; int16) internal _feeTiers;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    error InvalidSwapFee();</span>
  26 |     | <span class='neutral'>    error InvalidTickSpacing();</span>
  27 |     | <span class='neutral'>    error InvalidImplAddress();</span>
  28 |     | <span class='neutral'>    error TickSpacingAlreadyEnabled();</span>
  29 |     | <span class='neutral'>    error ImplementationAlreadyExists();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>    constructor() {</span>
  32 |     | <span class='unexecuted'>        owner = msg.sender;</span>
  33 |     | <span class='unexecuted'>        feeTo = msg.sender;</span>
  34 |     | <span class='unexecuted'>        emit OwnerTransfer(address(0), msg.sender);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>        // create initial fee tiers</span>
  37 |     | <span class='unexecuted'>        _feeTiers[500] = 10;</span>
  38 |     | <span class='unexecuted'>        _feeTiers[10000] = 100;</span>
  39 |     | <span class='unexecuted'>        emit FeeTierEnabled(500, 10);</span>
  40 |     | <span class='unexecuted'>        emit FeeTierEnabled(10000, 100);</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
  45 |     | <span class='neutral'>     */</span>
  46 |     | <span class='neutral'>    modifier onlyOwner() {</span>
  47 |     | <span class='unexecuted'>        _checkOwner();</span>
  48 |     | <span class='neutral'>        _;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    modifier onlyFeeTo() {</span>
  52 |     | <span class='unexecuted'>        _checkFeeTo();</span>
  53 |     | <span class='neutral'>        _;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  58 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='unexecuted'>    function transferOwner(address newOwner) public virtual onlyOwner {</span>
  61 |     | <span class='unexecuted'>        if(newOwner == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  62 |     | <span class='unexecuted'>        _transferOwner(newOwner);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>    function transferFeeTo(address newFeeTo) public virtual onlyFeeTo {</span>
  66 |     | <span class='unexecuted'>        if(newFeeTo == address(0)) require (false, &#39;TransferredToZeroAddress()&#39;);</span>
  67 |     | <span class='unexecuted'>        _transferFeeTo(newFeeTo);</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /**</span>
  71 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
  72 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  73 |     | <span class='neutral'>     */</span>
  74 |     | <span class='unexecuted'>    function _transferOwner(address newOwner) internal virtual {</span>
  75 |     | <span class='unexecuted'>        address oldOwner = owner;</span>
  76 |     | <span class='unexecuted'>        owner = newOwner;</span>
  77 |     | <span class='unexecuted'>        emit OwnerTransfer(oldOwner, newOwner);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    /**</span>
  81 |     | <span class='neutral'>     * @dev Transfers fee collection to a new account (`newFeeTo`).</span>
  82 |     | <span class='neutral'>     * Internal function without access restriction.</span>
  83 |     | <span class='neutral'>     */</span>
  84 |     | <span class='unexecuted'>    function _transferFeeTo(address newFeeTo) internal virtual {</span>
  85 |     | <span class='unexecuted'>        address oldFeeTo = feeTo;</span>
  86 |     | <span class='unexecuted'>        feeTo = newFeeTo;</span>
  87 |     | <span class='unexecuted'>        emit OwnerTransfer(oldFeeTo, newFeeTo);</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>    function enableTickSpacing(</span>
  91 |     | <span class='neutral'>        int16 tickSpacing,</span>
  92 |     | <span class='neutral'>        uint16 swapFee</span>
  93 |     | <span class='neutral'>    ) external onlyOwner {</span>
  94 |     | <span class='unexecuted'>        if (_feeTiers[swapFee] != 0) revert TickSpacingAlreadyEnabled();</span>
  95 |     | <span class='unexecuted'>        if (tickSpacing &lt;= 0) revert InvalidTickSpacing();</span>
  96 |     | <span class='unexecuted'>        if (tickSpacing % 2 != 0) revert InvalidTickSpacing();</span>
  97 |     | <span class='unexecuted'>        if (swapFee == 0) revert InvalidSwapFee();</span>
  98 |     | <span class='unexecuted'>        if (swapFee &gt; 10000) revert InvalidSwapFee();</span>
  99 |     | <span class='unexecuted'>        _feeTiers[swapFee] = tickSpacing;</span>
 100 |     | <span class='unexecuted'>        emit FeeTierEnabled(swapFee, tickSpacing);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>    function enableImplementation(</span>
 104 |     | <span class='neutral'>        bytes32 poolType_,</span>
 105 |     | <span class='neutral'>        address poolImpl_,</span>
 106 |     | <span class='neutral'>        address tokenImpl_</span>
 107 |     | <span class='neutral'>    ) external onlyOwner {</span>
 108 |     | <span class='unexecuted'>        if (_poolImpls[poolType_] != address(0)) revert ImplementationAlreadyExists();</span>
 109 |     | <span class='unexecuted'>        if (poolImpl_ == address(0) || tokenImpl_ == address(0)) revert InvalidImplAddress();</span>
 110 |     | <span class='neutral'>        /// @dev - prevent same addresses since factory does not support this</span>
 111 |     | <span class='unexecuted'>        if (poolImpl_ == tokenImpl_) revert InvalidImplAddress();</span>
 112 |     | <span class='unexecuted'>        _poolImpls[poolType_] = poolImpl_;</span>
 113 |     | <span class='unexecuted'>        _tokenImpls[poolType_] = tokenImpl_;</span>
 114 |     | <span class='unexecuted'>        emit ImplementationEnabled(poolType_, poolImpl_, tokenImpl_);</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    function setFactory(</span>
 118 |     | <span class='neutral'>        address factory_</span>
 119 |     | <span class='neutral'>    ) external onlyOwner {</span>
 120 |     | <span class='unexecuted'>        if (factory != address(0)) require (false, &#39;FactoryAlreadySet()&#39;);</span>
 121 |     | <span class='unexecuted'>        emit FactoryChanged(factory, factory_);</span>
 122 |     | <span class='unexecuted'>        factory = factory_;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>    function collectProtocolFees(</span>
 126 |     | <span class='neutral'>        address[] calldata pools</span>
 127 |     | <span class='unexecuted'>    ) external {</span>
 128 |     | <span class='unexecuted'>        if (pools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 129 |     | <span class='unexecuted'>        uint128[] memory token0FeesCollected = new uint128[](pools.length);</span>
 130 |     | <span class='unexecuted'>        uint128[] memory token1FeesCollected = new uint128[](pools.length);</span>
 131 |     | <span class='neutral'>        // pass empty fees params</span>
 132 |     | <span class='unexecuted'>        FeesParams memory feesParams;</span>
 133 |     | <span class='unexecuted'>        for (uint i; i &lt; pools.length;) {</span>
 134 |     | <span class='unexecuted'>            (</span>
 135 |     | <span class='unexecuted'>                token0FeesCollected[i],</span>
 136 |     | <span class='unexecuted'>                token1FeesCollected[i]</span>
 137 |     | <span class='unexecuted'>            ) = IPool(pools[i]).fees(feesParams);</span>
 138 |     | <span class='neutral'>            unchecked {</span>
 139 |     | <span class='unexecuted'>                ++i;</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(pools, token0FeesCollected, token1FeesCollected);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>    // protocol fee flags</span>
 146 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_0 = 2**0;</span>
 147 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_SWAP_FEE_1 = 2**1;</span>
 148 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_0 = 2**2;</span>
 149 |     | <span class='unexecuted'>    uint8 internal constant PROTOCOL_FILL_FEE_1 = 2**3;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>    function modifyProtocolFees(</span>
 152 |     | <span class='neutral'>        address[] calldata pools,</span>
 153 |     | <span class='neutral'>        FeesParams[] calldata feesParams</span>
 154 |     | <span class='unexecuted'>    ) external onlyOwner {</span>
 155 |     | <span class='unexecuted'>        if (pools.length == 0) require (false, &#39;EmptyPoolsArray()&#39;);</span>
 156 |     | <span class='unexecuted'>        if (pools.length != feesParams.length) {</span>
 157 |     | <span class='unexecuted'>            require (false, &#39;MismatchedArrayLengths()&#39;);</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='unexecuted'>        uint128[] memory token0FeesCollected = new uint128[](pools.length);</span>
 160 |     | <span class='unexecuted'>        uint128[] memory token1FeesCollected = new uint128[](pools.length);</span>
 161 |     | <span class='unexecuted'>        uint16[] memory protocolSwapFees0 = new uint16[](pools.length);</span>
 162 |     | <span class='unexecuted'>        uint16[] memory protocolSwapFees1 = new uint16[](pools.length);</span>
 163 |     | <span class='unexecuted'>        uint16[] memory protocolFillFees0 = new uint16[](pools.length);</span>
 164 |     | <span class='unexecuted'>        uint16[] memory protocolFillFees1 = new uint16[](pools.length);</span>
 165 |     | <span class='unexecuted'>        for (uint i; i &lt; pools.length;) {</span>
 166 |     | <span class='unexecuted'>            (</span>
 167 |     | <span class='unexecuted'>                token0FeesCollected[i],</span>
 168 |     | <span class='unexecuted'>                token1FeesCollected[i]</span>
 169 |     | <span class='unexecuted'>            ) = IPool(pools[i]).fees(</span>
 170 |     | <span class='unexecuted'>                feesParams[i]</span>
 171 |     | <span class='neutral'>            );</span>
 172 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_SWAP_FEE_0) &gt; 0) {</span>
 173 |     | <span class='unexecuted'>                protocolSwapFees0[i] = feesParams[i].protocolSwapFee0;</span>
 174 |     | <span class='neutral'>            }</span>
 175 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_SWAP_FEE_1) &gt; 0) {</span>
 176 |     | <span class='unexecuted'>                protocolSwapFees1[i] = feesParams[i].protocolSwapFee1;</span>
 177 |     | <span class='neutral'>            }</span>
 178 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_FILL_FEE_0) &gt; 0) {</span>
 179 |     | <span class='unexecuted'>                protocolFillFees0[i] = feesParams[i].protocolFillFee0;</span>
 180 |     | <span class='neutral'>            }</span>
 181 |     | <span class='unexecuted'>            if ((feesParams[i].setFeesFlags &amp; PROTOCOL_FILL_FEE_1) &gt; 0) {</span>
 182 |     | <span class='unexecuted'>                protocolFillFees1[i] = feesParams[i].protocolFillFee1;</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>            // else values will remain zero</span>
 185 |     | <span class='neutral'>            unchecked {</span>
 186 |     | <span class='unexecuted'>                ++i;</span>
 187 |     | <span class='neutral'>            }</span>
 188 |     | <span class='neutral'>        }</span>
 189 |     | <span class='unexecuted'>        emit ProtocolSwapFeesModified(</span>
 190 |     | <span class='unexecuted'>            pools,</span>
 191 |     | <span class='unexecuted'>            protocolSwapFees0,</span>
 192 |     | <span class='unexecuted'>            protocolSwapFees1</span>
 193 |     | <span class='neutral'>        );</span>
 194 |     | <span class='unexecuted'>        emit ProtocolFillFeesModified(</span>
 195 |     | <span class='unexecuted'>            pools,</span>
 196 |     | <span class='unexecuted'>            protocolFillFees0,</span>
 197 |     | <span class='unexecuted'>            protocolFillFees1</span>
 198 |     | <span class='neutral'>        );</span>
 199 |     | <span class='unexecuted'>        emit ProtocolFeesCollected(</span>
 200 |     | <span class='unexecuted'>            pools,</span>
 201 |     | <span class='unexecuted'>            token0FeesCollected,</span>
 202 |     | <span class='unexecuted'>            token1FeesCollected</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function implementations(</span>
 207 |     | <span class='neutral'>        bytes32 key</span>
 208 |     | <span class='neutral'>    ) external view returns (</span>
 209 |     | <span class='unexecuted'>        address,</span>
 210 |     | <span class='unexecuted'>        address</span>
 211 |     | <span class='neutral'>    ) {</span>
 212 |     | <span class='unexecuted'>        return (_poolImpls[key], _tokenImpls[key]);</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>    function feeTiers(</span>
 216 |     | <span class='neutral'>        uint16 swapFee</span>
 217 |     | <span class='neutral'>    ) external view returns (</span>
 218 |     | <span class='unexecuted'>        int16 tickSpacing</span>
 219 |     | <span class='neutral'>    ) {</span>
 220 |     | <span class='unexecuted'>        return _feeTiers[swapFee];</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>    </span>
 223 |     | <span class='neutral'>    /**</span>
 224 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 225 |     | <span class='neutral'>     */</span>
 226 |     | <span class='unexecuted'>    function _checkOwner() internal view {</span>
 227 |     | <span class='unexecuted'>        if (owner != msg.sender) require (false, &#39;OwnerOnly()&#39;);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /**</span>
 231 |     | <span class='neutral'>     * @dev Throws if the sender is not the feeTo.</span>
 232 |     | <span class='neutral'>     */</span>
 233 |     | <span class='unexecuted'>    function _checkFeeTo() internal view {</span>
 234 |     | <span class='unexecuted'>        if (feeTo != msg.sender) require (false, &#39;FeeToOnly()&#39;);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/home/ec2-user/git/limit/contracts/utils/PositionERC1155.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>pragma solidity 0.8.13;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &#39;../interfaces/IPool.sol&#39;;</span>
   6 |     | <span class='neutral'>import &quot;./LimitPoolErrors.sol&quot;;</span>
   7 |     | <span class='neutral'>import &#39;../base/storage/PositionERC1155Immutables.sol&#39;;</span>
   8 |     | <span class='neutral'>import &quot;../interfaces/IPositionERC1155.sol&quot;;</span>
   9 |     | <span class='neutral'>import &#39;../libraries/solady/LibClone.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>// needs to be deployed as a separate clone</span>
  12 |     | <span class='neutral'>// poolImpls; tokenImpls</span>
  13 |     | <span class='neutral'>// store address in Immutables struct</span>
  14 |     | <span class='neutral'>// emit token address on created pool</span>
  15 |     | <span class='neutral'>// launch an ERC1155 template to track events on Subgraph</span>
  16 |     | <span class='neutral'>// emitting msg.sender will give the pool address</span>
  17 |     | <span class='neutral'>// can verify the owner is the pool address designated based on immutables</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>contract PositionERC1155 is</span>
  20 |     | <span class='neutral'>    IPositionERC1155,</span>
  21 |     | <span class='neutral'>    PositionERC1155Immutables,</span>
  22 |     | <span class='neutral'>    PositionERC1155Errors </span>
  23 |     | <span class='neutral'>{</span>
  24 |     | <span class='neutral'>    error OwnerOnly();</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    address public immutable factory;</span>
  27 |     | <span class='unexecuted'>    address public immutable original;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>    constructor(</span>
  30 |     | <span class='neutral'>        address factory_</span>
  31 |     | <span class='neutral'>    ) {</span>
  32 |     | <span class='unexecuted'>        factory = factory_;</span>
  33 |     | <span class='unexecuted'>        original = address(this);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /// @dev token id =&gt; owner =&gt; balance</span>
  37 |     | <span class='neutral'>    mapping(uint256 =&gt; mapping(address =&gt; uint256)) private _tokenBalances;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @dev owner =&gt; spender =&gt; approved</span>
  40 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _spenderApprovals;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @dev token id =&gt; total supply</span>
  43 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private _totalSupplyById;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private constant _NAME = &quot;Poolshark LP&quot;;</span>
  46 |     | <span class='neutral'>    string private constant _SYMBOL = &quot;PSHARK-LP&quot;;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    modifier onlyCanonicalClones(</span>
  49 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  50 |     | <span class='neutral'>    ) {</span>
  51 |     | <span class='unexecuted'>        if(!_onlyCanonicalPools(constants)) require (false, &#39;CanoncialPoolsOnly()&#39;);</span>
  52 |     | <span class='unexecuted'>        if(!_onlyCanonicalPoolTokens(constants)) require (false, &#39;CanoncialPoolTokensOnly()&#39;);</span>
  53 |     | <span class='unexecuted'>        _;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    modifier checkApproval(address _from, address _spender) {</span>
  57 |     | <span class='unexecuted'>        if (_from != _spender)</span>
  58 |     | <span class='unexecuted'>            if(!_isApprovedForAll(_from, _spender)) </span>
  59 |     | <span class='unexecuted'>                revert SpenderNotApproved(_from, _spender);</span>
  60 |     | <span class='unexecuted'>        _;</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    modifier checkAddresses(address _from, address _to) {</span>
  64 |     | <span class='unexecuted'>        if (_from == address(0) || _to == address(0)) revert TransferFromOrToAddress0();</span>
  65 |     | <span class='unexecuted'>        if (_from == _to) revert TransferToSelf();</span>
  66 |     | <span class='unexecuted'>        _;</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    modifier checkLength(uint256 _lengthA, uint256 _lengthB) {</span>
  70 |     | <span class='unexecuted'>        if (_lengthA != _lengthB) revert LengthMismatch(_lengthA, _lengthB);</span>
  71 |     | <span class='unexecuted'>        _;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    modifier checkERC1155Support(address recipient) {</span>
  75 |     | <span class='unexecuted'>        if (!_verifyERC1155Support(recipient)) revert ERC1155NotSupported();</span>
  76 |     | <span class='neutral'>        _;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>    function mint(</span>
  80 |     | <span class='neutral'>        address _account,</span>
  81 |     | <span class='neutral'>        uint256 _id,</span>
  82 |     | <span class='neutral'>        uint256 _amount,</span>
  83 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  84 |     | <span class='neutral'>    ) external </span>
  85 |     | <span class='unexecuted'>        onlyCanonicalClones(constants)</span>
  86 |     | <span class='unexecuted'>        checkERC1155Support(_account)</span>
  87 |     | <span class='neutral'>    {</span>
  88 |     | <span class='unexecuted'>        _mint(_account, _id, _amount);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    function burn(</span>
  92 |     | <span class='neutral'>        address _account,</span>
  93 |     | <span class='neutral'>        uint256 _id,</span>
  94 |     | <span class='neutral'>        uint256 _amount,</span>
  95 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
  96 |     | <span class='neutral'>    ) external</span>
  97 |     | <span class='unexecuted'>        onlyCanonicalClones(constants)</span>
  98 |     | <span class='neutral'>    {</span>
  99 |     | <span class='unexecuted'>        _burn(_account, _id, _amount);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>    function setApprovalForAll(address _spender, bool _approved) public virtual override {</span>
 103 |     | <span class='unexecuted'>        _setApprovalForAll(msg.sender, _spender, _approved);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
 107 |     | <span class='neutral'>        address _from,</span>
 108 |     | <span class='neutral'>        address _to,</span>
 109 |     | <span class='neutral'>        uint256 _id,</span>
 110 |     | <span class='neutral'>        uint256 _amount</span>
 111 |     | <span class='neutral'>    ) public virtual override</span>
 112 |     | <span class='unexecuted'>        checkAddresses(_from, _to)</span>
 113 |     | <span class='unexecuted'>        checkApproval(_from, msg.sender)</span>
 114 |     | <span class='unexecuted'>        checkERC1155Support(_to)</span>
 115 |     | <span class='unexecuted'>    {</span>
 116 |     | <span class='unexecuted'>        address _spender = msg.sender;</span>
 117 |     | <span class='unexecuted'>        _transfer(_from, _to, _id, _amount);</span>
 118 |     | <span class='unexecuted'>        emit TransferSingle(_spender, _from, _to, _id, _amount);</span>
 119 |     | <span class='neutral'>    }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>    function safeBatchTransferFrom(</span>
 122 |     | <span class='neutral'>        address _from,</span>
 123 |     | <span class='neutral'>        address _to,</span>
 124 |     | <span class='neutral'>        uint256[] calldata _ids,</span>
 125 |     | <span class='neutral'>        uint256[] calldata _amounts</span>
 126 |     | <span class='neutral'>    ) public virtual override</span>
 127 |     | <span class='unexecuted'>        checkLength(_ids.length, _amounts.length)</span>
 128 |     | <span class='unexecuted'>        checkAddresses(_from, _to)</span>
 129 |     | <span class='unexecuted'>        checkApproval(_from, msg.sender)</span>
 130 |     | <span class='unexecuted'>        checkERC1155Support(_to)</span>
 131 |     | <span class='neutral'>    {</span>
 132 |     | <span class='neutral'>        unchecked {</span>
 133 |     | <span class='unexecuted'>            for (uint256 i; i &lt; _ids.length; ++i) {</span>
 134 |     | <span class='unexecuted'>                _transfer(_from, _to, _ids[i], _amounts[i]);</span>
 135 |     | <span class='neutral'>            }</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='unexecuted'>        emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {</span>
 141 |     | <span class='unexecuted'>        return _isApprovedForAll(_owner, _spender);</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {</span>
 145 |     | <span class='unexecuted'>      return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support</span>
 146 |     | <span class='unexecuted'>              interfaceID == 0xd9b67a26;      // ERC-1155 support</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>    function name() public pure virtual override returns (string memory) {</span>
 150 |     | <span class='unexecuted'>        return _NAME;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function symbol() public pure virtual override returns (string memory) {</span>
 154 |     | <span class='unexecuted'>        return _SYMBOL;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>    function totalSupply(uint256 _id) public view virtual override returns (uint256) {</span>
 158 |     | <span class='unexecuted'>        return _totalSupplyById[_id];</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='unexecuted'>    function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {</span>
 162 |     | <span class='unexecuted'>        return _tokenBalances[_id][_account];</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>    function balanceOfBatch(</span>
 166 |     | <span class='neutral'>        address[] calldata _accounts,</span>
 167 |     | <span class='neutral'>        uint256[] calldata _ids</span>
 168 |     | <span class='neutral'>    ) public view virtual override</span>
 169 |     | <span class='unexecuted'>        checkLength(_accounts.length, _ids.length)</span>
 170 |     | <span class='unexecuted'>        returns (uint256[] memory batchBalances)</span>
 171 |     | <span class='neutral'>    {</span>
 172 |     | <span class='unexecuted'>        batchBalances = new uint256[](_accounts.length);</span>
 173 |     | <span class='neutral'>        unchecked {</span>
 174 |     | <span class='unexecuted'>            for (uint256 i; i &lt; _accounts.length; ++i) {</span>
 175 |     | <span class='unexecuted'>                batchBalances[i] = balanceOf(_accounts[i], _ids[i]);</span>
 176 |     | <span class='neutral'>            }</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    function _mint(</span>
 181 |     | <span class='neutral'>        address _account,</span>
 182 |     | <span class='neutral'>        uint256 _id,</span>
 183 |     | <span class='neutral'>        uint256 _amount</span>
 184 |     | <span class='unexecuted'>    ) internal virtual {</span>
 185 |     | <span class='unexecuted'>        if (_account == address(0)) revert MintToAddress0();</span>
 186 |     | <span class='unexecuted'>        _beforeTokenTransfer(address(0), _account, _id, _amount);</span>
 187 |     | <span class='unexecuted'>        _totalSupplyById[_id] += _amount;</span>
 188 |     | <span class='unexecuted'>        uint256 _accountBalance = _tokenBalances[_id][_account];</span>
 189 |     | <span class='neutral'>        unchecked {</span>
 190 |     | <span class='unexecuted'>            _tokenBalances[_id][_account] = _accountBalance + _amount;</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='unexecuted'>        emit TransferSingle(msg.sender, address(0), _account, _id, _amount);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>    function _burn(</span>
 196 |     | <span class='neutral'>        address _account,</span>
 197 |     | <span class='neutral'>        uint256 _id,</span>
 198 |     | <span class='neutral'>        uint256 _amount</span>
 199 |     | <span class='unexecuted'>    ) internal virtual {</span>
 200 |     | <span class='unexecuted'>        if (_account == address(0)) revert BurnFromAddress0();</span>
 201 |     | <span class='unexecuted'>        uint256 _accountBalance = _tokenBalances[_id][_account];</span>
 202 |     | <span class='unexecuted'>        if (_accountBalance &lt; _amount) revert BurnExceedsBalance(_account, _id, _amount);</span>
 203 |     | <span class='unexecuted'>        _beforeTokenTransfer(_account, address(0), _id, _amount);</span>
 204 |     | <span class='neutral'>        unchecked {</span>
 205 |     | <span class='unexecuted'>            _tokenBalances[_id][_account] = _accountBalance - _amount;</span>
 206 |     | <span class='unexecuted'>            _totalSupplyById[_id] -= _amount;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='unexecuted'>        emit TransferSingle(msg.sender, _account, address(0), _id, _amount);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>    function _transfer(</span>
 212 |     | <span class='neutral'>        address _from,</span>
 213 |     | <span class='neutral'>        address _to,</span>
 214 |     | <span class='neutral'>        uint256 _id,</span>
 215 |     | <span class='neutral'>        uint256 _amount</span>
 216 |     | <span class='unexecuted'>    ) internal virtual {</span>
 217 |     | <span class='unexecuted'>        uint256 _fromBalance = _tokenBalances[_id][_from];</span>
 218 |     | <span class='unexecuted'>        if (_fromBalance &lt; _amount) revert TransferExceedsBalance(_from, _id, _amount);</span>
 219 |     | <span class='unexecuted'>        _beforeTokenTransfer(_from, _to, _id, _amount);</span>
 220 |     | <span class='neutral'>        unchecked {</span>
 221 |     | <span class='unexecuted'>            _tokenBalances[_id][_from] = _fromBalance - _amount;</span>
 222 |     | <span class='neutral'>        }</span>
 223 |     | <span class='unexecuted'>        uint256 _toBalance = _tokenBalances[_id][_to];</span>
 224 |     | <span class='neutral'>        unchecked {</span>
 225 |     | <span class='unexecuted'>            _tokenBalances[_id][_to] = _toBalance + _amount;</span>
 226 |     | <span class='neutral'>        }</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function _setApprovalForAll(</span>
 230 |     | <span class='neutral'>        address _owner,</span>
 231 |     | <span class='neutral'>        address _spender,</span>
 232 |     | <span class='neutral'>        bool _approved</span>
 233 |     | <span class='neutral'>    ) internal virtual {</span>
 234 |     | <span class='unexecuted'>        if (_owner == _spender) revert SelfApproval(_owner);</span>
 235 |     | <span class='unexecuted'>        _spenderApprovals[_owner][_spender] = _approved;</span>
 236 |     | <span class='unexecuted'>        emit ApprovalForAll(_owner, _spender, _approved);</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='unexecuted'>    function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {</span>
 240 |     | <span class='unexecuted'>        return _owner == _spender || _spenderApprovals[_owner][_spender];</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    /// @notice Hook that is called before any token transfer.</span>
 244 |     | <span class='unexecuted'>    function _beforeTokenTransfer(</span>
 245 |     | <span class='neutral'>        address from,</span>
 246 |     | <span class='neutral'>        address to,</span>
 247 |     | <span class='neutral'>        uint256 id,</span>
 248 |     | <span class='neutral'>        uint256 amount</span>
 249 |     | <span class='neutral'>    ) internal virtual {}</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='unexecuted'>    function _onlyCanonicalPoolTokens(</span>
 252 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 253 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 254 |     | <span class='neutral'>        // generate key for pool</span>
 255 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 256 |     | <span class='unexecuted'>            poolImpl(),</span>
 257 |     | <span class='unexecuted'>            constants.token0,</span>
 258 |     | <span class='unexecuted'>            constants.token1,</span>
 259 |     | <span class='unexecuted'>            constants.swapFee</span>
 260 |     | <span class='neutral'>        ));</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        // compute address</span>
 263 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 264 |     | <span class='unexecuted'>            original,</span>
 265 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 266 |     | <span class='unexecuted'>                poolImpl()</span>
 267 |     | <span class='neutral'>            ),</span>
 268 |     | <span class='unexecuted'>            key,</span>
 269 |     | <span class='unexecuted'>            factory</span>
 270 |     | <span class='neutral'>        );</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>        if (predictedAddress != address(this)) return false;</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        return true;</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>    function _onlyCanonicalPools(</span>
 278 |     | <span class='neutral'>        PoolsharkStructs.Immutables memory constants</span>
 279 |     | <span class='unexecuted'>    ) private view returns (bool) {</span>
 280 |     | <span class='neutral'>        // generate key for pool</span>
 281 |     | <span class='unexecuted'>        bytes32 key = keccak256(abi.encode(</span>
 282 |     | <span class='unexecuted'>            poolImpl(),</span>
 283 |     | <span class='unexecuted'>            constants.token0,</span>
 284 |     | <span class='unexecuted'>            constants.token1,</span>
 285 |     | <span class='unexecuted'>            constants.swapFee</span>
 286 |     | <span class='neutral'>        ));</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>        // compute address</span>
 289 |     | <span class='unexecuted'>        address predictedAddress = LibClone.predictDeterministicAddress(</span>
 290 |     | <span class='unexecuted'>            poolImpl(),</span>
 291 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 292 |     | <span class='unexecuted'>                constants.owner,</span>
 293 |     | <span class='unexecuted'>                constants.token0,</span>
 294 |     | <span class='unexecuted'>                constants.token1,</span>
 295 |     | <span class='unexecuted'>                constants.poolToken,</span>
 296 |     | <span class='unexecuted'>                constants.bounds.min,</span>
 297 |     | <span class='unexecuted'>                constants.bounds.max,</span>
 298 |     | <span class='unexecuted'>                constants.genesisTime,</span>
 299 |     | <span class='unexecuted'>                constants.tickSpacing,</span>
 300 |     | <span class='unexecuted'>                constants.swapFee</span>
 301 |     | <span class='neutral'>            ),</span>
 302 |     | <span class='unexecuted'>            key,</span>
 303 |     | <span class='unexecuted'>            factory</span>
 304 |     | <span class='neutral'>        );</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='unexecuted'>        if (predictedAddress != msg.sender) return false;</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='unexecuted'>        return true;</span>
 309 |     | <span class='neutral'>    }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>    /// @notice Return if the `_target` contract supports ERC-1155 interface</span>
 312 |     | <span class='neutral'>    /// @param _target The address of the contract</span>
 313 |     | <span class='neutral'>    /// @return supported Whether the contract is supported (true) or not (false)</span>
 314 |     | <span class='unexecuted'>    function _verifyERC1155Support(address _target) private view returns (bool supported) {</span>
 315 |     | <span class='unexecuted'>        if (_target.code.length == 0) return true;</span>
 316 |     | <span class='unexecuted'>        bytes memory encodedParams = abi.encodeWithSelector(</span>
 317 |     | <span class='unexecuted'>            IERC165.supportsInterface.selector,</span>
 318 |     | <span class='unexecuted'>            type(IPositionERC1155).interfaceId</span>
 319 |     | <span class='neutral'>        );</span>
 320 |     | <span class='unexecuted'>        (bool success, bytes memory result) = _target.staticcall{gas: 30_000}(encodedParams);</span>
 321 |     | <span class='unexecuted'>        if (result.length &lt; 32) return false;</span>
 322 |     | <span class='unexecuted'>        return success &amp;&amp; abi.decode(result, (bool));</span>
 323 |     | <span class='neutral'>    }</span>
 324 |     | <span class='neutral'>}</span>

</code>
<br />

