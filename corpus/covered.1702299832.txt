/root/git/limit/contracts/LimitEchidnaPool.sol
    1 |     | // SPDX-License-Identifier: BUSL-1.1
    2 |     | pragma solidity 0.8.13;
    3 |     | 
    4 |     | import './LimitPool.sol';
    5 |     | import './LimitPoolFactory.sol';
    6 |     | import './test/Token20.sol';
    7 |     | import './libraries/utils/SafeTransfers.sol';
    8 |     | import './utils/PositionERC1155.sol';
    9 |     | import './utils/LimitPoolManager.sol';
   10 |     | import './utils/PoolsharkRouter.sol';
   11 |     | import './interfaces/structs/PoolsharkStructs.sol';
   12 |     | 
   13 |     | // Fuzz LimitPool functionality
   14 | *r  | contract EchidnaPool {
   15 |     | 
   16 |     |     event PassedMint();
   17 |     |     event PassedBurn();
   18 |     |     event PassedMintRange();
   19 |     |     event PassedBurnRange();
   20 |     |     event Prices(uint160 price0, uint160 price1);
   21 |     |     event LiquidityGlobal(uint128 liqBefore, uint128 liqAfter);
   22 |     |     event Liquidity(uint128 liq0Before, uint128 liq1Before, uint128 liq0After, uint128 liq1After);
   23 |     |     event LiquidityRange(uint128 liqBefore, uint128 liqAfter);
   24 |     |     event PositionTicks(int24 lower, int24 upper);
   25 |     |     event BurnTicks(int24 lower, int24 upper, bool positionExists);
   26 |     |     event LiquidityMinted(uint256 amount, uint256 tokenAmount, bool zeroForOne);
   27 |     |     event PositionCreated(bool isCreated);
   28 |     |     event LiquidityAbsoluteNoPosCreated(uint128 beforeAbs, uint128 afterAbs);
   29 |     |     event LiquidityAbsoluteNoPosCreatedPriceCheck(uint256 priceBefore, uint256 priceTick, uint256 priceAfter);
   30 |     |     event LiquidityAbsolutePosCreated(uint128 beforeAbs, uint128 afterAbs);
   31 |     |     event LiquidityAbsoluteLower(uint128 beforeAbs, uint128 afterAbs);
   32 |     |     event LiquidityAbsoluteUpper(uint128 beforeAbs, uint128 afterAbs);
   33 |     |     event LiquidityDeltaAndAbsolute(int128 delta, uint128 abs);
   34 |     |     event PriceChange(uint160 priceBefore, uint160 priceAfter);
   35 |     |     event PositionIdNext(uint32 idNextBefore, uint32 idNextAfter);
   36 |     |     event LimitCallbackOnEchidnaPool(uint256 amount0, uint256 amount1);
   37 |     |     event RangeCallbackOnEchidnaPool(uint256 amount0, uint256 amount1);
   38 |     |     event GetResizedTicks(address pool);
   39 |     |     event MsgSenderPool(address sender, address thisAddress);
   40 |     |     event PriceCheck0(uint160 priceBefore, uint160 priceAfter, uint256 upperPrice);
   41 |     |     event PriceCheck1(uint160 priceBefore, uint160 priceAfter, uint256 lowerPrice);
   42 |     | 
   43 |     |     int16 tickSpacing;
   44 |     |     uint16 swapFee;
   45 |     |     address private immutable poolImpl;
   46 |     |     address private immutable tokenImpl;
   47 |     |     LimitPoolFactory private immutable factory;
   48 |     |     LimitPoolManager private immutable manager;
   49 |     |     PoolsharkRouter private immutable router;
   50 |     |     LimitPool private pool;
   51 |     |     PositionERC1155 private immutable token;
   52 |     |     Token20 private tokenIn;
   53 |     |     Token20 private tokenOut;
   54 |     |     LimitPosition[] private limitPositions;
   55 |     |     RangePosition[] private rangePositions;
   56 |     | 
   57 |     |     struct MintLimitArgs {
   58 |     |         address[] pools;
   59 |     |         PoolsharkStructs.MintLimitParams[] params;
   60 |     |     }
   61 |     | 
   62 |     |     struct MintRangeArgs {
   63 |     |         address[] pools;
   64 |     |         PoolsharkStructs.MintRangeParams[] params;
   65 |     |     }
   66 |     | 
   67 |     |     struct SwapArgs {
   68 |     |         address[] pools;
   69 |     |         PoolsharkStructs.SwapParams[] params;
   70 |     |     }
   71 |     | 
   72 |     |     struct LimitPoolValues {
   73 |     | 
   74 |     |         // global state
   75 |     |         PoolsharkStructs.GlobalState globalStateBefore;
   76 |     |         PoolsharkStructs.GlobalState globalStateAfter;
   77 |     | 
   78 |     |         // lower tick
   79 |     |         PoolsharkStructs.LimitTick lowerTickBefore;
   80 |     |         PoolsharkStructs.LimitTick lowerTickAfter;
   81 |     | 
   82 |     |         // upper tick
   83 |     |         PoolsharkStructs.LimitTick upperTickBefore;
   84 |     |         PoolsharkStructs.LimitTick upperTickAfter;
   85 |     | 
   86 |     |         // pool0
   87 |     |         PoolsharkStructs.LimitPoolState pool0Before;
   88 |     |         PoolsharkStructs.LimitPoolState pool0After;
   89 |     | 
   90 |     |         // pool1
   91 |     |         PoolsharkStructs.LimitPoolState pool1Before;
   92 |     |         PoolsharkStructs.LimitPoolState pool1After;
   93 |     | 
   94 |     |         // constants
   95 |     |         PoolsharkStructs.LimitImmutables constants;
   96 |     |     }
   97 |     | 
   98 |     |     struct RangePoolValues {
   99 |     |         uint256 liquidityMinted;
  100 |     |         PoolsharkStructs.LimitImmutables constants;
  101 |     | 
  102 |     |         // global state
  103 |     |         PoolsharkStructs.GlobalState globalStateBefore;
  104 |     |         PoolsharkStructs.GlobalState globalStateAfter;
  105 |     | 
  106 |     |         // lower tick
  107 |     |         PoolsharkStructs.RangeTick lowerTickBefore;
  108 |     |         PoolsharkStructs.RangeTick lowerTickAfter;
  109 |     | 
  110 |     |         // upper tick
  111 |     |         PoolsharkStructs.RangeTick upperTickBefore;
  112 |     |         PoolsharkStructs.RangeTick upperTickAfter;
  113 |     | 
  114 |     |         // pool
  115 |     |         PoolsharkStructs.RangePoolState poolBefore;
  116 |     |         PoolsharkStructs.RangePoolState poolAfter;
  117 |     |     }
  118 |     | 
  119 |     |     struct SwapCallbackData {
  120 |     |         address sender;
  121 |     |     }
  122 |     | 
  123 |     |     struct LimitPosition {
  124 |     |         address owner;
  125 |     |         uint32 positionId;
  126 |     |         int24 lower;
  127 |     |         int24 upper;
  128 |     |         bool zeroForOne;
  129 |     |     }
  130 |     | 
  131 |     |     struct RangePosition {
  132 |     |         address owner;
  133 |     |         uint32 positionId;
  134 |     |         int24 lower;
  135 |     |         int24 upper;
  136 |     |     }
  137 |     | 
  138 |     |     modifier tickPreconditions(int24 lower, int24 upper) {
  139 | *r  |         require(lower < upper);
  140 | *r  |         require(upper < 887272);
  141 | *r  |         require(lower > -887272);
  142 | *r  |         require(lower % tickSpacing == 0);
  143 | *r  |         require(upper % tickSpacing == 0);
  144 |     |         _;
  145 |     |     }
  146 |     | 
  147 |     |     constructor() {
  148 |     |         manager = new LimitPoolManager();
  149 |     |         factory = new LimitPoolFactory(address(manager));
  150 |     |         router = new PoolsharkRouter(address(factory), address(0), address(0));
  151 |     |         poolImpl = address(new LimitPool(address(factory)));
  152 |     |         tokenImpl = address(new PositionERC1155(address(factory)));
  153 |     |         
  154 |     |         manager.enablePoolType(address(poolImpl), address(tokenImpl), bytes32(uint256(0x1)));
  155 |     |         manager.enableFeeTier(500, 10);
  156 |     |         tickSpacing = 10;
  157 |     |         tokenIn = new Token20("IN", "IN", 18);
  158 |     |         tokenOut = new Token20("OUT", "OUT", 18);
  159 |     | 
  160 |     |         PoolsharkStructs.LimitPoolParams memory params;
  161 |     |         params.poolTypeId = 0;
  162 |     |         params.tokenIn = address(tokenIn);
  163 |     |         params.tokenOut = address(tokenOut);
  164 |     |         params.swapFee = 500;
  165 |     |         params.startPrice = 79228162514264337593543950336;
  166 |     |         (address poolAddr, address tokenAddr) = factory.createLimitPool(params);
  167 |     |         pool = LimitPool(poolAddr);
  168 |     |         token = PositionERC1155(tokenAddr);
  169 |     |     }
  170 |     | 
  171 |     |     // LIMIT CALLS
  172 |     | 
  173 | *   |     function mintLimit(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
  174 |     |         // PRE CONDITIONS
  175 | *   |         mintAndApprove();
  176 | *   |         amount = amount + 1;
  177 |     |         // Ensure the newly created position is using different ticks
  178 | *   |         for(uint i = 0; i < limitPositions.length;) {
  179 | *   |             if(limitPositions[i].owner == msg.sender && limitPositions[i].lower == lower && limitPositions[i].upper == upper && limitPositions[i].zeroForOne == zeroForOne) {
  180 | *r  |                 revert("Position already exists");
  181 |     |             }
  182 |     |             unchecked {
  183 | *   |                 ++i;
  184 |     |             }
  185 |     |         }
  186 |     | 
  187 | *   |         LimitPoolValues memory values;
  188 |     | 
  189 | *   |         values.globalStateBefore = pool.getGlobalState();
  190 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  191 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  192 |     | 
  193 | *   |         LimitPoolStructs.MintLimitParams memory params;
  194 | *   |         params.to = msg.sender;
  195 | *   |         params.amount = amount;
  196 | *   |         params.mintPercent = 0;
  197 | *   |         params.lower = lower;
  198 | *   |         params.upper = upper;
  199 | *   |         params.zeroForOne = zeroForOne;
  200 |     | 
  201 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
  202 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
  203 | *   |         bool posCreated;
  204 | *   |         emit GetResizedTicks(address(this));
  205 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
  206 | *   |         emit PositionTicks(lower, upper);
  207 | *   |         emit PositionCreated(posCreated);
  208 |     | 
  209 | *   |         (, values.lowerTickBefore) = pool.ticks(lower);
  210 | *   |         (, values.upperTickBefore) = pool.ticks(upper);
  211 |     | 
  212 |     |         // ACTION
  213 | *   |         MintLimitArgs memory args;
  214 | *   |         args.pools = new address[](1);
  215 | *   |         args.pools[0] = address(pool);
  216 | *   |         args.params = new PoolsharkStructs.MintLimitParams[](1);
  217 | *   |         args.params[0] = params;
  218 | *r  |         router.multiMintLimit(args.pools, args.params);
  219 | *   |         if (posCreated) limitPositions.push(LimitPosition(msg.sender, values.globalStateBefore.positionIdNext, lower, upper, zeroForOne));
  220 |     | 
  221 | *   |         (, values.lowerTickAfter) = pool.ticks(lower);
  222 | *   |         (, values.upperTickAfter) = pool.ticks(upper);
  223 |     | 
  224 | *   |         values.globalStateAfter = pool.getGlobalState();
  225 | *   |         values.pool0After = values.globalStateAfter.pool0;
  226 | *   |         values.pool1After = values.globalStateAfter.pool1;
  227 |     |         
  228 |     |         // POST CONDITIONS
  229 |     | 
  230 |     |         // Ensure prices have not crossed
  231 | *   |         emit Prices(values.pool0After.price, values.pool1After.price);
  232 | *   |         assert(values.pool0After.price >= values.pool1After.price);
  233 |     | 
  234 |     |         // Ensure liquidityDelta is always less or equal to liquidityAbsolute
  235 | *   |         emit LiquidityDeltaAndAbsolute(values.lowerTickAfter.liquidityDelta, values.lowerTickAfter.liquidityAbsolute);
  236 | *   |         assert(int256(values.lowerTickAfter.liquidityDelta) <= int256(uint256(values.lowerTickAfter.liquidityAbsolute)));
  237 | *   |         emit LiquidityDeltaAndAbsolute(values.upperTickAfter.liquidityDelta, values.upperTickAfter.liquidityAbsolute);
  238 | *   |         assert(int256(values.upperTickAfter.liquidityDelta) <= int256(uint256(values.upperTickAfter.liquidityAbsolute)));
  239 |     |         
  240 |     |         // Ensure that liquidityAbsolute is incremented when not undercutting
  241 | *   |         if (posCreated) {
  242 |     |             // positionIdNext should have been incremented
  243 | *   |             emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);
  244 | *   |             assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext + 1);
  245 | *   |             if(zeroForOne){
  246 | *   |                 if(values.pool0After.price >= values.pool0Before.price){
  247 |     |                     // ensure liquidityAbsolute is strictly greater
  248 |     |                     //TODO: could be falsified if liquidity cleared out
  249 | *   |                     emit LiquidityAbsolutePosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);
  250 | *   |                     assert(values.upperTickAfter.liquidityAbsolute > values.upperTickBefore.liquidityAbsolute);
  251 |     |                 }
  252 |     |             } else {
  253 | *   |                 if(values.pool1Before.price >= values.pool1After.price){
  254 |     |                     // ensure liquidityAbsolute is strictly greater
  255 |     |                     //TODO: could be falsified if liquidity cleared out
  256 | *   |                     emit LiquidityAbsolutePosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);
  257 | *   |                     assert(values.lowerTickAfter.liquidityAbsolute > values.lowerTickBefore.liquidityAbsolute);
  258 |     |                 }
  259 |     |             }
  260 |     |         } else {
  261 |     |             // positionIdNext should not have been incremented
  262 | *   |             emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);
  263 | *   |             assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext);
  264 | *   |             if(zeroForOne){
  265 | *   |                 if(values.pool0After.price >= values.pool0Before.price){
  266 |     |                     // ensure liquidityAbsolute is strictly equal
  267 | *   |                     emit LiquidityAbsoluteNoPosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);
  268 | *   |                     values.constants = pool.immutables();
  269 | *   |                     uint256 upperPrice = ConstantProduct.getPriceAtTick(upper, values.constants);
  270 | *   |                     emit PriceCheck0(values.pool0Before.price, values.pool1After.price, upperPrice);
  271 | *   |                     if (values.pool1Before.price >= upperPrice && values.pool1After.price <= upperPrice) {
  272 | *   |                         assert(values.upperTickAfter.liquidityAbsolute == 0);
  273 |     |                     } else {
  274 | *   |                         assert(values.upperTickAfter.liquidityAbsolute == values.upperTickBefore.liquidityAbsolute);
  275 |     |                     }
  276 |     |                 }
  277 |     |             } else {
  278 | *   |                 if(values.pool1Before.price >= values.pool1After.price){
  279 |     |                     // ensure liquidityAbsolute is strictly equal
  280 | *   |                     emit LiquidityAbsoluteNoPosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);
  281 | *   |                     values.constants = pool.immutables();
  282 | *   |                     uint256 lowerPrice = ConstantProduct.getPriceAtTick(lower, values.constants);
  283 | *   |                     emit PriceCheck1(values.pool0Before.price, values.pool0After.price, lowerPrice);
  284 | *   |                     if (values.pool0Before.price <= lowerPrice && values.pool0After.price >= lowerPrice) {
  285 | *   |                         assert(values.lowerTickAfter.liquidityAbsolute == 0);
  286 |     |                     } else {
  287 |     |                         assert(values.lowerTickAfter.liquidityAbsolute == values.lowerTickBefore.liquidityAbsolute);
  288 |     |                     }
  289 |     |                 }
  290 |     |             }
  291 |     |         }
  292 |     | 
  293 | *   |         if (posCreated) {
  294 | *   |             emit PositionTicks(lower, upper);
  295 |     |             // Ensure positions ticks arent crossed
  296 | *   |             assert(lower < upper);
  297 |     |             // Ensure minted ticks on proper tick spacing
  298 | *   |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
  299 |     |         }
  300 |     |         
  301 | *   |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  302 | *   |         emit Liquidity(values.pool0Before.liquidity, values.pool1Before.liquidity, values.pool0After.liquidity, values.pool1After.liquidity);
  303 |     |         
  304 |     |         // Ensure liquidityGlobal is incremented after mint
  305 |     |         // if no pos created should be strictly equal
  306 | *   |         assert(values.globalStateAfter.liquidityGlobal >= values.globalStateBefore.liquidityGlobal);
  307 |     |         
  308 |     |         // If undercut, liquidity should be non-zero
  309 |     |         // If not undercut, liquidity should be the same or greater
  310 | *   |         if (zeroForOne) {
  311 | *   |             emit PriceChange(values.pool0Before.price, values.pool0After.price);
  312 | *   |             if (values.pool0After.price < values.pool0Before.price) assert(values.pool0After.liquidity > 0);
  313 |     |         }
  314 |     |         else {
  315 | *   |             emit PriceChange(values.pool1Before.price, values.pool1After.price);
  316 | *   |             if (values.pool1After.price > values.pool1Before.price) assert(values.pool1After.liquidity > 0);
  317 |     |         }
  318 |     |     }
  319 |     | 
  320 | *   |     function mintLimitVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {
  321 |     |         // PRE CONDITIONS
  322 | *   |         mintAndApprove();
  323 | *   |         amount = amount + 1;
  324 |     |         // Ensure the newly created position is using different ticks
  325 | *   |         for(uint i = 0; i < limitPositions.length;) {
  326 | *   |             if(limitPositions[i].owner == msg.sender && limitPositions[i].lower == lower && limitPositions[i].upper == upper && limitPositions[i].zeroForOne == zeroForOne) {
  327 | *r  |                 revert("Position already exists");
  328 |     |             }
  329 |     |             unchecked {
  330 | *   |                 ++i;
  331 |     |             }
  332 |     |         }
  333 |     | 
  334 | *   |         LimitPoolValues memory values;
  335 |     | 
  336 | *   |         values.globalStateBefore = pool.getGlobalState();
  337 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  338 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  339 |     | 
  340 | *   |         LimitPoolStructs.MintLimitParams memory params;
  341 | *   |         params.to = msg.sender;
  342 | *   |         params.amount = amount;
  343 | *   |         params.mintPercent = mintPercent;
  344 | *   |         params.lower = lower;
  345 | *   |         params.upper = upper;
  346 | *   |         params.zeroForOne = zeroForOne;
  347 |     | 
  348 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
  349 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
  350 | *   |         bool posCreated;
  351 | *   |         (lower, upper, posCreated) = pool.getResizedTicksForMint(params);
  352 | *   |         emit PositionTicks(lower, upper);
  353 | *   |         emit PositionCreated(posCreated);
  354 |     | 
  355 | *   |         (, values.lowerTickBefore) = pool.ticks(lower);
  356 | *   |         (, values.upperTickBefore) = pool.ticks(upper);
  357 |     | 
  358 |     |         // ACTION 
  359 | *   |         MintLimitArgs memory args;
  360 | *   |         args.pools = new address[](1);
  361 | *   |         args.pools[0] = address(pool);
  362 | *   |         args.params = new PoolsharkStructs.MintLimitParams[](1);
  363 | *   |         args.params[0] = params;
  364 | *r  |         router.multiMintLimit(args.pools, args.params);
  365 | *   |         if (posCreated) limitPositions.push(LimitPosition(msg.sender, values.globalStateBefore.positionIdNext, lower, upper, zeroForOne));
  366 |     | 
  367 | *   |         (, values.lowerTickAfter) = pool.ticks(lower);
  368 | *   |         (, values.upperTickAfter) = pool.ticks(upper);
  369 |     | 
  370 | *   |         values.globalStateAfter = pool.getGlobalState();
  371 | *   |         values.pool0After = values.globalStateAfter.pool0;
  372 | *   |         values.pool1After = values.globalStateAfter.pool1;
  373 |     | 
  374 |     |         // POST CONDITIONS
  375 |     | 
  376 |     |         // Ensure prices have not crossed
  377 | *   |         emit Prices(values.pool0After.price, values.pool1After.price);
  378 | *   |         assert(values.pool0After.price >= values.pool1After.price);
  379 |     | 
  380 |     |         // Ensure liquidityDelta is always less or equal to liquidityAbsolute
  381 | *   |         emit LiquidityDeltaAndAbsolute(values.lowerTickAfter.liquidityDelta, values.lowerTickAfter.liquidityAbsolute);
  382 | *   |         assert(int256(values.lowerTickAfter.liquidityDelta) <= int256(uint256(values.lowerTickAfter.liquidityAbsolute)));
  383 | *   |         emit LiquidityDeltaAndAbsolute(values.upperTickAfter.liquidityDelta, values.upperTickAfter.liquidityAbsolute);
  384 | *   |         assert(int256(values.upperTickAfter.liquidityDelta) <= int256(uint256(values.upperTickAfter.liquidityAbsolute)));
  385 |     | 
  386 |     |         // Ensure that liquidityAbsolute is incremented when not undercutting
  387 | *   |         if (posCreated) {
  388 |     |             // positionIdNext should have been incremented
  389 | *   |             emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);
  390 | *   |             assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext + 1);
  391 | *   |             if(zeroForOne){
  392 | *   |                 if(values.pool0After.price >= values.pool0Before.price){
  393 |     |                     // ensure liquidityAbsolute is strictly greater
  394 |     |                     //TODO: could be falsified if liquidity cleared out
  395 | *   |                     emit LiquidityAbsolutePosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);
  396 | *   |                     assert(values.upperTickAfter.liquidityAbsolute > values.upperTickBefore.liquidityAbsolute);
  397 |     |                 }
  398 |     |             } else {
  399 | *   |                 if(values.pool1Before.price >= values.pool1After.price){
  400 |     |                     // ensure liquidityAbsolute is strictly greater
  401 |     |                     //TODO: could be falsified if liquidity cleared out
  402 | *   |                     emit LiquidityAbsolutePosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);
  403 | *   |                     assert(values.lowerTickAfter.liquidityAbsolute > values.lowerTickBefore.liquidityAbsolute);
  404 |     |                 }
  405 |     |             }
  406 |     |         } else {
  407 |     |             // positionIdNext should not have been incremented
  408 | *   |             emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);
  409 | *   |             assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext);
  410 | *   |             if(zeroForOne){
  411 | *   |                 if(values.pool0After.price >= values.pool0Before.price){
  412 |     |                     // ensure liquidityAbsolute is strictly equal
  413 |     |                     //TODO: be falsified if liquidity cleared out
  414 | *   |                     emit LiquidityAbsoluteNoPosCreated(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);
  415 | *   |                     values.constants = pool.immutables();
  416 | *   |                     uint256 upperPrice = ConstantProduct.getPriceAtTick(upper, values.constants);
  417 | *   |                     emit LiquidityAbsoluteNoPosCreatedPriceCheck(values.pool1Before.price, upperPrice, values.pool1After.price);
  418 | *   |                     if (values.pool1Before.price >= upperPrice && values.pool1After.price <= upperPrice) {
  419 | *   |                         assert(values.upperTickAfter.liquidityAbsolute == 0);
  420 |     |                     } else {
  421 | *   |                         assert(values.upperTickAfter.liquidityAbsolute == values.upperTickBefore.liquidityAbsolute);
  422 |     |                     }
  423 |     |                 }
  424 |     |             } else {
  425 | *   |                 if(values.pool1Before.price >= values.pool1After.price){
  426 |     |                     // ensure liquidityAbsolute is strictly equal
  427 |     |                     //TODO: be falsified if liquidity cleared out
  428 | *   |                     emit LiquidityAbsoluteNoPosCreated(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);
  429 | *   |                     values.constants = pool.immutables();
  430 | *   |                     uint256 lowerPrice = ConstantProduct.getPriceAtTick(lower, values.constants);
  431 | *   |                     emit LiquidityAbsoluteNoPosCreatedPriceCheck(values.pool0Before.price, lowerPrice, values.pool0After.price);
  432 | *   |                     if (values.pool0Before.price <= lowerPrice && values.pool0After.price >= lowerPrice) {
  433 | *   |                         assert(values.lowerTickAfter.liquidityAbsolute == 0);
  434 |     |                     } else {
  435 | *   |                         assert(values.lowerTickAfter.liquidityAbsolute == values.lowerTickBefore.liquidityAbsolute);
  436 |     |                     }
  437 |     |                 }
  438 |     |             }
  439 |     |         }
  440 |     | 
  441 | *   |         if (posCreated) {
  442 | *   |             emit PositionTicks(lower, upper);
  443 |     |             // Ensure positions ticks arent crossed
  444 | *   |             assert(lower < upper);
  445 |     |             // Ensure minted ticks on proper tick spacing
  446 | *   |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
  447 |     |         }
  448 |     |         
  449 | *   |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  450 | *   |         emit Liquidity(values.pool0Before.liquidity, values.pool1Before.liquidity, values.pool0After.liquidity, values.pool1After.liquidity);
  451 |     |         
  452 |     |         // Ensure liquidityGlobal is incremented after mint
  453 |     |         //TODO: strictly equal if !posCreated
  454 | *   |         assert(values.globalStateAfter.liquidityGlobal >= values.globalStateBefore.liquidityGlobal);
  455 |     | 
  456 |     |         // Ensure pool liquidity is non-zero after mint with no undercuts
  457 | *   |         if (zeroForOne) {
  458 | *   |             if (values.pool0After.price < values.pool0Before.price) assert(values.pool0After.liquidity > 0);
  459 |     |         }
  460 |     |         else {
  461 | *   |             if (values.pool1After.price > values.pool1Before.price) assert(values.pool1After.liquidity > 0);
  462 |     |         }
  463 |     |     }
  464 |     | 
  465 | *   |     function swap(uint160 priceLimit, uint128 amount, bool exactIn, bool zeroForOne) public {
  466 |     |         // PRE CONDITIONS
  467 | *   |         mintAndApprove();
  468 |     | 
  469 | *   |         LimitPoolStructs.SwapParams memory params;
  470 | *   |         params.to = msg.sender;
  471 | *   |         params.priceLimit = priceLimit;
  472 | *   |         params.amount = amount;
  473 | *   |         params.exactIn = exactIn;
  474 | *   |         params.zeroForOne = zeroForOne;
  475 | *   |         params.callbackData = abi.encodePacked(address(this));
  476 |     |         
  477 |     |         // ACTION
  478 | *   |         SwapArgs memory args;
  479 | *   |         args.pools = new address[](1);
  480 | *   |         args.pools[0] = address(pool);
  481 | *   |         args.params = new PoolsharkStructs.SwapParams[](1);
  482 | *   |         args.params[0] = params;
  483 | *r  |         router.multiSwapSplit(args.pools, args.params);
  484 |     | 
  485 |     |         // POST CONDITIONS
  486 | *   |         LimitPoolValues memory values;
  487 |     | 
  488 | *   |         values.globalStateAfter = pool.getGlobalState();
  489 | *   |         values.pool0After = values.globalStateAfter.pool0;
  490 | *   |         values.pool1After = values.globalStateAfter.pool1;
  491 |     |         
  492 |     |         // Ensure prices never cross
  493 | *   |         emit Prices(values.pool0After.price, values.pool1After.price);
  494 | *   |         assert(values.pool0After.price >= values.pool1After.price);
  495 |     |     }
  496 |     | 
  497 | *   |     function burnLimit(int24 claimAt, uint256 positionIndex, uint128 burnPercent) public {
  498 |     |         // PRE CONDITIONS
  499 | *   |         positionIndex = positionIndex % limitPositions.length;
  500 | *   |         LimitPosition memory pos = limitPositions[positionIndex];
  501 | *r  |         require(claimAt >= pos.lower && claimAt <= pos.upper);
  502 | *r  |         require(claimAt % (tickSpacing / 2) == 0);
  503 | *   |         LimitPoolValues memory values;
  504 |     | 
  505 | *   |         values.globalStateBefore = pool.getGlobalState();
  506 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  507 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  508 |     | 
  509 | *   |         LimitPoolStructs.BurnLimitParams memory params;
  510 | *   |         params.to = pos.owner;
  511 | *   |         params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;
  512 | *   |         params.positionId = pos.positionId;
  513 | *   |         params.claim = claimAt;
  514 | *   |         params.zeroForOne = pos.zeroForOne;
  515 |     | 
  516 | *   |         (, values.lowerTickBefore) = pool.ticks(pos.lower);
  517 | *   |         (, values.upperTickBefore) = pool.ticks(pos.upper);
  518 |     |         
  519 | *   |         emit PositionTicks(pos.lower, pos.upper);
  520 | *   |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
  521 | *   |         emit BurnTicks(lower, upper, positionExists);
  522 |     | 
  523 |     |         // ACTION
  524 | *r  |         pool.burnLimit(params);
  525 |     |         if (!positionExists) {
  526 |     |             limitPositions[positionIndex] = limitPositions[limitPositions.length - 1];
  527 |     |             delete limitPositions[limitPositions.length - 1];
  528 |     |         }
  529 |     |         else {
  530 |     |             // Update position data in array if not fully burned
  531 |     |             limitPositions[positionIndex] = LimitPosition(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);
  532 |     |             // Ensure positions ticks arent crossed
  533 |     |             assert(lower < upper);
  534 |     |             // Ensure minted ticks on proper tick spacing
  535 |     |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
  536 |     |         }
  537 |     | 
  538 |     |         (, values.lowerTickAfter) = pool.ticks(lower);
  539 |     |         (, values.upperTickAfter) = pool.ticks(upper);
  540 |     | 
  541 |     |         values.globalStateAfter = pool.getGlobalState();
  542 |     |         values.pool0After = values.globalStateAfter.pool0;
  543 |     |         values.pool1After = values.globalStateAfter.pool1;
  544 |     |         
  545 |     |         // POST CONDITIONS
  546 |     | 
  547 |     |         // Ensure prices never cross
  548 |     |         emit Prices(values.pool0After.price, values.pool1After.price);
  549 |     |         assert(values.pool0After.price >= values.pool1After.price);
  550 |     | 
  551 |     |         // Ensure liquidityGlobal is decremented after burn
  552 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  553 |     |         assert(values.globalStateAfter.liquidityGlobal <= values.globalStateBefore.liquidityGlobal);
  554 |     |     }
  555 |     | 
  556 | *   |     function claim(int24 claimAt, uint256 positionIndex) public {
  557 |     |         // PRE CONDITIONS
  558 | *   |         positionIndex = positionIndex % limitPositions.length;
  559 | *   |         LimitPosition memory pos = limitPositions[positionIndex];
  560 | *   |         claimAt = pos.lower + (claimAt % (pos.upper - pos.lower));
  561 | *r  |         require(claimAt % (tickSpacing / 2) == 0);
  562 |     | 
  563 | *   |         LimitPoolValues memory values;
  564 |     |         
  565 | *   |         values.globalStateBefore = pool.getGlobalState();
  566 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  567 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  568 |     | 
  569 | *   |         LimitPoolStructs.BurnLimitParams memory params;
  570 | *   |         params.to = pos.owner;
  571 | *   |         params.burnPercent = 0;
  572 | *   |         params.positionId = pos.positionId;
  573 | *   |         params.claim = claimAt;
  574 | *   |         params.zeroForOne = pos.zeroForOne;
  575 |     |         
  576 | *   |         emit PositionTicks(pos.lower, pos.upper);
  577 | *   |         (int24 lower, int24 upper, bool positionExists) = pool.getResizedTicksForBurn(params);
  578 | *   |         emit BurnTicks(lower, upper, positionExists);
  579 |     | 
  580 |     |         // ACTION
  581 | *r  |         pool.burnLimit(params);
  582 |     |         if (!positionExists) {
  583 |     |             limitPositions[positionIndex] = limitPositions[limitPositions.length - 1];
  584 |     |             delete limitPositions[limitPositions.length - 1];
  585 |     |         }
  586 |     |         else {
  587 |     |             // Update position data in array if not fully burned
  588 |     |             limitPositions[positionIndex] = LimitPosition(pos.owner, pos.positionId, lower, upper, pos.zeroForOne);
  589 |     |             // Ensure positions ticks arent crossed
  590 |     |             assert(lower < upper);
  591 |     |             // Ensure minted ticks on proper tick spacing
  592 |     |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
  593 |     |         }
  594 |     | 
  595 |     |         // POST CONDITIONS
  596 |     |         values.globalStateAfter = pool.getGlobalState();
  597 |     |         values.pool0After = values.globalStateAfter.pool0;
  598 |     |         values.pool1After = values.globalStateAfter.pool1;
  599 |     | 
  600 |     |         // Ensure prices never cross
  601 |     |         emit Prices(values.pool0After.price, values.pool1After.price);
  602 |     |         assert(values.pool0After.price >= values.pool1After.price);
  603 |     |     }
  604 |     | 
  605 | *   |     function mintThenBurnZeroLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint96 mintPercent) public tickPreconditions(lower, upper) {
  606 |     |         // PRE CONDITIONS
  607 | *   |         mintAndApprove();
  608 | *   |         LimitPoolValues memory values;
  609 |     |         
  610 | *   |         values.globalStateBefore = pool.getGlobalState();
  611 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  612 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  613 |     | 
  614 | *   |         (, values.lowerTickBefore) = pool.ticks(lower);
  615 | *   |         (, values.upperTickBefore) = pool.ticks(upper);
  616 |     | 
  617 |     |         // ACTION 
  618 | *   |         mintLimitVariable(amount, zeroForOne, lower, upper, mintPercent);
  619 | *   |         emit PassedMint();
  620 | *   |         burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);
  621 |     |         emit PassedBurn();
  622 |     | 
  623 |     |         // POST CONDITIONS
  624 |     |         (, values.lowerTickAfter) = pool.ticks(lower);
  625 |     |         (, values.upperTickAfter) = pool.ticks(upper);
  626 |     |         
  627 |     |         values.globalStateBefore = pool.getGlobalState();
  628 |     |         values.pool0Before = values.globalStateBefore.pool0;
  629 |     |         values.pool1Before = values.globalStateBefore.pool1;
  630 |     | 
  631 |     |         // Ensure prices never cross
  632 |     |         emit Prices(values.pool0After.price, values.pool1After.price);
  633 |     |         assert(values.pool0After.price >= values.pool1After.price);
  634 |     | 
  635 |     |         // Ensure liquidityGlobal is decremented after burn
  636 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  637 |     |         assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);
  638 |     |     }
  639 |     | 
  640 | *   |     function mintThenBurnZeroLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
  641 |     |         // PRE CONDITIONS
  642 | *   |         mintAndApprove();
  643 | *   |         LimitPoolValues memory values;
  644 |     | 
  645 | *   |         values.globalStateBefore = pool.getGlobalState();
  646 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  647 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  648 |     | 
  649 | *   |         (, values.lowerTickBefore) = pool.ticks(lower);
  650 | *   |         (, values.upperTickBefore) = pool.ticks(upper);
  651 |     | 
  652 |     |         // ACTION 
  653 | *   |         mintLimit(amount, zeroForOne, lower, upper);
  654 | *   |         emit PassedMint();
  655 | *   |         burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);
  656 |     |         emit PassedBurn();
  657 |     | 
  658 |     |         (, values.lowerTickAfter) = pool.ticks(lower);
  659 |     |         (, values.upperTickAfter) = pool.ticks(upper);
  660 |     | 
  661 |     |         values.globalStateAfter = pool.getGlobalState();
  662 |     |         values.pool0After = values.globalStateAfter.pool0;
  663 |     |         values.pool1After = values.globalStateAfter.pool1;
  664 |     |         
  665 |     |         // POST CONDITIONS
  666 |     | 
  667 |     |         // Ensure prices never cross
  668 |     |         emit Prices(values.pool0After.price, values.pool1After.price);
  669 |     |         assert(values.pool0After.price >= values.pool1After.price);
  670 |     | 
  671 |     |         // Ensure liquidityGlobal is equal after burn
  672 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  673 |     |         assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);
  674 |     |     }
  675 |     | 
  676 | *   |     function mintThenPartialBurnTwiceLiquidityChange(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
  677 |     |         // PRE CONDITIONS
  678 | *   |         percent = 1 + (percent % (1e38 - 1));
  679 | *   |         mintAndApprove();
  680 | *   |         LimitPoolValues memory values;
  681 |     |         
  682 | *   |         values.globalStateBefore = pool.getGlobalState();
  683 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  684 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  685 |     | 
  686 | *   |         (, values.lowerTickBefore) = pool.ticks(lower);
  687 | *   |         (, values.upperTickBefore) = pool.ticks(upper);
  688 |     | 
  689 |     |         // ACTION 
  690 | *   |         mintLimit(amount, zeroForOne, lower, upper);
  691 | *   |         emit PassedMint();
  692 | *   |         burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, percent);
  693 |     |         emit PassedBurn();
  694 |     |         burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);
  695 |     |         emit PassedBurn();
  696 |     | 
  697 |     |         (, values.lowerTickAfter) = pool.ticks(lower);
  698 |     |         (, values.upperTickAfter) = pool.ticks(upper);
  699 |     | 
  700 |     |         values.globalStateAfter = pool.getGlobalState();
  701 |     |         values.pool0After = values.globalStateAfter.pool0;
  702 |     |         values.pool1After = values.globalStateAfter.pool1;
  703 |     | 
  704 |     |         // POST CONDITIONS
  705 |     | 
  706 |     |         // Ensure prices never cross
  707 |     |         emit Prices(values.pool0After.price, values.pool1After.price);
  708 |     |         assert(values.pool0After.price >= values.pool1After.price);
  709 |     | 
  710 |     |         // Ensure liquidityGlobal is decremented after burn
  711 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  712 |     |         assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);
  713 |     |     }
  714 |     | 
  715 | *   |     function mintThenPartialBurnTwiceLiquidityChangeVariable(uint128 amount, bool zeroForOne, int24 lower, int24 upper, uint128 percent, uint96 mintPercent) public tickPreconditions(lower, upper) {
  716 |     |         // PRE CONDITIONS
  717 | *   |         percent = 1 + (percent % (1e38 - 1));
  718 | *   |         mintAndApprove();
  719 | *   |         LimitPoolValues memory values;
  720 |     | 
  721 | *   |         values.globalStateBefore = pool.getGlobalState();
  722 | *   |         values.pool0Before = values.globalStateBefore.pool0;
  723 | *   |         values.pool1Before = values.globalStateBefore.pool1;
  724 |     | 
  725 | *   |         (, values.lowerTickBefore) = pool.ticks(lower);
  726 | *   |         (, values.upperTickBefore) = pool.ticks(upper);
  727 |     | 
  728 |     |         // ACTION 
  729 | *   |         mintLimitVariable(amount, zeroForOne, lower, upper, mintPercent);
  730 | *   |         emit PassedMint();
  731 | *   |         burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, percent);
  732 |     |         emit PassedBurn();
  733 |     |         burnLimit(zeroForOne ? lower : upper, limitPositions.length - 1, 1e38);
  734 |     |         emit PassedBurn();
  735 |     | 
  736 |     |         (, values.lowerTickAfter) = pool.ticks(lower);
  737 |     |         (, values.upperTickAfter) = pool.ticks(upper);
  738 |     | 
  739 |     |         values.globalStateAfter = pool.getGlobalState();
  740 |     |         values.pool0After = values.globalStateAfter.pool0;
  741 |     |         values.pool1After = values.globalStateAfter.pool1;
  742 |     |         
  743 |     |         // POST CONDITIONS
  744 |     | 
  745 |     |         // Ensure prices never cross
  746 |     |         emit Prices(values.pool0After.price, values.pool1After.price);
  747 |     |         assert(values.pool0After.price >= values.pool1After.price);
  748 |     | 
  749 |     |         // Ensure liquidityGlobal is decremented after burn
  750 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  751 |     |         assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);
  752 |     |     }
  753 |     | 
  754 |     |     // RANGE CALLS
  755 |     | 
  756 | *   |     function mintRange(uint128 amount0, uint128 amount1, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
  757 |     |         // PRE CONDITIONS
  758 | *   |         mintAndApprove();
  759 | *   |         amount0 = amount0 + 1;
  760 | *   |         amount1 = amount1 + 1;
  761 |     |         // Ensure the newly created position is using different ticks
  762 | *   |         for(uint i = 0; i < rangePositions.length;) {
  763 |     |             if(rangePositions[i].owner == msg.sender && rangePositions[i].lower == lower && rangePositions[i].upper == upper) {
  764 |     |                 revert("Position already exists");
  765 |     |             }
  766 |     |             unchecked {
  767 |     |                 ++i;
  768 |     |             }
  769 |     |         }
  770 |     | 
  771 | *   |         RangePoolValues memory values;
  772 |     | 
  773 | *   |         values.globalStateBefore = pool.getGlobalState();
  774 | *   |         values.poolBefore = values.globalStateBefore.pool;
  775 |     | 
  776 | *   |         (values.lowerTickBefore,) = pool.ticks(lower);
  777 | *   |         (values.upperTickBefore,) = pool.ticks(upper);
  778 |     | 
  779 | *   |         values.constants = pool.immutables();
  780 |     | 
  781 | *   |         RangePoolStructs.MintRangeParams memory params;
  782 | *   |         params.to = msg.sender;
  783 | *   |         params.amount0 = amount0;
  784 | *   |         params.amount1 = amount1;
  785 | *   |         params.lower = lower;
  786 | *   |         params.upper = upper;
  787 |     | 
  788 |     |         // Get the ticks the position will be minted with rather than what was passed directly by fuzzer
  789 |     |         // This is so the we can properly compare before and after mint states of particular ticks.
  790 | *   |         bool posCreated = false;
  791 |     | 
  792 | *   |         values.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
  793 | *   |             ConstantProduct.getPriceAtTick(lower, values.constants),
  794 | *   |             ConstantProduct.getPriceAtTick(upper, values.constants),
  795 | *   |             values.poolBefore.price,
  796 | *   |             params.amount1,
  797 | *   |             params.amount0
  798 |     |         );
  799 | *   |         if (values.liquidityMinted > 0) posCreated = true;
  800 | *   |         emit PositionTicks(lower, upper);
  801 | *   |         emit PositionCreated(posCreated);
  802 |     | 
  803 |     |         // ACTION
  804 | *   |         MintRangeArgs memory args;
  805 | *   |         args.pools = new address[](1);
  806 | *   |         args.pools[0] = address(pool);
  807 | *   |         args.params = new PoolsharkStructs.MintRangeParams[](1);
  808 | *   |         args.params[0] = params;
  809 | *r  |         router.multiMintRange(args.pools, args.params);
  810 |     |         if (posCreated) rangePositions.push(RangePosition(msg.sender, values.globalStateBefore.positionIdNext, lower, upper));
  811 |     | 
  812 |     |         (values.lowerTickAfter,) = pool.ticks(lower);
  813 |     |         (values.upperTickAfter,) = pool.ticks(upper);
  814 |     | 
  815 |     |         values.globalStateAfter = pool.getGlobalState();
  816 |     |         values.poolAfter = values.globalStateAfter.pool;
  817 |     |         
  818 |     |         // POST CONDITIONS
  819 |     |         
  820 |     |         // Ensure that liquidityAbsolute is incremented if position created
  821 |     |         if (posCreated) {
  822 |     |             // positionIdNext should have been incremented
  823 |     |             emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);
  824 |     |             assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext + 1);
  825 |     |             emit LiquidityAbsoluteLower(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);
  826 |     |             assert(values.upperTickAfter.liquidityAbsolute > values.upperTickBefore.liquidityAbsolute);
  827 |     |             emit LiquidityAbsoluteUpper(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);
  828 |     |             assert(values.lowerTickAfter.liquidityAbsolute > values.lowerTickBefore.liquidityAbsolute);
  829 |     |         } else {
  830 |     |             // positionIdNext should not have been incremented
  831 |     |             emit PositionIdNext(values.globalStateBefore.positionIdNext, values.globalStateAfter.positionIdNext);
  832 |     |             assert(values.globalStateAfter.positionIdNext == values.globalStateBefore.positionIdNext);
  833 |     |             emit LiquidityAbsoluteLower(values.upperTickBefore.liquidityAbsolute, values.upperTickAfter.liquidityAbsolute);
  834 |     |             assert(values.upperTickAfter.liquidityAbsolute == values.upperTickBefore.liquidityAbsolute);
  835 |     |             emit LiquidityAbsoluteUpper(values.lowerTickBefore.liquidityAbsolute, values.lowerTickAfter.liquidityAbsolute);
  836 |     |             assert(values.lowerTickAfter.liquidityAbsolute == values.lowerTickBefore.liquidityAbsolute);
  837 |     |         }
  838 |     | 
  839 |     |         if (posCreated) {
  840 |     |             emit PositionTicks(lower, upper);
  841 |     |             // Ensure positions ticks arent crossed
  842 |     |             assert(lower < upper);
  843 |     |             // Ensure minted ticks on proper tick spacing
  844 |     |             assert((lower % tickSpacing == 0) && (upper % tickSpacing == 0));
  845 |     |         }
  846 |     |         
  847 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  848 |     |         emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);
  849 |     |         
  850 |     |         // Ensure liquidityGlobal is incremented after mint
  851 |     |         if (posCreated) {
  852 |     |             assert(values.globalStateAfter.liquidityGlobal > values.globalStateBefore.liquidityGlobal);
  853 |     |         } else {
  854 |     |             assert(values.globalStateAfter.liquidityGlobal == values.globalStateBefore.liquidityGlobal);
  855 |     |         }
  856 |     |         
  857 |     |         // Ensure prices does not change
  858 |     |         emit PriceChange(values.poolBefore.price, values.poolAfter.price);
  859 |     |         assert(values.poolBefore.price == values.poolAfter.price);
  860 |     |     }
  861 |     | 
  862 | *   |     function burnRange(uint256 positionIndex, uint128 burnPercent) public {
  863 |     |         // PRE CONDITIONS
  864 | *   |         positionIndex = positionIndex % rangePositions.length;
  865 |     |         RangePosition memory pos = rangePositions[positionIndex];
  866 |     |         RangePoolValues memory values;
  867 |     | 
  868 |     |         values.globalStateBefore = pool.getGlobalState();
  869 |     |         values.poolBefore = values.globalStateBefore.pool;
  870 |     | 
  871 |     |         (values.lowerTickBefore,) = pool.ticks(pos.lower);
  872 |     |         (values.upperTickBefore,) = pool.ticks(pos.upper);
  873 |     | 
  874 |     |         RangePoolStructs.BurnRangeParams memory params;
  875 |     |         params.to = pos.owner;
  876 |     |         params.burnPercent = burnPercent == 1e38 ? burnPercent : _between(burnPercent, 1e36, 1e38); //1e38;
  877 |     |         params.positionId = pos.positionId;
  878 |     |         
  879 |     |         emit PositionTicks(pos.lower, pos.upper);
  880 |     |         bool positionExists = false;
  881 |     |         (,,uint128 positionLiquidity,,) = pool.positions(pos.positionId);
  882 |     |         if (positionLiquidity > 0) positionExists = true;
  883 |     | 
  884 |     |         // ACTION
  885 |     |         pool.burnRange(params);
  886 |     |         if (params.burnPercent == 1e38) {
  887 |     |             delete rangePositions[positionIndex];
  888 |     |         }
  889 |     | 
  890 |     |         (values.lowerTickAfter,) = pool.ticks(pos.lower);
  891 |     |         (values.upperTickAfter,) = pool.ticks(pos.upper);
  892 |     | 
  893 |     |         values.globalStateAfter = pool.getGlobalState();
  894 |     |         values.poolAfter = values.globalStateAfter.pool;
  895 |     |         
  896 |     |         // POST CONDITIONS
  897 |     | 
  898 |     |         // Ensure liquidityGlobal is decremented after burn
  899 |     |         //TODO: if !positionExists liquidity should not change
  900 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  901 |     |         emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);
  902 |     |         assert(values.poolAfter.liquidity <= values.poolBefore.liquidity);
  903 |     |         assert(values.globalStateAfter.liquidityGlobal <= values.globalStateBefore.liquidityGlobal);
  904 |     |     }
  905 |     | 
  906 | *   |     function compoundRange(uint256 positionIndex) public {
  907 |     |         // PRE CONDITIONS
  908 | *   |         positionIndex = positionIndex % rangePositions.length;
  909 |     |         RangePosition memory pos = rangePositions[positionIndex];
  910 |     |         RangePoolValues memory values;
  911 |     | 
  912 |     |         values.globalStateBefore = pool.getGlobalState();
  913 |     |         values.poolBefore = values.globalStateBefore.pool;
  914 |     | 
  915 |     |         (values.lowerTickBefore,) = pool.ticks(pos.lower);
  916 |     |         (values.upperTickBefore,) = pool.ticks(pos.upper);
  917 |     | 
  918 |     |         RangePoolStructs.BurnRangeParams memory params;
  919 |     |         params.to = pos.owner;
  920 |     |         params.burnPercent = 0; //0 to compound
  921 |     |         params.positionId = pos.positionId;
  922 |     |         
  923 |     |         emit PositionTicks(pos.lower, pos.upper);
  924 |     |         bool positionExists = false;
  925 |     |         (,,uint128 positionLiquidity,,) = pool.positions(pos.positionId);
  926 |     |         if (positionLiquidity > 0) positionExists = true;
  927 |     | 
  928 |     |         // ACTION
  929 |     |         pool.burnRange(params);
  930 |     | 
  931 |     |         // position should still exist if it did before
  932 |     |         (values.lowerTickAfter,) = pool.ticks(pos.lower);
  933 |     |         (values.upperTickAfter,) = pool.ticks(pos.upper);
  934 |     | 
  935 |     |         values.globalStateAfter = pool.getGlobalState();
  936 |     |         values.poolAfter = values.globalStateAfter.pool;
  937 |     |         
  938 |     |         // POST CONDITIONS
  939 |     | 
  940 |     |         // Ensure liquidityGlobal is greater than or equal after compound
  941 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  942 |     |         emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);
  943 |     |         assert(values.poolAfter.liquidity >= values.poolBefore.liquidity);
  944 |     |         assert(values.globalStateAfter.liquidityGlobal >= values.globalStateBefore.liquidityGlobal);
  945 |     |     }
  946 |     | 
  947 | *   |     function collectRange(uint256 positionIndex) public {
  948 |     |         // PRE CONDITIONS
  949 | *   |         positionIndex = positionIndex % rangePositions.length;
  950 |     |         RangePosition memory pos = rangePositions[positionIndex];
  951 |     |         RangePoolValues memory values;
  952 |     | 
  953 |     |         values.globalStateBefore = pool.getGlobalState();
  954 |     |         values.poolBefore = values.globalStateBefore.pool;
  955 |     | 
  956 |     |         (values.lowerTickBefore,) = pool.ticks(pos.lower);
  957 |     |         (values.upperTickBefore,) = pool.ticks(pos.upper);
  958 |     | 
  959 |     |         RangePoolStructs.BurnRangeParams memory params;
  960 |     |         params.to = pos.owner;
  961 |     |         params.burnPercent = 1; //1 for collect
  962 |     |         params.positionId = pos.positionId;
  963 |     |         
  964 |     |         emit PositionTicks(pos.lower, pos.upper);
  965 |     |         bool positionExists = false;
  966 |     |         (,,uint128 positionLiquidity,,) = pool.positions(pos.positionId);
  967 |     |         if (positionLiquidity > 0) positionExists = true;
  968 |     | 
  969 |     |         // ACTION
  970 |     |         pool.burnRange(params);
  971 |     | 
  972 |     |         // position should still exist if it did before
  973 |     |         (values.lowerTickAfter,) = pool.ticks(pos.lower);
  974 |     |         (values.upperTickAfter,) = pool.ticks(pos.upper);
  975 |     | 
  976 |     |         values.globalStateAfter = pool.getGlobalState();
  977 |     |         values.poolAfter = values.globalStateAfter.pool;
  978 |     |         
  979 |     |         // POST CONDITIONS
  980 |     | 
  981 |     |         // Ensure liquidityGlobal is equal after collect
  982 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
  983 |     |         emit LiquidityRange(values.poolBefore.liquidity, values.poolAfter.liquidity);
  984 |     |         assert(values.poolAfter.liquidity <= values.poolBefore.liquidity);
  985 |     |         assert(values.globalStateAfter.liquidityGlobal <= values.globalStateBefore.liquidityGlobal);
  986 |     |     }
  987 |     | 
  988 | *   |     function mintRangeThenBurnZeroLiquidityChange(uint128 amount0, uint128 amount1, int24 lower, int24 upper) public tickPreconditions(lower, upper) {
  989 |     |         // PRE CONDITIONS
  990 | *   |         mintAndApprove();
  991 | *   |         RangePoolValues memory values;
  992 |     | 
  993 | *   |         values.globalStateBefore = pool.getGlobalState();
  994 | *   |         values.poolBefore = values.globalStateBefore.pool;
  995 |     | 
  996 | *   |         (values.lowerTickBefore,) = pool.ticks(lower);
  997 | *   |         (values.upperTickBefore,) = pool.ticks(upper);
  998 |     | 
  999 |     |         // ACTION 
 1000 | *   |         mintRange(amount0, amount1, lower, upper);
 1001 |     |         emit PassedMintRange();
 1002 |     |         burnRange(rangePositions.length - 1, 1e38);
 1003 |     |         emit PassedBurnRange();
 1004 |     | 
 1005 |     |         (values.lowerTickAfter,) = pool.ticks(lower);
 1006 |     |         (values.upperTickAfter,) = pool.ticks(upper);
 1007 |     | 
 1008 |     |         values.globalStateAfter = pool.getGlobalState();
 1009 |     |         values.poolAfter = values.globalStateAfter.pool;
 1010 |     |         
 1011 |     |         // POST CONDITIONS
 1012 |     | 
 1013 |     |         // Ensure price remains unchanged
 1014 |     |         emit Prices(values.poolBefore.price, values.poolAfter.price);
 1015 |     |         assert(values.poolBefore.price == values.poolAfter.price);
 1016 |     | 
 1017 |     |         // Ensure liquidityGlobal is equal
 1018 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
 1019 |     |         assert(values.globalStateBefore.liquidityGlobal == values.globalStateAfter.liquidityGlobal);
 1020 |     |     }
 1021 |     | 
 1022 | *   |     function mintRangeThenPartialBurnTwiceLiquidityChange(uint128 amount0, uint128 amount1, int24 lower, int24 upper, uint128 percent) public tickPreconditions(lower, upper) {
 1023 |     |         // PRE CONDITIONS
 1024 | *   |         percent = 1 + (percent % (1e38 - 1));
 1025 | *   |         mintAndApprove();
 1026 | *   |         RangePoolValues memory values;
 1027 |     | 
 1028 | *   |         values.globalStateBefore = pool.getGlobalState();
 1029 | *   |         values.poolBefore = values.globalStateBefore.pool;
 1030 |     | 
 1031 | *   |         (values.lowerTickBefore,) = pool.ticks(lower);
 1032 | *   |         (values.upperTickBefore,) = pool.ticks(upper);
 1033 |     | 
 1034 |     |         // ACTION 
 1035 | *   |         mintRange(amount0, amount1, lower, upper);
 1036 |     |         emit PassedMintRange();
 1037 |     |         burnRange(rangePositions.length - 1, percent);
 1038 |     |         emit PassedBurnRange();
 1039 |     |         burnRange(rangePositions.length - 1, 1e38);
 1040 |     |         emit PassedBurnRange();
 1041 |     | 
 1042 |     |         (values.lowerTickAfter,) = pool.ticks(lower);
 1043 |     |         (values.upperTickAfter,) = pool.ticks(upper);
 1044 |     | 
 1045 |     |         values.globalStateAfter = pool.getGlobalState();
 1046 |     |         values.poolAfter = values.globalStateAfter.pool;
 1047 |     | 
 1048 |     |         // POST CONDITIONS
 1049 |     | 
 1050 |     |         // Ensure prices never cross
 1051 |     |         emit Prices(values.poolBefore.price, values.poolAfter.price);
 1052 |     |         assert(values.poolBefore.price == values.poolAfter.price);
 1053 |     | 
 1054 |     |         // Ensure liquidityGlobal is equal
 1055 |     |         emit LiquidityGlobal(values.globalStateBefore.liquidityGlobal, values.globalStateAfter.liquidityGlobal);
 1056 |     |         assert(values.globalStateBefore.liquidityGlobal == values.globalStateAfter.liquidityGlobal);
 1057 |     |     }
 1058 |     | 
 1059 | *   |     function mintAndApprove() internal {
 1060 | *   |         tokenIn.mint(msg.sender, 100000000000 ether);
 1061 | *   |         tokenOut.mint(msg.sender, 100000000000 ether);
 1062 | *   |         tokenIn.mint(address(this), 100000000000 ether);
 1063 | *   |         tokenOut.mint(address(this), 100000000000 ether);
 1064 | *   |         tokenIn.approve(address(router), type(uint256).max);
 1065 | *   |         tokenOut.approve(address(router), type(uint256).max);
 1066 | *   |         tokenIn.approve(address(pool), type(uint256).max);
 1067 | *   |         tokenOut.approve(address(pool), type(uint256).max);
 1068 | *   |         tokenIn.approve(address(this), type(uint256).max);
 1069 | *   |         tokenOut.approve(address(this), type(uint256).max);
 1070 |     |     }
 1071 |     | 
 1072 | *   |     function limitPoolMintLimitCallback(
 1073 |     |         int256 amount0Delta,
 1074 |     |         int256 amount1Delta,
 1075 |     |         bytes calldata data
 1076 | *   |     ) external {
 1077 | *   |         emit LimitCallbackOnEchidnaPool(uint256(-amount0Delta), uint256(-amount1Delta));
 1078 | *   |         address token0 = LimitPool(pool).token0();
 1079 | *   |         address token1 = LimitPool(pool).token1();
 1080 | *   |         if (amount0Delta < 0) {
 1081 | *   |             emit MsgSenderPool(msg.sender, address(this));
 1082 | *   |             SafeTransfers.transferOut(msg.sender, token0, uint256(-amount0Delta));
 1083 | *   |             emit MsgSenderPool(msg.sender, address(this));
 1084 |     |         }
 1085 | *   |         if (amount1Delta < 0) {
 1086 | *   |             SafeTransfers.transferOut(msg.sender, token1, uint256(-amount1Delta));
 1087 |     |         }
 1088 |     |     }
 1089 |     | 
 1090 | *   |     function limitPoolMintRangeCallback(
 1091 |     |         int256 amount0Delta,
 1092 |     |         int256 amount1Delta,
 1093 |     |         bytes calldata data
 1094 | *   |     ) external {
 1095 | *   |         emit RangeCallbackOnEchidnaPool(uint256(-amount0Delta), uint256(-amount1Delta));
 1096 | *   |         address token0 = LimitPool(pool).token0();
 1097 | *   |         address token1 = LimitPool(pool).token1();
 1098 | *   |         if (amount0Delta < 0) {
 1099 | *   |             emit MsgSenderPool(msg.sender, address(this));
 1100 | *   |             SafeTransfers.transferOut(msg.sender, token0, uint256(-amount0Delta));
 1101 | *   |             emit MsgSenderPool(msg.sender, address(this));
 1102 |     |         }
 1103 | *   |         if (amount1Delta < 0) {
 1104 | *   |             SafeTransfers.transferOut(msg.sender, token1, uint256(-amount1Delta));
 1105 |     |         }
 1106 |     |     }
 1107 |     | 
 1108 | *   |     function limitPoolSwapCallback(
 1109 |     |         int256 amount0Delta,
 1110 |     |         int256 amount1Delta,
 1111 |     |         bytes calldata data
 1112 | *   |     ) external {
 1113 | *   |         address token0 = LimitPool(pool).token0();
 1114 | *   |         address token1 = LimitPool(pool).token1();
 1115 | *   |         if (amount0Delta < 0) {
 1116 | *   |             emit MsgSenderPool(msg.sender, address(this));
 1117 | *   |             SafeTransfers.transferOut(msg.sender, token0, uint256(-amount0Delta));
 1118 | *   |             emit MsgSenderPool(msg.sender, address(this));
 1119 |     |         }
 1120 | *   |         if (amount1Delta < 0) {
 1121 | *   |             SafeTransfers.transferOut(msg.sender, token1, uint256(-amount1Delta));
 1122 |     |         }
 1123 |     |     }
 1124 |     | 
 1125 | *   |     function _between(uint128 val, uint low, uint high) internal pure returns(uint128) {
 1126 | *   |         return uint128(low + (val % (high-low +1))); 
 1127 |     |     }
 1128 |     | 
 1129 |     |     function liquidityMintedBackcalculates(uint128 amount, bool zeroForOne, int24 lower, int24 upper) tickPreconditions(lower, upper) internal {
 1130 |     |         // NOTE: Do not use the exact inputs of this function for POCs, use the inputs after the input validation
 1131 |     |         amount = amount + 1e5 + 1;
 1132 |     |         LimitPoolStructs.LimitImmutables memory immutables = pool.immutables();
 1133 |     |         uint256 priceLower = ConstantProduct.getPriceAtTick(lower, immutables);
 1134 |     |         uint256 priceUpper = ConstantProduct.getPriceAtTick(upper, immutables);
 1135 |     | 
 1136 |     |         uint256 liquidityMinted = ConstantProduct.getLiquidityForAmounts(
 1137 |     |             priceLower,
 1138 |     |             priceUpper,
 1139 |     |             zeroForOne ? priceLower : priceUpper,
 1140 |     |             zeroForOne ? 0 : uint256(amount),
 1141 |     |             zeroForOne ? uint256(amount) : 0
 1142 |     |         );
 1143 |     | 
 1144 |     |         (uint256 token0Amount, uint256 token1Amount) = ConstantProduct.getAmountsForLiquidity(
 1145 |     |             priceLower,
 1146 |     |             priceUpper,
 1147 |     |             zeroForOne ? priceLower : priceUpper,
 1148 |     |             liquidityMinted,
 1149 |     |             true
 1150 |     |         );
 1151 |     | 
 1152 |     |         if(zeroForOne) {
 1153 |     |             emit LiquidityMinted(amount, token0Amount, zeroForOne);
 1154 |     |             assert(token0Amount <= amount);
 1155 |     |             
 1156 |     |         }
 1157 |     |         else {
 1158 |     |             emit LiquidityMinted(amount, token1Amount, zeroForOne);
 1159 |     |             assert(token1Amount <= amount);
 1160 |     |         }
 1161 |     |     }
 1162 |     | }
 1163 |     | 

/root/git/limit/contracts/LimitPool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './interfaces/IPool.sol';
   5 |     | import './interfaces/range/IRangePool.sol';
   6 |     | import './interfaces/limit/ILimitPool.sol';
   7 |     | import './interfaces/limit/ILimitPoolView.sol';
   8 |     | import './interfaces/limit/ILimitPoolManager.sol';
   9 |     | import './base/storage/LimitPoolStorage.sol';
  10 |     | import './base/storage/LimitPoolImmutables.sol';
  11 |     | import './libraries/pool/SwapCall.sol';
  12 |     | import './libraries/pool/QuoteCall.sol';
  13 |     | import './libraries/pool/FeesCall.sol';
  14 |     | import './libraries/pool/SampleCall.sol';
  15 |     | import './libraries/range/pool/MintRangeCall.sol';
  16 |     | import './libraries/range/pool/BurnRangeCall.sol';
  17 |     | import './libraries/range/pool/SnapshotRangeCall.sol';
  18 |     | import './libraries/limit/pool/MintLimitCall.sol';
  19 |     | import './test/echidna/EchidnaMintLimitCall.sol';
  20 |     | import './libraries/limit/pool/BurnLimitCall.sol';
  21 |     | import './test/echidna/EchidnaBurnLimitCall.sol';
  22 |     | import './libraries/limit/pool/SnapshotLimitCall.sol';
  23 |     | import './libraries/math/ConstantProduct.sol';
  24 |     | import './external/solady/LibClone.sol';
  25 |     | import './external/openzeppelin/security/ReentrancyGuard.sol';
  26 |     | 
  27 |     | 
  28 |     | /// @notice Poolshark Limit Pool Implementation
  29 | *   | contract LimitPool is
  30 |     |     ILimitPool,
  31 |     |     ILimitPoolView,
  32 |     |     LimitPoolStorage,
  33 |     |     LimitPoolImmutables,
  34 |     |     ReentrancyGuard
  35 |     | {
  36 |     | 
  37 |     |     event SimulateMint(bytes b);
  38 |     |     event SimulateMint(bytes4 b);
  39 |     |     event SimulateMint(bool b);
  40 |     | 
  41 |     |     modifier ownerOnly() {
  42 |     |         _onlyOwner();
  43 |     |         _;
  44 |     |     }
  45 |     | 
  46 |     |     modifier factoryOnly() {
  47 |     |         _onlyFactory();
  48 |     |         _;
  49 |     |     }
  50 |     | 
  51 |     |     modifier canonicalOnly() {
  52 |     |         _onlyCanoncialClones();
  53 |     |         _;
  54 |     |     }
  55 |     | 
  56 |     |     address public immutable original;
  57 |     |     address public immutable factory;
  58 |     | 
  59 |     |     constructor(
  60 |     |         address factory_
  61 |     |     ) {
  62 |     |         original = address(this);
  63 |     |         factory = factory_;
  64 |     |     }
  65 |     | 
  66 |     |     function initialize(
  67 |     |         uint160 startPrice
  68 |     |     ) external  
  69 |     |         nonReentrant(globalState)
  70 |     |         factoryOnly
  71 |     |         canonicalOnly
  72 |     |     {
  73 |     |         // initialize state
  74 |     |         globalState = Ticks.initialize(
  75 |     |             rangeTickMap,
  76 |     |             limitTickMap,
  77 |     |             samples,
  78 |     |             globalState,
  79 |     |             immutables(),
  80 |     |             startPrice
  81 |     |         );
  82 |     |     }
  83 |     | 
  84 |     |     function mintRange(
  85 |     |         MintRangeParams memory params
  86 |     |     ) external 
  87 |     |         nonReentrant(globalState)
  88 |     |         canonicalOnly
  89 |     |     {
  90 |     |         MintRangeCache memory cache;
  91 |     |         cache.constants = immutables();
  92 |     |         MintRangeCall.perform(
  93 |     |             positions,
  94 |     |             ticks,
  95 |     |             rangeTickMap,
  96 |     |             samples,
  97 |     |             globalState,
  98 |     |             cache,
  99 |     |             params
 100 |     |         );
 101 |     |     }
 102 |     | 
 103 |     |     function burnRange(
 104 |     |         BurnRangeParams memory params
 105 |     |     ) external 
 106 |     |         nonReentrant(globalState)
 107 |     |         canonicalOnly
 108 |     |     {
 109 |     |         BurnRangeCache memory cache;
 110 |     |         cache.constants = immutables();
 111 |     |         BurnRangeCall.perform(
 112 |     |             positions,
 113 |     |             ticks,
 114 |     |             rangeTickMap,
 115 |     |             samples,
 116 |     |             globalState,
 117 |     |             cache,
 118 |     |             params
 119 |     |         );
 120 |     |     }
 121 |     | 
 122 |     |     //limitSwap
 123 |     |     function mintLimit(
 124 |     |         MintLimitParams memory params
 125 |     |     ) external 
 126 |     |         nonReentrant(globalState)
 127 |     |         canonicalOnly
 128 |     |     {
 129 |     |         MintLimitCache memory cache;
 130 |     |         cache.constants = immutables();
 131 |     |         MintLimitCall.perform(
 132 |     |             params.zeroForOne ? positions0 : positions1,
 133 |     |             ticks,
 134 |     |             samples,
 135 |     |             rangeTickMap,
 136 |     |             limitTickMap,
 137 |     |             globalState,
 138 |     |             params,
 139 |     |             cache
 140 |     |         );
 141 |     |     }
 142 |     | 
 143 |     |     function burnLimit(
 144 |     |         BurnLimitParams memory params
 145 |     |     ) external 
 146 |     |         nonReentrant(globalState)
 147 |     |         canonicalOnly
 148 |     |     {
 149 |     |         BurnLimitCache memory cache;
 150 |     |         cache.constants = immutables();
 151 |     |         BurnLimitCall.perform(
 152 |     |             params.zeroForOne ? positions0 : positions1,
 153 |     |             ticks,
 154 |     |             limitTickMap,
 155 |     |             globalState,
 156 |     |             params, 
 157 |     |             cache
 158 |     |         );
 159 |     |     }
 160 |     | 
 161 |     |     function swap(
 162 |     |         SwapParams memory params
 163 |     |     ) external 
 164 |     |         nonReentrant(globalState)
 165 |     |         canonicalOnly
 166 |     |     returns (
 167 |     |         int256,
 168 |     |         int256
 169 |     |     ) 
 170 |     |     {
 171 |     |         SwapCache memory cache;
 172 |     |         cache.constants = immutables();
 173 |     |         return SwapCall.perform(
 174 |     |             ticks,
 175 |     |             samples,
 176 |     |             rangeTickMap,
 177 |     |             limitTickMap,
 178 |     |             globalState,
 179 |     |             params,
 180 |     |             cache
 181 |     |         );
 182 |     |     }
 183 |     | 
 184 |     |     function increaseSampleCount(
 185 |     |         uint16 newSampleCountMax
 186 |     |     ) external 
 187 |     |         nonReentrant(globalState)
 188 |     |         canonicalOnly 
 189 |     |     {
 190 |     |         Samples.expand(
 191 |     |             samples,
 192 |     |             globalState.pool,
 193 |     |             newSampleCountMax
 194 |     |         );
 195 |     |     }
 196 |     | 
 197 |     |     function fees(
 198 |     |         FeesParams memory params
 199 |     |     ) external 
 200 |     |         ownerOnly
 201 |     |         nonReentrant(globalState)
 202 |     |         canonicalOnly 
 203 |     |     returns (
 204 |     |         uint128 token0Fees,
 205 |     |         uint128 token1Fees
 206 |     |     ) {
 207 |     |         return FeesCall.perform(
 208 |     |             globalState,
 209 |     |             params,
 210 |     |             immutables()
 211 |     |         );
 212 |     |     }
 213 |     | 
 214 |     |     function quote(
 215 |     |         QuoteParams memory params
 216 |     |     ) external
 217 |     |     returns (
 218 |     |         uint256,
 219 |     |         uint256,
 220 |     |         uint160
 221 |     |     ) {
 222 |     |         SwapCache memory cache;
 223 |     |         cache.constants = immutables();
 224 |     |         return QuoteCall.perform(
 225 |     |             ticks,
 226 |     |             rangeTickMap,
 227 |     |             limitTickMap,
 228 |     |             globalState,
 229 |     |             params,
 230 |     |             cache
 231 |     |         );
 232 |     |     }
 233 |     | 
 234 |     |     function sample(
 235 |     |         uint32[] memory secondsAgo
 236 |     |     ) external view override
 237 |     |     returns(
 238 |     |         int56[]   memory tickSecondsAccum,
 239 |     |         uint160[] memory secondsPerLiquidityAccum,
 240 |     |         uint160 averagePrice,
 241 |     |         uint128 averageLiquidity,
 242 |     |         int24 averageTick
 243 |     |     ) 
 244 |     |     {
 245 |     |         return SampleCall.perform(
 246 |     |             globalState,
 247 |     |             immutables(),
 248 |     |             secondsAgo
 249 |     |         );
 250 |     |     }
 251 |     | 
 252 |     |     function snapshotRange(
 253 |     |         uint32 positionId 
 254 |     |     ) external view  returns (
 255 |     |         int56   tickSecondsAccum,
 256 |     |         uint160 secondsPerLiquidityAccum,
 257 |     |         uint128 feesOwed0,
 258 |     |         uint128 feesOwed1
 259 |     |     ) {
 260 |     |         return SnapshotRangeCall.perform(
 261 |     |             positions,
 262 |     |             ticks,
 263 |     |             globalState,
 264 |     |             immutables(),
 265 |     |             positionId
 266 |     |         );
 267 |     |     }
 268 |     | 
 269 |     |     function snapshotLimit(
 270 |     |         SnapshotLimitParams memory params
 271 |     |     ) external view  returns(
 272 |     |         uint128,
 273 |     |         uint128
 274 |     |     ) {
 275 |     |         return SnapshotLimitCall.perform(
 276 |     |             params.zeroForOne ? positions0 : positions1,
 277 |     |             ticks,
 278 |     |             limitTickMap,
 279 |     |             globalState,
 280 |     |             immutables(),
 281 |     |             params
 282 |     |         );
 283 |     |     }
 284 |     | 
 285 |     |     function immutables() public view returns (
 286 |     |         LimitImmutables memory
 287 |     |     ) {
 288 |     |         return LimitImmutables(
 289 |     |             owner(),
 290 |     |             original,
 291 |     |             factory,
 292 |     |             PriceBounds(minPrice(), maxPrice()),
 293 |     |             token0(),
 294 |     |             token1(),
 295 |     |             poolToken(),
 296 |     |             genesisTime(),
 297 |     |             tickSpacing(),
 298 |     |             swapFee()
 299 |     |         );
 300 |     |     }
 301 |     | 
 302 |     |     function getResizedTicksForMint(
 303 |     |         MintLimitParams memory params
 304 |     |     ) external returns (int24 lower, int24 upper, bool positionCreated){
 305 |     |         MintLimitCache memory cache;
 306 |     |         {
 307 |     |             cache.state = globalState;
 308 |     |             cache.constants = immutables();
 309 |     |         }
 310 |     | 
 311 |     |         try EchidnaMintLimitCall.getResizedTicks(
 312 |     |             params.zeroForOne ? positions0 : positions1,
 313 |     |             ticks,
 314 |     |             samples,
 315 |     |             rangeTickMap,
 316 |     |             limitTickMap,
 317 |     |             globalState,
 318 |     |             params,
 319 |     |             cache
 320 |     |         ) {
 321 |     |         } catch (bytes memory data) {
 322 |     |             emit SimulateMint(data);
 323 |     |             bytes4 sig;
 324 |     |             assembly {
 325 |     |                 sig := mload(add(data, 0x20))
 326 |     |             }
 327 |     |             
 328 |     |             // SimulateMint error
 329 |     |             if (sig == hex"5cc1f67b") {
 330 |     |                 (, lower, upper, positionCreated) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 331 |     |             }
 332 |     |             else {
 333 |     |                 lower = -8388608;
 334 |     |                 upper = -8388608;
 335 |     |                 positionCreated = false;
 336 |     |             }
 337 |     |         }
 338 |     |     }
 339 |     | 
 340 |     |     function getResizedTicksForBurn(
 341 |     |         BurnLimitParams memory params
 342 |     |     ) external returns (int24 lower, int24 upper, bool positionExists){
 343 |     |         if (params.to == address(0)) require(false, 'CollectToZeroAddress()');
 344 |     |         BurnLimitCache memory cache;
 345 |     |         cache.constants = immutables();
 346 |     | 
 347 |     |         try EchidnaBurnLimitCall.getResizedTicks(
 348 |     |             params.zeroForOne ? positions0 : positions1,
 349 |     |             ticks,
 350 |     |             limitTickMap,
 351 |     |             globalState,
 352 |     |             params, 
 353 |     |             cache
 354 |     |         ) {
 355 |     |         } catch (bytes memory data) {
 356 |     |             bytes4 sig;
 357 |     |             assembly {
 358 |     |                 sig := mload(add(data, 0x20))
 359 |     |             }
 360 |     |             // SimulateBurn error
 361 |     |             if (sig == hex"97dd6e0a") {
 362 |     |                 (, lower, upper, positionExists) = abi.decode(abi.encodePacked(bytes28(0), data),(bytes32,int24,int24,bool));
 363 |     |             }
 364 |     |              else {
 365 |     |                 lower = -8388608;
 366 |     |                 upper = -8388608;
 367 |     |                 positionExists = false;
 368 |     |             }
 369 |     |         }
 370 |     |     }
 371 |     | 
 372 |     |     function priceBounds(
 373 |     |         int16 tickSpacing
 374 |     |     ) external pure returns (uint160, uint160) {
 375 |     |         return ConstantProduct.priceBounds(tickSpacing);
 376 |     |     }
 377 |     | 
 378 |     |     function _onlyOwner() private view {
 379 |     |         if (msg.sender != owner()) require(false, 'OwnerOnly()');
 380 |     |     }
 381 |     | 
 382 |     |     function _onlyCanoncialClones() private view {
 383 |     |         // compute pool key
 384 |     |         bytes32 key = keccak256(abi.encode(original, token0(), token1(), swapFee()));
 385 |     |         
 386 |     |         // compute canonical pool address
 387 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 388 |     |             original,
 389 |     |             abi.encodePacked(
 390 |     |                 owner(),
 391 |     |                 token0(),
 392 |     |                 token1(),
 393 |     |                 poolToken(),
 394 |     |                 minPrice(),
 395 |     |                 maxPrice(),
 396 |     |                 genesisTime(),
 397 |     |                 tickSpacing(),
 398 |     |                 swapFee()
 399 |     |             ),
 400 |     |             key,
 401 |     |             factory
 402 |     |         );
 403 |     |         // only allow delegateCall from canonical clones
 404 |     |         if (address(this) != predictedAddress) require(false, 'NoDelegateCall()');
 405 |     |     }
 406 |     | 
 407 |     |     function getGlobalState() public view returns(
 408 |     |         GlobalState memory
 409 |     |     ) {
 410 |     |         return globalState;
 411 |     |     }
 412 |     | 
 413 |     |     function _onlyFactory() private view {
 414 |     |         if (msg.sender != factory) require(false, 'FactoryOnly()');
 415 |     |     }
 416 |     | }
 417 |     | 

/root/git/limit/contracts/LimitPoolFactory.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './interfaces/range/IRangePool.sol';
   5 |     | import './interfaces/limit/ILimitPool.sol';
   6 |     | import './interfaces/limit/ILimitPoolView.sol';
   7 |     | import './interfaces/structs/LimitPoolStructs.sol';
   8 |     | import './interfaces/structs/RangePoolStructs.sol';
   9 |     | import './interfaces/limit/ILimitPoolFactory.sol';
  10 |     | import './interfaces/limit/ILimitPoolManager.sol';
  11 |     | import './base/events/LimitPoolFactoryEvents.sol';
  12 |     | import './external/solady/LibClone.sol';
  13 |     | import './libraries/utils/SafeCast.sol';
  14 |     | import './libraries/utils/PositionTokens.sol';
  15 |     | import './libraries/math/ConstantProduct.sol';
  16 |     | 
  17 |     | contract LimitPoolFactory is 
  18 |     |     ILimitPoolFactory,
  19 |     |     LimitPoolStructs,
  20 |     |     RangePoolStructs,
  21 |     |     LimitPoolFactoryEvents
  22 |     | {
  23 |     |     using LibClone for address;
  24 |     |     using SafeCast for uint256;
  25 |     | 
  26 |     |     address immutable public owner;
  27 |     |     address immutable public original;
  28 |     | 
  29 |     |     constructor(
  30 |     |         address owner_
  31 |     |     ) {
  32 |     |         owner = owner_;
  33 |     |         original = address(this);
  34 |     |     }
  35 |     | 
  36 |     |     function createLimitPool(
  37 |     |         LimitPoolParams memory params
  38 |     |     ) public override returns (
  39 |     |         address pool,
  40 |     |         address poolToken
  41 |     |     ) {
  42 |     |         // validate token pair
  43 |     |         if (params.tokenIn == params.tokenOut || params.tokenIn == address(0) || params.tokenOut == address(0)) {
  44 |     |             require(false, 'InvalidTokenAddress()');
  45 |     |         }
  46 |     | 
  47 |     |         // sort tokens by address
  48 |     |         LimitImmutables memory constants;
  49 |     |         (constants.token0, constants.token1) = params.tokenIn < params.tokenOut ? (params.tokenIn,  params.tokenOut) 
  50 |     |                                                                                 : (params.tokenOut, params.tokenIn);
  51 |     | 
  52 |     |         // check if tick spacing supported
  53 |     |         constants.swapFee = params.swapFee;
  54 |     |         constants.tickSpacing = ILimitPoolManager(owner).feeTiers(params.swapFee);
  55 |     |         if (constants.tickSpacing == 0) require(false, 'FeeTierNotSupported()');
  56 |     | 
  57 |     |         // check if pool type supported
  58 |     |         (
  59 |     |             address poolImpl,
  60 |     |             address tokenImpl
  61 |     |          ) = ILimitPoolManager(owner).poolTypes(params.poolTypeId);
  62 |     |         if (poolImpl == address(0) || tokenImpl == address(0)) require(false, 'PoolTypeNotSupported()');
  63 |     | 
  64 |     |         // generate key for pool
  65 |     |         bytes32 key = keccak256(abi.encode(
  66 |     |             poolImpl,
  67 |     |             constants.token0,
  68 |     |             constants.token1,
  69 |     |             constants.swapFee
  70 |     |         ));
  71 |     | 
  72 |     |         // check if pool already exists
  73 |     |         if (pools[key] != address(0)) require(false, 'PoolAlreadyExists()');
  74 |     | 
  75 |     |         // set immutables
  76 |     |         constants.owner = owner;
  77 |     |         constants.factory = original;
  78 |     |         constants.genesisTime = block.timestamp.toUint32();
  79 |     |         (
  80 |     |             constants.bounds.min,
  81 |     |             constants.bounds.max
  82 |     |         ) = ILimitPoolView(poolImpl).priceBounds(constants.tickSpacing);
  83 |     | 
  84 |     |         // take that ERC1155 contract address and pass that into pool
  85 |     |         // launch pool token
  86 |     |         constants.poolToken = tokenImpl.cloneDeterministic({
  87 |     |             salt: key,
  88 |     |             data: abi.encodePacked(
  89 |     |                 PositionTokens.name(constants.token0, constants.token1),
  90 |     |                 PositionTokens.symbol(constants.token0, constants.token1)
  91 |     |             )
  92 |     |         });
  93 |     | 
  94 |     |         // launch pool
  95 |     |         pool = poolImpl.cloneDeterministic({
  96 |     |             salt: key,
  97 |     |             data: abi.encodePacked(
  98 |     |                 constants.owner,
  99 |     |                 constants.token0,
 100 |     |                 constants.token1,
 101 |     |                 constants.poolToken,
 102 |     |                 constants.bounds.min,
 103 |     |                 constants.bounds.max,
 104 |     |                 constants.genesisTime,
 105 |     |                 constants.tickSpacing,
 106 |     |                 constants.swapFee
 107 |     |             )
 108 |     |         });
 109 |     | 
 110 |     |         // initialize pool storage
 111 |     |         ILimitPool(pool).initialize(params.startPrice);
 112 |     | 
 113 |     |         // save pool in mapping
 114 |     |         pools[key] = pool;
 115 |     | 
 116 |     |         emit PoolCreated(
 117 |     |             pool,
 118 |     |             constants.poolToken,
 119 |     |             constants.token0,
 120 |     |             constants.token1,
 121 |     |             constants.swapFee,
 122 |     |             constants.tickSpacing,
 123 |     |             params.poolTypeId
 124 |     |         );
 125 |     | 
 126 |     |         return (pool, constants.poolToken);
 127 |     |     }
 128 |     | 
 129 |     |     function getLimitPool(
 130 |     |         address tokenIn,
 131 |     |         address tokenOut,
 132 |     |         uint16 swapFee,
 133 |     |         uint16 poolTypeId
 134 |     |     ) public view override returns (
 135 |     |         address pool,
 136 |     |         address poolToken
 137 |     |     ) {
 138 |     |         // set lexographical token address ordering
 139 |     |         address token0 = tokenIn < tokenOut ? tokenIn : tokenOut;
 140 |     |         address token1 = tokenIn < tokenOut ? tokenOut : tokenIn;
 141 |     | 
 142 |     |         // check if tick spacing supported
 143 |     |         int16 tickSpacing = ILimitPoolManager(owner).feeTiers(swapFee);
 144 |     |         if (tickSpacing == 0) require(false, 'FeeTierNotSupported()');
 145 |     | 
 146 |     |         // check if pool type supported
 147 |     |         (
 148 |     |             address poolImpl,
 149 |     |             address tokenImpl
 150 |     |          ) = ILimitPoolManager(owner).poolTypes(poolTypeId);
 151 |     |         if (poolImpl == address(0) || tokenImpl == address(0)) require(false, 'PoolTypeNotSupported()');
 152 |     | 
 153 |     |         // generate key for pool
 154 |     |         bytes32 key = keccak256(abi.encode(
 155 |     |             poolImpl,
 156 |     |             token0,
 157 |     |             token1,
 158 |     |             swapFee
 159 |     |         ));
 160 |     | 
 161 |     |         pool = pools[key];
 162 |     | 
 163 |     |         poolToken = LibClone.predictDeterministicAddress(
 164 |     |             tokenImpl,
 165 |     |             abi.encodePacked(
 166 |     |                 PositionTokens.name(token0, token1),
 167 |     |                 PositionTokens.symbol(token0, token1)
 168 |     |             ),
 169 |     |             key,
 170 |     |             address(this)
 171 |     |         );
 172 |     | 
 173 |     |         return (pool, poolToken);
 174 |     |     }
 175 |     | }
 176 |     | 

/root/git/limit/contracts/base/events/LimitPoolFactoryEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolFactoryEvents {
  5 |     |     event PoolCreated(
  6 |     |         address pool,
  7 |     |         address token,
  8 |     |         address indexed token0,
  9 |     |         address indexed token1,
 10 |     |         uint16 indexed swapFee,
 11 |     |         int16 tickSpacing,
 12 |     |         uint16 poolTypeId
 13 |     |     );
 14 |     | }
 15 |     | 

/root/git/limit/contracts/base/events/LimitPoolManagerEvents.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | abstract contract LimitPoolManagerEvents is PoolsharkStructs {
  7 |     |     event FactoryChanged(address indexed previousFactory, address indexed newFactory);
  8 |     |     event PoolTypeEnabled(
  9 |     |         bytes32 poolTypeName,
 10 |     |         address poolImpl,
 11 |     |         address tokenImpl,
 12 |     |         uint16  poolTypeId
 13 |     |     );
 14 |     |     event FeeTierEnabled(
 15 |     |         uint16 swapFee,
 16 |     |         int16 tickSpacing
 17 |     |     );
 18 |     |     event FeeToTransfer(address indexed previousFeeTo, address indexed newFeeTo);
 19 |     |     event OwnerTransfer(address indexed previousOwner, address indexed newOwner);
 20 |     |     event ProtocolSwapFeesModified(
 21 |     |         address[] pools,
 22 |     |         int16[] protocolSwapFees0,
 23 |     |         int16[] protocolSwapFees1
 24 |     |     );
 25 |     |     event ProtocolFillFeesModified(
 26 |     |         address[] pools,
 27 |     |         int16[] protocolFillFees0,
 28 |     |         int16[] protocolFillFees1
 29 |     |     );
 30 |     |     event ProtocolFeesCollected(
 31 |     |         address[] pools,
 32 |     |         uint128[] token0FeesCollected,
 33 |     |         uint128[] token1FeesCollected
 34 |     |     );
 35 |     | }

/root/git/limit/contracts/base/storage/LimitPoolFactoryStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract LimitPoolFactoryStorage {
  5 |     |     mapping(bytes32 => address) public pools;
  6 |     | }
  7 |     | 
  8 |     | 
  9 |     | 
 10 |     | 
 11 |     | 

/root/git/limit/contracts/base/storage/LimitPoolImmutables.sol
  1 |     | // SPDX-License-Identifier: BSD
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import { Clone } from "../../external/solady/Clone.sol";
  5 |     | 
  6 |     | contract LimitPoolImmutables is Clone {
  7 |     |     function owner() public pure returns (address) {
  8 |     |         return _getArgAddress(0);
  9 |     |     }
 10 |     | 
 11 |     |     function token0() public pure returns (address) {
 12 |     |         return _getArgAddress(20);
 13 |     |     }
 14 |     | 
 15 |     |     function token1() public pure returns (address) {
 16 |     |         return _getArgAddress(40);
 17 |     |     }
 18 |     | 
 19 |     |     function poolToken() public pure returns (address) {
 20 |     |         return _getArgAddress(60);
 21 |     |     }
 22 |     | 
 23 |     |     function minPrice() public pure returns (uint160) {
 24 |     |         return _getArgUint160(80);
 25 |     |     }
 26 |     | 
 27 |     |     function maxPrice() public pure returns (uint160) {
 28 |     |         return _getArgUint160(100);
 29 |     |     }
 30 |     | 
 31 |     |     function genesisTime() public pure returns (uint32) {
 32 |     |         return _getArgUint32(120);
 33 |     |     }
 34 |     | 
 35 |     |     function tickSpacing() public pure returns (int16) {
 36 |     |         return int16(_getArgUint16(124));
 37 |     |     }
 38 |     | 
 39 |     |     function swapFee() public pure returns (uint16) {
 40 |     |         return _getArgUint16(126);
 41 |     |     }
 42 |     | }

/root/git/limit/contracts/base/storage/LimitPoolStorage.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/RangePoolStructs.sol';
  5 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
  6 |     | import '../../interfaces/limit/ILimitPoolFactory.sol';
  7 |     | import '../../interfaces/limit/ILimitPoolStorageView.sol';
  8 |     | 
  9 |     | abstract contract LimitPoolStorage is ILimitPoolStorageView, RangePoolStructs {
 10 |     |     GlobalState public globalState; ///@dev - holds pool state and other contract storage
 11 |     |     TickMap public rangeTickMap; ///@dev - tick bitmap for range ticks
 12 |     |     TickMap public limitTickMap; ///@dev - tick bitmap for limit ticks
 13 |     |     Sample[65535] public samples; ///@dev - oracle TWAP samples
 14 |     |     mapping(int24 => Tick) public ticks; ///@dev - range and limit tick data
 15 |     |     mapping(uint256 => RangePosition) public positions;  ///@dev - range positions token0 <> token1
 16 |     |     mapping(uint256 => LimitPosition) public positions0; ///@dev - limit positions token0 -> token1
 17 |     |     mapping(uint256 => LimitPosition) public positions1; ///@dev - limit positions token0 <- token1
 18 |     | }
 19 |     | 

/root/git/limit/contracts/base/storage/PositionERC1155Immutables.sol
  1 |     | // SPDX-License-Identifier: BSD
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import { Clone } from "../../external/solady/Clone.sol";
  5 |     | 
  6 |     | contract PositionERC1155Immutables is Clone {
  7 |     |     function tokenName() public pure returns (bytes32) {
  8 |     |         return _getArgBytes32(0);
  9 |     |     }
 10 |     | 
 11 |     |     function tokenSymbol() public pure returns (bytes32) {
 12 |     |         return _getArgBytes32(32);
 13 |     |     }
 14 |     | }

/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  22 |     |  * instead returning `false` on failure. This behavior is nonetheless
  23 |     |  * conventional and does not conflict with the expectations of ERC20
  24 |     |  * applications.
  25 |     |  *
  26 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  27 |     |  * This allows applications to reconstruct the allowance for all accounts just
  28 |     |  * by listening to said events. Other implementations of the EIP may not emit
  29 |     |  * these events, as it isn't required by the specification.
  30 |     |  *
  31 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  32 |     |  * functions have been added to mitigate the well-known issues around setting
  33 |     |  * allowances. See {IERC20-approve}.
  34 |     |  */
  35 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  36 |     |     mapping(address => uint256) private _balances;
  37 |     | 
  38 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  39 |     | 
  40 |     |     uint256 private _totalSupply;
  41 |     | 
  42 |     |     string private _name;
  43 |     |     string private _symbol;
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Sets the values for {name} and {symbol}.
  47 |     |      *
  48 |     |      * The default value of {decimals} is 18. To select a different value for
  49 |     |      * {decimals} you should overload it.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 |     |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the value {ERC20} uses, unless this function is
  81 |     |      * overridden;
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 |     |     function decimals() public view virtual override returns (uint8) {
  88 |     |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 |     |     function totalSupply() public view virtual override returns (uint256) {
  95 |     |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 | *   |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 | *   |         address owner = _msgSender();
 115 | *   |         _transfer(owner, to, amount);
 116 | *   |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 | *   |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(
 159 |     |         address from,
 160 |     |         address to,
 161 |     |         uint256 amount
 162 | *   |     ) public virtual override returns (bool) {
 163 | *   |         address spender = _msgSender();
 164 | *   |         _spendAllowance(from, spender, amount);
 165 | *   |         _transfer(from, to, amount);
 166 | *   |         return true;
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 171 |     |      *
 172 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 173 |     |      * problems described in {IERC20-approve}.
 174 |     |      *
 175 |     |      * Emits an {Approval} event indicating the updated allowance.
 176 |     |      *
 177 |     |      * Requirements:
 178 |     |      *
 179 |     |      * - `spender` cannot be the zero address.
 180 |     |      */
 181 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 182 |     |         address owner = _msgSender();
 183 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 184 |     |         return true;
 185 |     |     }
 186 |     | 
 187 |     |     /**
 188 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 189 |     |      *
 190 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 191 |     |      * problems described in {IERC20-approve}.
 192 |     |      *
 193 |     |      * Emits an {Approval} event indicating the updated allowance.
 194 |     |      *
 195 |     |      * Requirements:
 196 |     |      *
 197 |     |      * - `spender` cannot be the zero address.
 198 |     |      * - `spender` must have allowance for the caller of at least
 199 |     |      * `subtractedValue`.
 200 |     |      */
 201 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 202 |     |         address owner = _msgSender();
 203 |     |         uint256 currentAllowance = allowance(owner, spender);
 204 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 205 |     |         unchecked {
 206 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 207 |     |         }
 208 |     | 
 209 |     |         return true;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 214 |     |      *
 215 |     |      * This internal function is equivalent to {transfer}, and can be used to
 216 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 217 |     |      *
 218 |     |      * Emits a {Transfer} event.
 219 |     |      *
 220 |     |      * Requirements:
 221 |     |      *
 222 |     |      * - `from` cannot be the zero address.
 223 |     |      * - `to` cannot be the zero address.
 224 |     |      * - `from` must have a balance of at least `amount`.
 225 |     |      */
 226 | *   |     function _transfer(
 227 |     |         address from,
 228 |     |         address to,
 229 |     |         uint256 amount
 230 | *   |     ) internal virtual {
 231 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 232 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 233 |     | 
 234 | *   |         _beforeTokenTransfer(from, to, amount);
 235 |     | 
 236 | *   |         uint256 fromBalance = _balances[from];
 237 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 238 |     |         unchecked {
 239 | *   |             _balances[from] = fromBalance - amount;
 240 |     |         }
 241 | *   |         _balances[to] += amount;
 242 |     | 
 243 | *   |         emit Transfer(from, to, amount);
 244 |     | 
 245 | *   |         _afterTokenTransfer(from, to, amount);
 246 |     |     }
 247 |     | 
 248 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 249 |     |      * the total supply.
 250 |     |      *
 251 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 252 |     |      *
 253 |     |      * Requirements:
 254 |     |      *
 255 |     |      * - `account` cannot be the zero address.
 256 |     |      */
 257 | *   |     function _mint(address account, uint256 amount) internal virtual {
 258 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 259 |     | 
 260 | *   |         _beforeTokenTransfer(address(0), account, amount);
 261 |     | 
 262 | *   |         _totalSupply += amount;
 263 | *   |         _balances[account] += amount;
 264 | *   |         emit Transfer(address(0), account, amount);
 265 |     | 
 266 | *   |         _afterTokenTransfer(address(0), account, amount);
 267 |     |     }
 268 |     | 
 269 |     |     /**
 270 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 271 |     |      * total supply.
 272 |     |      *
 273 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 274 |     |      *
 275 |     |      * Requirements:
 276 |     |      *
 277 |     |      * - `account` cannot be the zero address.
 278 |     |      * - `account` must have at least `amount` tokens.
 279 |     |      */
 280 |     |     function _burn(address account, uint256 amount) internal virtual {
 281 |     |         require(account != address(0), "ERC20: burn from the zero address");
 282 |     | 
 283 |     |         _beforeTokenTransfer(account, address(0), amount);
 284 |     | 
 285 |     |         uint256 accountBalance = _balances[account];
 286 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 287 |     |         unchecked {
 288 |     |             _balances[account] = accountBalance - amount;
 289 |     |         }
 290 |     |         _totalSupply -= amount;
 291 |     | 
 292 |     |         emit Transfer(account, address(0), amount);
 293 |     | 
 294 |     |         _afterTokenTransfer(account, address(0), amount);
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 299 |     |      *
 300 |     |      * This internal function is equivalent to `approve`, and can be used to
 301 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 302 |     |      *
 303 |     |      * Emits an {Approval} event.
 304 |     |      *
 305 |     |      * Requirements:
 306 |     |      *
 307 |     |      * - `owner` cannot be the zero address.
 308 |     |      * - `spender` cannot be the zero address.
 309 |     |      */
 310 | *   |     function _approve(
 311 |     |         address owner,
 312 |     |         address spender,
 313 |     |         uint256 amount
 314 |     |     ) internal virtual {
 315 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 316 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 317 |     | 
 318 | *   |         _allowances[owner][spender] = amount;
 319 | *   |         emit Approval(owner, spender, amount);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 324 |     |      *
 325 |     |      * Does not update the allowance amount in case of infinite allowance.
 326 |     |      * Revert if not enough allowance is available.
 327 |     |      *
 328 |     |      * Might emit an {Approval} event.
 329 |     |      */
 330 | *   |     function _spendAllowance(
 331 |     |         address owner,
 332 |     |         address spender,
 333 |     |         uint256 amount
 334 | *   |     ) internal virtual {
 335 | *   |         uint256 currentAllowance = allowance(owner, spender);
 336 | *   |         if (currentAllowance != type(uint256).max) {
 337 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 338 |     |             unchecked {
 339 |     |                 _approve(owner, spender, currentAllowance - amount);
 340 |     |             }
 341 |     |         }
 342 |     |     }
 343 |     | 
 344 |     |     /**
 345 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 346 |     |      * minting and burning.
 347 |     |      *
 348 |     |      * Calling conditions:
 349 |     |      *
 350 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 351 |     |      * will be transferred to `to`.
 352 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 353 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 354 |     |      * - `from` and `to` are never both zero.
 355 |     |      *
 356 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 357 |     |      */
 358 | *   |     function _beforeTokenTransfer(
 359 |     |         address from,
 360 |     |         address to,
 361 |     |         uint256 amount
 362 |     |     ) internal virtual {}
 363 |     | 
 364 |     |     /**
 365 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 366 |     |      * minting and burning.
 367 |     |      *
 368 |     |      * Calling conditions:
 369 |     |      *
 370 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 371 |     |      * has been transferred to `to`.
 372 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 373 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 374 |     |      * - `from` and `to` are never both zero.
 375 |     |      *
 376 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 377 |     |      */
 378 | *   |     function _afterTokenTransfer(
 379 |     |         address from,
 380 |     |         address to,
 381 |     |         uint256 amount
 382 |     |     ) internal virtual {}
 383 |     | }
 384 |     | 

/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(
 78 |     |         address from,
 79 |     |         address to,
 80 |     |         uint256 amount
 81 |     |     ) external returns (bool);
 82 |     | }
 83 |     | 

/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../ERC20.sol";
  7 |     | import "../../../utils/Context.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev Extension of {ERC20} that allows token holders to destroy both their own
 11 |     |  * tokens and those that they have an allowance for, in a way that can be
 12 |     |  * recognized off-chain (via event analysis).
 13 |     |  */
 14 |     | abstract contract ERC20Burnable is Context, ERC20 {
 15 |     |     /**
 16 |     |      * @dev Destroys `amount` tokens from the caller.
 17 |     |      *
 18 |     |      * See {ERC20-_burn}.
 19 |     |      */
 20 |     |     function burn(uint256 amount) public virtual {
 21 |     |         _burn(_msgSender(), amount);
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Destroys `amount` tokens from `account`, deducting from the caller's
 26 |     |      * allowance.
 27 |     |      *
 28 |     |      * See {ERC20-_burn} and {ERC20-allowance}.
 29 |     |      *
 30 |     |      * Requirements:
 31 |     |      *
 32 |     |      * - the caller must have allowance for ``accounts``'s tokens of at least
 33 |     |      * `amount`.
 34 |     |      */
 35 |     |     function burnFrom(address account, uint256 amount) public virtual {
 36 |     |         _spendAllowance(account, _msgSender(), amount);
 37 |     |         _burn(account, amount);
 38 |     |     }
 39 |     | }
 40 |     | 

/root/git/limit/contracts/external/openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | pragma solidity 0.8.13;
  4 |     | 
  5 |     | import {IERC20} from "../IERC20.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
  9 |     |  */
 10 |     | interface IERC20Metadata is IERC20 {
 11 |     |     /**
 12 |     |      * @dev Returns the name of the token.
 13 |     |      */
 14 |     |     function name() external view returns (string memory);
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Returns the symbol of the token.
 18 |     |      */
 19 |     |     function symbol() external view returns (string memory);
 20 |     | 
 21 |     |     /**
 22 |     |      * @dev Returns the decimals places of the token.
 23 |     |      */
 24 |     |     function decimals() external view returns (uint8);
 25 |     | }

/root/git/limit/contracts/external/openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 | *   |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | }
 25 |     | 

/root/git/limit/contracts/external/openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/root/git/limit/contracts/external/openzeppelin/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity 0.8.13;
  5 |     | 
  6 |     | import '../../../interfaces/structs/PoolsharkStructs.sol';
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
 10 |     |  *
 11 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 12 |     |  * available, which can be applied to functions to make sure there are no nested
 13 |     |  * (reentrant) calls to them.
 14 |     |  *
 15 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 16 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 17 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 18 |     |  * points to them.
 19 |     |  *
 20 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 21 |     |  * to protect against it, check out our blog post
 22 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 23 |     |  */
 24 |     | abstract contract ReentrancyGuard is PoolsharkStructs {
 25 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 26 |     |     // word because each write operation emits an extra SLOAD to first read the
 27 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 28 |     |     // back. This is the compiler's defense against contract upgrades and
 29 |     |     // pointer aliasing, and it cannot be disabled.
 30 |     | 
 31 |     |     // The values being non-zero value makes deployment a bit more expensive,
 32 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 33 |     |     // amount. Since refunds are capped to a percentage of the total
 34 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 35 |     |     // increase the likelihood of the full refund coming into effect.
 36 |     |     uint8 private constant _NOT_ENTERED = 1;
 37 |     |     uint8 private constant _ENTERED = 2;
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Unauthorized reentrant call.
 41 |     |      */
 42 |     |     error ReentrancyGuardReentrantCall();
 43 |     | 
 44 |     |     /**
 45 |     |      * @dev Unauthorized read-only reentrant call.
 46 |     |      */
 47 |     |     error ReentrancyGuardReadOnlyReentrantCall();
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev Reentrant state invalid.
 51 |     |      */
 52 |     |     error ReentrancyGuardInvalidState();
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 56 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 57 |     |      * function is not supported. It is possible to prevent this from happening
 58 |     |      * by making the `nonReentrant` function external, and making it call a
 59 |     |      * `private` function that does the actual work.
 60 |     |      */
 61 |     |     modifier nonReentrant(GlobalState storage state) {
 62 |     |         _nonReentrantBefore(state);
 63 |     |         _;
 64 |     |         _nonReentrantAfter(state);
 65 |     |     }
 66 |     | 
 67 |     |     function _nonReentrantBefore(GlobalState storage state) private {
 68 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 69 |     |         if (state.unlocked == _ENTERED) {
 70 |     |             revert ReentrancyGuardReentrantCall();
 71 |     |         }
 72 |     | 
 73 |     |         // Any calls to nonReentrant after this point will fail
 74 |     |         state.unlocked = _ENTERED;
 75 |     |     }
 76 |     | 
 77 |     |     function _nonReentrantAfter(GlobalState storage state) private {
 78 |     |         if (state.unlocked != _ENTERED) revert ReentrancyGuardInvalidState();
 79 |     |         // By storing the original value once again, a refund is triggered (see
 80 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 81 |     |         state.unlocked = _NOT_ENTERED;
 82 |     |     }
 83 |     | 
 84 |     |     /**
 85 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 86 |     |      * `nonReentrant` function in the call stack.
 87 |     |      */
 88 |     |     function _reentrancyGuardEntered(GlobalState storage state) internal view returns (bool) {
 89 |     |         return state.unlocked == _ENTERED;
 90 |     |     }
 91 |     | }

/root/git/limit/contracts/external/solady/Clone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Class with helper read functions for clone with immutable args.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Clone.sol)
   6 |     | /// @author Adapted from clones with immutable args by zefram.eth, Saw-mon & Natalie
   7 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   8 |     | abstract contract Clone {
   9 |     |     /// @dev Reads an immutable arg with type bytes.
  10 |     |     function _getArgBytes(uint256 argOffset, uint256 length)
  11 |     |         internal
  12 |     |         pure
  13 |     |         returns (bytes memory arg)
  14 |     |     {
  15 |     |         uint256 offset = _getImmutableArgsOffset();
  16 |     |         /// @solidity memory-safe-assembly
  17 |     |         assembly {
  18 |     |             arg := mload(0x40)
  19 |     |             mstore(arg, length) // Store the length.
  20 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), length)
  21 |     |             let o := add(add(arg, 0x20), length)
  22 |     |             mstore(o, 0) // Zeroize the slot after the bytes.
  23 |     |             mstore(0x40, add(o, 0x20)) // Allocate the memory.
  24 |     |         }
  25 |     |     }
  26 |     | 
  27 |     |     /// @dev Reads an immutable arg with type address.
  28 |     |     function _getArgAddress(uint256 argOffset) internal pure returns (address arg) {
  29 |     |         uint256 offset = _getImmutableArgsOffset();
  30 |     |         /// @solidity memory-safe-assembly
  31 |     |         assembly {
  32 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
  33 |     |         }
  34 |     |     }
  35 |     | 
  36 |     |     /// @dev Reads a uint256 array stored in the immutable args.
  37 |     |     function _getArgUint256Array(uint256 argOffset, uint256 length)
  38 |     |         internal
  39 |     |         pure
  40 |     |         returns (uint256[] memory arg)
  41 |     |     {
  42 |     |         uint256 offset = _getImmutableArgsOffset();
  43 |     |         /// @solidity memory-safe-assembly
  44 |     |         assembly {
  45 |     |             arg := mload(0x40)
  46 |     |             mstore(arg, length) // Store the length.
  47 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  48 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @dev Reads a bytes32 array stored in the immutable args.
  53 |     |     function _getArgBytes32Array(uint256 argOffset, uint256 length)
  54 |     |         internal
  55 |     |         pure
  56 |     |         returns (bytes32[] memory arg)
  57 |     |     {
  58 |     |         uint256 offset = _getImmutableArgsOffset();
  59 |     |         /// @solidity memory-safe-assembly
  60 |     |         assembly {
  61 |     |             arg := mload(0x40)
  62 |     |             mstore(arg, length) // Store the length.
  63 |     |             calldatacopy(add(arg, 0x20), add(offset, argOffset), shl(5, length))
  64 |     |             mstore(0x40, add(add(arg, 0x20), shl(5, length))) // Allocate the memory.
  65 |     |         }
  66 |     |     }
  67 |     | 
  68 |     |     /// @dev Reads an immutable arg with type bytes32.
  69 |     |     function _getArgBytes32(uint256 argOffset) internal pure returns (bytes32 arg) {
  70 |     |         uint256 offset = _getImmutableArgsOffset();
  71 |     |         /// @solidity memory-safe-assembly
  72 |     |         assembly {
  73 |     |             arg := calldataload(add(offset, argOffset))
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /// @dev Reads an immutable arg with type uint256.
  78 |     |     function _getArgUint256(uint256 argOffset) internal pure returns (uint256 arg) {
  79 |     |         uint256 offset = _getImmutableArgsOffset();
  80 |     |         /// @solidity memory-safe-assembly
  81 |     |         assembly {
  82 |     |             arg := calldataload(add(offset, argOffset))
  83 |     |         }
  84 |     |     }
  85 |     | 
  86 |     |     /// @dev Reads an immutable arg with type uint248.
  87 |     |     function _getArgUint248(uint256 argOffset) internal pure returns (uint248 arg) {
  88 |     |         uint256 offset = _getImmutableArgsOffset();
  89 |     |         /// @solidity memory-safe-assembly
  90 |     |         assembly {
  91 |     |             arg := shr(8, calldataload(add(offset, argOffset)))
  92 |     |         }
  93 |     |     }
  94 |     | 
  95 |     |     /// @dev Reads an immutable arg with type uint240.
  96 |     |     function _getArgUint240(uint256 argOffset) internal pure returns (uint240 arg) {
  97 |     |         uint256 offset = _getImmutableArgsOffset();
  98 |     |         /// @solidity memory-safe-assembly
  99 |     |         assembly {
 100 |     |             arg := shr(16, calldataload(add(offset, argOffset)))
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     /// @dev Reads an immutable arg with type uint232.
 105 |     |     function _getArgUint232(uint256 argOffset) internal pure returns (uint232 arg) {
 106 |     |         uint256 offset = _getImmutableArgsOffset();
 107 |     |         /// @solidity memory-safe-assembly
 108 |     |         assembly {
 109 |     |             arg := shr(24, calldataload(add(offset, argOffset)))
 110 |     |         }
 111 |     |     }
 112 |     | 
 113 |     |     /// @dev Reads an immutable arg with type uint224.
 114 |     |     function _getArgUint224(uint256 argOffset) internal pure returns (uint224 arg) {
 115 |     |         uint256 offset = _getImmutableArgsOffset();
 116 |     |         /// @solidity memory-safe-assembly
 117 |     |         assembly {
 118 |     |             arg := shr(0x20, calldataload(add(offset, argOffset)))
 119 |     |         }
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev Reads an immutable arg with type uint216.
 123 |     |     function _getArgUint216(uint256 argOffset) internal pure returns (uint216 arg) {
 124 |     |         uint256 offset = _getImmutableArgsOffset();
 125 |     |         /// @solidity memory-safe-assembly
 126 |     |         assembly {
 127 |     |             arg := shr(40, calldataload(add(offset, argOffset)))
 128 |     |         }
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev Reads an immutable arg with type uint208.
 132 |     |     function _getArgUint208(uint256 argOffset) internal pure returns (uint208 arg) {
 133 |     |         uint256 offset = _getImmutableArgsOffset();
 134 |     |         /// @solidity memory-safe-assembly
 135 |     |         assembly {
 136 |     |             arg := shr(48, calldataload(add(offset, argOffset)))
 137 |     |         }
 138 |     |     }
 139 |     | 
 140 |     |     /// @dev Reads an immutable arg with type uint200.
 141 |     |     function _getArgUint200(uint256 argOffset) internal pure returns (uint200 arg) {
 142 |     |         uint256 offset = _getImmutableArgsOffset();
 143 |     |         /// @solidity memory-safe-assembly
 144 |     |         assembly {
 145 |     |             arg := shr(56, calldataload(add(offset, argOffset)))
 146 |     |         }
 147 |     |     }
 148 |     | 
 149 |     |     /// @dev Reads an immutable arg with type uint192.
 150 |     |     function _getArgUint192(uint256 argOffset) internal pure returns (uint192 arg) {
 151 |     |         uint256 offset = _getImmutableArgsOffset();
 152 |     |         /// @solidity memory-safe-assembly
 153 |     |         assembly {
 154 |     |             arg := shr(64, calldataload(add(offset, argOffset)))
 155 |     |         }
 156 |     |     }
 157 |     | 
 158 |     |     /// @dev Reads an immutable arg with type uint184.
 159 |     |     function _getArgUint184(uint256 argOffset) internal pure returns (uint184 arg) {
 160 |     |         uint256 offset = _getImmutableArgsOffset();
 161 |     |         /// @solidity memory-safe-assembly
 162 |     |         assembly {
 163 |     |             arg := shr(72, calldataload(add(offset, argOffset)))
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @dev Reads an immutable arg with type uint176.
 168 |     |     function _getArgUint176(uint256 argOffset) internal pure returns (uint176 arg) {
 169 |     |         uint256 offset = _getImmutableArgsOffset();
 170 |     |         /// @solidity memory-safe-assembly
 171 |     |         assembly {
 172 |     |             arg := shr(80, calldataload(add(offset, argOffset)))
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /// @dev Reads an immutable arg with type uint168.
 177 |     |     function _getArgUint168(uint256 argOffset) internal pure returns (uint168 arg) {
 178 |     |         uint256 offset = _getImmutableArgsOffset();
 179 |     |         /// @solidity memory-safe-assembly
 180 |     |         assembly {
 181 |     |             arg := shr(88, calldataload(add(offset, argOffset)))
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @dev Reads an immutable arg with type uint160.
 186 |     |     function _getArgUint160(uint256 argOffset) internal pure returns (uint160 arg) {
 187 |     |         uint256 offset = _getImmutableArgsOffset();
 188 |     |         /// @solidity memory-safe-assembly
 189 |     |         assembly {
 190 |     |             arg := shr(96, calldataload(add(offset, argOffset)))
 191 |     |         }
 192 |     |     }
 193 |     | 
 194 |     |     /// @dev Reads an immutable arg with type uint152.
 195 |     |     function _getArgUint152(uint256 argOffset) internal pure returns (uint152 arg) {
 196 |     |         uint256 offset = _getImmutableArgsOffset();
 197 |     |         /// @solidity memory-safe-assembly
 198 |     |         assembly {
 199 |     |             arg := shr(104, calldataload(add(offset, argOffset)))
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @dev Reads an immutable arg with type uint144.
 204 |     |     function _getArgUint144(uint256 argOffset) internal pure returns (uint144 arg) {
 205 |     |         uint256 offset = _getImmutableArgsOffset();
 206 |     |         /// @solidity memory-safe-assembly
 207 |     |         assembly {
 208 |     |             arg := shr(112, calldataload(add(offset, argOffset)))
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     /// @dev Reads an immutable arg with type uint136.
 213 |     |     function _getArgUint136(uint256 argOffset) internal pure returns (uint136 arg) {
 214 |     |         uint256 offset = _getImmutableArgsOffset();
 215 |     |         /// @solidity memory-safe-assembly
 216 |     |         assembly {
 217 |     |             arg := shr(120, calldataload(add(offset, argOffset)))
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     /// @dev Reads an immutable arg with type uint128.
 222 |     |     function _getArgUint128(uint256 argOffset) internal pure returns (uint128 arg) {
 223 |     |         uint256 offset = _getImmutableArgsOffset();
 224 |     |         /// @solidity memory-safe-assembly
 225 |     |         assembly {
 226 |     |             arg := shr(128, calldataload(add(offset, argOffset)))
 227 |     |         }
 228 |     |     }
 229 |     | 
 230 |     |     /// @dev Reads an immutable arg with type uint120.
 231 |     |     function _getArgUint120(uint256 argOffset) internal pure returns (uint120 arg) {
 232 |     |         uint256 offset = _getImmutableArgsOffset();
 233 |     |         /// @solidity memory-safe-assembly
 234 |     |         assembly {
 235 |     |             arg := shr(136, calldataload(add(offset, argOffset)))
 236 |     |         }
 237 |     |     }
 238 |     | 
 239 |     |     /// @dev Reads an immutable arg with type uint112.
 240 |     |     function _getArgUint112(uint256 argOffset) internal pure returns (uint112 arg) {
 241 |     |         uint256 offset = _getImmutableArgsOffset();
 242 |     |         /// @solidity memory-safe-assembly
 243 |     |         assembly {
 244 |     |             arg := shr(144, calldataload(add(offset, argOffset)))
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /// @dev Reads an immutable arg with type uint104.
 249 |     |     function _getArgUint104(uint256 argOffset) internal pure returns (uint104 arg) {
 250 |     |         uint256 offset = _getImmutableArgsOffset();
 251 |     |         /// @solidity memory-safe-assembly
 252 |     |         assembly {
 253 |     |             arg := shr(152, calldataload(add(offset, argOffset)))
 254 |     |         }
 255 |     |     }
 256 |     | 
 257 |     |     /// @dev Reads an immutable arg with type uint96.
 258 |     |     function _getArgUint96(uint256 argOffset) internal pure returns (uint96 arg) {
 259 |     |         uint256 offset = _getImmutableArgsOffset();
 260 |     |         /// @solidity memory-safe-assembly
 261 |     |         assembly {
 262 |     |             arg := shr(160, calldataload(add(offset, argOffset)))
 263 |     |         }
 264 |     |     }
 265 |     | 
 266 |     |     /// @dev Reads an immutable arg with type uint88.
 267 |     |     function _getArgUint88(uint256 argOffset) internal pure returns (uint88 arg) {
 268 |     |         uint256 offset = _getImmutableArgsOffset();
 269 |     |         /// @solidity memory-safe-assembly
 270 |     |         assembly {
 271 |     |             arg := shr(168, calldataload(add(offset, argOffset)))
 272 |     |         }
 273 |     |     }
 274 |     | 
 275 |     |     /// @dev Reads an immutable arg with type uint80.
 276 |     |     function _getArgUint80(uint256 argOffset) internal pure returns (uint80 arg) {
 277 |     |         uint256 offset = _getImmutableArgsOffset();
 278 |     |         /// @solidity memory-safe-assembly
 279 |     |         assembly {
 280 |     |             arg := shr(176, calldataload(add(offset, argOffset)))
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     /// @dev Reads an immutable arg with type uint72.
 285 |     |     function _getArgUint72(uint256 argOffset) internal pure returns (uint72 arg) {
 286 |     |         uint256 offset = _getImmutableArgsOffset();
 287 |     |         /// @solidity memory-safe-assembly
 288 |     |         assembly {
 289 |     |             arg := shr(184, calldataload(add(offset, argOffset)))
 290 |     |         }
 291 |     |     }
 292 |     | 
 293 |     |     /// @dev Reads an immutable arg with type uint64.
 294 |     |     function _getArgUint64(uint256 argOffset) internal pure returns (uint64 arg) {
 295 |     |         uint256 offset = _getImmutableArgsOffset();
 296 |     |         /// @solidity memory-safe-assembly
 297 |     |         assembly {
 298 |     |             arg := shr(192, calldataload(add(offset, argOffset)))
 299 |     |         }
 300 |     |     }
 301 |     | 
 302 |     |     /// @dev Reads an immutable arg with type uint56.
 303 |     |     function _getArgUint56(uint256 argOffset) internal pure returns (uint56 arg) {
 304 |     |         uint256 offset = _getImmutableArgsOffset();
 305 |     |         /// @solidity memory-safe-assembly
 306 |     |         assembly {
 307 |     |             arg := shr(200, calldataload(add(offset, argOffset)))
 308 |     |         }
 309 |     |     }
 310 |     | 
 311 |     |     /// @dev Reads an immutable arg with type uint48.
 312 |     |     function _getArgUint48(uint256 argOffset) internal pure returns (uint48 arg) {
 313 |     |         uint256 offset = _getImmutableArgsOffset();
 314 |     |         /// @solidity memory-safe-assembly
 315 |     |         assembly {
 316 |     |             arg := shr(208, calldataload(add(offset, argOffset)))
 317 |     |         }
 318 |     |     }
 319 |     | 
 320 |     |     /// @dev Reads an immutable arg with type uint40.
 321 |     |     function _getArgUint40(uint256 argOffset) internal pure returns (uint40 arg) {
 322 |     |         uint256 offset = _getImmutableArgsOffset();
 323 |     |         /// @solidity memory-safe-assembly
 324 |     |         assembly {
 325 |     |             arg := shr(216, calldataload(add(offset, argOffset)))
 326 |     |         }
 327 |     |     }
 328 |     | 
 329 |     |     /// @dev Reads an immutable arg with type uint32.
 330 |     |     function _getArgUint32(uint256 argOffset) internal pure returns (uint32 arg) {
 331 |     |         uint256 offset = _getImmutableArgsOffset();
 332 |     |         /// @solidity memory-safe-assembly
 333 |     |         assembly {
 334 |     |             arg := shr(224, calldataload(add(offset, argOffset)))
 335 |     |         }
 336 |     |     }
 337 |     | 
 338 |     |     /// @dev Reads an immutable arg with type uint24.
 339 |     |     function _getArgUint24(uint256 argOffset) internal pure returns (uint24 arg) {
 340 |     |         uint256 offset = _getImmutableArgsOffset();
 341 |     |         /// @solidity memory-safe-assembly
 342 |     |         assembly {
 343 |     |             arg := shr(232, calldataload(add(offset, argOffset)))
 344 |     |         }
 345 |     |     }
 346 |     | 
 347 |     |     /// @dev Reads an immutable arg with type uint16.
 348 |     |     function _getArgUint16(uint256 argOffset) internal pure returns (uint16 arg) {
 349 |     |         uint256 offset = _getImmutableArgsOffset();
 350 |     |         /// @solidity memory-safe-assembly
 351 |     |         assembly {
 352 |     |             arg := shr(240, calldataload(add(offset, argOffset)))
 353 |     |         }
 354 |     |     }
 355 |     | 
 356 |     |     /// @dev Reads an immutable arg with type uint8.
 357 |     |     function _getArgUint8(uint256 argOffset) internal pure returns (uint8 arg) {
 358 |     |         uint256 offset = _getImmutableArgsOffset();
 359 |     |         /// @solidity memory-safe-assembly
 360 |     |         assembly {
 361 |     |             arg := shr(248, calldataload(add(offset, argOffset)))
 362 |     |         }
 363 |     |     }
 364 |     | 
 365 |     |     /// @return offset The offset of the packed immutable args in calldata.
 366 |     |     function _getImmutableArgsOffset() internal pure returns (uint256 offset) {
 367 |     |         /// @solidity memory-safe-assembly
 368 |     |         assembly {
 369 |     |             offset := sub(calldatasize(), shr(240, calldataload(sub(calldatasize(), 2))))
 370 |     |         }
 371 |     |     }
 372 |     | }

/root/git/limit/contracts/external/solady/LibClone.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Minimal proxy library.
   5 |     | /// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibClone.sol)
   6 |     | /// @author Minimal proxy by 0age (https://github.com/0age)
   7 |     | /// @author Clones with immutable args by wighawag, zefram.eth, Saw-mon & Natalie
   8 |     | /// (https://github.com/Saw-mon-and-Natalie/clones-with-immutable-args)
   9 |     | ///
  10 |     | /// @dev Minimal proxy:
  11 |     | /// Although the sw0nt pattern saves 5 gas over the erc-1167 pattern during runtime,
  12 |     | /// it is not supported out-of-the-box on Etherscan. Hence, we choose to use the 0age pattern,
  13 |     | /// which saves 4 gas over the erc-1167 pattern during runtime, and has the smallest bytecode.
  14 |     | ///
  15 |     | /// @dev Clones with immutable args (CWIA):
  16 |     | /// The implementation of CWIA here implements a `receive()` method that emits the
  17 |     | /// `ReceiveETH(uint256)` event. This skips the `DELEGATECALL` when there is no calldata,
  18 |     | /// enabling us to accept hard gas-capped `sends` & `transfers` for maximum backwards
  19 |     | /// composability. The minimal proxy implementation does not offer this feature.
  20 |     | library LibClone {
  21 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  22 |     |     /*                       CUSTOM ERRORS                        */
  23 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  24 |     | 
  25 |     |     /// @dev Unable to deploy the clone.
  26 |     |     error DeploymentFailed();
  27 |     | 
  28 |     |     /// @dev The salt must start with either the zero address or the caller.
  29 |     |     error SaltDoesNotStartWithCaller();
  30 |     | 
  31 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
  32 |     |     /*                  MINIMAL PROXY OPERATIONS                  */
  33 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
  34 |     | 
  35 |     |     /// @dev Deploys a deterministic clone of `implementation`,
  36 |     |     /// using immutable  arguments encoded in `data`, with `salt`.
  37 |     |     function cloneDeterministic(address implementation, bytes memory data, bytes32 salt)
  38 |     |         internal
  39 |     |         returns (address instance)
  40 |     |     {
  41 |     |         assembly {
  42 |     |             // Compute the boundaries of the data and cache the memory slots around it.
  43 |     |             let mBefore3 := mload(sub(data, 0x60))
  44 |     |             let mBefore2 := mload(sub(data, 0x40))
  45 |     |             let mBefore1 := mload(sub(data, 0x20))
  46 |     |             let dataLength := mload(data)
  47 |     |             let dataEnd := add(add(data, 0x20), dataLength)
  48 |     |             let mAfter1 := mload(dataEnd)
  49 |     | 
  50 |     |             // +2 bytes for telling how much data there is appended to the call.
  51 |     |             let extraLength := add(dataLength, 2)
  52 |     | 
  53 |     |             // Write the bytecode before the data.
  54 |     |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
  55 |     |             // Write the address of the implementation.
  56 |     |             mstore(sub(data, 0x0d), implementation)
  57 |     |             // Write the rest of the bytecode.
  58 |     |             mstore(
  59 |     |                 sub(data, 0x21),
  60 |     |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
  61 |     |             )
  62 |     |             // `keccak256("ReceiveETH(uint256)")`
  63 |     |             mstore(
  64 |     |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
  65 |     |             )
  66 |     |             mstore(
  67 |     |                 sub(data, 0x5a),
  68 |     |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
  69 |     |             )
  70 |     |             mstore(dataEnd, shl(0xf0, extraLength))
  71 |     | 
  72 |     |             // Create the instance.
  73 |     |             instance := create2(0, sub(data, 0x4c), add(extraLength, 0x6c), salt)
  74 |     | 
  75 |     |             // If `instance` is zero, revert.
  76 |     |             if iszero(instance) {
  77 |     |                 // Store the function selector of `DeploymentFailed()`.
  78 |     |                 mstore(0x00, 0x30116425)
  79 |     |                 // Revert with (offset, size).
  80 |     |                 revert(0x1c, 0x04)
  81 |     |             }
  82 |     | 
  83 |     |             // Restore the overwritten memory surrounding `data`.
  84 |     |             mstore(dataEnd, mAfter1)
  85 |     |             mstore(data, dataLength)
  86 |     |             mstore(sub(data, 0x20), mBefore1)
  87 |     |             mstore(sub(data, 0x40), mBefore2)
  88 |     |             mstore(sub(data, 0x60), mBefore3)
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /// @dev Returns the initialization code hash of the clone of `implementation`
  93 |     |     /// using immutable arguments encoded in `data`.
  94 |     |     /// Used for mining vanity addresses with create2crunch.
  95 | *   |     function initCodeHash(address implementation, bytes memory data)
  96 |     |         internal
  97 |     |         pure
  98 | *   |         returns (bytes32 hash)
  99 |     |     {
 100 | *   |         assembly {
 101 |     |             // Compute the boundaries of the data and cache the memory slots around it.
 102 | *   |             let mBefore3 := mload(sub(data, 0x60))
 103 | *   |             let mBefore2 := mload(sub(data, 0x40))
 104 | *   |             let mBefore1 := mload(sub(data, 0x20))
 105 | *   |             let dataLength := mload(data)
 106 | *   |             let dataEnd := add(add(data, 0x20), dataLength)
 107 | *   |             let mAfter1 := mload(dataEnd)
 108 |     | 
 109 |     |             // +2 bytes for telling how much data there is appended to the call.
 110 | *   |             let extraLength := add(dataLength, 2)
 111 |     | 
 112 |     |             // Write the bytecode before the data.
 113 | *   |             mstore(data, 0x5af43d3d93803e606057fd5bf3)
 114 |     |             // Write the address of the implementation.
 115 | *   |             mstore(sub(data, 0x0d), implementation)
 116 |     |             // Write the rest of the bytecode.
 117 | *   |             mstore(
 118 | *   |                 sub(data, 0x21),
 119 | *   |                 or(shl(0x48, extraLength), 0x593da1005b363d3d373d3d3d3d610000806062363936013d73)
 120 |     |             )
 121 |     |             // `keccak256("ReceiveETH(uint256)")`
 122 | *   |             mstore(
 123 | *   |                 sub(data, 0x3a), 0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff
 124 |     |             )
 125 | *   |             mstore(
 126 | *   |                 sub(data, 0x5a),
 127 | *   |                 or(shl(0x78, add(extraLength, 0x62)), 0x6100003d81600a3d39f336602c57343d527f)
 128 |     |             )
 129 | *   |             mstore(dataEnd, shl(0xf0, extraLength))
 130 |     | 
 131 |     |             // Compute and store the bytecode hash.
 132 | *   |             hash := keccak256(sub(data, 0x4c), add(extraLength, 0x6c))
 133 |     | 
 134 |     |             // Restore the overwritten memory surrounding `data`.
 135 | *   |             mstore(dataEnd, mAfter1)
 136 | *   |             mstore(data, dataLength)
 137 | *   |             mstore(sub(data, 0x20), mBefore1)
 138 | *   |             mstore(sub(data, 0x40), mBefore2)
 139 | *   |             mstore(sub(data, 0x60), mBefore3)
 140 |     |         }
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev Returns the address of the deterministic clone of
 144 |     |     /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.
 145 | *   |     function predictDeterministicAddress(
 146 |     |         address implementation,
 147 |     |         bytes memory data,
 148 |     |         bytes32 salt,
 149 |     |         address deployer
 150 | *   |     ) internal pure returns (address predicted) {
 151 | *   |         bytes32 hash = initCodeHash(implementation, data);
 152 | *   |         predicted = predictDeterministicAddress(hash, salt, deployer);
 153 |     |     }
 154 |     | 
 155 |     |     /*:.+.*.*:.*..:..*.*:.*..:.+.*.*:*/
 156 |     |     /*                      OTHER OPERATIONS                      */
 157 |     |     /*.:.+.*.:*.*.+.:*.*..:.:.*.:*.+.*/
 158 |     | 
 159 |     |     /// @dev Returns the address when a contract with initialization code hash,
 160 |     |     /// `hash`, is deployed with `salt`, by `deployer`.
 161 | *   |     function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)
 162 |     |         internal
 163 |     |         pure
 164 | *   |         returns (address predicted)
 165 |     |     {
 166 |     |         /// @solidity memory-safe-assembly
 167 |     |         assembly {
 168 |     |             // Compute and store the bytecode hash.
 169 | *   |             mstore8(0x00, 0xff) // Write the prefix.
 170 | *   |             mstore(0x35, hash)
 171 | *   |             mstore(0x01, shl(96, deployer))
 172 | *   |             mstore(0x15, salt)
 173 | *   |             predicted := keccak256(0x00, 0x55)
 174 |     |             // Restore the part of the free memory pointer that has been overwritten.
 175 | *   |             mstore(0x35, 0)
 176 |     |         }
 177 |     |     }
 178 |     | 
 179 |     |     /// @dev Reverts if `salt` does not start with either the zero address or the caller.
 180 |     |     function checkStartsWithCaller(bytes32 salt) internal view {
 181 |     |         /// @solidity memory-safe-assembly
 182 |     |         assembly {
 183 |     |             // If the salt does not start with the zero address or the caller.
 184 |     |             if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {
 185 |     |                 // Store the function selector of `SaltDoesNotStartWithCaller()`.
 186 |     |                 mstore(0x00, 0x2f634836)
 187 |     |                 // Revert with (offset, size).
 188 |     |                 revert(0x1c, 0x04)
 189 |     |             }
 190 |     |         }
 191 |     |     }
 192 |     | }

/root/git/limit/contracts/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IERC20Minimal {
  5 |     |     /// @notice Returns the balance of a token
  6 |     |     /// @param account The address for which to look up the balance for
  7 |     |     /// @return amount of tokens held by the account
  8 |     |     function balanceOf(address account) external view returns (uint256);
  9 |     | }

/root/git/limit/contracts/interfaces/IPool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../interfaces/structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface IPool is PoolsharkStructs {
  7 |     |     function immutables() external view returns (LimitImmutables memory);
  8 |     |     
  9 |     |     function swap(
 10 |     |         SwapParams memory params
 11 |     |     ) external returns (
 12 |     |         int256 amount0,
 13 |     |         int256 amount1
 14 |     |     );
 15 |     | 
 16 |     |     function quote(
 17 |     |         QuoteParams memory params
 18 |     |     ) external view returns (
 19 |     |         int256 inAmount,
 20 |     |         int256 outAmount,
 21 |     |         uint160 priceAfter
 22 |     |     );
 23 |     | 
 24 |     |     function fees(
 25 |     |         FeesParams memory params
 26 |     |     ) external returns (
 27 |     |         uint128 token0Fees,
 28 |     |         uint128 token1Fees
 29 |     |     );
 30 |     | 
 31 |     |     function sample(
 32 |     |         uint32[] memory secondsAgo
 33 |     |     ) external view returns (
 34 |     |         int56[]   memory tickSecondsAccum,
 35 |     |         uint160[] memory secondsPerLiquidityAccum,
 36 |     |         uint160 averagePrice,
 37 |     |         uint128 averageLiquidity,
 38 |     |         int24 averageTick
 39 |     |     );
 40 |     | 
 41 |     |     function snapshotRange(
 42 |     |         uint32 positionId
 43 |     |     ) external view returns(
 44 |     |         int56   tickSecondsAccum,
 45 |     |         uint160 secondsPerLiquidityAccum,
 46 |     |         uint128 feesOwed0,
 47 |     |         uint128 feesOwed1
 48 |     |     );
 49 |     | 
 50 |     |     function snapshotLimit(
 51 |     |         SnapshotLimitParams memory params
 52 |     |     ) external view returns(
 53 |     |         uint128 amountIn,
 54 |     |         uint128 amountOut
 55 |     |     );
 56 |     | 
 57 |     |     function poolToken() external view returns(
 58 |     |         address poolToken
 59 |     |     );
 60 |     | 
 61 |     |     function token0() external view returns (address token0);
 62 |     | 
 63 |     |     function token1() external view returns (address token1);
 64 |     | }
 65 |     | 

/root/git/limit/contracts/interfaces/IPositionERC1155.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.13;
  4 |     | 
  5 |     | import '../interfaces/structs/PoolsharkStructs.sol';
  6 |     | import "../external/openzeppelin/contracts/utils/introspection/IERC165.sol";
  7 |     | 
  8 |     | interface IPositionERC1155 is IERC165, PoolsharkStructs {
  9 |     |     event TransferSingle(
 10 |     |         address indexed sender,
 11 |     |         address indexed from,
 12 |     |         address indexed to,
 13 |     |         uint256 id,
 14 |     |         uint256 amount
 15 |     |     );
 16 |     | 
 17 |     |     event TransferBatch(
 18 |     |         address indexed sender,
 19 |     |         address indexed from,
 20 |     |         address indexed to,
 21 |     |         uint256[] ids,
 22 |     |         uint256[] amounts
 23 |     |     );
 24 |     | 
 25 |     |     event ApprovalForAll(
 26 |     |         address indexed account,
 27 |     |         address indexed sender,
 28 |     |         bool approve
 29 |     |     );
 30 |     | 
 31 |     |     function name() external view returns (string memory);
 32 |     | 
 33 |     |     function symbol() external view returns (string memory);
 34 |     | 
 35 |     |     function balanceOf(address account, uint256 id) external view returns (uint256);
 36 |     | 
 37 |     |     function balanceOfBatch(
 38 |     |         address[] calldata accounts,
 39 |     |         uint256[] calldata ids
 40 |     |     ) external view returns (
 41 |     |         uint256[] memory batchBalances
 42 |     |     );
 43 |     | 
 44 |     |     function totalSupply(uint256 id) external view returns (uint256);
 45 |     | 
 46 |     |     function isApprovedForAll(address owner, address spender) external view returns (bool);
 47 |     | 
 48 |     |     function setApprovalForAll(address sender, bool approved) external;
 49 |     | 
 50 |     |     function mint(
 51 |     |         address account,
 52 |     |         uint256 id,
 53 |     |         uint256 amount,
 54 |     |         PoolsharkStructs.LimitImmutables memory constants
 55 |     |     ) external;
 56 |     | 
 57 |     |     function burn(
 58 |     |         address account,
 59 |     |         uint256 id,
 60 |     |         uint256 amount,
 61 |     |         PoolsharkStructs.LimitImmutables memory constants
 62 |     |     ) external;
 63 |     | 
 64 |     |     function safeTransferFrom(
 65 |     |         address from,
 66 |     |         address to,
 67 |     |         uint256 id,
 68 |     |         uint256 amount
 69 |     |     ) external;
 70 |     | 
 71 |     |     function safeBatchTransferFrom(
 72 |     |         address from,
 73 |     |         address to,
 74 |     |         uint256[] calldata id,
 75 |     |         uint256[] calldata amount
 76 |     |     ) external;
 77 |     | 
 78 |     |     function withdrawEth(
 79 |     |         address recipient,
 80 |     |         PoolsharkStructs.LimitImmutables memory constants
 81 |     |     ) external;
 82 |     | }

/root/git/limit/contracts/interfaces/IWETH9.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IWETH9 {
  5 |     |     /// @notice Deposits ether in return for wrapped ether
  6 |     |     function deposit() external payable;
  7 |     | 
  8 |     |     /// @notice Withdraws ether from wrapped ether balance
  9 |     |     function withdraw(uint wad) external;
 10 |     | 
 11 |     |     /// @notice Withdraws ether from wrapped ether balance
 12 |     |     function transfer(address dst, uint wad) external returns (bool);
 13 |     | 
 14 |     |     /// @notice Returns balance for address
 15 |     |     function balanceOf(address account) external returns (uint256);
 16 |     | }

/root/git/limit/contracts/interfaces/callbacks/ICoverPoolCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Callback for mints
  5 |     | /// @notice Any contract that calls the `mint` function must implement this interface.
  6 |     | interface ICoverPoolMintCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a mint.
  8 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
  9 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 10 |     |     function coverPoolMintCallback(
 11 |     |         int256 amount0Delta,
 12 |     |         int256 amount1Delta,
 13 |     |         bytes calldata data
 14 |     |     ) external;
 15 |     | }
 16 |     | 
 17 |     | 
 18 |     | /// @title Callback for swaps
 19 |     | /// @notice Any contract that calls the `swap` function must implement this interface.
 20 |     | interface ICoverPoolSwapCallback {
 21 |     |     /// @notice Called to `msg.sender` after executing a swap.
 22 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
 23 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 24 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
 25 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 26 |     |     function coverPoolSwapCallback(
 27 |     |         int256 amount0Delta,
 28 |     |         int256 amount1Delta,
 29 |     |         bytes calldata data
 30 |     |     ) external;
 31 |     | }

/root/git/limit/contracts/interfaces/callbacks/ILimitPoolCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Callback for range mints
  5 |     | /// @notice Any contract that calls the `mintRange` function must implement this interface.
  6 |     | interface ILimitPoolMintRangeCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a mint.
  8 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
  9 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 10 |     |     function limitPoolMintRangeCallback(
 11 |     |         int256 amount0Delta,
 12 |     |         int256 amount1Delta,
 13 |     |         bytes calldata data
 14 |     |     ) external;
 15 |     | }
 16 |     | 
 17 |     | /// @title Callback for limit mints
 18 |     | /// @notice Any contract that calls the `mintLimit` function must implement this interface.
 19 |     | interface ILimitPoolMintLimitCallback {
 20 |     |     /// @notice Called to `msg.sender` after executing a mint.
 21 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
 22 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 23 |     |     function limitPoolMintLimitCallback(
 24 |     |         int256 amount0Delta,
 25 |     |         int256 amount1Delta,
 26 |     |         bytes calldata data
 27 |     |     ) external;
 28 |     | }
 29 |     | 
 30 |     | /// @title Callback for swaps
 31 |     | /// @notice Any contract that calls the `swap` function must implement this interface.
 32 |     | interface ILimitPoolSwapCallback {
 33 |     |     /// @notice Called to `msg.sender` after executing a swap.
 34 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
 35 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 36 |     |     /// @param amount0Delta The amount of token0 either received by (positive) or sent from (negative) the user.
 37 |     |     /// @param amount1Delta The amount of token1 either received by (positive) or sent from (negative) the user.
 38 |     |     function limitPoolSwapCallback(
 39 |     |         int256 amount0Delta,
 40 |     |         int256 amount1Delta,
 41 |     |         bytes calldata data
 42 |     |     ) external;
 43 |     | }

/root/git/limit/contracts/interfaces/cover/ICoverPool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | /**
  7 |     |  * @title ICoverPool
  8 |     |  * @author Poolshark
  9 |     |  * @notice Defines the basic interface for a Cover Pool.
 10 |     |  */
 11 |     | interface ICoverPool is PoolsharkStructs {
 12 |     | 
 13 |     |     function immutables(
 14 |     |     ) external view returns (
 15 |     |         CoverImmutables memory constants
 16 |     |     );
 17 |     | 
 18 |     |     /**
 19 |     |      * @notice Deposits `amountIn` of asset to be auctioned off each time price range is crossed further into.
 20 |     |      * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH
 21 |     |               As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,
 22 |     |               the user's liquidity within each tick spacing is auctioned off.
 23 |     |      * @dev The position will be shrunk onto the correct side of latestTick.
 24 |     |      * @dev The position will be minted with the `to` address as the owner.
 25 |     |      * @param params The parameters for the function. See MintCoverParams.
 26 |     |      */
 27 |     |     function mint(
 28 |     |         MintCoverParams memory params
 29 |     |     ) external;
 30 |     | 
 31 |     |     /**
 32 |     |      * @notice Withdraws the input token and returns any filled and/or unfilled amounts to the 'to' address specified. 
 33 |     |      * - E.g. User supplies 1 WETH in the range 1500 USDC per WETH to 1400 USDC per WETH
 34 |     |               As latestTick crosses from 1500 USDC per WETH to 1400 USDC per WETH,
 35 |     |               the user's liquidity within each tick spacing is auctioned off.
 36 |     |      * @dev The position will be shrunk based on the claim tick passed.
 37 |     |      * @dev The position amounts will be returned to the `to` address specified.
 38 |     |      * @dev The `sync` flag can be set to false so users can exit safely without syncing latestTick.
 39 |     |      * @param params The parameters for the function. See BurnCoverParams.
 40 |     |      */
 41 |     |     function burn(
 42 |     |         BurnCoverParams memory params
 43 |     |     ) external;
 44 |     | 
 45 |     |     /**
 46 |     |      * @notice Swaps `tokenIn` for `tokenOut`. 
 47 |     |                `tokenIn` will be `token0` if `zeroForOne` is true.
 48 |     |                `tokenIn` will be `token1` if `zeroForOne` is false.
 49 |     |                The pool price represents token1 per token0.
 50 |     |                The pool price will decrease if `zeroForOne` is true.
 51 |     |                The pool price will increase if `zeroForOne` is false. 
 52 |     |      * @param params The parameters for the function. See SwapParams above.
 53 |     |      * @return amount0Delta The amount of token0 spent (negative) or received (positive) by the user
 54 |     |      * @return amount1Delta The amount of token1 spent (negative) or received (positive) by the user
 55 |     |      */
 56 |     |     function swap(
 57 |     |         SwapParams memory params
 58 |     |     ) external returns (
 59 |     |         int256 amount0Delta,
 60 |     |         int256 amount1Delta
 61 |     |     );
 62 |     | 
 63 |     |     /**
 64 |     |      * @notice Quotes the amount of `tokenIn` for `tokenOut`. 
 65 |     |                `tokenIn` will be `token0` if `zeroForOne` is true.
 66 |     |                `tokenIn` will be `token1` if `zeroForOne` is false.
 67 |     |                The pool price represents token1 per token0.
 68 |     |                The pool price will decrease if `zeroForOne` is true.
 69 |     |                The pool price will increase if `zeroForOne` is false. 
 70 |     |      * @param params The parameters for the function. See SwapParams above.
 71 |     |      * @return inAmount  The amount of tokenIn to be spent
 72 |     |      * @return outAmount The amount of tokenOut to be received
 73 |     |      * @return priceAfter The Q64.96 square root price after the swap
 74 |     |      */
 75 |     |     function quote(
 76 |     |         QuoteParams memory params
 77 |     |     ) external view returns (
 78 |     |         int256 inAmount,
 79 |     |         int256 outAmount,
 80 |     |         uint256 priceAfter
 81 |     |     );
 82 |     | }
 83 |     | 

/root/git/limit/contracts/interfaces/cover/ICoverPoolFactory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | abstract contract ICoverPoolFactory {
  5 |     | 
  6 |     |     struct CoverPoolParams {
  7 |     |         bytes32 poolType;
  8 |     |         address tokenIn;
  9 |     |         address tokenOut;
 10 |     |         uint16 feeTier;
 11 |     |         int16  tickSpread;
 12 |     |         uint16 twapLength;
 13 |     |     }
 14 |     | 
 15 |     |     /**
 16 |     |      * @notice Creates a new CoverPool.
 17 |     |      * @param params The CoverPoolParams struct referenced above.
 18 |     |      */
 19 |     |     function createCoverPool(
 20 |     |         CoverPoolParams memory params
 21 |     |     ) external virtual returns (
 22 |     |         address pool,
 23 |     |         address poolToken
 24 |     |     );
 25 |     | 
 26 |     |     /**
 27 |     |      * @notice Fetches an existing CoverPool.
 28 |     |      * @param params The CoverPoolParams struct referenced above.
 29 |     |      */
 30 |     |     function getCoverPool(
 31 |     |         CoverPoolParams memory params
 32 |     |     ) external view virtual returns (
 33 |     |         address pool,
 34 |     |         address poolToken
 35 |     |     );
 36 |     | }
 37 |     | 

/root/git/limit/contracts/interfaces/cover/ITwapSource.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity ^0.8.13;
  3 |     | 
  4 |     | import '../structs/PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface ITwapSource {
  7 |     |     function initialize(
  8 |     |         PoolsharkStructs.CoverImmutables memory constants
  9 |     |     ) external returns (
 10 |     |         uint8 initializable,
 11 |     |         int24 startingTick
 12 |     |     );
 13 |     | 
 14 |     |     function calculateAverageTick(
 15 |     |         PoolsharkStructs.CoverImmutables memory constants,
 16 |     |         int24 latestTick
 17 |     |     ) external view returns (
 18 |     |         int24 averageTick
 19 |     |     );
 20 |     | 
 21 |     |     function getPool(
 22 |     |         address tokenA,
 23 |     |         address tokenB,
 24 |     |         uint16 feeTier
 25 |     |     ) external view returns (
 26 |     |         address pool
 27 |     |     );
 28 |     | 
 29 |     |     function feeTierTickSpacing(
 30 |     |         uint16 feeTier
 31 |     |     ) external view returns (
 32 |     |         int24 tickSpacing
 33 |     |     );
 34 |     | 
 35 |     |     function factory()
 36 |     |     external view returns (address);
 37 |     | }
 38 |     | 

/root/git/limit/contracts/interfaces/limit/ILimitPool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../structs/LimitPoolStructs.sol';
  5 |     | 
  6 |     | interface ILimitPool is LimitPoolStructs {
  7 |     |     function initialize(
  8 |     |         uint160 startPrice
  9 |     |     ) external;
 10 |     | 
 11 |     |     function mintLimit(
 12 |     |         MintLimitParams memory params
 13 |     |     ) external;
 14 |     | 
 15 |     |     function burnLimit(
 16 |     |         BurnLimitParams memory params
 17 |     |     ) external;
 18 |     | 
 19 |     |     function fees(
 20 |     |         FeesParams memory params
 21 |     |     ) external returns (
 22 |     |         uint128 token0Fees,
 23 |     |         uint128 token1Fees
 24 |     |     );
 25 |     | }
 26 |     | 

/root/git/limit/contracts/interfaces/limit/ILimitPoolFactory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../structs/PoolsharkStructs.sol';
  5 |     | import '../../base/storage/LimitPoolFactoryStorage.sol';
  6 |     | 
  7 |     | abstract contract ILimitPoolFactory is LimitPoolFactoryStorage, PoolsharkStructs {
  8 |     |     function createLimitPool(
  9 |     |         LimitPoolParams memory params
 10 |     |     ) external virtual returns (
 11 |     |         address pool,
 12 |     |         address poolToken
 13 |     |     );
 14 |     | 
 15 |     |     function getLimitPool(
 16 |     |         address tokenIn,
 17 |     |         address tokenOut,
 18 |     |         uint16  swapFee,
 19 |     |         uint16  poolTypeId
 20 |     |     ) external view virtual returns (
 21 |     |         address pool,
 22 |     |         address poolToken
 23 |     |     );
 24 |     | }
 25 |     | 

/root/git/limit/contracts/interfaces/limit/ILimitPoolManager.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @notice LimitPoolManager interface
  5 |     | interface ILimitPoolManager {
  6 |     |     
  7 |     |     function owner() external view returns (address);
  8 |     |     function feeTo() external view returns (address);
  9 |     |     function poolTypes(
 10 |     |         uint16 poolType
 11 |     |     ) external view returns (
 12 |     |         address poolImpl,
 13 |     |         address tokenImpl
 14 |     |     );
 15 |     |     function feeTiers(
 16 |     |         uint16 swapFee
 17 |     |     ) external view returns (
 18 |     |         int16 tickSpacing
 19 |     |     );
 20 |     | }
 21 |     | 

/root/git/limit/contracts/interfaces/limit/ILimitPoolStorageView.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../structs/LimitPoolStructs.sol';
  5 |     | 
  6 |     | interface ILimitPoolStorageView is LimitPoolStructs {
  7 |     |     function globalState() external view returns (
  8 |     |         RangePoolState memory pool,
  9 |     |         LimitPoolState memory pool0,
 10 |     |         LimitPoolState memory pool1,
 11 |     |         uint128 liquidityGlobal,
 12 |     |         uint32 positionIdNext,
 13 |     |         uint32 epoch,
 14 |     |         uint8 unlocked
 15 |     |     );
 16 |     | }
 17 |     | 

/root/git/limit/contracts/interfaces/limit/ILimitPoolView.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../structs/LimitPoolStructs.sol';
  5 |     | 
  6 |     | interface ILimitPoolView is LimitPoolStructs {
  7 |     | 
  8 |     |     function snapshotLimit(
  9 |     |         SnapshotLimitParams memory params
 10 |     |     ) external view returns(
 11 |     |         uint128,
 12 |     |         uint128
 13 |     |     );
 14 |     | 
 15 |     |     function immutables(
 16 |     |     ) external view returns(
 17 |     |         LimitImmutables memory
 18 |     |     );
 19 |     | 
 20 |     |     function priceBounds(
 21 |     |         int16 tickSpacing
 22 |     |     ) external pure returns (
 23 |     |         uint160 minPrice,
 24 |     |         uint160 maxPrice
 25 |     |     );
 26 |     | 
 27 |     |     function sample(
 28 |     |         uint32[] memory secondsAgo
 29 |     |     ) external view returns(
 30 |     |         int56[]   memory tickSecondsAccum,
 31 |     |         uint160[] memory secondsPerLiquidityAccum,
 32 |     |         uint160 averagePrice,
 33 |     |         uint128 averageLiquidity,
 34 |     |         int24 averageTick
 35 |     |     );
 36 |     | }
 37 |     | 

/root/git/limit/contracts/interfaces/range/IRangePool.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../structs/RangePoolStructs.sol';
  5 |     | import './IRangePoolManager.sol';
  6 |     | 
  7 |     | interface IRangePool is RangePoolStructs {
  8 |     |     function mintRange(
  9 |     |         MintRangeParams memory mintParams
 10 |     |     ) external;
 11 |     | 
 12 |     |     function burnRange(
 13 |     |         BurnRangeParams memory burnParams
 14 |     |     ) external;
 15 |     | 
 16 |     |     function swap(
 17 |     |         SwapParams memory params
 18 |     |     ) external returns (
 19 |     |         int256 amount0,
 20 |     |         int256 amount1
 21 |     |     );
 22 |     | 
 23 |     |     function quote(
 24 |     |         QuoteParams memory params
 25 |     |     ) external view returns (
 26 |     |         uint256 inAmount,
 27 |     |         uint256 outAmount,
 28 |     |         uint160 priceAfter
 29 |     |     );
 30 |     | 
 31 |     |     function snapshotRange(
 32 |     |         uint32 positionId
 33 |     |     ) external view returns(
 34 |     |         int56   tickSecondsAccum,
 35 |     |         uint160 secondsPerLiquidityAccum,
 36 |     |         uint128 feesOwed0,
 37 |     |         uint128 feesOwed1
 38 |     |     );
 39 |     | 
 40 |     |     function sample(
 41 |     |         uint32[] memory secondsAgo
 42 |     |     ) external view returns(
 43 |     |         int56[]   memory tickSecondsAccum,
 44 |     |         uint160[] memory secondsPerLiquidityAccum,
 45 |     |         uint160 averagePrice,
 46 |     |         uint128 averageLiquidity,
 47 |     |         int24 averageTick
 48 |     |     );
 49 |     | 
 50 |     |     function positions(uint256 positionId) external view returns (
 51 |     |         uint256 feeGrowthInside0Last,
 52 |     |         uint256 feeGrowthInside1Last,
 53 |     |         uint128 liquidity,
 54 |     |         int24 lower,
 55 |     |         int24 upper
 56 |     |     );
 57 |     | 
 58 |     |     function increaseSampleCount(
 59 |     |         uint16 newSampleCountMax
 60 |     |     ) external;
 61 |     | 
 62 |     |     function ticks(int24) external view returns (
 63 |     |         RangeTick memory,
 64 |     |         LimitTick memory
 65 |     |     );
 66 |     | 
 67 |     |     function samples(uint256) external view returns (
 68 |     |         uint32,
 69 |     |         int56,
 70 |     |         uint160
 71 |     |     );
 72 |     | }
 73 |     | 

/root/git/limit/contracts/interfaces/range/IRangePoolFactory.sol
  1 |     | // SPDX-License-Identifier: GPLv3
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | interface IRangePoolFactory {
  5 |     |     function createRangePool(
  6 |     |         address fromToken,
  7 |     |         address destToken,
  8 |     |         uint16 fee,
  9 |     |         uint160 startPrice
 10 |     |     ) external returns (address book);
 11 |     | 
 12 |     |     function getRangePool(
 13 |     |         address fromToken,
 14 |     |         address destToken,
 15 |     |         uint256 fee
 16 |     |     ) external view returns (address);
 17 |     | 
 18 |     |     function owner() external view returns(address);
 19 |     | }
 20 |     | 

/root/git/limit/contracts/interfaces/range/IRangePoolManager.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../structs/RangePoolStructs.sol';
  5 |     | 
  6 |     | interface IRangePoolManager {
  7 |     |     function owner() external view returns (address);
  8 |     |     function feeTo() external view returns (address);
  9 |     |     function protocolFees(address pool) external view returns (uint16);
 10 |     |     function feeTiers(uint16 swapFee) external view returns (int24);
 11 |     | }

/root/git/limit/contracts/interfaces/staking/IRangeStaker.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | 
  3 |     | pragma solidity 0.8.13;
  4 |     | 
  5 |     | import '../structs/PoolsharkStructs.sol';
  6 |     | 
  7 |     | interface IRangeStaker is PoolsharkStructs {
  8 |     |     function stakeRange(StakeRangeParams memory) external;
  9 |     | }

/root/git/limit/contracts/interfaces/structs/LimitPoolStructs.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import './PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface LimitPoolStructs is PoolsharkStructs {
  7 |     | 
  8 |     |     struct LimitPosition {
  9 |     |         uint128 liquidity; // expected amount to be used not actual
 10 |     |         uint32 epochLast;  // epoch when this position was created at
 11 |     |         int24 lower;       // lower price tick of position range
 12 |     |         int24 upper;       // upper price tick of position range
 13 |     |         bool crossedInto;  // whether the position was crossed into already
 14 |     |     }
 15 |     | 
 16 |     |     struct MintLimitCache {
 17 |     |         GlobalState state;
 18 |     |         LimitPosition position;
 19 |     |         LimitImmutables constants;
 20 |     |         LimitPoolState pool;
 21 |     |         SwapCache swapCache;
 22 |     |         uint256 liquidityMinted;
 23 |     |         uint256 mintSize;
 24 |     |         uint256 priceLimit;
 25 |     |         int256 amountIn;
 26 |     |         uint256 amountOut;
 27 |     |         uint256 priceLower;
 28 |     |         uint256 priceUpper;
 29 |     |         int24 tickLimit;
 30 |     |     }
 31 |     | 
 32 |     |     struct BurnLimitCache {
 33 |     |         GlobalState state;
 34 |     |         LimitPoolState pool;
 35 |     |         LimitTick claimTick;
 36 |     |         LimitPosition position;
 37 |     |         PoolsharkStructs.LimitImmutables constants;
 38 |     |         uint160 priceLower;
 39 |     |         uint160 priceClaim;
 40 |     |         uint160 priceUpper;
 41 |     |         uint128 liquidityBurned;
 42 |     |         uint128 amountIn;
 43 |     |         uint128 amountOut;
 44 |     |         int24 claim;
 45 |     |         bool removeLower;
 46 |     |         bool removeUpper;
 47 |     |         bool search;
 48 |     |     }
 49 |     | 
 50 |     |     struct InsertSingleLocals {
 51 |     |         int24 previousFullTick;
 52 |     |         int24 nextFullTick;
 53 |     |         uint256 priceNext;
 54 |     |         uint256 pricePrevious;
 55 |     |         uint256 amountInExact;
 56 |     |         uint256 amountOutExact;
 57 |     |         uint256 amountToCross;
 58 |     |     }
 59 |     | 
 60 |     |     struct GetDeltasLocals {
 61 |     |         int24 previousFullTick;
 62 |     |         uint256 pricePrevious;
 63 |     |         uint256 priceNext;
 64 |     |     }
 65 |     | 
 66 |     |     struct SearchLocals {
 67 |     |         int24[] ticksFound;
 68 |     |         int24 searchTick;
 69 |     |         int24 searchTickAhead;
 70 |     |         uint16 searchIdx;
 71 |     |         uint16 startIdx;
 72 |     |         uint16 endIdx;
 73 |     |         uint16 ticksIncluded;
 74 |     |         uint32 claimTickEpoch;
 75 |     |         uint32 claimTickAheadEpoch;
 76 |     |     }
 77 |     | 
 78 |     |     struct TickMapLocals {
 79 |     |         uint256 word;
 80 |     |         uint256 tickIndex;
 81 |     |         uint256 wordIndex;
 82 |     |         uint256 blockIndex;
 83 |     |     }
 84 |     | }
 85 |     | 

/root/git/limit/contracts/interfaces/structs/PoolsharkStructs.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../cover/ITwapSource.sol';
   5 |     | 
   6 |     | interface PoolsharkStructs {
   7 |     |     struct GlobalState {
   8 |     |         RangePoolState pool;
   9 |     |         LimitPoolState pool0;
  10 |     |         LimitPoolState pool1;
  11 |     |         uint128 liquidityGlobal;
  12 |     |         uint32  positionIdNext;
  13 |     |         uint32 epoch;
  14 |     |         uint8 unlocked;
  15 |     |     }
  16 |     | 
  17 |     |     struct LimitPoolState {
  18 |     |         uint160 price; /// @dev Starting price current
  19 |     |         uint128 liquidity; /// @dev Liquidity currently active
  20 |     |         uint128 protocolFees;
  21 |     |         uint16 protocolFillFee;
  22 |     |         int24 tickAtPrice;
  23 |     |     }
  24 |     | 
  25 |     |     struct RangePoolState {
  26 |     |         SampleState  samples;
  27 |     |         uint200 feeGrowthGlobal0;
  28 |     |         uint200 feeGrowthGlobal1;
  29 |     |         uint160 secondsPerLiquidityAccum;
  30 |     |         uint160 price;               /// @dev Starting price current
  31 |     |         uint128 liquidity;           /// @dev Liquidity currently active
  32 |     |         int56   tickSecondsAccum;
  33 |     |         int24   tickAtPrice;
  34 |     |         uint16 protocolSwapFee0;
  35 |     |         uint16 protocolSwapFee1;
  36 |     |     }
  37 |     | 
  38 |     |     struct Tick {
  39 |     |         RangeTick range;
  40 |     |         LimitTick limit;
  41 |     |     }
  42 |     | 
  43 |     |     struct LimitTick {
  44 |     |         uint160 priceAt;
  45 |     |         int128 liquidityDelta;
  46 |     |         uint128 liquidityAbsolute;
  47 |     |     }
  48 |     | 
  49 |     |     struct RangeTick {
  50 |     |         uint200 feeGrowthOutside0;
  51 |     |         uint200 feeGrowthOutside1;
  52 |     |         uint160 secondsPerLiquidityAccumOutside;
  53 |     |         int56 tickSecondsAccumOutside;
  54 |     |         int128 liquidityDelta;
  55 |     |         uint128 liquidityAbsolute;
  56 |     |     }
  57 |     | 
  58 |     |     struct Sample {
  59 |     |         uint32  blockTimestamp;
  60 |     |         int56   tickSecondsAccum;
  61 |     |         uint160 secondsPerLiquidityAccum;
  62 |     |     }
  63 |     | 
  64 |     |     struct SampleState {
  65 |     |         uint16  index;
  66 |     |         uint16  count;
  67 |     |         uint16  countMax;
  68 |     |     }
  69 |     | 
  70 |     |     struct LimitPoolParams {
  71 |     |         address tokenIn;
  72 |     |         address tokenOut;
  73 |     |         uint160 startPrice;
  74 |     |         uint16  swapFee;
  75 |     |         uint16  poolTypeId;
  76 |     |     }
  77 |     | 
  78 |     |     struct SwapParams {
  79 |     |         address to;
  80 |     |         uint160 priceLimit;
  81 |     |         uint128  amount;
  82 |     |         bool exactIn;
  83 |     |         bool zeroForOne;
  84 |     |         bytes callbackData;
  85 |     |     }
  86 |     | 
  87 |     |     struct MintLimitParams {
  88 |     |         address to;
  89 |     |         uint128 amount;
  90 |     |         uint96 mintPercent;
  91 |     |         uint32 positionId;
  92 |     |         int24 lower;
  93 |     |         int24 upper;
  94 |     |         bool zeroForOne;
  95 |     |         bytes callbackData;
  96 |     |     }
  97 |     | 
  98 |     |     struct BurnLimitParams {
  99 |     |         address to;
 100 |     |         uint128 burnPercent;
 101 |     |         uint32 positionId;
 102 |     |         int24 claim;
 103 |     |         bool zeroForOne;
 104 |     |     }
 105 |     | 
 106 |     |     struct MintRangeParams {
 107 |     |         address to;
 108 |     |         int24 lower;
 109 |     |         int24 upper;
 110 |     |         uint32 positionId;
 111 |     |         uint128 amount0;
 112 |     |         uint128 amount1;
 113 |     |         bytes callbackData;
 114 |     |     }
 115 |     | 
 116 |     |     struct BurnRangeParams {
 117 |     |         address to;
 118 |     |         uint32 positionId;
 119 |     |         uint128 burnPercent;
 120 |     |     }
 121 |     | 
 122 |     |     struct QuoteParams {
 123 |     |         uint160 priceLimit;
 124 |     |         uint128 amount;
 125 |     |         bool exactIn;
 126 |     |         bool zeroForOne;
 127 |     |     }
 128 |     | 
 129 |     |     struct FeesParams {
 130 |     |         uint16 protocolSwapFee0;
 131 |     |         uint16 protocolSwapFee1;
 132 |     |         uint16 protocolFillFee0;
 133 |     |         uint16 protocolFillFee1;
 134 |     |         uint8 setFeesFlags;
 135 |     |     }
 136 |     | 
 137 |     |     struct SnapshotLimitParams {
 138 |     |         address owner;
 139 |     |         uint128 burnPercent;
 140 |     |         uint32 positionId;
 141 |     |         int24 claim;
 142 |     |         bool zeroForOne;
 143 |     |     }
 144 |     | 
 145 |     |     struct StakeRangeParams {
 146 |     |         address to;
 147 |     |         address pool;
 148 |     |         uint32 positionId;
 149 |     |     }
 150 |     | 
 151 |     |     struct UnstakeRangeParams {
 152 |     |         address to;
 153 |     |         address pool;
 154 |     |         uint32 positionId;
 155 |     |     }
 156 |     | 
 157 |     |     struct StakeFinParams {
 158 |     |         address to;
 159 |     |         uint128 amount;
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @custom:struct MintCoverParams
 164 |     |      */
 165 |     |     struct MintCoverParams {
 166 |     |         /**
 167 |     |          * @custom:field to
 168 |     |          * @notice Address for the receiver of the minted position
 169 |     |          */
 170 |     |         address to;
 171 |     | 
 172 |     |         /**
 173 |     |          * @custom:field amount
 174 |     |          * @notice Token amount to be deposited into the minted position
 175 |     |          */
 176 |     |         uint128 amount;
 177 |     | 
 178 |     |         /**
 179 |     |          * @custom:field positionId
 180 |     |          * @notice 0 if creating a new position; id of previous if adding liquidity
 181 |     |          */
 182 |     |         uint32 positionId;
 183 |     | 
 184 |     |         /**
 185 |     |          * @custom:field lower
 186 |     |          * @notice The lower price tick for the position range
 187 |     |          */
 188 |     |         int24 lower;
 189 |     | 
 190 |     |         /**
 191 |     |          * @custom:field upper
 192 |     |          * @notice The upper price tick for the position range
 193 |     |          */
 194 |     |         int24 upper;
 195 |     | 
 196 |     |         /**
 197 |     |          * @custom:field zeroForOne
 198 |     |          * @notice True if depositing token0, the first token address in lexographical order
 199 |     |          * @notice False if depositing token1, the second token address in lexographical order 
 200 |     |          */
 201 |     |         bool zeroForOne;
 202 |     | 
 203 |     |         /**
 204 |     |          * @custom:field callbackData
 205 |     |          * @notice callback data which gets passed back to msg.sender at the end of a `mint` call
 206 |     |          */
 207 |     |         bytes callbackData;
 208 |     |     }
 209 |     | 
 210 |     |     /**
 211 |     |      * @custom:struct BurnCoverParams
 212 |     |      */
 213 |     |     struct BurnCoverParams {
 214 |     |         /**
 215 |     |          * @custom:field to
 216 |     |          * @notice Address for the receiver of the collected position amounts
 217 |     |          */
 218 |     |         address to;
 219 |     | 
 220 |     |         /**
 221 |     |          * @custom:field burnPercent
 222 |     |          * @notice Percent of the remaining liquidity to be removed
 223 |     |          * @notice 1e38 represents 100%
 224 |     |          * @notice 5e37 represents 50%
 225 |     |          * @notice 1e37 represents 10%
 226 |     |          */
 227 |     |         uint128 burnPercent;
 228 |     | 
 229 |     |         /**
 230 |     |          * @custom:field positionId
 231 |     |          * @notice 0 if creating a new position; id of previous if adding liquidity
 232 |     |          */
 233 |     |         uint32 positionId;
 234 |     | 
 235 |     |         /**
 236 |     |          * @custom:field claim
 237 |     |          * @notice The most recent tick crossed in this range
 238 |     |          * @notice if `zeroForOne` is true, claim tick progresses from upper => lower
 239 |     |          * @notice if `zeroForOne` is false, claim tick progresses from lower => upper
 240 |     |          */
 241 |     |         int24 claim;
 242 |     | 
 243 |     |         /**
 244 |     |          * @custom:field zeroForOne
 245 |     |          * @notice True if deposited token0, the first token address in lexographical order
 246 |     |          * @notice False if deposited token1, the second token address in lexographical order 
 247 |     |          */
 248 |     |         bool zeroForOne;
 249 |     | 
 250 |     |         /**
 251 |     |          * @custom:field sync
 252 |     |          * @notice True will sync the pool latestTick
 253 |     |          * @notice False will skip syncing latestTick 
 254 |     |          */
 255 |     |         bool sync;
 256 |     |     }
 257 |     | 
 258 |     |     /**
 259 |     |      * @custom:struct SnapshotCoverParams
 260 |     |      */
 261 |     |     struct SnapshotCoverParams {
 262 |     |         /**
 263 |     |          * @custom:field to
 264 |     |          * @notice Address of the position owner
 265 |     |          */
 266 |     |         address owner;
 267 |     | 
 268 |     |         /**
 269 |     |          * @custom:field positionId
 270 |     |          * @notice id of position
 271 |     |          */
 272 |     |         uint32 positionId;
 273 |     | 
 274 |     |         /**
 275 |     |          * @custom:field burnPercent
 276 |     |          * @notice Percent of the remaining liquidity to be removed
 277 |     |          * @notice 1e38 represents 100%
 278 |     |          * @notice 5e37 represents 50%
 279 |     |          * @notice 1e37 represents 10%
 280 |     |          */
 281 |     |         uint128 burnPercent;
 282 |     | 
 283 |     |         /**
 284 |     |          * @custom:field claim
 285 |     |          * @notice The most recent tick crossed in this range
 286 |     |          * @notice if `zeroForOne` is true, claim tick progresses from upper => lower
 287 |     |          * @notice if `zeroForOne` is false, claim tick progresses from lower => upper
 288 |     |          */
 289 |     |         int24 claim;
 290 |     | 
 291 |     |         /**
 292 |     |          * @custom:field zeroForOne
 293 |     |          * @notice True if deposited token0, the first token address in lexographical order
 294 |     |          * @notice False if deposited token1, the second token address in lexographical order 
 295 |     |          */
 296 |     |         bool zeroForOne;
 297 |     |     }
 298 |     | 
 299 |     |     struct QuoteResults {
 300 |     |         address pool;
 301 |     |         int256 amountIn;
 302 |     |         int256 amountOut;
 303 |     |         uint160 priceAfter;
 304 |     |     }
 305 |     |     
 306 |     |     struct LimitImmutables {
 307 |     |         address owner;
 308 |     |         address poolImpl;
 309 |     |         address factory;
 310 |     |         PriceBounds bounds;
 311 |     |         address token0;
 312 |     |         address token1;
 313 |     |         address poolToken;
 314 |     |         uint32 genesisTime;
 315 |     |         int16 tickSpacing;
 316 |     |         uint16 swapFee;
 317 |     |     }
 318 |     | 
 319 |     |     struct CoverImmutables {
 320 |     |         ITwapSource source;
 321 |     |         PriceBounds bounds;
 322 |     |         address owner;
 323 |     |         address token0;
 324 |     |         address token1;
 325 |     |         address poolImpl;
 326 |     |         address poolToken;
 327 |     |         address inputPool;
 328 |     |         uint128 minAmountPerAuction;
 329 |     |         uint32 genesisTime;
 330 |     |         int16  minPositionWidth;
 331 |     |         int16  tickSpread;
 332 |     |         uint16 twapLength;
 333 |     |         uint16 auctionLength;
 334 |     |         uint16 sampleInterval;
 335 |     |         uint8 token0Decimals;
 336 |     |         uint8 token1Decimals;
 337 |     |         bool minAmountLowerPriced;
 338 |     |     }
 339 |     | 
 340 |     |     struct PriceBounds {
 341 |     |         uint160 min;
 342 |     |         uint160 max;
 343 |     |     }
 344 |     | 
 345 |     |     struct TickMap {
 346 |     |         uint256 blocks;                     /// @dev - sets of words
 347 |     |         mapping(uint256 => uint256) words;  /// @dev - sets to words
 348 |     |         mapping(uint256 => uint256) ticks;  /// @dev - words to ticks
 349 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs0; /// @dev - ticks to epochs
 350 |     |         mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) epochs1; /// @dev - ticks to epochs
 351 |     |     }
 352 |     | 
 353 |     |     struct SwapCache {
 354 |     |         GlobalState state;
 355 |     |         LimitImmutables constants;
 356 |     |         uint256 price;
 357 |     |         uint256 liquidity;
 358 |     |         uint256 amountLeft;
 359 |     |         uint256 input;
 360 |     |         uint256 output;
 361 |     |         uint160 crossPrice;
 362 |     |         uint160 averagePrice;
 363 |     |         uint160 secondsPerLiquidityAccum;
 364 |     |         uint128 feeAmount;
 365 |     |         int56   tickSecondsAccum;
 366 |     |         int56   tickSecondsAccumBase;
 367 |     |         int24   crossTick;
 368 |     |         uint8   crossStatus;
 369 |     |         bool    limitActive;
 370 |     |         bool    exactIn;
 371 |     |         bool    cross;
 372 |     |     }  
 373 |     | 
 374 |     |     enum CrossStatus {
 375 |     |         RANGE,
 376 |     |         LIMIT,
 377 |     |         BOTH
 378 |     |     }
 379 |     | }

/root/git/limit/contracts/interfaces/structs/RangePoolStructs.sol
  1 |     | // SPDX-License-Identifier: GPLv3
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import './PoolsharkStructs.sol';
  5 |     | 
  6 |     | interface RangePoolStructs is PoolsharkStructs {
  7 |     | 
  8 |     |     struct RangePosition {
  9 |     |         uint256 feeGrowthInside0Last;
 10 |     |         uint256 feeGrowthInside1Last;
 11 |     |         uint128 liquidity;
 12 |     |         int24 lower;
 13 |     |         int24 upper;
 14 |     |     }
 15 |     | 
 16 |     |     struct CompoundRangeParams {
 17 |     |         uint160 priceLower;
 18 |     |         uint160 priceUpper;
 19 |     |         uint128 amount0;
 20 |     |         uint128 amount1;
 21 |     |         uint32 positionId;
 22 |     |     }
 23 |     | 
 24 |     |     struct SampleParams {
 25 |     |         uint16 sampleIndex;
 26 |     |         uint16 sampleLength;
 27 |     |         uint32 time;
 28 |     |         uint32[] secondsAgo;
 29 |     |         int24 tick;
 30 |     |         uint128 liquidity;
 31 |     |         PoolsharkStructs.LimitImmutables constants;
 32 |     |     }
 33 |     | 
 34 |     |     struct UpdateParams {
 35 |     |         int24 lower;
 36 |     |         int24 upper;
 37 |     |         uint32 positionId;
 38 |     |         uint128 burnPercent;
 39 |     |     }
 40 |     | 
 41 |     |     struct MintRangeCache {
 42 |     |         GlobalState state;
 43 |     |         RangePosition position;
 44 |     |         PoolsharkStructs.LimitImmutables constants;
 45 |     |         address owner;
 46 |     |         uint256 liquidityMinted;
 47 |     |         uint160 priceLower;
 48 |     |         uint160 priceUpper;
 49 |     |         int128 amount0;
 50 |     |         int128 amount1;
 51 |     |         int128 feesAccrued0;
 52 |     |         int128 feesAccrued1;
 53 |     |     }
 54 |     | 
 55 |     |     struct BurnRangeCache {
 56 |     |         GlobalState state;
 57 |     |         RangePosition position;
 58 |     |         PoolsharkStructs.LimitImmutables constants;
 59 |     |         uint256 liquidityBurned;
 60 |     |         uint160 priceLower;
 61 |     |         uint160 priceUpper;
 62 |     |         int128 amount0;
 63 |     |         int128 amount1;
 64 |     |     }
 65 |     | 
 66 |     |     struct RangePositionCache {
 67 |     |         uint256 liquidityAmount;
 68 |     |         uint256 rangeFeeGrowth0;
 69 |     |         uint256 rangeFeeGrowth1;
 70 |     |         uint128 amountFees0;
 71 |     |         uint128 amountFees1;
 72 |     |         uint128 feesBurned0;
 73 |     |         uint128 feesBurned1;
 74 |     |     }
 75 |     | 
 76 |     |     struct SnapshotRangeCache {
 77 |     |         RangePosition position;
 78 |     |         SampleState samples;
 79 |     |         PoolsharkStructs.LimitImmutables constants;
 80 |     |         uint160 price;
 81 |     |         uint160 secondsPerLiquidityAccum;
 82 |     |         uint160 secondsPerLiquidityAccumLower;
 83 |     |         uint160 secondsPerLiquidityAccumUpper;
 84 |     |         uint128 liquidity;
 85 |     |         uint128 amount0;
 86 |     |         uint128 amount1;
 87 |     |         int56   tickSecondsAccum;
 88 |     |         int56   tickSecondsAccumLower;
 89 |     |         int56   tickSecondsAccumUpper;
 90 |     |         uint32  secondsOutsideLower;
 91 |     |         uint32  secondsOutsideUpper;
 92 |     |         uint32  blockTimestamp;
 93 |     |         int24   tick;
 94 |     |     }
 95 |     | }
 96 |     | 

/root/git/limit/contracts/libraries/Samples.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './math/ConstantProduct.sol';
   5 |     | import './utils/SafeCast.sol';
   6 |     | import '../interfaces/range/IRangePool.sol';
   7 |     | import '../interfaces/structs/RangePoolStructs.sol';
   8 |     | 
   9 |     | library Samples {
  10 |     |     using SafeCast for uint256;
  11 |     | 
  12 |     |     uint8 internal constant TIME_DELTA_MAX = 6;
  13 |     | 
  14 |     |     event SampleRecorded(
  15 |     |         int56 tickSecondsAccum,
  16 |     |         uint160 secondsPerLiquidityAccum
  17 |     |     );
  18 |     | 
  19 |     |     event SampleCountIncreased(
  20 |     |         uint16 newSampleCountMax
  21 |     |     );
  22 |     | 
  23 |     |     function initialize(
  24 |     |         RangePoolStructs.Sample[65535] storage samples,
  25 |     |         PoolsharkStructs.RangePoolState memory state
  26 |     |     ) internal returns (
  27 |     |         PoolsharkStructs.RangePoolState memory
  28 |     |     )
  29 |     |     {
  30 |     |         samples[0] = PoolsharkStructs.Sample({
  31 |     |             blockTimestamp: uint32(block.timestamp),
  32 |     |             tickSecondsAccum: 0,
  33 |     |             secondsPerLiquidityAccum: 0
  34 |     |         });
  35 |     | 
  36 |     |         state.samples.count = 1;
  37 |     |         state.samples.countMax = 5;
  38 |     | 
  39 |     |         return state;
  40 |     |         /// @dev - TWAP length of 5 is safer for oracle manipulation
  41 |     |     }
  42 |     | 
  43 |     |     function save(
  44 |     |         RangePoolStructs.Sample[65535] storage samples,
  45 |     |         PoolsharkStructs.SampleState memory sampleState,
  46 |     |         uint128 startLiquidity, /// @dev - liquidity from start of block
  47 |     |         int24  tick
  48 |     |     ) internal returns (
  49 |     |         uint16 sampleIndexNew,
  50 |     |         uint16 sampleLengthNew
  51 |     |     ) {
  52 |     |         // grab the latest sample
  53 |     |         RangePoolStructs.Sample memory newSample = samples[sampleState.index];
  54 |     | 
  55 |     |         // early return if timestamp has not advanced 2 seconds
  56 |     |         if (newSample.blockTimestamp + 2 > uint32(block.timestamp))
  57 |     |             return (sampleState.index, sampleState.count);
  58 |     | 
  59 |     |         if (sampleState.countMax > sampleState.count
  60 |     |             && sampleState.index == (sampleState.count - 1)) {
  61 |     |             // increase sampleLengthNew if old size exceeded
  62 |     |             sampleLengthNew = sampleState.count + 1;
  63 |     |         } else {
  64 |     |             sampleLengthNew = sampleState.count;
  65 |     |         }
  66 |     |         sampleIndexNew = (sampleState.index + 1) % sampleLengthNew;
  67 |     |         samples[sampleIndexNew] = _build(newSample, uint32(block.timestamp), tick, startLiquidity);
  68 |     | 
  69 |     |         emit SampleRecorded(
  70 |     |             samples[sampleIndexNew].tickSecondsAccum,
  71 |     |             samples[sampleIndexNew].secondsPerLiquidityAccum
  72 |     |         );
  73 |     |     }
  74 |     | 
  75 |     |     function expand(
  76 |     |         RangePoolStructs.Sample[65535] storage samples,
  77 |     |         PoolsharkStructs.RangePoolState storage pool,
  78 |     |         uint16 newSampleCountMax
  79 |     |     ) internal {
  80 |     |         if (newSampleCountMax <= pool.samples.countMax) return ;
  81 |     |         for (uint16 i = pool.samples.countMax; i < newSampleCountMax; i++) {
  82 |     |             samples[i].blockTimestamp = 1;
  83 |     |         }
  84 |     |         pool.samples.countMax = newSampleCountMax;
  85 |     |         emit SampleCountIncreased(newSampleCountMax);
  86 |     |     }
  87 |     | 
  88 |     |     function get(
  89 |     |         address pool,
  90 |     |         RangePoolStructs.SampleParams memory params
  91 |     |     ) internal view returns (
  92 |     |         int56[]   memory tickSecondsAccum,
  93 |     |         uint160[] memory secondsPerLiquidityAccum,
  94 |     |         uint160 averagePrice,
  95 |     |         uint128 averageLiquidity,
  96 |     |         int24 averageTick
  97 |     |     ) {
  98 |     |         if (params.sampleLength == 0) require(false, 'InvalidSampleLength()');
  99 |     |         if (params.secondsAgo.length == 0) require(false, 'SecondsAgoArrayEmpty()');
 100 |     |         uint256 size = params.secondsAgo.length > 1 ? params.secondsAgo.length : 2;
 101 |     |         uint32[] memory secondsAgo = new uint32[](size);
 102 |     |         if (params.secondsAgo.length == 1) {
 103 |     |             secondsAgo = new uint32[](2);
 104 |     |             secondsAgo[0] = params.secondsAgo[0];
 105 |     |             secondsAgo[1] = params.secondsAgo[0] + 2;
 106 |     |         }
 107 |     |         else secondsAgo = params.secondsAgo;
 108 |     | 
 109 |     |         if (secondsAgo[0] == secondsAgo[secondsAgo.length - 1]) require(false, 'SecondsAgoArrayValuesEqual()');
 110 |     | 
 111 |     |         tickSecondsAccum = new int56[](secondsAgo.length);
 112 |     |         secondsPerLiquidityAccum = new uint160[](secondsAgo.length);
 113 |     | 
 114 |     |         for (uint256 i = 0; i < secondsAgo.length; i++) {
 115 |     |             (
 116 |     |                 tickSecondsAccum[i],
 117 |     |                 secondsPerLiquidityAccum[i]
 118 |     |             ) = getSingle(
 119 |     |                 IRangePool(pool),
 120 |     |                 params,
 121 |     |                 secondsAgo[i]
 122 |     |             );
 123 |     |         }
 124 |     |         if (secondsAgo[secondsAgo.length - 1] > secondsAgo[0]) {
 125 |     |             averageTick = int24((tickSecondsAccum[0] - tickSecondsAccum[secondsAgo.length - 1]) 
 126 |     |                                 / int32(secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));
 127 |     |             averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);
 128 |     |             averageLiquidity = uint128((secondsPerLiquidityAccum[0] - secondsPerLiquidityAccum[secondsAgo.length - 1]) 
 129 |     |                                     * (secondsAgo[secondsAgo.length - 1] - secondsAgo[0]));
 130 |     |         } else {
 131 |     |             averageTick = int24((tickSecondsAccum[secondsAgo.length - 1] - tickSecondsAccum[0]) 
 132 |     |                                 / int32(secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));
 133 |     |             averagePrice = ConstantProduct.getPriceAtTick(averageTick, params.constants);
 134 |     |             averageLiquidity = uint128((secondsPerLiquidityAccum[secondsAgo.length - 1] - secondsPerLiquidityAccum[0]) 
 135 |     |                                     * (secondsAgo[0] - secondsAgo[secondsAgo.length - 1]));
 136 |     |         }
 137 |     |     }
 138 |     | 
 139 |     |     function _poolSample(
 140 |     |         IRangePool pool,
 141 |     |         uint256 sampleIndex
 142 |     |     ) internal view returns (
 143 |     |         RangePoolStructs.Sample memory
 144 |     |     ) {
 145 |     |         (
 146 |     |             uint32 blockTimestamp,
 147 |     |             int56 tickSecondsAccum,
 148 |     |             uint160 liquidityPerSecondsAccum
 149 |     |         ) = IRangePool(pool).samples(sampleIndex);
 150 |     | 
 151 |     |         return PoolsharkStructs.Sample(
 152 |     |             blockTimestamp,
 153 |     |             tickSecondsAccum,
 154 |     |             liquidityPerSecondsAccum
 155 |     |         );
 156 |     |     }
 157 |     | 
 158 |     |     function getSingle(
 159 |     |         IRangePool pool,
 160 |     |         RangePoolStructs.SampleParams memory params,
 161 |     |         uint32 secondsAgo
 162 |     |     ) internal view returns (
 163 |     |         int56   tickSecondsAccum,
 164 |     |         uint160 secondsPerLiquidityAccum
 165 |     |     ) {
 166 |     |         RangePoolStructs.Sample memory latest = _poolSample(pool, params.sampleIndex);
 167 |     | 
 168 |     |         if (secondsAgo == 0) {
 169 |     |             // if 2 seconds have elapsed build new sample
 170 |     |             if (latest.blockTimestamp + 2 <= uint32(block.timestamp)) {
 171 |     |                 latest = _build(
 172 |     |                     latest,
 173 |     |                     uint32(block.timestamp),
 174 |     |                     params.tick,
 175 |     |                     params.liquidity
 176 |     |                 );
 177 |     |             }
 178 |     |             // else use latest sample
 179 |     |             return (
 180 |     |                 latest.tickSecondsAccum,
 181 |     |                 latest.secondsPerLiquidityAccum
 182 |     |             );
 183 |     |         }
 184 |     | 
 185 |     |         uint32 targetTime = uint32(block.timestamp) - secondsAgo;
 186 |     | 
 187 |     |         // should be getting samples
 188 |     |         (
 189 |     |             RangePoolStructs.Sample memory firstSample,
 190 |     |             RangePoolStructs.Sample memory secondSample
 191 |     |         ) = _getAdjacentSamples(
 192 |     |                 pool,
 193 |     |                 latest,
 194 |     |                 params,
 195 |     |                 targetTime
 196 |     |         );
 197 |     | 
 198 |     |         if (targetTime == firstSample.blockTimestamp) {
 199 |     |             // first sample
 200 |     |             return (
 201 |     |                 firstSample.tickSecondsAccum,
 202 |     |                 firstSample.secondsPerLiquidityAccum
 203 |     |             );
 204 |     |         } else if (targetTime == secondSample.blockTimestamp) {
 205 |     |             // second sample
 206 |     |             return (
 207 |     |                 secondSample.tickSecondsAccum,
 208 |     |                 secondSample.secondsPerLiquidityAccum
 209 |     |             );
 210 |     |         } else {
 211 |     |             // average two samples
 212 |     |             int32 sampleTimeDelta = int32(secondSample.blockTimestamp - firstSample.blockTimestamp);
 213 |     |             int56 targetDelta = int56(int32(targetTime - firstSample.blockTimestamp));
 214 |     |             return (
 215 |     |                 firstSample.tickSecondsAccum +
 216 |     |                     ((secondSample.tickSecondsAccum - firstSample.tickSecondsAccum) 
 217 |     |                     / sampleTimeDelta)
 218 |     |                     * targetDelta,
 219 |     |                 firstSample.secondsPerLiquidityAccum +
 220 |     |                     uint160(
 221 |     |                         (uint256(
 222 |     |                             secondSample.secondsPerLiquidityAccum - firstSample.secondsPerLiquidityAccum
 223 |     |                         ) 
 224 |     |                         * uint256(uint56(targetDelta))) 
 225 |     |                         / uint32(sampleTimeDelta)
 226 |     |                     )
 227 |     |             );
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function getLatest(
 232 |     |         PoolsharkStructs.GlobalState memory state,
 233 |     |         PoolsharkStructs.LimitImmutables memory constants,
 234 |     |         uint256 liquidity
 235 |     |     ) internal view returns (
 236 |     |         uint160 latestPrice,
 237 |     |         uint160 secondsPerLiquidityAccum,
 238 |     |         int56 tickSecondsAccum
 239 |     |     ) {
 240 |     |         uint32 timeDelta = timeElapsed(constants);
 241 |     |         (
 242 |     |             tickSecondsAccum,
 243 |     |             secondsPerLiquidityAccum
 244 |     |         ) = getSingle(
 245 |     |                 IRangePool(address(this)), 
 246 |     |                 RangePoolStructs.SampleParams(
 247 |     |                     state.pool.samples.index,
 248 |     |                     state.pool.samples.count,
 249 |     |                     uint32(block.timestamp),
 250 |     |                     new uint32[](2),
 251 |     |                     state.pool.tickAtPrice,
 252 |     |                     liquidity.toUint128(),
 253 |     |                     constants
 254 |     |                 ),
 255 |     |                 0
 256 |     |         );
 257 |     |         // grab older sample for dynamic fee calculation
 258 |     |         (
 259 |     |             int56 tickSecondsAccumBase,
 260 |     |         ) = Samples.getSingle(
 261 |     |                 IRangePool(address(this)), 
 262 |     |                 RangePoolStructs.SampleParams(
 263 |     |                     state.pool.samples.index,
 264 |     |                     state.pool.samples.count,
 265 |     |                     uint32(block.timestamp),
 266 |     |                     new uint32[](2),
 267 |     |                     state.pool.tickAtPrice,
 268 |     |                     liquidity.toUint128(),
 269 |     |                     constants
 270 |     |                 ),
 271 |     |                 timeDelta
 272 |     |         );
 273 |     | 
 274 |     |         latestPrice = calculateLatestPrice(
 275 |     |             tickSecondsAccum,
 276 |     |             tickSecondsAccumBase,
 277 |     |             timeDelta,
 278 |     |             TIME_DELTA_MAX,
 279 |     |             constants
 280 |     |         );
 281 |     |     }
 282 |     | 
 283 |     |     function calculateLatestPrice(
 284 |     |         int56 tickSecondsAccum,
 285 |     |         int56 tickSecondsAccumBase,
 286 |     |         uint32 timeDelta,
 287 |     |         uint32 timeDeltaMax,
 288 |     |         PoolsharkStructs.LimitImmutables memory constants
 289 |     |     ) private pure returns (
 290 |     |         uint160 averagePrice
 291 |     |     ) {
 292 |     |         int56 tickSecondsAccumDiff = tickSecondsAccum - tickSecondsAccumBase;
 293 |     |         int24 averageTick;
 294 |     |         if (timeDelta == timeDeltaMax) {
 295 |     |             averageTick = int24(tickSecondsAccumDiff / int32(timeDelta));
 296 |     |         } else {
 297 |     |             averageTick = int24(tickSecondsAccum / int32(timeDelta));
 298 |     |         }
 299 |     |         averagePrice = ConstantProduct.getPriceAtTick(averageTick, constants);
 300 |     |     }
 301 |     | 
 302 |     | 
 303 |     |     function timeElapsed(
 304 |     |         PoolsharkStructs.LimitImmutables memory constants
 305 |     |     ) private view returns (
 306 |     |         uint32
 307 |     |     )    
 308 |     |     {
 309 |     |         return  uint32(block.timestamp) - constants.genesisTime >= TIME_DELTA_MAX
 310 |     |                     ? TIME_DELTA_MAX
 311 |     |                     : uint32(block.timestamp - constants.genesisTime);
 312 |     |     }
 313 |     | 
 314 |     |     function _lte(
 315 |     |         uint32 timeA,
 316 |     |         uint32 timeB
 317 |     |     ) private view returns (bool) {
 318 |     |         uint32 currentTime = uint32(block.timestamp);
 319 |     |         if (timeA <= currentTime && timeB <= currentTime) return timeA <= timeB;
 320 |     | 
 321 |     |         uint256 timeAOverflow = timeA;
 322 |     |         uint256 timeBOverflow = timeB;
 323 |     | 
 324 |     |         if (timeA <= currentTime) {
 325 |     |             timeAOverflow = timeA + 2**32;
 326 |     |         }
 327 |     |         if (timeB <= currentTime) {
 328 |     |             timeBOverflow = timeB + 2**32;
 329 |     |         }
 330 |     | 
 331 |     |         return timeAOverflow <= timeBOverflow;
 332 |     |     }
 333 |     | 
 334 |     |     function _build(
 335 |     |         RangePoolStructs.Sample memory newSample,
 336 |     |         uint32  blockTimestamp,
 337 |     |         int24   tick,
 338 |     |         uint128 liquidity
 339 |     |     ) internal pure returns (
 340 |     |          RangePoolStructs.Sample memory
 341 |     |     ) {
 342 |     |         int56 timeDelta = int56(uint56(blockTimestamp - newSample.blockTimestamp));
 343 |     | 
 344 |     |         return
 345 |     |             PoolsharkStructs.Sample({
 346 |     |                 blockTimestamp: blockTimestamp,
 347 |     |                 tickSecondsAccum: newSample.tickSecondsAccum + int56(tick) * int32(timeDelta),
 348 |     |                 secondsPerLiquidityAccum: newSample.secondsPerLiquidityAccum +
 349 |     |                     ((uint160(uint56(timeDelta)) << 128) / (liquidity > 0 ? liquidity : 1))
 350 |     |             });
 351 |     |     }
 352 |     | 
 353 |     |     function _binarySearch(
 354 |     |         IRangePool pool,
 355 |     |         uint32 targetTime,
 356 |     |         uint16 sampleIndex,
 357 |     |         uint16 sampleLength
 358 |     |     ) private view returns (
 359 |     |         RangePoolStructs.Sample memory firstSample,
 360 |     |         RangePoolStructs.Sample memory secondSample
 361 |     |     ) {
 362 |     |         uint256 oldIndex = (sampleIndex + 1) % sampleLength;
 363 |     |         uint256 newIndex = oldIndex + sampleLength - 1;             
 364 |     |         uint256 index;
 365 |     |         while (true) {
 366 |     |             // start in the middle
 367 |     |             index = (oldIndex + newIndex) / 2;
 368 |     | 
 369 |     |             // get the first sample
 370 |     |             firstSample = _poolSample(pool, index % sampleLength);
 371 |     | 
 372 |     |             // if sample is uninitialized
 373 |     |             if (firstSample.blockTimestamp == 0) {
 374 |     |                 // skip this index and continue
 375 |     |                 oldIndex = index + 1;
 376 |     |                 continue;
 377 |     |             }
 378 |     |             // else grab second sample
 379 |     |             secondSample = _poolSample(pool, (index + 1) % sampleLength);
 380 |     | 
 381 |     |             // check if target time within first and second sample
 382 |     |             bool targetAfterFirst   = _lte(firstSample.blockTimestamp, targetTime);
 383 |     |             bool targetBeforeSecond = _lte(targetTime, secondSample.blockTimestamp);
 384 |     |             if (targetAfterFirst && targetBeforeSecond) break;
 385 |     |             if (!targetAfterFirst) newIndex = index - 1;
 386 |     |             else oldIndex = index + 1;
 387 |     |         }
 388 |     |     }
 389 |     | 
 390 |     |     function _getAdjacentSamples(
 391 |     |         IRangePool pool,
 392 |     |         RangePoolStructs.Sample memory firstSample,
 393 |     |         RangePoolStructs.SampleParams memory params,
 394 |     |         uint32 targetTime
 395 |     |     ) private view returns (
 396 |     |         RangePoolStructs.Sample memory,
 397 |     |         RangePoolStructs.Sample memory
 398 |     |     ) {
 399 |     |         if (_lte(firstSample.blockTimestamp, targetTime)) {
 400 |     |             if (firstSample.blockTimestamp == targetTime) {
 401 |     |                 return (firstSample, PoolsharkStructs.Sample(0,0,0));
 402 |     |             } else {
 403 |     |                 return (firstSample, _build(firstSample, targetTime, params.tick, params.liquidity));
 404 |     |             }
 405 |     |         }
 406 |     |         firstSample = _poolSample(pool, (params.sampleIndex + 1) % params.sampleLength);
 407 |     |         if (firstSample.blockTimestamp == 0) {
 408 |     |             firstSample = _poolSample(pool, 0);
 409 |     |         }
 410 |     |         if(!_lte(firstSample.blockTimestamp, targetTime)) require(false, 'SampleLengthNotAvailable()');
 411 |     | 
 412 |     |         return _binarySearch(
 413 |     |             pool,
 414 |     |             targetTime,
 415 |     |             params.sampleIndex,
 416 |     |             params.sampleLength
 417 |     |         );
 418 |     |     }
 419 |     | }

/root/git/limit/contracts/libraries/TickMap.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './math/ConstantProduct.sol';
   5 |     | import '../interfaces/structs/PoolsharkStructs.sol';
   6 |     | 
   7 |     | library TickMap {
   8 |     | 
   9 |     |     function get(
  10 |     |         PoolsharkStructs.TickMap storage tickMap,
  11 |     |         int24 tick,
  12 |     |         int24 tickSpacing
  13 |     |     ) internal view returns (
  14 |     |         bool exists
  15 |     |     ) {
  16 |     |         (
  17 |     |             uint256 tickIndex,
  18 |     |             uint256 wordIndex,
  19 |     |         ) = getIndices(tick, tickSpacing);
  20 |     | 
  21 |     |         // check if bit is already set
  22 |     |         uint256 word = tickMap.ticks[wordIndex] | 1 << (tickIndex & 0xFF);
  23 |     |         if (word == tickMap.ticks[wordIndex]) {
  24 |     |             return true;
  25 |     |         }
  26 |     |         return false;
  27 |     |     }
  28 |     | 
  29 |     |     function set(
  30 |     |         PoolsharkStructs.TickMap storage tickMap,
  31 |     |         int24 tick,
  32 |     |         int24 tickSpacing
  33 |     |     ) internal returns (
  34 |     |         bool exists
  35 |     |     ) {
  36 |     |         (
  37 |     |             uint256 tickIndex,
  38 |     |             uint256 wordIndex,
  39 |     |             uint256 blockIndex
  40 |     |         ) = getIndices(tick, tickSpacing);
  41 |     | 
  42 |     |         // check if bit is already set
  43 |     |         uint256 word = tickMap.ticks[wordIndex] | 1 << (tickIndex & 0xFF);
  44 |     |         if (word == tickMap.ticks[wordIndex]) {
  45 |     |             return true;
  46 |     |         }
  47 |     | 
  48 |     |         tickMap.ticks[wordIndex]     = word; 
  49 |     |         tickMap.words[blockIndex]   |= 1 << (wordIndex & 0xFF); // same as modulus 255
  50 |     |         tickMap.blocks              |= 1 << blockIndex;
  51 |     |         return false;
  52 |     |     }
  53 |     | 
  54 |     |     function unset(
  55 |     |         PoolsharkStructs.TickMap storage tickMap,
  56 |     |         int24 tick,
  57 |     |         int16 tickSpacing
  58 |     |     ) internal {
  59 |     |         (
  60 |     |             uint256 tickIndex,
  61 |     |             uint256 wordIndex,
  62 |     |             uint256 blockIndex
  63 |     |         ) = getIndices(tick, tickSpacing);
  64 |     | 
  65 |     |         tickMap.ticks[wordIndex] &= ~(1 << (tickIndex & 0xFF));
  66 |     |         if (tickMap.ticks[wordIndex] == 0) {
  67 |     |             tickMap.words[blockIndex] &= ~(1 << (wordIndex & 0xFF));
  68 |     |             if (tickMap.words[blockIndex] == 0) {
  69 |     |                 tickMap.blocks &= ~(1 << blockIndex);
  70 |     |             }
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     function previous(
  75 |     |         PoolsharkStructs.TickMap storage tickMap,
  76 |     |         int24 tick,
  77 |     |         int16 tickSpacing,
  78 |     |         bool inclusive
  79 |     |     ) internal view returns (
  80 |     |         int24 previousTick
  81 |     |     ) {
  82 |     |         unchecked {
  83 |     |             // rounds up to ensure relative position
  84 |     |             if (tick % (tickSpacing / 2) != 0 || inclusive) {
  85 |     |                 if (tick < (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {
  86 |     |                     /// @dev - ensures we cross when tick >= 0
  87 |     |                     if (tick >= 0) {
  88 |     |                         tick += tickSpacing / 2;
  89 |     |                     } else if (inclusive && tick % (tickSpacing / 2) == 0) {
  90 |     |                     /// @dev - ensures we cross when tick == tickAtPrice
  91 |     |                         tick += tickSpacing / 2;
  92 |     |                     }
  93 |     |                 }
  94 |     |             }
  95 |     |             (
  96 |     |               uint256 tickIndex,
  97 |     |               uint256 wordIndex,
  98 |     |               uint256 blockIndex
  99 |     |             ) = getIndices(tick, tickSpacing);
 100 |     | 
 101 |     |             uint256 word = tickMap.ticks[wordIndex] & ((1 << (tickIndex & 0xFF)) - 1);
 102 |     |             if (word == 0) {
 103 |     |                 uint256 block_ = tickMap.words[blockIndex] & ((1 << (wordIndex & 0xFF)) - 1);
 104 |     |                 if (block_ == 0) {
 105 |     |                     uint256 blockMap = tickMap.blocks & ((1 << blockIndex) - 1);
 106 |     |                     if (blockMap == 0) return tick;
 107 |     | 
 108 |     |                     blockIndex = _msb(blockMap);
 109 |     |                     block_ = tickMap.words[blockIndex];
 110 |     |                 }
 111 |     |                 wordIndex = (blockIndex << 8) | _msb(block_);
 112 |     |                 word = tickMap.ticks[wordIndex];
 113 |     |             }
 114 |     |             previousTick = _tick((wordIndex << 8) | _msb(word), tickSpacing);
 115 |     |         }
 116 |     |     }
 117 |     | 
 118 |     |     function next(
 119 |     |         PoolsharkStructs.TickMap storage tickMap,
 120 |     |         int24 tick,
 121 |     |         int16 tickSpacing,
 122 |     |         bool inclusive
 123 |     |     ) internal view returns (
 124 |     |         int24 nextTick
 125 |     |     ) {
 126 |     |         unchecked {
 127 |     |             /// @dev - handles tickAtPrice being past tickSpacing / 2
 128 |     |             if (inclusive && tick % tickSpacing != 0) {
 129 |     |                 // e.g. tick is 5 we subtract 1 to look ahead at 5
 130 |     |                 if (tick > 0 && (tick % tickSpacing <= (tickSpacing / 2)))
 131 |     |                     tick -= 1;
 132 |     |                 // e.g. tick is -5 we subtract 1 to look ahead at -5
 133 |     |                 else if (tick < 0 && (tick % tickSpacing <= -(tickSpacing / 2)))
 134 |     |                     tick -= 1;
 135 |     |                 // e.g. tick = 7 and tickSpacing = 10 we sub 5 to look ahead at 5
 136 |     |                 // e.g. tick = -2 and tickSpacing = 10 we sub 5 to look ahead at -5
 137 |     |                 else
 138 |     |                     tick -= tickSpacing / 2;
 139 |     |             }
 140 |     |             /// @dev - handles negative ticks rounding up
 141 |     |             if (tick % (tickSpacing / 2) != 0) {
 142 |     |                 if (tick < 0)
 143 |     |                     if (tick > (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))
 144 |     |                         tick -= tickSpacing / 2;
 145 |     |             }
 146 |     |             (
 147 |     |               uint256 tickIndex,
 148 |     |               uint256 wordIndex,
 149 |     |               uint256 blockIndex
 150 |     |             ) = getIndices(tick, tickSpacing);
 151 |     |             uint256 word;
 152 |     |             if ((tickIndex & 0xFF) != 255) {
 153 |     |                 word = tickMap.ticks[wordIndex] & ~((1 << ((tickIndex & 0xFF) + 1)) - 1);
 154 |     |             }
 155 |     |             if (word == 0) {
 156 |     |                 uint256 block_;
 157 |     |                 if ((blockIndex & 0xFF) != 255) {
 158 |     |                     block_ = tickMap.words[blockIndex] & ~((1 << ((wordIndex & 0xFF) + 1)) - 1);
 159 |     |                 }
 160 |     |                 if (block_ == 0) {
 161 |     |                     uint256 blockMap = tickMap.blocks & ~((1 << blockIndex + 1) - 1);
 162 |     |                     if (blockMap == 0) return tick;
 163 |     |                     blockIndex = _lsb(blockMap);
 164 |     |                     block_ = tickMap.words[blockIndex];
 165 |     |                 }
 166 |     |                 wordIndex = (blockIndex << 8) | _lsb(block_);
 167 |     |                 word = tickMap.ticks[wordIndex];
 168 |     |             }
 169 |     |             nextTick = _tick((wordIndex << 8) | _lsb(word), tickSpacing);
 170 |     |         }
 171 |     |     }
 172 |     | 
 173 |     |     function previousTicksWithinWord(
 174 |     |         PoolsharkStructs.TickMap storage tickMap,
 175 |     |         int24 tick,
 176 |     |         int16 tickSpacing,
 177 |     |         int24 stopTick,
 178 |     |         int24[] memory previousTicks,
 179 |     |         uint16 ticksIncluded
 180 |     |     ) internal view returns (
 181 |     |         int24[] memory,
 182 |     |         uint16,
 183 |     |         int24
 184 |     |     ) {
 185 |     |         // rounds up to ensure relative position
 186 |     |         if (tick % (tickSpacing / 2) != 0) {
 187 |     |             if (tick < (ConstantProduct.maxTick(tickSpacing) - tickSpacing / 2)) {
 188 |     |                 /// @dev - ensures we cross when tick >= 0
 189 |     |                 if (tick >= 0) {
 190 |     |                     tick += tickSpacing / 2;
 191 |     |                 }
 192 |     |             }
 193 |     |         }
 194 |     |         LimitPoolStructs.TickMapLocals memory locals; 
 195 |     |         (
 196 |     |             locals.tickIndex,
 197 |     |             locals.wordIndex,
 198 |     |             locals.blockIndex
 199 |     |         ) = getIndices(tick, tickSpacing);
 200 |     |         locals.word = tickMap.ticks[locals.wordIndex] & ((1 << (locals.tickIndex & 0xFF)) - 1);
 201 |     |         while (locals.word != 0 && tick > stopTick) {
 202 |     |             // ticks left within word
 203 |     |             tick = _tick((locals.wordIndex << 8) | _msb(locals.word), tickSpacing);
 204 |     |             previousTicks[ticksIncluded] = tick;
 205 |     |             unchecked {
 206 |     |                 ++ticksIncluded;
 207 |     |             }
 208 |     |             (
 209 |     |                 locals.tickIndex,,
 210 |     |             ) = getIndices(tick, tickSpacing);
 211 |     |             locals.word = locals.word & ((1 << (locals.tickIndex & 0xFF)) - 1);
 212 |     |         }
 213 |     |         // no ticks left within word
 214 |     |         // int24 firstTickNextWord =  
 215 |     |         return (previousTicks, ticksIncluded, locals.wordIndex > 0 ? _tick((locals.wordIndex - 1) << 8 | _msb(1 << 255), tickSpacing)
 216 |     |                                                                    : ConstantProduct.minTick(tickSpacing));
 217 |     |     }
 218 |     | 
 219 |     |     function nextTicksWithinWord(
 220 |     |         PoolsharkStructs.TickMap storage tickMap,
 221 |     |         int24 tick,
 222 |     |         int16 tickSpacing,
 223 |     |         int24 stopTick,
 224 |     |         int24[] memory nextTicks,
 225 |     |         uint16 ticksIncluded
 226 |     |     ) internal view returns (
 227 |     |         int24[] memory,
 228 |     |         uint16,
 229 |     |         int24
 230 |     |     ) {
 231 |     |         /// @dev - handles negative ticks rounding up
 232 |     |         if (tick % (tickSpacing / 2) != 0) {
 233 |     |             if (tick < 0)
 234 |     |                 if (tick > (ConstantProduct.minTick(tickSpacing) + tickSpacing / 2))
 235 |     |                     tick -= tickSpacing / 2;
 236 |     |         }
 237 |     |         LimitPoolStructs.TickMapLocals memory locals; 
 238 |     |         (
 239 |     |             locals.tickIndex,
 240 |     |             locals.wordIndex,
 241 |     |             locals.blockIndex
 242 |     |         ) = getIndices(tick, tickSpacing);
 243 |     |         if ((locals.tickIndex & 0xFF) != 255) {
 244 |     |            locals.word = tickMap.ticks[locals.wordIndex] & ~((1 << ((locals.tickIndex & 0xFF) + 1)) - 1);
 245 |     |         }
 246 |     |         while (locals.word != 0 && tick < stopTick) {
 247 |     |             // ticks left within word
 248 |     |             tick = _tick((locals.wordIndex << 8) | _lsb(locals.word), tickSpacing);
 249 |     |             nextTicks[ticksIncluded] = tick;
 250 |     |             unchecked {
 251 |     |                 ++ticksIncluded;
 252 |     |             }
 253 |     |             (
 254 |     |                 locals.tickIndex,,
 255 |     |             ) = getIndices(tick, tickSpacing);
 256 |     |             if ((locals.tickIndex & 0xFF) != 255) {
 257 |     |                 locals.word = locals.word & ~((1 << ((locals.tickIndex & 0xFF) + 1)) - 1);
 258 |     |             }
 259 |     |         }
 260 |     |         // no ticks left within word
 261 |     |         return (nextTicks, ticksIncluded, _tick((locals.wordIndex + 1) << 8 | _lsb(1), tickSpacing));
 262 |     |     }
 263 |     | 
 264 |     |     function getIndices(
 265 |     |         int24 tick,
 266 |     |         int24 tickSpacing
 267 |     |     ) public pure returns (
 268 |     |             uint256 tickIndex,
 269 |     |             uint256 wordIndex,
 270 |     |             uint256 blockIndex
 271 |     |         )
 272 |     |     {
 273 |     |         unchecked {
 274 |     |             if (tick > ConstantProduct.MAX_TICK) require(false, 'TickIndexOverflow()');
 275 |     |             if (tick < ConstantProduct.MIN_TICK) require(false, 'TickIndexUnderflow()');
 276 |     |             if (tick % (tickSpacing / 2) != 0) tick = round(tick, tickSpacing / 2);
 277 |     |             tickIndex = uint256(int256((round(tick, tickSpacing / 2) 
 278 |     |                                         - round(ConstantProduct.MIN_TICK, tickSpacing / 2)) 
 279 |     |                                         / (tickSpacing / 2)));
 280 |     |             wordIndex = tickIndex >> 8;   // 2^8 ticks per word
 281 |     |             blockIndex = tickIndex >> 16; // 2^8 words per block
 282 |     |             if (blockIndex > 255) require(false, 'BlockIndexOverflow()');
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     | 
 287 |     | 
 288 |     |     function _tick (
 289 |     |         uint256 tickIndex,
 290 |     |         int24 tickSpacing
 291 |     |     ) internal pure returns (
 292 |     |         int24 tick
 293 |     |     ) {
 294 |     |         unchecked {
 295 |     |             if (tickIndex > uint24(round(ConstantProduct.MAX_TICK, tickSpacing) * 2) * 2) 
 296 |     |                 require(false, 'TickIndexOverflow()');
 297 |     |             tick = int24(int256(tickIndex) * (tickSpacing / 2) + round(ConstantProduct.MIN_TICK, tickSpacing / 2));
 298 |     |         }
 299 |     |     }
 300 |     | 
 301 |     |     function _msb(
 302 |     |         uint256 x
 303 |     |     ) internal pure returns (
 304 |     |         uint8 r
 305 |     |     ) {
 306 |     |         unchecked {
 307 |     |             assert(x > 0);
 308 |     |             if (x >= 0x100000000000000000000000000000000) {
 309 |     |                 x >>= 128;
 310 |     |                 r += 128;
 311 |     |             }
 312 |     |             if (x >= 0x10000000000000000) {
 313 |     |                 x >>= 64;
 314 |     |                 r += 64;
 315 |     |             }
 316 |     |             if (x >= 0x100000000) {
 317 |     |                 x >>= 32;
 318 |     |                 r += 32;
 319 |     |             }
 320 |     |             if (x >= 0x10000) {
 321 |     |                 x >>= 16;
 322 |     |                 r += 16;
 323 |     |             }
 324 |     |             if (x >= 0x100) {
 325 |     |                 x >>= 8;
 326 |     |                 r += 8;
 327 |     |             }
 328 |     |             if (x >= 0x10) {
 329 |     |                 x >>= 4;
 330 |     |                 r += 4;
 331 |     |             }
 332 |     |             if (x >= 0x4) {
 333 |     |                 x >>= 2;
 334 |     |                 r += 2;
 335 |     |             }
 336 |     |             if (x >= 0x2) r += 1;
 337 |     |         }
 338 |     |     }
 339 |     | 
 340 |     |     function _lsb(
 341 |     |         uint256 x
 342 |     |     ) internal pure returns (
 343 |     |         uint8 r
 344 |     |     ) {
 345 |     |         unchecked {
 346 |     |             assert(x > 0); // if x is 0 return 0
 347 |     |             r = 255;
 348 |     |             if (x & type(uint128).max > 0) {
 349 |     |                 r -= 128;
 350 |     |             } else {
 351 |     |                 x >>= 128;
 352 |     |             }
 353 |     |             if (x & type(uint64).max > 0) {
 354 |     |                 r -= 64;
 355 |     |             } else {
 356 |     |                 x >>= 64;
 357 |     |             }
 358 |     |             if (x & type(uint32).max > 0) {
 359 |     |                 r -= 32;
 360 |     |             } else {
 361 |     |                 x >>= 32;
 362 |     |             }
 363 |     |             if (x & type(uint16).max > 0) {
 364 |     |                 r -= 16;
 365 |     |             } else {
 366 |     |                 x >>= 16;
 367 |     |             }
 368 |     |             if (x & type(uint8).max > 0) {
 369 |     |                 r -= 8;
 370 |     |             } else {
 371 |     |                 x >>= 8;
 372 |     |             }
 373 |     |             if (x & 0xf > 0) {
 374 |     |                 r -= 4;
 375 |     |             } else {
 376 |     |                 x >>= 4;
 377 |     |             }
 378 |     |             if (x & 0x3 > 0) {
 379 |     |                 r -= 2;
 380 |     |             } else {
 381 |     |                 x >>= 2;
 382 |     |             }
 383 |     |             if (x & 0x1 > 0) r -= 1;
 384 |     |         }
 385 |     |     }
 386 |     | 
 387 |     |     function round(
 388 |     |         int24 tick,
 389 |     |         int24 tickSpacing
 390 |     |     ) internal pure returns (
 391 |     |         int24 roundedTick
 392 |     |     ) {
 393 |     |         return tick / tickSpacing * tickSpacing;
 394 |     |     }
 395 |     | 
 396 |     |     function roundHalf(
 397 |     |         int24 tick,
 398 |     |         PoolsharkStructs.LimitImmutables memory constants,
 399 |     |         uint256 price
 400 |     |     ) internal pure returns (
 401 |     |         int24 roundedTick,
 402 |     |         uint160 roundedTickPrice
 403 |     |     ) {
 404 |     |         //pool.tickAtPrice -99.5
 405 |     |         //pool.tickAtPrice -100
 406 |     |         //-105
 407 |     |         //-95
 408 |     |         roundedTick = tick / constants.tickSpacing * constants.tickSpacing;
 409 |     |         roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);
 410 |     |         if (price == roundedTickPrice)
 411 |     |             return (roundedTick, roundedTickPrice);
 412 |     |         if (roundedTick > 0) {
 413 |     |             roundedTick += constants.tickSpacing / 2;
 414 |     |         } else if (roundedTick < 0) {
 415 |     |             if (roundedTickPrice < price)
 416 |     |                 roundedTick += constants.tickSpacing / 2;
 417 |     |             else
 418 |     |                 roundedTick -= constants.tickSpacing / 2;
 419 |     |         } else {
 420 |     |             if (price > roundedTickPrice) {
 421 |     |                 roundedTick += constants.tickSpacing / 2;
 422 |     |             } else if (price < roundedTickPrice) {
 423 |     |                 roundedTick -= constants.tickSpacing / 2;
 424 |     |             }
 425 |     |         }
 426 |     |     }
 427 |     | 
 428 |     |     function roundAhead(
 429 |     |         int24 tick,
 430 |     |         PoolsharkStructs.LimitImmutables memory constants,
 431 |     |         bool zeroForOne,
 432 |     |         uint256 price
 433 |     |     ) internal pure returns (
 434 |     |         int24 roundedTick
 435 |     |     ) {
 436 |     |         roundedTick = tick / constants.tickSpacing * constants.tickSpacing;
 437 |     |         uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);
 438 |     |         if (price == roundedTickPrice)
 439 |     |             return roundedTick;
 440 |     |         if (zeroForOne) {
 441 |     |             // round up if positive
 442 |     |             if (roundedTick > 0 || (roundedTick == 0 && tick >= 0))
 443 |     |                 roundedTick += constants.tickSpacing;
 444 |     |             else if (tick % constants.tickSpacing == 0) {
 445 |     |                 // handle price at -99.5 and tickAtPrice == -100
 446 |     |                 if (tick < 0 && roundedTickPrice < price) {
 447 |     |                     roundedTick += constants.tickSpacing;
 448 |     |                 }
 449 |     |             }
 450 |     |         } else {
 451 |     |             // round down if negative
 452 |     |             if (roundedTick < 0 || (roundedTick == 0 && tick < 0))
 453 |     |             /// @dev - strictly less due to TickMath always rounding to lesser values
 454 |     |                 roundedTick -= constants.tickSpacing;
 455 |     |         }
 456 |     |     }
 457 |     | 
 458 |     |     function roundBack(
 459 |     |         int24 tick,
 460 |     |         PoolsharkStructs.LimitImmutables memory constants,
 461 |     |         bool zeroForOne,
 462 |     |         uint256 price
 463 |     |     ) internal pure returns (
 464 |     |         int24 roundedTick
 465 |     |     ) {
 466 |     |         roundedTick = tick / constants.tickSpacing * constants.tickSpacing;
 467 |     |         uint160 roundedTickPrice = ConstantProduct.getPriceAtTick(roundedTick, constants);
 468 |     |         if (price == roundedTickPrice)
 469 |     |             return roundedTick;
 470 |     |         if (zeroForOne) {
 471 |     |             // round down if negative
 472 |     |             if (roundedTick < 0 || (roundedTick == 0 && tick < 0))
 473 |     |                 roundedTick -= constants.tickSpacing;
 474 |     |         } else {
 475 |     |             // round up if positive
 476 |     |             if (roundedTick > 0 || (roundedTick == 0 && tick >= 0))
 477 |     |                 roundedTick += constants.tickSpacing;
 478 |     |             else if (tick % constants.tickSpacing == 0) {
 479 |     |                 // handle price at -99.5 and tickAtPrice == -100
 480 |     |                 if (tick < 0 && roundedTickPrice < price) {
 481 |     |                     roundedTick += constants.tickSpacing;
 482 |     |                 }
 483 |     |             }
 484 |     |         }
 485 |     |     }
 486 |     | }

/root/git/limit/contracts/libraries/Ticks.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/structs/PoolsharkStructs.sol';
   5 |     | import './range/math/FeeMath.sol';
   6 |     | import './math/OverflowMath.sol';
   7 |     | import './math/ConstantProduct.sol';
   8 |     | import './TickMap.sol';
   9 |     | import './utils/SafeCast.sol';
  10 |     | import './range/math/FeeMath.sol';
  11 |     | import './Samples.sol';
  12 |     | import './limit/EpochMap.sol';
  13 |     | import './limit/LimitTicks.sol';
  14 |     | import '../test/echidna/EchidnaAssertions.sol';
  15 |     | 
  16 |     | library Ticks {
  17 |     | 
  18 |     |     using SafeCast for uint256;
  19 |     | 
  20 |     |     // cross flags
  21 |     |     uint8 internal constant RANGE_TICK = 2**0;
  22 |     |     uint8 internal constant LIMIT_TICK = 2**1;
  23 |     |     uint8 internal constant LIMIT_POOL = 2**2;
  24 |     | 
  25 |     |     // for Q64.96 numbers
  26 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  27 |     | 
  28 |     |     event Initialize(
  29 |     |         int24 minTick,
  30 |     |         int24 maxTick,
  31 |     |         uint160 startPrice,
  32 |     |         int24 startTick
  33 |     |     );
  34 |     | 
  35 |     |     event BuildNewSample(
  36 |     |         uint32 blockTimestamp,
  37 |     |         uint160 secondsPerLiquidityAccum
  38 |     |     );
  39 |     | 
  40 |     |     event UseOldSample(
  41 |     |         uint32 blockTimestamp,
  42 |     |         uint160 secondsPerLiquidityAccum
  43 |     |     );
  44 |     | 
  45 |     |     event Swap(
  46 |     |         address indexed recipient,
  47 |     |         uint256 amountIn,
  48 |     |         uint256 amountOut,
  49 |     |         uint200 feeGrowthGlobal0,
  50 |     |         uint200 feeGrowthGlobal1,
  51 |     |         uint160 price,
  52 |     |         uint128 liquidity,
  53 |     |         uint128 feeAmount,
  54 |     |         int24 tickAtPrice,
  55 |     |         bool indexed zeroForOne,
  56 |     |         bool indexed exactIn
  57 |     |     );
  58 |     | 
  59 |     |     event SyncRangeTick(
  60 |     |         uint200 feeGrowthOutside0,
  61 |     |         uint200 feeGrowthOutside1,
  62 |     |         int24 tick
  63 |     |     );
  64 |     | 
  65 |     |     function initialize(
  66 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
  67 |     |         PoolsharkStructs.TickMap storage limitTickMap,
  68 |     |         RangePoolStructs.Sample[65535] storage samples,
  69 |     |         PoolsharkStructs.GlobalState memory state,
  70 |     |         PoolsharkStructs.LimitImmutables memory constants,
  71 |     |         uint160 startPrice
  72 |     |     ) internal returns (
  73 |     |         PoolsharkStructs.GlobalState memory  
  74 |     |     )
  75 |     |     {
  76 |     |         // state should only be initialized once
  77 |     |         if (state.pool0.price > 0) require (false, 'PoolAlreadyInitialized()');
  78 |     | 
  79 |     |         // initialize state
  80 |     |         state.epoch = 1;
  81 |     |         state.positionIdNext = 1;
  82 |     | 
  83 |     |         // check price bounds
  84 |     |         if (startPrice < constants.bounds.min || startPrice >= constants.bounds.max) require(false, 'StartPriceInvalid()');
  85 |     | 
  86 |     |         // initialize range ticks
  87 |     |         TickMap.set(rangeTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);
  88 |     |         TickMap.set(rangeTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);
  89 |     |         
  90 |     |         // initialize limit ticks
  91 |     |         TickMap.set(limitTickMap, ConstantProduct.minTick(constants.tickSpacing), constants.tickSpacing);
  92 |     |         TickMap.set(limitTickMap, ConstantProduct.maxTick(constants.tickSpacing), constants.tickSpacing);
  93 |     | 
  94 |     |         // initialize price
  95 |     |         state.pool.price = startPrice;
  96 |     |         state.pool0.price = startPrice;
  97 |     |         state.pool1.price = startPrice;
  98 |     | 
  99 |     |         int24 startTick = ConstantProduct.getTickAtPrice(startPrice, constants);
 100 |     |         state.pool.tickAtPrice = startTick;
 101 |     |         state.pool0.tickAtPrice = startTick;
 102 |     |         state.pool1.tickAtPrice = startTick;
 103 |     | 
 104 |     |         // intialize samples
 105 |     |         state.pool = Samples.initialize(samples, state.pool);
 106 |     | 
 107 |     |         // emit event
 108 |     |         emit Initialize(
 109 |     |             ConstantProduct.minTick(constants.tickSpacing),
 110 |     |             ConstantProduct.maxTick(constants.tickSpacing),
 111 |     |             state.pool0.price,
 112 |     |             state.pool0.tickAtPrice
 113 |     |         );
 114 |     | 
 115 |     |         return state;
 116 |     |     }
 117 |     |     
 118 |     |     function swap(
 119 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 120 |     |         RangePoolStructs.Sample[65535] storage samples,
 121 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
 122 |     |         PoolsharkStructs.TickMap storage limitTickMap,
 123 |     |         PoolsharkStructs.SwapParams memory params,
 124 |     |         PoolsharkStructs.SwapCache memory cache
 125 |     |     ) internal returns (
 126 |     |         PoolsharkStructs.SwapCache memory
 127 |     |     )
 128 |     |     {
 129 |     |         cache.price = cache.state.pool.price;
 130 |     |         cache.crossTick = cache.state.pool.tickAtPrice;
 131 |     | 
 132 |     |         // set initial cross state
 133 |     |         cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);
 134 |     | 
 135 |     |         uint128 startLiquidity = cache.state.pool.liquidity;
 136 |     | 
 137 |     |         // grab sample for accumulators
 138 |     |         cache = PoolsharkStructs.SwapCache({
 139 |     |             state: cache.state,
 140 |     |             constants: cache.constants,
 141 |     |             price: cache.price,
 142 |     |             liquidity: cache.liquidity,
 143 |     |             amountLeft: params.amount,
 144 |     |             input:  0,
 145 |     |             output: 0,
 146 |     |             crossPrice: cache.crossPrice,
 147 |     |             secondsPerLiquidityAccum: 0,
 148 |     |             feeAmount: 0,
 149 |     |             tickSecondsAccum: 0,
 150 |     |             tickSecondsAccumBase: 0,
 151 |     |             crossTick: cache.crossTick,
 152 |     |             crossStatus: cache.crossStatus,
 153 |     |             limitActive: cache.limitActive,
 154 |     |             exactIn: params.exactIn,
 155 |     |             cross: true,
 156 |     |             averagePrice: 0
 157 |     |         });
 158 |     |         // grab latest price and sample
 159 |     |         RangePoolStructs.Sample memory latest = Samples._poolSample(IRangePool(address(this)), cache.state.pool.samples.index);
 160 |     |         if (latest.blockTimestamp + 2 <= uint32(block.timestamp)) {
 161 |     |                 latest = Samples._build(
 162 |     |                     latest,
 163 |     |                     uint32(block.timestamp),
 164 |     |                     cache.state.pool.tickAtPrice,
 165 |     |                     cache.liquidity.toUint128()
 166 |     |                 );
 167 |     |                 emit BuildNewSample(
 168 |     |                     latest.blockTimestamp,
 169 |     |                     latest.secondsPerLiquidityAccum
 170 |     |                 );
 171 |     |             } else {
 172 |     |                 emit UseOldSample(
 173 |     |                     latest.blockTimestamp,
 174 |     |                     latest.secondsPerLiquidityAccum
 175 |     |                 );
 176 |     |             }
 177 |     |         (
 178 |     |             cache.averagePrice,
 179 |     |             cache.secondsPerLiquidityAccum,
 180 |     |             cache.tickSecondsAccum
 181 |     |          ) = Samples.getLatest(cache.state, cache.constants, cache.state.pool.liquidity);
 182 |     | 
 183 |     |         // grab latest sample and store in cache for _cross
 184 |     |         while (cache.cross) {
 185 |     |             // handle price being at cross tick
 186 |     |             cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);
 187 |     |             if (cache.cross) {
 188 |     |                 cache = _cross(
 189 |     |                     ticks,
 190 |     |                     rangeTickMap,
 191 |     |                     limitTickMap,
 192 |     |                     cache,
 193 |     |                     params
 194 |     |                 );
 195 |     |             }
 196 |     |         }
 197 |     |         /// @dev - write oracle entry after start of block
 198 |     |         (
 199 |     |             cache.state.pool.samples.index,
 200 |     |             cache.state.pool.samples.count
 201 |     |         ) = Samples.save(
 202 |     |             samples,
 203 |     |             cache.state.pool.samples,
 204 |     |             startLiquidity,
 205 |     |             cache.state.pool.tickAtPrice
 206 |     |         );
 207 |     |         // pool liquidity should be updated along the way
 208 |     |         cache.state.pool.price = cache.price.toUint160();
 209 |     | 
 210 |     |         if (cache.price != cache.crossPrice) {
 211 |     |             cache.state.pool.tickAtPrice = ConstantProduct.getTickAtPrice(cache.price.toUint160(), cache.constants);
 212 |     |         } else {
 213 |     |             cache.state.pool.tickAtPrice = cache.crossTick;
 214 |     |         }
 215 |     |         if (cache.limitActive) {
 216 |     |             if (params.zeroForOne) {
 217 |     |                 cache.state.pool1.price = cache.state.pool.price;
 218 |     |                 cache.state.pool1.tickAtPrice = cache.state.pool.tickAtPrice;
 219 |     |             } else {
 220 |     |                 cache.state.pool0.price = cache.state.pool.price;
 221 |     |                 cache.state.pool0.tickAtPrice = cache.state.pool.tickAtPrice;
 222 |     |             }
 223 |     |         }
 224 |     |         emit Swap(
 225 |     |             params.to,
 226 |     |             cache.input,
 227 |     |             cache.output,
 228 |     |             cache.state.pool.feeGrowthGlobal0,
 229 |     |             cache.state.pool.feeGrowthGlobal1,
 230 |     |             cache.price.toUint160(),
 231 |     |             cache.liquidity.toUint128(),
 232 |     |             cache.feeAmount,
 233 |     |             cache.state.pool.tickAtPrice,
 234 |     |             params.zeroForOne,
 235 |     |             params.exactIn
 236 |     |         );
 237 |     |         return cache;
 238 |     |     }
 239 |     | 
 240 |     |     function quote(
 241 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 242 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
 243 |     |         PoolsharkStructs.TickMap storage limitTickMap,
 244 |     |         PoolsharkStructs.QuoteParams memory params,
 245 |     |         PoolsharkStructs.SwapCache memory cache
 246 |     |     ) internal returns (
 247 |     |         uint256,
 248 |     |         uint256,
 249 |     |         uint160
 250 |     |     ) {
 251 |     |         // start with range price
 252 |     |         cache.price = cache.state.pool.price;
 253 |     |         cache.crossTick = cache.state.pool.tickAtPrice;
 254 |     | 
 255 |     |         cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, true);
 256 |     |         
 257 |     |         // set crossTick/crossPrice based on the best between limit and range
 258 |     |         // grab sample for accumulators
 259 |     |         cache = PoolsharkStructs.SwapCache({
 260 |     |             state: cache.state,
 261 |     |             constants: cache.constants,
 262 |     |             price: cache.price,
 263 |     |             liquidity: cache.liquidity,
 264 |     |             amountLeft: params.amount,
 265 |     |             input:  0,
 266 |     |             output: 0,
 267 |     |             crossPrice: cache.crossPrice,
 268 |     |             secondsPerLiquidityAccum: 0,
 269 |     |             feeAmount: 0,
 270 |     |             tickSecondsAccum: 0,
 271 |     |             tickSecondsAccumBase: 0,
 272 |     |             crossTick: cache.crossTick,
 273 |     |             crossStatus: cache.crossStatus,
 274 |     |             limitActive: cache.limitActive,
 275 |     |             exactIn: params.exactIn,
 276 |     |             cross: true,
 277 |     |             averagePrice: 0
 278 |     |         });
 279 |     |         // grab latest price and sample
 280 |     |         (
 281 |     |             cache.averagePrice,
 282 |     |             cache.secondsPerLiquidityAccum,
 283 |     |             cache.tickSecondsAccum
 284 |     |          ) = Samples.getLatest(cache.state, cache.constants, cache.state.pool.liquidity);
 285 |     |         while (cache.cross) {
 286 |     |             cache = _quoteSingle(cache, params.priceLimit, params.zeroForOne);
 287 |     |             if (cache.cross) {
 288 |     |                 cache = _pass(
 289 |     |                     ticks,
 290 |     |                     rangeTickMap,
 291 |     |                     limitTickMap,
 292 |     |                     cache,
 293 |     |                     params
 294 |     |                 );
 295 |     |             }
 296 |     |         }
 297 |     |         return (
 298 |     |             cache.input,
 299 |     |             cache.output,
 300 |     |             cache.price.toUint160()
 301 |     |         );
 302 |     |     }
 303 |     | 
 304 |     |     function _quoteSingle(
 305 |     |         PoolsharkStructs.SwapCache memory cache,
 306 |     |         uint160 priceLimit,
 307 |     |         bool zeroForOne
 308 |     |     ) internal pure returns (
 309 |     |         PoolsharkStructs.SwapCache memory
 310 |     |     ) {
 311 |     |         if ((zeroForOne ? priceLimit >= cache.price
 312 |     |                         : priceLimit <= cache.price) ||
 313 |     |             (zeroForOne && cache.price == cache.constants.bounds.min) ||
 314 |     |             (!zeroForOne && cache.price == cache.constants.bounds.max) ||
 315 |     |             (cache.amountLeft == 0 && cache.liquidity > 0))
 316 |     |         {
 317 |     |             cache.cross = false;
 318 |     |             return cache;
 319 |     |         }
 320 |     |         uint256 nextPrice = cache.crossPrice;
 321 |     |          uint256 amountIn; uint256 amountOut;
 322 |     |         if (zeroForOne) {
 323 |     |             // Trading token 0 (x) for token 1 (y).
 324 |     |             // price  is decreasing.
 325 |     |             if (nextPrice < priceLimit) {
 326 |     |                 nextPrice = priceLimit;
 327 |     |             }
 328 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true)
 329 |     |                                               : ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
 330 |     |             if (cache.amountLeft < amountMax) {
 331 |     |                 // calculate price after swap
 332 |     |                 uint256 newPrice = ConstantProduct.getNewPrice(
 333 |     |                     cache.price,
 334 |     |                     cache.liquidity,
 335 |     |                     cache.amountLeft,
 336 |     |                     zeroForOne,
 337 |     |                     cache.exactIn
 338 |     |                 );
 339 |     |                 if (cache.exactIn) {
 340 |     |                     amountIn = cache.amountLeft;
 341 |     |                     amountOut = ConstantProduct.getDy(cache.liquidity, newPrice, cache.price, false);
 342 |     |                 } else {
 343 |     |                     amountIn = ConstantProduct.getDx(cache.liquidity, newPrice, cache.price, true);
 344 |     |                     amountOut = cache.amountLeft;
 345 |     |                 }
 346 |     |                 cache.amountLeft = 0;
 347 |     |                 cache.cross = false;
 348 |     |                 cache.price = uint160(newPrice);
 349 |     |             } else {
 350 |     |                 if (cache.exactIn) {
 351 |     |                     amountIn = amountMax;
 352 |     |                     amountOut = ConstantProduct.getDy(cache.liquidity, nextPrice, cache.price, false);
 353 |     | 
 354 |     |                 } else {
 355 |     |                     amountIn = ConstantProduct.getDx(cache.liquidity, nextPrice, cache.price, true);
 356 |     |                     amountOut = amountMax;
 357 |     |                 }
 358 |     |                 cache.amountLeft -= amountMax;
 359 |     |                 if (nextPrice == cache.crossPrice) cache.cross = true;
 360 |     |                 else cache.cross = false;
 361 |     |                 cache.price = uint160(nextPrice);
 362 |     |             }
 363 |     |         } else {
 364 |     |             // Price is increasing.
 365 |     |             if (nextPrice > priceLimit) {
 366 |     |                 nextPrice = priceLimit;
 367 |     |             }
 368 |     |             uint256 amountMax = cache.exactIn ? ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true)
 369 |     |                                               : ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);
 370 |     |             if (cache.amountLeft < amountMax) {
 371 |     |                 uint256 newPrice = ConstantProduct.getNewPrice(
 372 |     |                     cache.price,
 373 |     |                     cache.liquidity,
 374 |     |                     cache.amountLeft,
 375 |     |                     zeroForOne,
 376 |     |                     cache.exactIn
 377 |     |                 );
 378 |     |                 if (cache.exactIn) {
 379 |     |                     amountIn = cache.amountLeft;
 380 |     |                     amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, newPrice, false);
 381 |     |                 } else {
 382 |     |                     amountIn = ConstantProduct.getDy(cache.liquidity, cache.price, newPrice, true);
 383 |     |                     amountOut = cache.amountLeft;
 384 |     |                 }
 385 |     |                 cache.amountLeft = 0;
 386 |     |                 cache.cross = false;
 387 |     |                 cache.price = uint160(newPrice);
 388 |     |             } else {
 389 |     |                 if (cache.exactIn) {
 390 |     |                     amountIn = amountMax;
 391 |     |                     amountOut = ConstantProduct.getDx(cache.liquidity, cache.price, nextPrice, false);
 392 |     |                 } else {
 393 |     |                     amountIn = ConstantProduct.getDy(cache.liquidity, cache.price, nextPrice, true);
 394 |     |                     amountOut = amountMax;
 395 |     |                 }
 396 |     |                 cache.amountLeft -= amountMax;
 397 |     |                 if (nextPrice == cache.crossPrice) cache.cross = true;
 398 |     |                 else cache.cross = false;
 399 |     |                 cache.price = uint160(nextPrice);
 400 |     |             }
 401 |     |         }
 402 |     |         cache = FeeMath.calculate(cache, amountIn, amountOut, zeroForOne);
 403 |     |         return cache;
 404 |     |     }
 405 |     | 
 406 |     |     function _cross(
 407 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 408 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
 409 |     |         PoolsharkStructs.TickMap storage limitTickMap,
 410 |     |         PoolsharkStructs.SwapCache memory cache,
 411 |     |         PoolsharkStructs.SwapParams memory params
 412 |     |     ) internal returns (
 413 |     |         PoolsharkStructs.SwapCache memory
 414 |     |     ) {
 415 |     |         // crossing range ticks
 416 |     |         if ((cache.crossStatus & RANGE_TICK) > 0) {
 417 |     |             // skip if crossing down and stopping at crossPrice
 418 |     |             if (!params.zeroForOne || (cache.amountLeft > 0 && params.priceLimit < cache.crossPrice)) {
 419 |     |                 PoolsharkStructs.RangeTick memory crossTick = ticks[cache.crossTick].range;
 420 |     |                 EchidnaAssertions.assertFeeGrowthOutsideUnderflows(cache.state.pool.feeGrowthGlobal0, crossTick.feeGrowthOutside0);
 421 |     |                 crossTick.feeGrowthOutside0       = cache.state.pool.feeGrowthGlobal0 - crossTick.feeGrowthOutside0;
 422 |     |                 EchidnaAssertions.assertFeeGrowthOutsideUnderflows(cache.state.pool.feeGrowthGlobal1, crossTick.feeGrowthOutside1);
 423 |     |                 crossTick.feeGrowthOutside1       = cache.state.pool.feeGrowthGlobal1 - crossTick.feeGrowthOutside1;
 424 |     |                 EchidnaAssertions.assertTickSecondsAccumWithinBounds(cache.tickSecondsAccum, crossTick.tickSecondsAccumOutside);
 425 |     |                 crossTick.tickSecondsAccumOutside = cache.tickSecondsAccum - crossTick.tickSecondsAccumOutside;
 426 |     |                 EchidnaAssertions.assertSecondsPerLiquidityAccumUnderflows(cache.secondsPerLiquidityAccum, crossTick.secondsPerLiquidityAccumOutside, cache.crossTick);
 427 |     |                 crossTick.secondsPerLiquidityAccumOutside = cache.secondsPerLiquidityAccum - crossTick.secondsPerLiquidityAccumOutside;
 428 |     |                 ticks[cache.crossTick].range = crossTick;
 429 |     |                 int128 liquidityDelta = crossTick.liquidityDelta;
 430 |     |                 emit SyncRangeTick(
 431 |     |                     crossTick.feeGrowthOutside0,
 432 |     |                     crossTick.feeGrowthOutside1,
 433 |     |                     cache.crossTick
 434 |     |                 );
 435 |     |                 if (params.zeroForOne) {
 436 |     |                     unchecked {
 437 |     |                         if (liquidityDelta >= 0){
 438 |     |                             EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), "TKS-1");
 439 |     |                             cache.liquidity -= uint128(liquidityDelta);
 440 |     |                             cache.state.pool.liquidity -= uint128(liquidityDelta);
 441 |     |                         } else {
 442 |     |                             EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), "TKS-2");
 443 |     |                             cache.liquidity += uint128(-liquidityDelta);
 444 |     |                             cache.state.pool.liquidity += uint128(-liquidityDelta); 
 445 |     |                         }
 446 |     |                     }
 447 |     |                 } else {
 448 |     |                     unchecked {
 449 |     |                         if (liquidityDelta >= 0) {
 450 |     |                             EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(liquidityDelta), "TKS-3");
 451 |     |                             cache.liquidity += uint128(liquidityDelta);
 452 |     |                             cache.state.pool.liquidity += uint128(liquidityDelta);
 453 |     |                         } else {
 454 |     |                             EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(-liquidityDelta), "TKS-4");
 455 |     |                             cache.liquidity -= uint128(-liquidityDelta);
 456 |     |                             cache.state.pool.liquidity -= uint128(-liquidityDelta);
 457 |     |                         }
 458 |     |                     }
 459 |     |                 }
 460 |     |             } else {
 461 |     |                 // skip crossing the tick
 462 |     |                 cache.cross = false;
 463 |     |             }
 464 |     |         }
 465 |     |         // crossing limit tick
 466 |     |         if ((cache.crossStatus & LIMIT_TICK) > 0) {
 467 |     |             // cross limit tick
 468 |     |             EpochMap.set(cache.crossTick, !params.zeroForOne, cache.state.epoch, limitTickMap, cache.constants);
 469 |     |             int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;
 470 |     | 
 471 |     |             if (liquidityDelta >= 0) {
 472 |     |                 cache.liquidity += uint128(liquidityDelta);
 473 |     |                 if (params.zeroForOne) cache.state.pool1.liquidity += uint128(liquidityDelta);
 474 |     |                 else cache.state.pool0.liquidity += uint128(liquidityDelta);
 475 |     |             }
 476 |     |             else {
 477 |     |                 cache.liquidity -= uint128(-liquidityDelta);
 478 |     |                 if (params.zeroForOne) cache.state.pool1.liquidity -= uint128(-liquidityDelta);
 479 |     |                 else cache.state.pool0.liquidity -= uint128(-liquidityDelta);
 480 |     |             }
 481 |     |             // zero out liquidityDelta and priceAt
 482 |     |             ticks[cache.crossTick].limit = PoolsharkStructs.LimitTick(0,0,0);
 483 |     |             LimitTicks.clear(ticks, cache.constants, limitTickMap, cache.crossTick);
 484 |     |             /// @dev - price and tickAtPrice updated at end of loop
 485 |     |         }
 486 |     |         if ((cache.crossStatus & LIMIT_POOL) > 0) {
 487 |     |             // add one-way liquidity
 488 |     |             uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity
 489 |     |                                                        : cache.state.pool0.liquidity;
 490 |     |             if (liquidityDelta > 0) cache.liquidity += liquidityDelta;
 491 |     |         }
 492 |     |         if (cache.cross)
 493 |     |             cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);
 494 |     | 
 495 |     |         return cache;
 496 |     |     }
 497 |     | 
 498 |     |     function _pass(
 499 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 500 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
 501 |     |         PoolsharkStructs.TickMap storage limitTickMap,
 502 |     |         PoolsharkStructs.SwapCache memory cache,
 503 |     |         PoolsharkStructs.QuoteParams memory params
 504 |     |     ) internal returns (
 505 |     |         PoolsharkStructs.SwapCache memory
 506 |     |     ) {
 507 |     |         if ((cache.crossStatus & RANGE_TICK) > 0) {
 508 |     |             if (!params.zeroForOne || (cache.amountLeft > 0 && params.priceLimit < cache.crossPrice)) {
 509 |     |                 int128 liquidityDelta = ticks[cache.crossTick].range.liquidityDelta;
 510 |     |                 if (params.zeroForOne) {
 511 |     |                     unchecked {
 512 |     |                         if (liquidityDelta >= 0){
 513 |     |                             // start of position boundary
 514 |     |                             EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(liquidityDelta), "TKS-1");
 515 |     |                             cache.state.pool.liquidity -= uint128(liquidityDelta);
 516 |     |                         } else {
 517 |     |                             // end of position boundary
 518 |     |                             EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(-liquidityDelta), "TKS-2");
 519 |     |                             cache.state.pool.liquidity += uint128(-liquidityDelta); 
 520 |     |                         }
 521 |     |                     }
 522 |     |                 } else {
 523 |     |                     unchecked {
 524 |     |                         if (liquidityDelta >= 0) {
 525 |     |                             // start of position boundary
 526 |     |                             EchidnaAssertions.assertLiquidityOverflows(cache.state.pool.liquidity, uint128(liquidityDelta), "TKS-3");
 527 |     |                             cache.state.pool.liquidity += uint128(liquidityDelta);
 528 |     |                         } else {
 529 |     |                             // end of position boundary
 530 |     |                             EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool.liquidity, uint128(-liquidityDelta), "TKS-4");
 531 |     |                             cache.state.pool.liquidity -= uint128(-liquidityDelta);
 532 |     |                         }
 533 |     |                     }
 534 |     |                 }
 535 |     |             } else {
 536 |     |                 cache.cross = false;
 537 |     |             }
 538 |     |         }
 539 |     |         if ((cache.crossStatus & LIMIT_TICK) > 0) {
 540 |     |             // cross limit tick
 541 |     |             int128 liquidityDelta = ticks[cache.crossTick].limit.liquidityDelta;
 542 |     | 
 543 |     |             if (liquidityDelta > 0) {
 544 |     |                 if (params.zeroForOne) {
 545 |     |                     EchidnaAssertions.assertLiquidityOverflows(cache.state.pool1.liquidity, uint128(liquidityDelta), "TKS-5");
 546 |     |                     cache.state.pool1.liquidity += uint128(liquidityDelta);
 547 |     |                 } else {
 548 |     |                     EchidnaAssertions.assertLiquidityOverflows(cache.state.pool0.liquidity, uint128(liquidityDelta), "TKS-6");
 549 |     |                     cache.state.pool0.liquidity += uint128(liquidityDelta);
 550 |     |                 }
 551 |     |             } 
 552 |     |             else {
 553 |     |                 if (params.zeroForOne) {
 554 |     |                     EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool1.liquidity, uint128(-liquidityDelta), "TKS-7");
 555 |     |                     cache.state.pool1.liquidity -= uint128(-liquidityDelta);
 556 |     |                 } else {
 557 |     |                     EchidnaAssertions.assertLiquidityUnderflows(cache.state.pool0.liquidity, uint128(-liquidityDelta), "TKS-8");
 558 |     |                     cache.state.pool0.liquidity -= uint128(-liquidityDelta);
 559 |     |                 }
 560 |     |             }
 561 |     |         }
 562 |     |         if ((cache.crossStatus & LIMIT_POOL) > 0) {
 563 |     |             // add limit pool
 564 |     |             uint128 liquidityDelta = params.zeroForOne ? cache.state.pool1.liquidity
 565 |     |                                                     : cache.state.pool0.liquidity;
 566 |     | 
 567 |     |             if (liquidityDelta > 0) {
 568 |     |                 cache.liquidity += liquidityDelta;
 569 |     |             }
 570 |     |         }
 571 |     | 
 572 |     |         if (cache.cross)
 573 |     |             cache = _iterate(ticks, rangeTickMap, limitTickMap, cache, params.zeroForOne, false);
 574 |     | 
 575 |     |         return cache;
 576 |     |     }
 577 |     | 
 578 |     |     function _iterate(
 579 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 580 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
 581 |     |         PoolsharkStructs.TickMap storage limitTickMap,
 582 |     |         PoolsharkStructs.SwapCache memory cache,
 583 |     |         bool zeroForOne,
 584 |     |         bool inclusive
 585 |     |     ) internal view returns (
 586 |     |         PoolsharkStructs.SwapCache memory 
 587 |     |     )    
 588 |     |     {
 589 |     |         if (zeroForOne) {
 590 |     |             if (cache.price > cache.state.pool1.price) {
 591 |     |                 // load range pool
 592 |     |                 cache.limitActive = false;
 593 |     |                 cache.liquidity = cache.state.pool.liquidity;
 594 |     |                 (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);
 595 |     |                 // next range tick vs. limit pool price
 596 |     |                 cache.crossTick = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);
 597 |     |                 cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);
 598 |     |                 if (cache.state.pool1.price >= cache.crossPrice) {
 599 |     |                     // cross into limit pool
 600 |     |                     cache.crossStatus = LIMIT_POOL;
 601 |     |                     if (cache.state.pool1.price == cache.crossPrice)
 602 |     |                         // also cross range tick
 603 |     |                         cache.crossStatus |= RANGE_TICK;
 604 |     |                     else {
 605 |     |                         cache.crossTick = cache.state.pool1.tickAtPrice;
 606 |     |                         cache.crossPrice = cache.state.pool1.price;
 607 |     |                     }
 608 |     |                 }
 609 |     |                 else {
 610 |     |                     // cross only range tick
 611 |     |                     cache.crossStatus = RANGE_TICK;
 612 |     |                 }
 613 |     |             } else {
 614 |     |                 // load range and limit pools
 615 |     |                 cache.limitActive = true;
 616 |     |                 cache.liquidity = cache.state.pool.liquidity + cache.state.pool1.liquidity;
 617 |     |                 (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);
 618 |     |                 int24 rangeTickAhead; int24 limitTickAhead;
 619 |     |                 if (cache.crossStatus == LIMIT_POOL &&
 620 |     |                         cache.crossTick % cache.constants.tickSpacing != 0 &&
 621 |     |                         TickMap.get(limitTickMap, cache.crossTick, cache.constants.tickSpacing))
 622 |     |                 {
 623 |     |                     limitTickAhead = cache.crossTick;
 624 |     |                     rangeTickAhead = cache.crossTick - cache.constants.tickSpacing / 2;
 625 |     |                 } else {
 626 |     |                     rangeTickAhead = TickMap.previous(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);
 627 |     |                     limitTickAhead = TickMap.previous(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);
 628 |     |                 }
 629 |     |                 // next range tick vs. next limit tick
 630 |     |                 
 631 |     |                 if (rangeTickAhead >= limitTickAhead) {
 632 |     |                     cache.crossTick = rangeTickAhead;
 633 |     |                     // cross range tick
 634 |     |                     cache.crossStatus = RANGE_TICK;
 635 |     |                     if (rangeTickAhead == limitTickAhead)
 636 |     |                         // also cross limit tick
 637 |     |                         cache.crossStatus |= LIMIT_TICK;
 638 |     |                     cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);
 639 |     |                 } else {
 640 |     |                     // only cross limit tick
 641 |     |                     cache.crossTick = limitTickAhead;
 642 |     |                     cache.crossStatus = LIMIT_TICK;
 643 |     |                     cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)
 644 |     |                                                                                  : ticks[cache.crossTick].limit.priceAt;
 645 |     |                 }
 646 |     |             }
 647 |     |         } else {
 648 |     |             if (cache.price < cache.state.pool0.price) {
 649 |     |                 // load range pool
 650 |     |                 cache.limitActive = false;
 651 |     |                 cache.liquidity = cache.state.pool.liquidity;
 652 |     |                 (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);
 653 |     |                 // next range tick vs. limit pool price
 654 |     |                 cache.crossTick = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);
 655 |     |                 cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);
 656 |     |                 if (cache.state.pool0.price <= cache.crossPrice) {
 657 |     |                     // cross into limit pool
 658 |     |                     cache.crossStatus = LIMIT_POOL;
 659 |     |                     if (cache.state.pool0.price == cache.crossPrice)
 660 |     |                         // also cross range tick
 661 |     |                         cache.crossStatus |= RANGE_TICK;
 662 |     |                     else {
 663 |     |                         cache.crossTick = cache.state.pool0.tickAtPrice;
 664 |     |                         cache.crossPrice = cache.state.pool0.price;
 665 |     |                     }
 666 |     |                 }
 667 |     |                 else {
 668 |     |                     // cross only range tick
 669 |     |                     cache.crossStatus = RANGE_TICK;
 670 |     |                 }
 671 |     |             } else {
 672 |     |                 // load range and limit pools
 673 |     |                 cache.limitActive = true;
 674 |     |                 cache.liquidity = cache.state.pool.liquidity + cache.state.pool0.liquidity;
 675 |     |                 (cache.crossTick,) = TickMap.roundHalf(cache.crossTick, cache.constants, cache.price);
 676 |     |                 // next range tick vs. next limit tick
 677 |     |                 int24 rangeTickAhead; int24 limitTickAhead;
 678 |     |                 if (cache.crossStatus == LIMIT_POOL &&
 679 |     |                         cache.crossTick % cache.constants.tickSpacing != 0 &&
 680 |     |                         TickMap.get(limitTickMap, cache.crossTick, cache.constants.tickSpacing))
 681 |     |                 {
 682 |     |                     limitTickAhead = cache.crossTick;
 683 |     |                     rangeTickAhead = cache.crossTick + cache.constants.tickSpacing / 2;
 684 |     |                 } else {
 685 |     |                     rangeTickAhead = TickMap.next(rangeTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);
 686 |     |                     limitTickAhead = TickMap.next(limitTickMap, cache.crossTick, cache.constants.tickSpacing, inclusive);
 687 |     |                 }
 688 |     |                 if (rangeTickAhead <= limitTickAhead) {
 689 |     |                     cache.crossTick = rangeTickAhead;
 690 |     |                     // cross range tick
 691 |     |                     cache.crossStatus |= RANGE_TICK;
 692 |     |                     if (rangeTickAhead == limitTickAhead)
 693 |     |                         // also cross limit tick
 694 |     |                         cache.crossStatus |= LIMIT_TICK;
 695 |     |                     cache.crossPrice = ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants);
 696 |     |                 } else {
 697 |     |                     // only cross limit tick
 698 |     |                     cache.crossTick = limitTickAhead;
 699 |     |                     cache.crossStatus |= LIMIT_TICK;
 700 |     |                     cache.crossPrice = ticks[cache.crossTick].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(cache.crossTick, cache.constants)
 701 |     |                                                                                  : ticks[cache.crossTick].limit.priceAt;
 702 |     |                 }
 703 |     |             }
 704 |     |         }
 705 |     |         return cache;
 706 |     |     }
 707 |     | }

/root/git/limit/contracts/libraries/limit/Claims.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import './EpochMap.sol';
   6 |     | import '../TickMap.sol';
   7 |     | import '../utils/String.sol';
   8 |     | import '../utils/SafeCast.sol';
   9 |     | 
  10 |     | library Claims {
  11 |     | 
  12 |     |     using SafeCast for uint256;
  13 |     | 
  14 |     |     // if claim tick searched, look max 512 spacings ahead
  15 |     |     uint256 public constant maxWordsSearched = 4;
  16 |     | 
  17 |     |     function validate(
  18 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  19 |     |         PoolsharkStructs.TickMap storage tickMap,
  20 |     |         PoolsharkStructs.BurnLimitParams memory params,
  21 |     |         LimitPoolStructs.BurnLimitCache memory cache
  22 |     |     ) internal view returns (
  23 |     |         PoolsharkStructs.BurnLimitParams memory,
  24 |     |         LimitPoolStructs.BurnLimitCache memory
  25 |     |     ) { 
  26 |     |         if (params.claim < cache.position.lower ||
  27 |     |                 params.claim > cache.position.upper)
  28 |     |             require (false, 'ClaimTick::OutsidePositionBounds()');
  29 |     |         
  30 |     |         if (params.claim % (cache.constants.tickSpacing / 2) != 0)
  31 |     |             require (false, 'ClaimTick::NotHalfTickOrFullTick()');
  32 |     | 
  33 |     |         uint32 claimTickEpoch = EpochMap.get(params.claim, params.zeroForOne, tickMap, cache.constants);
  34 |     | 
  35 |     |         if (params.zeroForOne){
  36 |     |             if (cache.pool.price >= cache.priceClaim) {
  37 |     |                 if (cache.pool.price <= cache.priceUpper) {
  38 |     |                     cache.priceClaim = cache.pool.price;
  39 |     |                     params.claim = TickMap.roundBack(cache.pool.tickAtPrice, cache.constants, params.zeroForOne, cache.priceClaim);
  40 |     |                 } else {
  41 |     |                     cache.priceClaim = cache.priceUpper;
  42 |     |                     params.claim = cache.position.upper;
  43 |     |                     cache.claimTick = ticks[cache.position.upper].limit;
  44 |     |                 }
  45 |     |                 claimTickEpoch = cache.state.epoch;
  46 |     |             } else if (params.claim % cache.constants.tickSpacing != 0) {
  47 |     |                 if (cache.claimTick.priceAt == 0) {
  48 |     |                     // if tick untouched since position creation revert
  49 |     |                     if (claimTickEpoch <= cache.position.epochLast)
  50 |     |                         require (false, 'ClaimTick::HalfTickClaimInvalid()'); 
  51 |     |                     else
  52 |     |                         // search ahead for the correct claim tick
  53 |     |                         cache.search = true;
  54 |     |                 }
  55 |     |                 cache.priceClaim = cache.claimTick.priceAt;
  56 |     |             }
  57 |     |         } else {
  58 |     |             if (cache.pool.price <= cache.priceClaim) {
  59 |     |                 if (cache.pool.price >= cache.priceLower) {
  60 |     |                     cache.priceClaim = cache.pool.price;
  61 |     |                     params.claim = TickMap.roundBack(cache.pool.tickAtPrice, cache.constants, params.zeroForOne, cache.priceClaim);
  62 |     |                 } else {
  63 |     |                     cache.priceClaim = cache.priceLower;
  64 |     |                     params.claim = cache.position.lower;
  65 |     |                     cache.claimTick = ticks[cache.position.upper].limit;
  66 |     |                 }
  67 |     |                 claimTickEpoch = cache.state.epoch;
  68 |     |             } else if (params.claim % cache.constants.tickSpacing != 0) {
  69 |     |                 if (cache.claimTick.priceAt == 0) {
  70 |     |                     if (claimTickEpoch <= cache.position.epochLast)
  71 |     |                         require (false, 'ClaimTick::HalfTickClaimInvalid()'); 
  72 |     |                     else
  73 |     |                         // search ahead for the correct claim tick
  74 |     |                         cache.search = true;
  75 |     |                 }
  76 |     |                 cache.priceClaim = cache.claimTick.priceAt;
  77 |     |             }
  78 |     |         }
  79 |     | 
  80 |     |         if (params.claim == (params.zeroForOne ? cache.position.upper : cache.position.lower)) {
  81 |     |             // check if final tick crossed
  82 |     |             cache.liquidityBurned = 0;
  83 |     |             if (claimTickEpoch <= cache.position.epochLast)
  84 |     |                 // nothing to search
  85 |     |                 require (false, 'ClaimTick::FinalTickNotCrossedYet()');
  86 |     |         } else if (cache.liquidityBurned > 0) {
  87 |     |             /// @dev - partway claim is valid as long as liquidity is not being removed
  88 |     |             if (params.zeroForOne) {
  89 |     |                 // check final tick first
  90 |     |                 uint32 endTickEpoch = EpochMap.get(cache.position.upper, params.zeroForOne, tickMap, cache.constants);
  91 |     |                 if (endTickEpoch > cache.position.epochLast) {
  92 |     |                     // final tick crossed
  93 |     |                     params.claim = cache.position.upper;
  94 |     |                     cache.priceClaim = cache.priceUpper;
  95 |     |                     cache.claimTick = ticks[cache.position.upper].limit;
  96 |     |                     cache.liquidityBurned = 0;
  97 |     |                 } else {
  98 |     |                     // check claim tick passed is valid
  99 |     |                     int24 claimTickNext = TickMap.next(tickMap, params.claim, cache.constants.tickSpacing, false);
 100 |     |                     uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, cache.constants);
 101 |     |                     if (claimTickNextEpoch > cache.position.epochLast) {
 102 |     |                         ///@dev - next tick in range should not have been crossed
 103 |     |                         // require (false, 'ClaimTick::NextTickAlreadyCrossed()');
 104 |     |                         cache.search = true;
 105 |     |                     }
 106 |     |                 }
 107 |     |             } else {
 108 |     |                 // check final tick first
 109 |     |                 uint32 endTickEpoch = EpochMap.get(cache.position.lower, params.zeroForOne, tickMap, cache.constants);
 110 |     |                 if (endTickEpoch > cache.position.epochLast) {
 111 |     |                     // final tick crossed
 112 |     |                     params.claim = cache.position.lower;
 113 |     |                     cache.priceClaim = cache.priceLower;
 114 |     |                     cache.claimTick = ticks[cache.position.lower].limit;
 115 |     |                     cache.liquidityBurned = 0;
 116 |     |                 } else {
 117 |     |                     // check claim tick passed is valid
 118 |     |                     int24 claimTickNext = TickMap.previous(tickMap, params.claim, cache.constants.tickSpacing, false);
 119 |     |                     uint32 claimTickNextEpoch = EpochMap.get(claimTickNext, params.zeroForOne, tickMap, cache.constants);
 120 |     |                     if (claimTickNextEpoch > cache.position.epochLast) {
 121 |     |                         ///@dev - next tick in range should not have been crossed
 122 |     |                         // require (false, 'ClaimTick::NextTickAlreadyCrossed()');
 123 |     |                         cache.search = true;
 124 |     |                     }
 125 |     |                 }
 126 |     |             }
 127 |     |         }
 128 |     | 
 129 |     |         if (cache.search) {
 130 |     |             (params, cache, claimTickEpoch) = search(ticks, tickMap, params, cache);
 131 |     |         }
 132 |     | 
 133 |     |         /// @dev - start tick does not overwrite position and final tick clears position
 134 |     |         if (params.claim != cache.position.upper && params.claim != cache.position.lower) {
 135 |     |             // check epochLast on claim tick
 136 |     |             if (claimTickEpoch <= cache.position.epochLast)
 137 |     |                 require (false, 'ClaimTick::TickNotCrossed()');
 138 |     |         }
 139 |     | 
 140 |     |         return (params, cache);
 141 |     |     }
 142 |     | 
 143 |     |     function getDeltas(
 144 |     |         PoolsharkStructs.BurnLimitParams memory params,
 145 |     |         LimitPoolStructs.BurnLimitCache memory cache,
 146 |     |         PoolsharkStructs.LimitImmutables memory constants
 147 |     |     ) internal pure returns (
 148 |     |         LimitPoolStructs.BurnLimitCache memory
 149 |     |     ) {
 150 |     |         // if half tick priceAt > 0 add amountOut to amountOutClaimed
 151 |     |         // set claimPriceLast if zero
 152 |     |         if (!cache.position.crossedInto) {
 153 |     |             cache.position.crossedInto = true;
 154 |     |         }
 155 |     |         LimitPoolStructs.GetDeltasLocals memory locals;
 156 |     | 
 157 |     |         if (params.claim % constants.tickSpacing != 0)
 158 |     |             // this should pass price at the claim tick
 159 |     |             locals.previousFullTick = TickMap.roundBack(params.claim, constants, params.zeroForOne, ConstantProduct.getPriceAtTick(params.claim, constants));
 160 |     |         else
 161 |     |             locals.previousFullTick = params.claim;
 162 |     |         locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);
 163 |     |         if (params.zeroForOne ? locals.previousFullTick > cache.position.lower
 164 |     |                               : locals.previousFullTick < cache.position.upper) {
 165 |     |             
 166 |     |             // claim amounts up to latest full tick crossed
 167 |     |             cache.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.position.liquidity, cache.priceLower, locals.pricePrevious, false)
 168 |     |                                                         : ConstantProduct.getDx(cache.position.liquidity, locals.pricePrevious, cache.priceUpper, false));
 169 |     |         }
 170 |     |         if (cache.liquidityBurned > 0) {
 171 |     |            // if tick hasn't been set back calculate amountIn
 172 |     |             if (params.zeroForOne ? cache.priceClaim > locals.pricePrevious
 173 |     |                                   : cache.priceClaim < locals.pricePrevious) {
 174 |     |                 // allow partial tick claim if removing liquidity
 175 |     |                 cache.amountIn += uint128(params.zeroForOne ? ConstantProduct.getDy(cache.liquidityBurned, locals.pricePrevious, cache.priceClaim, false)
 176 |     |                                                             : ConstantProduct.getDx(cache.liquidityBurned, cache.priceClaim, locals.pricePrevious, false));
 177 |     |             }
 178 |     |             // use priceClaim if tick hasn't been set back
 179 |     |             // else use claimPriceLast to calculate amountOut
 180 |     |             if (params.claim != (params.zeroForOne ? cache.position.upper : cache.position.lower)) {
 181 |     |                 cache.amountOut += uint128(params.zeroForOne ? ConstantProduct.getDx(cache.liquidityBurned, cache.priceClaim, cache.priceUpper, false)
 182 |     |                                                              : ConstantProduct.getDy(cache.liquidityBurned, cache.priceLower, cache.priceClaim, false));
 183 |     |             }
 184 |     |         }
 185 |     |         // take protocol fee if needed
 186 |     |         if (cache.pool.protocolFillFee > 0 && cache.amountIn > 0) {
 187 |     |             uint128 protocolFeeAmount = OverflowMath.mulDiv(cache.amountIn, cache.pool.protocolFillFee, 1e4).toUint128();
 188 |     |             cache.amountIn -= protocolFeeAmount;
 189 |     |             cache.pool.protocolFees += protocolFeeAmount;
 190 |     |         }
 191 |     |         return cache;
 192 |     |     }
 193 |     | 
 194 |     |     function search(
 195 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 196 |     |         PoolsharkStructs.TickMap storage tickMap,
 197 |     |         PoolsharkStructs.BurnLimitParams memory params,
 198 |     |         LimitPoolStructs.BurnLimitCache memory cache
 199 |     |     ) internal view returns (
 200 |     |         PoolsharkStructs.BurnLimitParams memory,
 201 |     |         LimitPoolStructs.BurnLimitCache memory,
 202 |     |         uint32 claimTickEpoch
 203 |     |     ) {
 204 |     |         LimitPoolStructs.SearchLocals memory locals;
 205 |     | 
 206 |     |         locals.ticksFound = new int24[](256);
 207 |     |         locals.searchTick = params.claim;
 208 |     |         if (params.zeroForOne) {
 209 |     |             for (uint i=0; i < maxWordsSearched;) {
 210 |     |                 (locals.ticksFound, locals.ticksIncluded, locals.searchTick) = TickMap.nextTicksWithinWord(
 211 |     |                     tickMap,
 212 |     |                     locals.searchTick,
 213 |     |                     cache.constants.tickSpacing,
 214 |     |                     cache.position.upper,
 215 |     |                     locals.ticksFound,
 216 |     |                     locals.ticksIncluded
 217 |     |                 );
 218 |     |                 // add start of next word if tick exists and is within range
 219 |     |                 if (locals.searchTick < cache.position.upper && TickMap.get(tickMap, locals.searchTick, cache.constants.tickSpacing)) {
 220 |     |                     locals.ticksFound[locals.ticksIncluded] = locals.searchTick;
 221 |     |                     unchecked {
 222 |     |                         ++locals.ticksIncluded;
 223 |     |                     }
 224 |     |                 }
 225 |     |                 // if we reached the final tick break the loop
 226 |     |                 if (locals.ticksIncluded > 0 && 
 227 |     |                         locals.searchTick >= cache.position.upper) {
 228 |     |                     break;
 229 |     |                 }
 230 |     |                 unchecked {
 231 |     |                     ++i;
 232 |     |                 }
 233 |     |             }
 234 |     |         } else {
 235 |     |             for (int i=0; i<2;) {
 236 |     |                 (locals.ticksFound, locals.ticksIncluded, locals.searchTick) = TickMap.previousTicksWithinWord(
 237 |     |                     tickMap,
 238 |     |                     locals.searchTick,
 239 |     |                     cache.constants.tickSpacing,
 240 |     |                     cache.position.lower,
 241 |     |                     locals.ticksFound,
 242 |     |                     locals.ticksIncluded
 243 |     |                 );
 244 |     |                 // add start of next word if tick exists and is within range
 245 |     |                 if (locals.searchTick > cache.position.lower && TickMap.get(tickMap, locals.searchTick, cache.constants.tickSpacing)) {
 246 |     |                     locals.ticksFound[locals.ticksIncluded] = locals.searchTick;
 247 |     |                     unchecked {
 248 |     |                         ++locals.ticksIncluded;
 249 |     |                     }
 250 |     |                 }
 251 |     |                 // if we reached the final tick break the loop
 252 |     |                 if (locals.ticksIncluded > 0 && 
 253 |     |                         locals.searchTick <= cache.position.lower) {
 254 |     |                     break;
 255 |     |                 }
 256 |     |                 unchecked {
 257 |     |                     ++i;
 258 |     |                 }
 259 |     |             } 
 260 |     |         }
 261 |     | 
 262 |     |         // set initial endIdx
 263 |     |         if (locals.ticksIncluded > 0) {
 264 |     |             locals.endIdx = locals.ticksIncluded - 1;
 265 |     |         } else {
 266 |     |             require(false, "ClaimTick::NoTicksFoundViaSearch()");
 267 |     |         }
 268 |     | 
 269 |     |         while (locals.startIdx <= locals.endIdx) {
 270 |     |             // set idx at middle of start & end
 271 |     |             locals.searchIdx = (locals.endIdx - locals.startIdx) / 2 + locals.startIdx;
 272 |     |             
 273 |     |             // set ticks
 274 |     |             locals.searchTick = locals.ticksFound[locals.searchIdx];
 275 |     |             if (locals.searchIdx + 1 < locals.ticksIncluded) {
 276 |     |                 // tick ahead in array
 277 |     |                 locals.searchTickAhead = locals.ticksFound[locals.searchIdx + 1];
 278 |     |             } else {
 279 |     |                 // tick ahead in storage
 280 |     |                 locals.searchTickAhead = params.zeroForOne ? TickMap.next(tickMap, locals.searchTick, cache.constants.tickSpacing, false)
 281 |     |                                                            : TickMap.previous(tickMap, locals.searchTick, cache.constants.tickSpacing, false);
 282 |     |             }
 283 |     | 
 284 |     |             // set epochs
 285 |     |             locals.claimTickEpoch = EpochMap.get(locals.searchTick, params.zeroForOne, tickMap, cache.constants);
 286 |     |             locals.claimTickAheadEpoch = EpochMap.get(locals.searchTickAhead, params.zeroForOne, tickMap, cache.constants);
 287 |     |             
 288 |     |             // check epochs
 289 |     |             if (locals.claimTickEpoch > cache.position.epochLast) {
 290 |     |                 if (locals.claimTickAheadEpoch <= cache.position.epochLast) {
 291 |     |                     // correct claim tick
 292 |     |                     break;
 293 |     |                 } else {
 294 |     |                     // search higher
 295 |     |                     locals.startIdx = locals.searchIdx + 1;
 296 |     |                 }
 297 |     |             } else if (locals.searchIdx > 0) {
 298 |     |                 // search lower
 299 |     |                 locals.endIdx = locals.searchIdx - 1;
 300 |     |             } else {
 301 |     |                 // 0 index hit; end of search
 302 |     |                 break;
 303 |     |             }
 304 |     |         }
 305 |     | 
 306 |     |         // final check on valid claim tick
 307 |     |         if (locals.claimTickEpoch <= cache.position.epochLast ||
 308 |     |                 locals.claimTickAheadEpoch > cache.position.epochLast) {
 309 |     |             require(false, "ClaimTick::NotFoundViaSearch()");
 310 |     |         }
 311 |     |         
 312 |     |         cache.claimTick = ticks[locals.searchTick].limit;
 313 |     |         if ((locals.searchTick % cache.constants.tickSpacing) == 0)
 314 |     |             cache.priceClaim = ConstantProduct.getPriceAtTick(locals.searchTick, cache.constants);
 315 |     |         else {
 316 |     |             cache.priceClaim = cache.claimTick.priceAt;
 317 |     |         }
 318 |     |         if (cache.liquidityBurned == 0)
 319 |     |             params.claim = TickMap.roundBack(locals.searchTick, cache.constants, params.zeroForOne, cache.priceClaim);
 320 |     |         else
 321 |     |             params.claim = locals.searchTick;
 322 |     | 
 323 |     |         return (params, cache, locals.claimTickEpoch);
 324 |     |     }
 325 |     | }

/root/git/limit/contracts/libraries/limit/EpochMap.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../math/ConstantProduct.sol';
   5 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   6 |     | 
   7 |     | library EpochMap {
   8 |     |     event SyncLimitTick(
   9 |     |         uint32 epoch,
  10 |     |         int24 tick,
  11 |     |         bool zeroForOne
  12 |     |     );
  13 |     | 
  14 |     |     function set(
  15 |     |         int24  tick,
  16 |     |         bool zeroForOne,
  17 |     |         uint256 epoch,
  18 |     |         PoolsharkStructs.TickMap storage tickMap,
  19 |     |         PoolsharkStructs.LimitImmutables memory constants
  20 |     |     ) internal {
  21 |     |         (
  22 |     |             uint256 tickIndex,
  23 |     |             uint256 wordIndex,
  24 |     |             uint256 blockIndex,
  25 |     |             uint256 volumeIndex
  26 |     |         ) = getIndices(tick, constants);
  27 |     |         // assert epoch isn't bigger than max uint32
  28 |     |         uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]
  29 |     |                                         : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];
  30 |     |         // clear previous value
  31 |     |         epochValue &=  ~(((1 << 9) - 1) << ((tickIndex & 0x7) * 32));
  32 |     |         // add new value to word
  33 |     |         epochValue |= epoch << ((tickIndex & 0x7) * 32);
  34 |     |         // store word in map
  35 |     |         zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex] = epochValue
  36 |     |                    : tickMap.epochs1[volumeIndex][blockIndex][wordIndex] = epochValue;
  37 |     | 
  38 |     |         emit SyncLimitTick(uint32(epoch), tick, zeroForOne);
  39 |     |     }
  40 |     | 
  41 |     |     function get(
  42 |     |         int24 tick,
  43 |     |         bool zeroForOne,
  44 |     |         PoolsharkStructs.TickMap storage tickMap,
  45 |     |         PoolsharkStructs.LimitImmutables memory constants
  46 |     |     ) internal view returns (
  47 |     |         uint32 epoch
  48 |     |     ) {
  49 |     |         (
  50 |     |             uint256 tickIndex,
  51 |     |             uint256 wordIndex,
  52 |     |             uint256 blockIndex,
  53 |     |             uint256 volumeIndex
  54 |     |         ) = getIndices(tick, constants);
  55 |     | 
  56 |     |         uint256 epochValue = zeroForOne ? tickMap.epochs0[volumeIndex][blockIndex][wordIndex]
  57 |     |                                         : tickMap.epochs1[volumeIndex][blockIndex][wordIndex];
  58 |     |         // right shift so first 8 bits are epoch value
  59 |     |         epochValue >>= ((tickIndex & 0x7) * 32);
  60 |     |         // clear other bits
  61 |     |         epochValue &= ((1 << 32) - 1);
  62 |     |         return uint32(epochValue);
  63 |     |     }
  64 |     | 
  65 |     |     function getIndices(
  66 |     |         int24 tick,
  67 |     |         PoolsharkStructs.LimitImmutables memory constants
  68 |     |     ) internal pure returns (
  69 |     |             uint256 tickIndex,
  70 |     |             uint256 wordIndex,
  71 |     |             uint256 blockIndex,
  72 |     |             uint256 volumeIndex
  73 |     |         )
  74 |     |     {
  75 |     |         unchecked {
  76 |     |             if (tick > ConstantProduct.maxTick(constants.tickSpacing)) require (false, 'TickIndexOverflow()');
  77 |     |             if (tick < ConstantProduct.minTick(constants.tickSpacing)) require (false, 'TickIndexUnderflow()');
  78 |     |             if (tick % (constants.tickSpacing / 2) != 0) {
  79 |     |                 require (false, 'TickIndexInvalid()');
  80 |     |             } 
  81 |     |             tickIndex = uint256(int256((_round(tick, constants.tickSpacing / 2) 
  82 |     |                                         - _round(ConstantProduct.MIN_TICK, constants.tickSpacing / 2)) 
  83 |     |                                         / (constants.tickSpacing / 2)));
  84 |     |             wordIndex = tickIndex >> 3;        // 2^3 epochs per word
  85 |     |             blockIndex = tickIndex >> 11;      // 2^8 words per block
  86 |     |             volumeIndex = tickIndex >> 19;     // 2^8 blocks per volume
  87 |     |             if (blockIndex > 2046) require (false, 'BlockIndexOverflow()');
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     function _round(
  92 |     |         int24 tick,
  93 |     |         int24 tickSpacing
  94 |     |     ) internal pure returns (
  95 |     |         int24 roundedTick
  96 |     |     ) {
  97 |     |         return tick / tickSpacing * tickSpacing;
  98 |     |     }
  99 |     | }
 100 |     | 

/root/git/limit/contracts/libraries/limit/LimitPositions.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './LimitTicks.sol';
   5 |     | import '../../interfaces/IPositionERC1155.sol';
   6 |     | import '../../interfaces/structs/RangePoolStructs.sol';
   7 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   8 |     | import '../math/OverflowMath.sol';
   9 |     | import './Claims.sol';
  10 |     | import './EpochMap.sol';
  11 |     | import '../utils/SafeCast.sol';
  12 |     | import '../Ticks.sol';
  13 |     | import '../../test/echidna/EchidnaAssertions.sol';
  14 |     | 
  15 |     | /// @notice Position management library for ranged liquidity.
  16 |     | /// @notice Position management library for ranged liquidity.
  17 |     | library LimitPositions {
  18 |     |     using SafeCast for uint256;
  19 |     | 
  20 |     |     event BurnLimit(
  21 |     |         address indexed to,
  22 |     |         uint32 positionId,
  23 |     |         int24 lower,
  24 |     |         int24 upper,
  25 |     |         int24 oldClaim,
  26 |     |         int24 newClaim,
  27 |     |         bool zeroForOne,
  28 |     |         uint128 liquidityBurned,
  29 |     |         uint128 tokenInClaimed,
  30 |     |         uint128 tokenOutBurned
  31 |     |     );
  32 |     | 
  33 |     |     function resize(
  34 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  35 |     |         RangePoolStructs.Sample[65535] storage samples,
  36 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
  37 |     |         PoolsharkStructs.TickMap storage limitTickMap,
  38 |     |         PoolsharkStructs.MintLimitParams memory params,
  39 |     |         LimitPoolStructs.MintLimitCache memory cache
  40 |     |     ) internal returns (
  41 |     |         PoolsharkStructs.MintLimitParams memory,
  42 |     |         LimitPoolStructs.MintLimitCache memory
  43 |     |     )
  44 |     |     {
  45 |     |         cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
  46 |     |         cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
  47 |     |         cache.mintSize = uint256(params.mintPercent) * uint256(params.amount) / 1e28;
  48 |     | 
  49 |     |         // calculate L constant
  50 |     |         cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
  51 |     |             cache.priceLower,
  52 |     |             cache.priceUpper,
  53 |     |             params.zeroForOne ? cache.priceLower : cache.priceUpper,
  54 |     |             params.zeroForOne ? 0 : uint256(params.amount),
  55 |     |             params.zeroForOne ? uint256(params.amount) : 0
  56 |     |         );
  57 |     | 
  58 |     |         if (cache.liquidityMinted == 0) require (false, 'NoLiquidityBeingAdded()');
  59 |     |         // calculate price limit by using half of input
  60 |     |         {
  61 |     |             cache.priceLimit = params.zeroForOne ? ConstantProduct.getNewPrice(cache.priceUpper, cache.liquidityMinted, params.amount / 2, true, true)
  62 |     |                                                  : ConstantProduct.getNewPrice(cache.priceLower, cache.liquidityMinted, params.amount / 2, false, true);
  63 |     |             if (cache.priceLimit == 0) require (false, 'PriceLimitZero()');
  64 |     |             // get tick at price
  65 |     |             cache.tickLimit = ConstantProduct.getTickAtPrice(cache.priceLimit.toUint160(), cache.constants);
  66 |     |             // round to nearest tick spacing
  67 |     |             cache.priceLimit = ConstantProduct.getPriceAtTick(cache.tickLimit, cache.constants);
  68 |     |         }
  69 |     | 
  70 |     |         PoolsharkStructs.SwapCache memory swapCache;
  71 |     |         swapCache.state = cache.state;
  72 |     |         swapCache.constants = cache.constants;
  73 |     |         swapCache.price = cache.state.pool.price;
  74 |     | 
  75 |     |         // swap zero if no liquidity near market price
  76 |     |         if (cache.state.pool.liquidity == 0 && 
  77 |     |             (params.zeroForOne ? swapCache.price > cache.priceLower
  78 |     |                                : swapCache.price < cache.priceUpper)) {
  79 |     |             swapCache = Ticks.swap(
  80 |     |                 ticks,
  81 |     |                 samples,
  82 |     |                 rangeTickMap,
  83 |     |                 limitTickMap,
  84 |     |                 PoolsharkStructs.SwapParams({
  85 |     |                     to: params.to,
  86 |     |                     priceLimit: (params.zeroForOne ? cache.priceLower 
  87 |     |                                                    : cache.priceUpper).toUint160(),
  88 |     |                     amount: 0,
  89 |     |                     exactIn: true,
  90 |     |                     zeroForOne: params.zeroForOne,
  91 |     |                     callbackData: abi.encodePacked(bytes1(0x0))
  92 |     |                 }),
  93 |     |                 swapCache
  94 |     |             );
  95 |     |         }
  96 |     | 
  97 |     |         // only swap if priceLimit is beyond current pool price
  98 |     |         if (params.zeroForOne ? cache.priceLimit < swapCache.price
  99 |     |                               : cache.priceLimit > swapCache.price) {
 100 |     |             // swap and save the pool state
 101 |     |             swapCache = Ticks.swap(
 102 |     |                 ticks,
 103 |     |                 samples,
 104 |     |                 rangeTickMap,
 105 |     |                 limitTickMap,
 106 |     |                 PoolsharkStructs.SwapParams({
 107 |     |                     to: params.to,
 108 |     |                     priceLimit: cache.priceLimit.toUint160(),
 109 |     |                     amount: params.amount,
 110 |     |                     exactIn: true,
 111 |     |                     zeroForOne: params.zeroForOne,
 112 |     |                     callbackData: abi.encodePacked(bytes1(0x0))
 113 |     |                 }),
 114 |     |                 swapCache
 115 |     |             );
 116 |     |             // subtract from remaining input amount
 117 |     |             params.amount -= uint128(swapCache.input);
 118 |     | 
 119 |     |         }
 120 |     |         // save to cache
 121 |     |         cache.swapCache = swapCache;
 122 |     |         cache.state = swapCache.state;
 123 |     | 
 124 |     |         if (params.amount < cache.mintSize) params.amount = 0;
 125 |     |         // move start tick based on amount filled in swap
 126 |     |         if ((params.amount > 0 && swapCache.input > 0) ||
 127 |     |             (params.zeroForOne ? cache.priceLower < swapCache.price
 128 |     |                                : cache.priceUpper > swapCache.price)
 129 |     |         ) {
 130 |     |             // move the tick limit based on pool.tickAtPrice
 131 |     |             if (params.zeroForOne ? cache.priceLower < swapCache.price
 132 |     |                                   : cache.priceUpper > swapCache.price) {
 133 |     |                 cache.tickLimit = swapCache.state.pool.tickAtPrice;
 134 |     |             }
 135 |     |             // round ahead tickLimit to avoid crossing epochs
 136 |     |             cache.tickLimit = TickMap.roundAhead(cache.tickLimit, cache.constants, params.zeroForOne, swapCache.price);
 137 |     |             if (params.zeroForOne) {
 138 |     |                 if (cache.priceLower < swapCache.price) {
 139 |     |                     // if rounding goes past limit trim position
 140 |     |                     /// @dev - if swap didn't go to limit user would be 100% filled
 141 |     |                     params.lower = cache.tickLimit;
 142 |     |                     cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 143 |     |                 }
 144 |     |                 if (params.lower >= params.upper && 
 145 |     |                     params.lower < ConstantProduct.maxTick(cache.constants.tickSpacing) - cache.constants.tickSpacing
 146 |     |                 ) {
 147 |     |                     params.upper = params.lower + cache.constants.tickSpacing;
 148 |     |                 }
 149 |     |                 cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 150 |     |             } else {
 151 |     |                 if (cache.priceUpper > swapCache.price) {
 152 |     |                     // if rounding goes past limit trim position
 153 |     |                     params.upper = cache.tickLimit;
 154 |     |                     cache.priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 155 |     |                 }
 156 |     |                 if (params.upper <= params.lower && 
 157 |     |                     params.lower > ConstantProduct.minTick(cache.constants.tickSpacing) + cache.constants.tickSpacing
 158 |     |                 ) {
 159 |     |                     params.lower = params.upper - cache.constants.tickSpacing;
 160 |     |                 }
 161 |     |                 cache.priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 162 |     |             }
 163 |     |             if (params.amount > 0 && params.lower < params.upper) {
 164 |     |                 cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
 165 |     |                     cache.priceLower,
 166 |     |                     cache.priceUpper,
 167 |     |                     params.zeroForOne ? cache.priceLower : cache.priceUpper,
 168 |     |                     params.zeroForOne ? 0 : uint256(params.amount),
 169 |     |                     params.zeroForOne ? uint256(params.amount) : 0
 170 |     |                 );
 171 |     |                  if (cache.liquidityMinted == 0) {
 172 |     |                     // skip minting
 173 |     |                     params.amount = 0;
 174 |     |                  }
 175 |     |             } else {
 176 |     |                 // skip minting
 177 |     |                 params.amount = 0;
 178 |     |                 cache.liquidityMinted = 0;
 179 |     |             }
 180 |     |             cache.state.epoch += 1;
 181 |     |         }
 182 |     | 
 183 |     |         if (params.lower >= params.upper) {
 184 |     |             // zero out amount transferred in
 185 |     |             params.amount = 0;
 186 |     |         }
 187 |     | 
 188 |     |         // liquidity overflow check
 189 |     |         if (cache.state.liquidityGlobal + cache.liquidityMinted > uint128(type(int128).max))
 190 |     |             require(false, 'LiquidityOverflow()');
 191 |     | 
 192 |     |         return (
 193 |     |             params,
 194 |     |             cache
 195 |     |         );
 196 |     |     }
 197 |     | 
 198 |     |     function add(
 199 |     |         LimitPoolStructs.MintLimitCache memory cache,
 200 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 201 |     |         PoolsharkStructs.TickMap storage tickMap,
 202 |     |         PoolsharkStructs.MintLimitParams memory params
 203 |     |     ) internal returns (
 204 |     |         PoolsharkStructs.LimitPoolState memory,
 205 |     |         LimitPoolStructs.LimitPosition memory
 206 |     |     ) {
 207 |     |         if (cache.liquidityMinted == 0) return (cache.pool, cache.position);
 208 |     | 
 209 |     |         if (cache.position.liquidity == 0) {
 210 |     |             cache.position.epochLast = cache.state.epoch;
 211 |     |             cache.state.epoch += 1; // increment for future swaps
 212 |     |             IPositionERC1155(cache.constants.poolToken).mint(
 213 |     |                 params.to,
 214 |     |                 params.positionId,
 215 |     |                 1,
 216 |     |                 cache.constants
 217 |     |             );
 218 |     |         } else {
 219 |     |             // safety check in case we somehow get here
 220 |     |             if (
 221 |     |                 params.zeroForOne
 222 |     |                     ? EpochMap.get(params.lower, params.zeroForOne, tickMap, cache.constants)
 223 |     |                             > cache.position.epochLast
 224 |     |                     : EpochMap.get(params.upper, params.zeroForOne, tickMap, cache.constants)
 225 |     |                             > cache.position.epochLast
 226 |     |             ) {
 227 |     |                 require (false, 'PositionAlreadyEntered()');
 228 |     |             }
 229 |     |             /// @auditor maybe this shouldn't be a revert but rather just not mint the position?
 230 |     |         }
 231 |     |         
 232 |     |         // add liquidity to ticks
 233 |     |         LimitTicks.insert(
 234 |     |             ticks,
 235 |     |             tickMap,
 236 |     |             cache,
 237 |     |             params
 238 |     |         );
 239 |     | 
 240 |     |         // update liquidity global
 241 |     |         cache.state.liquidityGlobal += uint128(cache.liquidityMinted);
 242 |     | 
 243 |     |         cache.position.liquidity += uint128(cache.liquidityMinted);
 244 |     | 
 245 |     |         return (cache.pool, cache.position);
 246 |     |     }
 247 |     | 
 248 |     |     function update(
 249 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 250 |     |         PoolsharkStructs.TickMap storage tickMap,
 251 |     |         LimitPoolStructs.BurnLimitCache memory cache,
 252 |     |         PoolsharkStructs.BurnLimitParams memory params
 253 |     |     ) internal returns (
 254 |     |         PoolsharkStructs.BurnLimitParams memory,
 255 |     |         LimitPoolStructs.BurnLimitCache memory
 256 |     |     )
 257 |     |     {
 258 |     |         (
 259 |     |             params,
 260 |     |             cache
 261 |     |         ) = _deltas(
 262 |     |             ticks,
 263 |     |             tickMap,
 264 |     |             params,
 265 |     |             cache
 266 |     |         );
 267 |     | 
 268 |     |         // update pool liquidity
 269 |     |         if (cache.priceClaim == cache.pool.price && cache.liquidityBurned > 0) {
 270 |     |             // handle pool.price at edge of range
 271 |     |             if (params.zeroForOne ? cache.priceClaim < cache.priceUpper
 272 |     |                                   : cache.priceClaim > cache.priceLower)
 273 |     |                 EchidnaAssertions.assertLiquidityUnderflows(cache.pool.liquidity, cache.liquidityBurned, "PLU-3");
 274 |     |                 cache.pool.liquidity -= cache.liquidityBurned;
 275 |     |         }
 276 |     | 
 277 |     |         if (cache.liquidityBurned > 0) {
 278 |     |             if (params.claim == (params.zeroForOne ? cache.position.upper : cache.position.lower)) {
 279 |     |                 // if claim is final tick no liquidity to remove
 280 |     |                 cache.removeLower = false;
 281 |     |                 cache.removeUpper = false;
 282 |     |             } else {
 283 |     |                 // else remove liquidity from final tick
 284 |     |                 params.zeroForOne ? cache.removeUpper = true 
 285 |     |                                   : cache.removeLower = true;
 286 |     |                 if (params.zeroForOne) {
 287 |     | 
 288 |     |                     if (params.claim == cache.position.lower && 
 289 |     |                         cache.pool.price < cache.priceLower
 290 |     |                     ) {
 291 |     |                         // full tick price was touched
 292 |     |                         cache.removeLower = true;
 293 |     |                     } else if (params.claim % cache.constants.tickSpacing != 0 && 
 294 |     |                                     cache.pool.price < cache.priceClaim)
 295 |     |                         // half tick was created
 296 |     |                         cache.removeLower = true;
 297 |     |                 } else {
 298 |     |                     if (params.claim == cache.position.upper &&
 299 |     |                         cache.pool.price > cache.priceUpper
 300 |     |                     )
 301 |     |                         // full tick price was touched
 302 |     |                         cache.removeUpper = true;
 303 |     |                     else if (params.claim % cache.constants.tickSpacing != 0 &&
 304 |     |                                     cache.pool.price > cache.priceClaim)
 305 |     |                         // half tick was created
 306 |     |                         cache.removeUpper = true;
 307 |     |                 }
 308 |     |             }
 309 |     |             LimitTicks.remove(
 310 |     |                 ticks,
 311 |     |                 tickMap,
 312 |     |                 params,
 313 |     |                 cache,
 314 |     |                 cache.constants
 315 |     |             );
 316 |     |             // update position liquidity
 317 |     |             cache.position.liquidity -= uint128(cache.liquidityBurned);
 318 |     |             // update global liquidity
 319 |     |             EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.liquidityBurned, "LGU-2");
 320 |     |             cache.state.liquidityGlobal -= cache.liquidityBurned;
 321 |     |         }
 322 |     | 
 323 |     |         // round back claim tick for storage
 324 |     |         if (params.claim % cache.constants.tickSpacing != 0) {
 325 |     |             cache.claim = params.claim;
 326 |     |             params.claim = TickMap.roundBack(params.claim, cache.constants, params.zeroForOne, cache.priceClaim);
 327 |     |         }
 328 |     | 
 329 |     |         // clear filled position
 330 |     |         if (params.zeroForOne ? params.claim == cache.position.upper
 331 |     |                               : params.claim == cache.position.lower) {
 332 |     |             EchidnaAssertions.assertLiquidityGlobalUnderflows(cache.state.liquidityGlobal, cache.position.liquidity, "LGU-3");
 333 |     |             cache.state.liquidityGlobal -= cache.position.liquidity;
 334 |     |             cache.position.liquidity = 0;
 335 |     |         }
 336 |     | 
 337 |     |         // clear position if empty
 338 |     |         if (cache.position.liquidity == 0) {
 339 |     |             cache.position.epochLast = 0;
 340 |     |             cache.position.crossedInto = false;
 341 |     |         }
 342 |     |         
 343 |     |         emit BurnLimit(
 344 |     |             params.to,
 345 |     |             params.positionId,
 346 |     |             cache.position.lower,
 347 |     |             cache.position.upper,
 348 |     |             cache.claim,
 349 |     |             params.claim,
 350 |     |             params.zeroForOne,
 351 |     |             cache.liquidityBurned,
 352 |     |             cache.amountIn,
 353 |     |             cache.amountOut
 354 |     |         );
 355 |     | 
 356 |     |         // save pool to state in memory
 357 |     |         if (params.zeroForOne) cache.state.pool0 = cache.pool;
 358 |     |         else cache.state.pool1 = cache.pool;
 359 |     | 
 360 |     |         return (params, cache);
 361 |     |     }
 362 |     | 
 363 |     |     function snapshot(
 364 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 365 |     |         PoolsharkStructs.TickMap storage tickMap,
 366 |     |         LimitPoolStructs.BurnLimitCache memory cache,
 367 |     |         PoolsharkStructs.BurnLimitParams memory params
 368 |     |     ) internal view returns (
 369 |     |         uint128 amountIn,
 370 |     |         uint128 amountOut
 371 |     |     ) {
 372 |     |         (
 373 |     |             params,
 374 |     |             cache
 375 |     |         ) = _deltas(
 376 |     |             ticks,
 377 |     |             tickMap,
 378 |     |             params,
 379 |     |             cache
 380 |     |         );
 381 |     | 
 382 |     |         return (cache.amountIn, cache.amountOut);
 383 |     |     }
 384 |     | 
 385 |     |     function _deltas(
 386 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 387 |     |         PoolsharkStructs.TickMap storage tickMap,
 388 |     |         PoolsharkStructs.BurnLimitParams memory params,
 389 |     |         LimitPoolStructs.BurnLimitCache memory cache
 390 |     |     ) internal view returns (
 391 |     |         PoolsharkStructs.BurnLimitParams memory,
 392 |     |         LimitPoolStructs.BurnLimitCache memory
 393 |     |     ) {
 394 |     |         cache = LimitPoolStructs.BurnLimitCache({
 395 |     |             state: cache.state,
 396 |     |             pool: params.zeroForOne ? cache.state.pool0 : cache.state.pool1,
 397 |     |             claimTick: ticks[params.claim].limit,
 398 |     |             position: cache.position,
 399 |     |             constants: cache.constants,
 400 |     |             priceLower: ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants),
 401 |     |             priceClaim: ticks[params.claim].limit.priceAt == 0 ? ConstantProduct.getPriceAtTick(params.claim, cache.constants)
 402 |     |                                                                : ticks[params.claim].limit.priceAt,
 403 |     |             priceUpper: ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants),
 404 |     |             liquidityBurned: _convert(cache.position.liquidity, params.burnPercent),
 405 |     |             amountIn: 0,
 406 |     |             amountOut: 0,
 407 |     |             claim: params.claim,
 408 |     |             removeLower: false,
 409 |     |             removeUpper: false,
 410 |     |             search: false
 411 |     |         });
 412 |     | 
 413 |     |         // check claim is valid
 414 |     |         (params, cache) = Claims.validate(
 415 |     |             ticks,
 416 |     |             tickMap,
 417 |     |             params,
 418 |     |             cache
 419 |     |         );
 420 |     | 
 421 |     |         // calculate position deltas
 422 |     |         cache = Claims.getDeltas(params, cache, cache.constants);
 423 |     | 
 424 |     |         return (params, cache);
 425 |     |     }
 426 |     | 
 427 |     |     function _convert(
 428 |     |         uint128 liquidity,
 429 |     |         uint128 percent
 430 |     |     ) internal pure returns (
 431 |     |         uint128
 432 |     |     ) {
 433 |     |         // convert percentage to liquidity amount
 434 |     |         if (percent > 1e38) percent = 1e38;
 435 |     |         if (liquidity == 0 && percent > 0) require (false, 'PositionNotFound()');
 436 |     |         return uint128(uint256(liquidity) * uint256(percent) / 1e38);
 437 |     |     }
 438 |     | }

/root/git/limit/contracts/libraries/limit/LimitTicks.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import '../../interfaces/limit/ILimitPoolFactory.sol';
   6 |     | import '../../interfaces/limit/ILimitPool.sol';
   7 |     | import '../math/ConstantProduct.sol';
   8 |     | import './LimitPositions.sol';
   9 |     | import '../math/OverflowMath.sol';
  10 |     | import '../TickMap.sol';
  11 |     | import './EpochMap.sol';
  12 |     | import '../Samples.sol';
  13 |     | import '../utils/SafeCast.sol';
  14 |     | 
  15 |     | /// @notice Tick management library for limit pools
  16 |     | library LimitTicks {
  17 |     | 
  18 |     |     using SafeCast for uint256;
  19 |     | 
  20 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  21 |     | 
  22 |     |     event SyncLimitLiquidity(
  23 |     |         uint128 liquidityAdded,
  24 |     |         int24 tick,
  25 |     |         bool zeroForOne
  26 |     |     );
  27 |     | 
  28 |     |     function validate(
  29 |     |         int24 lower,
  30 |     |         int24 upper,
  31 |     |         int24 tickSpacing
  32 |     |     ) internal pure {
  33 |     |         if (lower % tickSpacing != 0) require(false, 'InvalidLowerTick()');
  34 |     |         if (lower <= ConstantProduct.MIN_TICK) require(false, 'InvalidLowerTick()');
  35 |     |         if (upper % tickSpacing != 0) require(false, 'InvalidUpperTick()');
  36 |     |         if (upper >= ConstantProduct.MAX_TICK) require(false, 'InvalidUpperTick()');
  37 |     |         if (lower >= upper) require(false, 'InvalidPositionBounds()');
  38 |     |     }
  39 |     | 
  40 |     |     function insert(
  41 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  42 |     |         PoolsharkStructs.TickMap storage tickMap,
  43 |     |         LimitPoolStructs.MintLimitCache memory cache,
  44 |     |         PoolsharkStructs.MintLimitParams memory params
  45 |     |     ) internal {
  46 |     |         int256 liquidityMinted = int256(cache.liquidityMinted);
  47 |     | 
  48 |     |         // check if adding liquidity necessary
  49 |     |         if (!params.zeroForOne || cache.priceLower > cache.pool.price) {
  50 |     |             // sets bit in map
  51 |     |             if(!TickMap.set(tickMap, params.lower, cache.constants.tickSpacing)){
  52 |     |                 // inherit epoch 
  53 |     |                 int24 tickAhead;
  54 |     |                 if (params.zeroForOne) {
  55 |     |                     tickAhead  = TickMap.next(tickMap, params.lower, cache.constants.tickSpacing, false);
  56 |     |                 } else {
  57 |     |                     tickAhead  = TickMap.previous(tickMap, params.lower, cache.constants.tickSpacing, false);
  58 |     |                 }
  59 |     |                 uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);
  60 |     |                 EpochMap.set(params.lower, params.zeroForOne, epochAhead, tickMap, cache.constants);
  61 |     |             }
  62 |     |             PoolsharkStructs.LimitTick memory tickLower = ticks[params.lower].limit;
  63 |     |             if (params.zeroForOne) {
  64 |     |                 tickLower.liquidityDelta += int128(liquidityMinted);
  65 |     |             } else {
  66 |     |                 tickLower.liquidityDelta -= int128(liquidityMinted);
  67 |     |             }
  68 |     |             tickLower.liquidityAbsolute += cache.liquidityMinted.toUint128();
  69 |     |             ticks[params.lower].limit = tickLower;
  70 |     |         } else {
  71 |     |             /// @dev - i.e. if zeroForOne && cache.priceLower <= cache.pool.price
  72 |     |             cache.state.epoch += 1;
  73 |     |             // mark epoch on undercut tick
  74 |     |             EpochMap.set(params.lower, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);
  75 |     |         }
  76 |     | 
  77 |     |         if (params.zeroForOne || cache.priceUpper < cache.pool.price) {
  78 |     |             if(!TickMap.set(tickMap, params.upper, cache.constants.tickSpacing)) {
  79 |     |                 int24 tickAhead;
  80 |     |                 if (params.zeroForOne) {
  81 |     |                     tickAhead  = TickMap.next(tickMap, params.upper, cache.constants.tickSpacing, false);
  82 |     |                 } else {
  83 |     |                     tickAhead  = TickMap.previous(tickMap, params.upper, cache.constants.tickSpacing, false);
  84 |     |                 }
  85 |     |                 uint32 epochAhead = EpochMap.get(tickAhead, params.zeroForOne, tickMap, cache.constants);
  86 |     |                 EpochMap.set(params.upper, params.zeroForOne, epochAhead, tickMap, cache.constants);
  87 |     |             }
  88 |     |             PoolsharkStructs.LimitTick memory tickUpper = ticks[params.upper].limit;
  89 |     |             if (params.zeroForOne) {
  90 |     |                 tickUpper.liquidityDelta -= int128(liquidityMinted);
  91 |     |             } else {
  92 |     |                 tickUpper.liquidityDelta += int128(liquidityMinted);
  93 |     |             }
  94 |     |             tickUpper.liquidityAbsolute += cache.liquidityMinted.toUint128();
  95 |     |             ticks[params.upper].limit = tickUpper;
  96 |     |         } else {
  97 |     |             /// @dev - i.e. if !zeroForOne && cache.priceUpper >= cache.pool.price
  98 |     |             cache.state.epoch += 1;
  99 |     |             // mark epoch on undercut tick
 100 |     |             EpochMap.set(params.upper, params.zeroForOne, cache.state.epoch, tickMap, cache.constants);
 101 |     |         }
 102 |     |     }
 103 |     | 
 104 |     |     function insertSingle(
 105 |     |         PoolsharkStructs.MintLimitParams memory params,
 106 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 107 |     |         PoolsharkStructs.TickMap storage tickMap,
 108 |     |         LimitPoolStructs.MintLimitCache memory cache,
 109 |     |         PoolsharkStructs.LimitPoolState memory pool,
 110 |     |         PoolsharkStructs.LimitImmutables memory constants
 111 |     |     ) internal returns (
 112 |     |         PoolsharkStructs.LimitPoolState memory
 113 |     |     ){
 114 |     |         /// @auditor - would be smart to protect against the case of epochs crossing
 115 |     |         (
 116 |     |             int24 tickToSave,
 117 |     |             uint160 roundedPrice
 118 |     |         ) = TickMap.roundHalf(pool.tickAtPrice, constants, pool.price);
 119 |     |         // update tick to save
 120 |     |         LimitPoolStructs.LimitTick memory tick = ticks[tickToSave].limit;
 121 |     |         /// @auditor - tick.priceAt will be zero for tick % tickSpacing == 0
 122 |     |         if (tick.priceAt == 0) {
 123 |     |             if (pool.price != (params.zeroForOne ? cache.priceLower : cache.priceUpper)) {
 124 |     |                 TickMap.set(tickMap, tickToSave, constants.tickSpacing);
 125 |     |             }
 126 |     |             EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);
 127 |     |         }
 128 |     |         // skip if we are at the nearest full tick
 129 |     |         if(pool.price != roundedPrice) {
 130 |     |             // if empty just save the pool price
 131 |     |             if (tick.priceAt == 0) {
 132 |     |                 tick.priceAt = pool.price;
 133 |     |                 EchidnaAssertions.assertTickAtPriceDivisibleByTickSpacing(tickToSave, ticks[tickToSave].limit.priceAt, constants.tickSpacing);
 134 |     |             }
 135 |     |             else {
 136 |     |                 // we need to blend the two partial fills into a single tick
 137 |     |                 LimitPoolStructs.InsertSingleLocals memory locals;
 138 |     |                 if (params.zeroForOne) {
 139 |     |                     // price moves up so previousFullTick is lesser
 140 |     |                     locals.previousFullTick = tickToSave - constants.tickSpacing / 2;
 141 |     |                     locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);
 142 |     |                     // calculate amountOut filled across both partial fills
 143 |     |                     locals.amountOutExact = ConstantProduct.getDy(pool.liquidity, locals.pricePrevious, pool.price, false);
 144 |     |                     locals.amountOutExact += ConstantProduct.getDy(uint128(tick.liquidityDelta), locals.pricePrevious, tick.priceAt, false);
 145 |     |                     // add current pool liquidity to partial tick
 146 |     |                     uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);
 147 |     |                     // advance price based on combined fill
 148 |     |                     tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, false, true).toUint160();
 149 |     |                     // dx to the next tick is less than before the tick blend
 150 |     |                     EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);
 151 |     |                 } else {
 152 |     |                     // price moves down so previousFullTick is greater
 153 |     |                     locals.previousFullTick = tickToSave + constants.tickSpacing / 2;
 154 |     |                     locals.pricePrevious = ConstantProduct.getPriceAtTick(locals.previousFullTick, constants);
 155 |     |                     // calculate amountOut filled across both partial fills
 156 |     |                     locals.amountOutExact = ConstantProduct.getDx(pool.liquidity, pool.price, locals.pricePrevious, false);
 157 |     |                     locals.amountOutExact += ConstantProduct.getDx(uint128(tick.liquidityDelta), tick.priceAt, locals.pricePrevious, false);
 158 |     |                     // add current pool liquidity to partial tick
 159 |     |                     uint128 combinedLiquidity = pool.liquidity + uint128(tick.liquidityDelta);
 160 |     |                     // advance price based on combined fill
 161 |     |                     tick.priceAt = ConstantProduct.getNewPrice(uint256(locals.pricePrevious), combinedLiquidity, locals.amountOutExact, true, true).toUint160();
 162 |     |                     // mark epoch for second partial fill positions
 163 |     |                     EpochMap.set(tickToSave, params.zeroForOne, cache.state.epoch, tickMap, constants);
 164 |     |                 }
 165 |     |             }
 166 |     |         }
 167 |     |         // invariant => if we save liquidity to tick clear pool liquidity
 168 |     |         if ((tickToSave != (params.zeroForOne ? params.lower : params.upper))) {
 169 |     |             tick.liquidityDelta += int128(pool.liquidity);
 170 |     |             tick.liquidityAbsolute += pool.liquidity;
 171 |     |             emit SyncLimitLiquidity(pool.liquidity, tickToSave, params.zeroForOne);
 172 |     |             pool.liquidity = 0;
 173 |     |         }
 174 |     |         ticks[tickToSave].limit = tick;
 175 |     |         return pool;
 176 |     |     }
 177 |     | 
 178 |     |     function remove(
 179 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 180 |     |         PoolsharkStructs.TickMap storage tickMap,
 181 |     |         PoolsharkStructs.BurnLimitParams memory params,
 182 |     |         LimitPoolStructs.BurnLimitCache memory cache,
 183 |     |         PoolsharkStructs.LimitImmutables memory constants
 184 |     |     ) internal {
 185 |     |         // set ticks based on claim and zeroForOne
 186 |     |         int24 lower = params.zeroForOne ? params.claim : cache.position.lower;
 187 |     |         int24 upper = params.zeroForOne ? cache.position.upper : params.claim;
 188 |     |         {    
 189 |     |             PoolsharkStructs.LimitTick memory tickLower = ticks[lower].limit;
 190 |     |             
 191 |     |             if (cache.removeLower) {
 192 |     |                 if (params.zeroForOne) {
 193 |     |                     tickLower.liquidityDelta -= int128(cache.liquidityBurned);
 194 |     |                 } else {
 195 |     |                     tickLower.liquidityDelta += int128(cache.liquidityBurned);
 196 |     |                 }
 197 |     |                 EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, cache.liquidityBurned, 'TSL-1');
 198 |     |                 tickLower.liquidityAbsolute -= cache.liquidityBurned;
 199 |     |                 ticks[lower].limit = tickLower;
 200 |     |                 clear(ticks, constants, tickMap, lower);
 201 |     |             }
 202 |     |         }
 203 |     |         {
 204 |     |             PoolsharkStructs.LimitTick memory tickUpper = ticks[upper].limit;
 205 |     |             if (cache.removeUpper) {
 206 |     |                 if (params.zeroForOne) {
 207 |     |                     tickUpper.liquidityDelta += int128(cache.liquidityBurned);
 208 |     |                 } else {
 209 |     |                     tickUpper.liquidityDelta -= int128(cache.liquidityBurned);
 210 |     |                 }
 211 |     |                 EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickUpper.liquidityAbsolute, cache.liquidityBurned, 'TSL-2');
 212 |     |                 tickUpper.liquidityAbsolute -= cache.liquidityBurned;
 213 |     |                 ticks[upper].limit = tickUpper;
 214 |     |                 clear(ticks, constants, tickMap, upper);
 215 |     |             }
 216 |     |         }
 217 |     |     }
 218 |     | 
 219 |     |      function unlock(
 220 |     |         LimitPoolStructs.MintLimitCache memory cache,
 221 |     |         PoolsharkStructs.LimitPoolState memory pool,
 222 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 223 |     |         PoolsharkStructs.TickMap storage tickMap,
 224 |     |         bool zeroForOne
 225 |     |     ) internal returns (
 226 |     |         LimitPoolStructs.MintLimitCache memory,
 227 |     |         PoolsharkStructs.LimitPoolState memory
 228 |     |     )
 229 |     |     {
 230 |     |         if (pool.liquidity > 0) return (cache, pool);
 231 |     | 
 232 |     |         (int24 startTick,) = TickMap.roundHalf(pool.tickAtPrice, cache.constants, pool.price);
 233 |     | 
 234 |     |         if (zeroForOne) {
 235 |     |             pool.tickAtPrice = TickMap.next(tickMap, startTick, cache.constants.tickSpacing, true);
 236 |     |             if (pool.tickAtPrice < ConstantProduct.maxTick(cache.constants.tickSpacing)) {
 237 |     |                 EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);
 238 |     |             }
 239 |     |         } else {
 240 |     |             /// @dev - roundedUp true since liquidity could be equal to the current pool tickAtPrice
 241 |     |             pool.tickAtPrice = TickMap.previous(tickMap, startTick, cache.constants.tickSpacing, true);
 242 |     |             if (pool.tickAtPrice > ConstantProduct.minTick(cache.constants.tickSpacing)) {
 243 |     |                 EpochMap.set(pool.tickAtPrice, zeroForOne, cache.state.epoch, tickMap, cache.constants);
 244 |     |             }
 245 |     |         }
 246 |     | 
 247 |     |         // increment pool liquidity
 248 |     |         EchidnaAssertions.assertPositiveLiquidityOnUnlock(ticks[pool.tickAtPrice].limit.liquidityDelta);
 249 |     |         pool.liquidity += uint128(ticks[pool.tickAtPrice].limit.liquidityDelta);
 250 |     |         int24 tickToClear = pool.tickAtPrice;
 251 |     |         uint160 tickPriceAt = ticks[pool.tickAtPrice].limit.priceAt;
 252 |     | 
 253 |     |         if (tickPriceAt == 0) {
 254 |     |             // if full tick crossed
 255 |     |             pool.price = ConstantProduct.getPriceAtTick(pool.tickAtPrice, cache.constants);
 256 |     |         } else {
 257 |     |             // if half tick crossed
 258 |     |             pool.price = tickPriceAt;
 259 |     |             pool.tickAtPrice = ConstantProduct.getTickAtPrice(tickPriceAt, cache.constants);
 260 |     |         }
 261 |     | 
 262 |     |         // zero out tick
 263 |     |         ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);
 264 |     |         clear(ticks, cache.constants, tickMap, tickToClear);
 265 |     | 
 266 |     |         return (cache, pool);
 267 |     |     }
 268 |     | 
 269 |     |     function clear(
 270 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 271 |     |         PoolsharkStructs.LimitImmutables memory constants,
 272 |     |         PoolsharkStructs.TickMap storage tickMap,
 273 |     |         int24 tickToClear
 274 |     |     ) internal {
 275 |     |         if (_empty(ticks[tickToClear])) {
 276 |     |             if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &&
 277 |     |                 tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {
 278 |     |                 ticks[tickToClear].limit = PoolsharkStructs.LimitTick(0,0,0);
 279 |     |                 TickMap.unset(tickMap, tickToClear, constants.tickSpacing);
 280 |     |             }
 281 |     |         }
 282 |     |     }
 283 |     | 
 284 |     |     function _empty(
 285 |     |         LimitPoolStructs.Tick memory tick
 286 |     |     ) internal pure returns (
 287 |     |         bool
 288 |     |     ) {
 289 |     |         return tick.limit.liquidityAbsolute == 0;
 290 |     |     }
 291 |     | }
 292 |     | 

/root/git/limit/contracts/libraries/limit/pool/BurnLimitCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import '../../../interfaces/IPositionERC1155.sol';
   6 |     | import '../LimitPositions.sol';
   7 |     | import '../../utils/Collect.sol';
   8 |     | import '../../utils/PositionTokens.sol';
   9 |     | 
  10 |     | library BurnLimitCall {
  11 |     |     event BurnLimit(
  12 |     |         address indexed to,
  13 |     |         uint32 positionId,
  14 |     |         int24 lower,
  15 |     |         int24 upper,
  16 |     |         int24 oldClaim,
  17 |     |         int24 newClaim,
  18 |     |         bool zeroForOne,
  19 |     |         uint128 liquidityBurned,
  20 |     |         uint128 tokenInClaimed,
  21 |     |         uint128 tokenOutBurned
  22 |     |     );
  23 |     | 
  24 |     |     function perform(
  25 |     |         mapping(uint256 => LimitPoolStructs.LimitPosition)
  26 |     |             storage positions,
  27 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  28 |     |         PoolsharkStructs.TickMap storage tickMap,
  29 |     |         PoolsharkStructs.GlobalState storage globalState,
  30 |     |         PoolsharkStructs.BurnLimitParams memory params,
  31 |     |         LimitPoolStructs.BurnLimitCache memory cache
  32 |     |     ) internal {
  33 |     |         // check for invalid receiver
  34 |     |         if (params.to == address(0))
  35 |     |             require(false, 'CollectToZeroAddress()');
  36 |     | 
  37 |     |         // initialize cache
  38 |     |         cache.state = globalState;
  39 |     |         cache.position = positions[params.positionId];
  40 |     | 
  41 |     |         if (cache.position.liquidity == 0) 
  42 |     |             require(false, 'PositionNotFound()');
  43 |     |         if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
  44 |     |             require(false, 'PositionOwnerMismatch()');
  45 |     |         
  46 |     |         // update position
  47 |     |         (
  48 |     |             params,
  49 |     |             cache
  50 |     |         ) = LimitPositions.update(
  51 |     |             ticks,
  52 |     |             tickMap,
  53 |     |             cache,
  54 |     |             params
  55 |     |         );
  56 |     | 
  57 |     |         // save position before transfer
  58 |     |         if ((params.zeroForOne ? params.claim != cache.position.upper
  59 |     |                                : params.claim != cache.position.lower)) {
  60 |     |             if (cache.position.liquidity > 0) {
  61 |     |                 if (params.zeroForOne) {
  62 |     |                     cache.position.lower = params.claim;
  63 |     |                 } else {
  64 |     |                     cache.position.upper = params.claim;
  65 |     |                 }
  66 |     |                 positions[params.positionId] = cache.position;
  67 |     |             } else {
  68 |     |                 IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);
  69 |     |                 delete positions[params.positionId];
  70 |     |             }
  71 |     |         } else {
  72 |     |             IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);
  73 |     |             delete positions[params.positionId];
  74 |     |         }
  75 |     | 
  76 |     |         // save state before transfer call
  77 |     |         save(cache, globalState, params.zeroForOne);
  78 |     |         
  79 |     |         cache = Collect.burnLimit(
  80 |     |             cache,
  81 |     |             params
  82 |     |         );
  83 |     |     }
  84 |     | 
  85 |     |     function save(
  86 |     |         LimitPoolStructs.BurnLimitCache memory cache,
  87 |     |         PoolsharkStructs.GlobalState storage globalState,
  88 |     |         bool zeroForOne
  89 |     |     ) internal {
  90 |     |         globalState.epoch = cache.state.epoch;
  91 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
  92 |     |         if (zeroForOne) {
  93 |     |             globalState.pool = cache.state.pool;
  94 |     |             globalState.pool0 = cache.state.pool0;
  95 |     |         } else {
  96 |     |             globalState.pool = cache.state.pool;
  97 |     |             globalState.pool1 = cache.state.pool1;
  98 |     |         }
  99 |     |     }
 100 |     | }
 101 |     | 

/root/git/limit/contracts/libraries/limit/pool/MintLimitCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import '../../../interfaces/callbacks/ILimitPoolCallback.sol';
   6 |     | import '../../../interfaces/IERC20Minimal.sol';
   7 |     | import '../LimitPositions.sol';
   8 |     | import '../../utils/Collect.sol';
   9 |     | import '../../utils/PositionTokens.sol';
  10 |     | 
  11 |     | library MintLimitCall {
  12 |     |     event MintLimit(
  13 |     |         address indexed to,
  14 |     |         int24 lower,
  15 |     |         int24 upper,
  16 |     |         bool zeroForOne,
  17 |     |         uint32 positionId,
  18 |     |         uint32 epochLast,
  19 |     |         uint128 amountIn,
  20 |     |         uint128 liquidityMinted
  21 |     |     );
  22 |     | 
  23 |     |     event SyncLimitPool(
  24 |     |         uint160 price,
  25 |     |         uint128 liquidity,
  26 |     |         uint32 epoch,
  27 |     |         int24 tickAtPrice,
  28 |     |         bool isPool0
  29 |     |     );
  30 |     | 
  31 |     |     function perform(
  32 |     |         mapping(uint256 => LimitPoolStructs.LimitPosition)
  33 |     |             storage positions,
  34 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  35 |     |         RangePoolStructs.Sample[65535] storage samples,
  36 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
  37 |     |         PoolsharkStructs.TickMap storage limitTickMap,
  38 |     |         PoolsharkStructs.GlobalState storage globalState,
  39 |     |         PoolsharkStructs.MintLimitParams memory params,
  40 |     |         LimitPoolStructs.MintLimitCache memory cache
  41 |     |     ) internal {
  42 |     |         // check for invalid receiver
  43 |     |         if (params.to == address(0))
  44 |     |             require(false, "CollectToZeroAddress()");
  45 |     | 
  46 |     |         cache.state = globalState;
  47 |     | 
  48 |     |         // validate position ticks
  49 |     |         ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);
  50 |     | 
  51 |     |         if (params.positionId > 0) {
  52 |     |             cache.position = positions[params.positionId];
  53 |     |             if (cache.position.liquidity == 0) {
  54 |     |                 // position doesn't exist
  55 |     |                 require(false, 'PositionNotFound()');
  56 |     |             }
  57 |     |             if (PositionTokens.balanceOf(cache.constants, params.to, params.positionId) == 0)
  58 |     |                 require(false, 'PositionOwnerMismatch()');
  59 |     |         }
  60 |     | 
  61 |     |         // resize position if necessary
  62 |     |         (params, cache) = LimitPositions.resize(
  63 |     |             ticks,
  64 |     |             samples,
  65 |     |             rangeTickMap,
  66 |     |             limitTickMap,
  67 |     |             params,
  68 |     |             cache
  69 |     |         );
  70 |     | 
  71 |     |         // save state for reentrancy safety
  72 |     |         save(cache, globalState, !params.zeroForOne);
  73 |     | 
  74 |     |         // transfer out if swap output 
  75 |     |         if (cache.swapCache.output > 0) {
  76 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
  77 |     |                 (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),
  78 |     |                 cache.swapCache.output
  79 |     |             );
  80 |     |             SafeTransfers.transferOut(
  81 |     |                 params.to,
  82 |     |                 params.zeroForOne ? cache.constants.token1 
  83 |     |                                   : cache.constants.token0,
  84 |     |                 cache.swapCache.output
  85 |     |             );
  86 |     |         }
  87 |     | 
  88 |     |         // mint position if amount is left
  89 |     |         if (params.amount > 0 && cache.liquidityMinted > 0 && params.lower < params.upper) {
  90 |     |             // check if new position created
  91 |     |             if (params.positionId == 0 ||                       // new position
  92 |     |                     params.lower != cache.position.lower ||     // lower mismatch
  93 |     |                     params.upper != cache.position.upper) {     // upper mismatch
  94 |     |                 LimitPoolStructs.LimitPosition memory newPosition;
  95 |     |                 newPosition.lower = params.lower;
  96 |     |                 newPosition.upper = params.upper;
  97 |     |                 // use new position in cache
  98 |     |                 cache.position = newPosition;
  99 |     |                 params.positionId = cache.state.positionIdNext;
 100 |     |                 cache.state.positionIdNext += 1;
 101 |     |             }
 102 |     |             cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;
 103 |     |             // bump to the next tick if there is no liquidity
 104 |     |             if (cache.pool.liquidity == 0) {
 105 |     |                 /// @dev - this makes sure to have liquidity unlocked if undercutting
 106 |     |                 (cache, cache.pool) = LimitTicks.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);
 107 |     |             }
 108 |     | 
 109 |     |             if (params.zeroForOne) {
 110 |     |                 uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 111 |     |                 if (priceLower <= cache.pool.price) {
 112 |     |                     // save liquidity if active
 113 |     |                     if (cache.pool.liquidity > 0) {
 114 |     |                         cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);
 115 |     |                     }
 116 |     |                     cache.pool.price = priceLower;
 117 |     |                     cache.pool.tickAtPrice = params.lower;
 118 |     |                     /// @auditor - double check liquidity is set correctly for this in insertSingle
 119 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 120 |     |                     cache.position.crossedInto = true;
 121 |     |                     // set epoch on start tick to signify position being crossed into
 122 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 123 |     |                     emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);
 124 |     |                 }
 125 |     |             } else {
 126 |     |                 uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 127 |     |                 if (priceUpper >= cache.pool.price) {
 128 |     |                     if (cache.pool.liquidity > 0) {
 129 |     |                         cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);
 130 |     |                     }
 131 |     |                     cache.pool.price = priceUpper;
 132 |     |                     cache.pool.tickAtPrice = params.upper;
 133 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 134 |     |                     cache.position.crossedInto = true;
 135 |     |                     // set epoch on start tick to signify position being crossed into
 136 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 137 |     |                     emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);
 138 |     |                 }
 139 |     |             }
 140 |     |             (cache.pool, cache.position) = LimitPositions.add(
 141 |     |                 cache,
 142 |     |                 ticks,
 143 |     |                 limitTickMap,
 144 |     |                 params
 145 |     |             );
 146 |     | 
 147 |     |             // save position to storage
 148 |     |             positions[params.positionId] = cache.position;
 149 |     | 
 150 |     |             params.zeroForOne ? cache.state.pool0 = cache.pool : cache.state.pool1 = cache.pool;
 151 |     | 
 152 |     |             emit MintLimit(
 153 |     |                 params.to,
 154 |     |                 params.lower,
 155 |     |                 params.upper,
 156 |     |                 params.zeroForOne,
 157 |     |                 params.positionId,
 158 |     |                 cache.position.epochLast,
 159 |     |                 uint128(params.amount),
 160 |     |                 uint128(cache.liquidityMinted)
 161 |     |             );
 162 |     |         }
 163 |     |         // save lp side for safe reentrancy
 164 |     |         save(cache, globalState, params.zeroForOne);
 165 |     | 
 166 |     |         // check balance and execute callback
 167 |     |         uint256 balanceStart = balance(params, cache);
 168 |     |         ILimitPoolMintLimitCallback(msg.sender).limitPoolMintLimitCallback(
 169 |     |             params.zeroForOne ? -int256(params.amount + cache.swapCache.input) : int256(cache.swapCache.output),
 170 |     |             params.zeroForOne ? int256(cache.swapCache.output) : -int256(params.amount + cache.swapCache.input),
 171 |     |             params.callbackData
 172 |     |         );
 173 |     | 
 174 |     |         // check balance requirements after callback
 175 |     |         if (balance(params, cache) < balanceStart + params.amount + cache.swapCache.input)
 176 |     |             require(false, 'MintInputAmountTooLow()');
 177 |     |     }
 178 |     | 
 179 |     |     function balance(
 180 |     |         address token
 181 |     |     ) private view returns (uint256) {
 182 |     |         (
 183 |     |             bool success,
 184 |     |             bytes memory data
 185 |     |         ) = token.staticcall(
 186 |     |                                     abi.encodeWithSelector(
 187 |     |                                         IERC20Minimal.balanceOf.selector,
 188 |     |                                         address(this)
 189 |     |                                     )
 190 |     |                                 );
 191 |     |         require(success && data.length >= 32);
 192 |     |         return abi.decode(data, (uint256));
 193 |     |     }
 194 |     | 
 195 |     |     function save(
 196 |     |         LimitPoolStructs.MintLimitCache memory cache,
 197 |     |         PoolsharkStructs.GlobalState storage globalState,
 198 |     |         bool zeroForOne
 199 |     |     ) internal {
 200 |     |         globalState.epoch = cache.state.epoch;
 201 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 202 |     |         globalState.positionIdNext = cache.state.positionIdNext;
 203 |     |         if (zeroForOne) {
 204 |     |             globalState.pool = cache.state.pool;
 205 |     |             globalState.pool0 = cache.state.pool0;
 206 |     |         } else {
 207 |     |             globalState.pool = cache.state.pool;
 208 |     |             globalState.pool1 = cache.state.pool1;
 209 |     |         }
 210 |     |     }
 211 |     | 
 212 |     |     
 213 |     |     function balance(
 214 |     |         PoolsharkStructs.MintLimitParams memory params,
 215 |     |         LimitPoolStructs.MintLimitCache memory cache
 216 |     |     ) private view returns (uint256) {
 217 |     |         (
 218 |     |             bool success,
 219 |     |             bytes memory data
 220 |     |         ) = (params.zeroForOne ? cache.constants.token0
 221 |     |                                : cache.constants.token1)
 222 |     |                                .staticcall(
 223 |     |                                     abi.encodeWithSelector(
 224 |     |                                         IERC20Minimal.balanceOf.selector,
 225 |     |                                         address(this)
 226 |     |                                     )
 227 |     |                                 );
 228 |     |         require(success && data.length >= 32);
 229 |     |         return abi.decode(data, (uint256));
 230 |     |     }
 231 |     | }
 232 |     | 

/root/git/limit/contracts/libraries/limit/pool/SnapshotLimitCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../../interfaces/structs/LimitPoolStructs.sol';
  5 |     | import '../LimitPositions.sol';
  6 |     | import '../../utils/Collect.sol';
  7 |     | 
  8 |     | library SnapshotLimitCall {
  9 |     |     uint8 private constant _ENTERED = 2;
 10 |     | 
 11 |     |     event BurnLimit(
 12 |     |         address indexed to,
 13 |     |         uint32 positionId,
 14 |     |         int24 lower,
 15 |     |         int24 upper,
 16 |     |         int24 oldClaim,
 17 |     |         int24 newClaim,
 18 |     |         bool zeroForOne,
 19 |     |         uint128 liquidityBurned,
 20 |     |         uint128 tokenInClaimed,
 21 |     |         uint128 tokenOutBurned
 22 |     |     );
 23 |     | 
 24 |     |     function perform(
 25 |     |         mapping(uint256 => LimitPoolStructs.LimitPosition)
 26 |     |             storage positions,
 27 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 28 |     |         PoolsharkStructs.TickMap storage tickMap,
 29 |     |         PoolsharkStructs.GlobalState memory state,
 30 |     |         PoolsharkStructs.LimitImmutables memory constants,
 31 |     |         LimitPoolStructs.SnapshotLimitParams memory params
 32 |     |     ) internal view returns (
 33 |     |         uint128,
 34 |     |         uint128
 35 |     |     )
 36 |     |     {
 37 |     |         if (state.unlocked == _ENTERED)
 38 |     |             require(false, 'ReentrancyGuardReadOnlyReentrantCall()');
 39 |     |         LimitPoolStructs.BurnLimitCache memory cache;
 40 |     |         cache.state = state;
 41 |     |         cache.constants = constants;
 42 |     |         cache.position = positions[params.positionId];
 43 |     |         PoolsharkStructs.BurnLimitParams memory burnParams = PoolsharkStructs.BurnLimitParams ({
 44 |     |             to: params.owner,
 45 |     |             burnPercent: params.burnPercent,
 46 |     |             positionId: params.positionId,
 47 |     |             claim: params.claim,
 48 |     |             zeroForOne: params.zeroForOne
 49 |     |         });
 50 |     |         if (cache.position.epochLast == 0) require(false, 'PositionNotFound()');
 51 |     |         return LimitPositions.snapshot(
 52 |     |             ticks,
 53 |     |             tickMap,
 54 |     |             cache,
 55 |     |             burnParams
 56 |     |         );
 57 |     |     }
 58 |     | }
 59 |     | 

/root/git/limit/contracts/libraries/math/ConstantProduct.sol
   1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import './OverflowMath.sol';
   5 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   6 |     | import '../../interfaces/structs/PoolsharkStructs.sol';
   7 |     | 
   8 |     | /// @notice Math library that facilitates ranged liquidity calculations.
   9 |     | library ConstantProduct {
  10 | *   |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  11 |     | 
  12 |     |     struct PriceBounds {
  13 |     |         uint160 min;
  14 |     |         uint160 max;
  15 |     |     }
  16 |     | 
  17 |     |     /////////////////////////////////////////////////////////////
  18 |     |     ///////////////////////// DYDX MATH /////////////////////////
  19 |     |     /////////////////////////////////////////////////////////////
  20 |     | 
  21 |     |     function getDy(
  22 |     |         uint256 liquidity,
  23 |     |         uint256 priceLower,
  24 |     |         uint256 priceUpper,
  25 |     |         bool roundUp
  26 |     |     ) internal pure returns (uint256 dy) {
  27 |     |         unchecked {
  28 |     |             if (liquidity == 0) return 0;
  29 |     |             if (roundUp) {
  30 |     |                 dy = OverflowMath.mulDivRoundingUp(liquidity, priceUpper - priceLower, Q96);
  31 |     |             } else {
  32 |     |                 dy = OverflowMath.mulDiv(liquidity, priceUpper - priceLower, Q96);
  33 |     |             }
  34 |     |         }
  35 |     |     }
  36 |     | 
  37 |     |     function getDx(
  38 |     |         uint256 liquidity,
  39 |     |         uint256 priceLower,
  40 |     |         uint256 priceUpper,
  41 |     |         bool roundUp
  42 |     |     ) internal pure returns (uint256 dx) {
  43 |     |         unchecked {
  44 |     |             if (liquidity == 0) return 0;
  45 |     |             if (roundUp) {
  46 |     |                 dx = OverflowMath.divRoundingUp(
  47 |     |                         OverflowMath.mulDivRoundingUp(
  48 |     |                             liquidity << 96, 
  49 |     |                             priceUpper - priceLower,
  50 |     |                             priceUpper
  51 |     |                         ),
  52 |     |                         priceLower
  53 |     |                 );
  54 |     |             } else {
  55 |     |                 dx = OverflowMath.mulDiv(
  56 |     |                         liquidity << 96,
  57 |     |                         priceUpper - priceLower,
  58 |     |                         priceUpper
  59 |     |                 ) / priceLower;
  60 |     |             }
  61 |     |         }
  62 |     |     }
  63 |     | 
  64 | *   |     function getLiquidityForAmounts(
  65 |     |         uint256 priceLower,
  66 |     |         uint256 priceUpper,
  67 |     |         uint256 currentPrice,
  68 |     |         uint256 dy,
  69 |     |         uint256 dx
  70 | *   |     ) internal pure returns (uint256 liquidity) {
  71 |     |         unchecked {
  72 | *   |             if (priceUpper <= currentPrice) {
  73 | *   |                 liquidity = OverflowMath.mulDiv(dy, Q96, priceUpper - priceLower);
  74 | *   |             } else if (currentPrice <= priceLower) {
  75 | *   |                 liquidity = OverflowMath.mulDiv(
  76 | *   |                     dx,
  77 | *   |                     OverflowMath.mulDiv(priceLower, priceUpper, Q96),
  78 | *   |                     priceUpper - priceLower
  79 |     |                 );
  80 | *   |             } else {
  81 | *   |                 uint256 liquidity0 = OverflowMath.mulDiv(
  82 | *   |                     dx,
  83 | *   |                     OverflowMath.mulDiv(priceUpper, currentPrice, Q96),
  84 | *   |                     priceUpper - currentPrice
  85 |     |                 );
  86 | *   |                 uint256 liquidity1 = OverflowMath.mulDiv(dy, Q96, currentPrice - priceLower);
  87 | *   |                 liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  88 |     |             }
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     function getAmountsForLiquidity(
  93 |     |         uint256 priceLower,
  94 |     |         uint256 priceUpper,
  95 |     |         uint256 currentPrice,
  96 |     |         uint256 liquidityAmount,
  97 |     |         bool roundUp
  98 |     |     ) internal pure returns (uint128 token0amount, uint128 token1amount) {
  99 |     |         if (priceUpper <= currentPrice) {
 100 |     |             token1amount = uint128(getDy(liquidityAmount, priceLower, priceUpper, roundUp));
 101 |     |         } else if (currentPrice <= priceLower) {
 102 |     |             token0amount = uint128(getDx(liquidityAmount, priceLower, priceUpper, roundUp));
 103 |     |         } else {
 104 |     |             token0amount = uint128(getDx(liquidityAmount, currentPrice, priceUpper, roundUp));
 105 |     |             token1amount = uint128(getDy(liquidityAmount, priceLower, currentPrice, roundUp));
 106 |     |         }
 107 |     |         if (token0amount > uint128(type(int128).max)) require(false, 'AmountsOutOfBounds()');
 108 |     |         if (token1amount > uint128(type(int128).max)) require(false, 'AmountsOutOfBounds()');
 109 |     |     }
 110 |     | 
 111 |     |     function getNewPrice(
 112 |     |         uint256 price,
 113 |     |         uint256 liquidity,
 114 |     |         uint256 amount,
 115 |     |         bool zeroForOne,
 116 |     |         bool exactIn
 117 |     |     ) internal pure returns (
 118 |     |         uint256 newPrice
 119 |     |     ) {
 120 |     |         if (exactIn) {
 121 |     |             if (zeroForOne) {
 122 |     |                 uint256 liquidityPadded = liquidity << 96;
 123 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 124 |     |                         liquidityPadded,
 125 |     |                         price,
 126 |     |                         liquidityPadded + price * amount
 127 |     |                     );
 128 |     |             } else {
 129 |     |                 newPrice = price + (amount << 96) / liquidity;
 130 |     |             }
 131 |     |         } else {
 132 |     |             if (zeroForOne) {
 133 |     |                 newPrice = price - 
 134 |     |                         OverflowMath.divRoundingUp(amount << 96, liquidity);
 135 |     |             } else {
 136 |     |                 uint256 liquidityPadded = uint256(liquidity) << 96;
 137 |     |                 newPrice = OverflowMath.mulDivRoundingUp(
 138 |     |                         liquidityPadded, 
 139 |     |                         price,
 140 |     |                         liquidityPadded - uint256(price) * amount
 141 |     |                 );
 142 |     |             }
 143 |     |         }
 144 |     |     }
 145 |     | 
 146 |     |     function getPrice(
 147 |     |         uint256 sqrtPrice
 148 |     |     ) internal pure returns (uint256 price) {
 149 |     |         if (sqrtPrice >= 2 ** 48)
 150 |     |             price = OverflowMath.mulDiv(sqrtPrice, sqrtPrice, 2 ** 96);
 151 |     |         else
 152 |     |             price = sqrtPrice;
 153 |     |     }
 154 |     | 
 155 |     |     /////////////////////////////////////////////////////////////
 156 |     |     ///////////////////////// TICK MATH /////////////////////////
 157 |     |     /////////////////////////////////////////////////////////////
 158 |     | 
 159 | *   |     int24 internal constant MIN_TICK = -887272;   /// @dev - tick for price of 2^-128
 160 | *   |     int24 internal constant MAX_TICK = -MIN_TICK; /// @dev - tick for price of 2^128
 161 |     | 
 162 |     |     function minTick(
 163 |     |         int16 tickSpacing
 164 |     |     ) internal pure returns (
 165 |     |         int24 tick
 166 |     |     ) {
 167 |     |         return MIN_TICK / tickSpacing * tickSpacing;
 168 |     |     }
 169 |     | 
 170 | *   |     function maxTick(
 171 |     |         int16 tickSpacing
 172 |     |     ) internal pure returns (
 173 | *   |         int24 tick
 174 |     |     ) {
 175 | *   |         return MAX_TICK / tickSpacing * tickSpacing;
 176 |     |     }
 177 |     | 
 178 |     |     function priceBounds(
 179 |     |         int16 tickSpacing
 180 |     |     ) internal pure returns (
 181 |     |         uint160,
 182 |     |         uint160
 183 |     |     ) {
 184 |     |         return (minPrice(tickSpacing), maxPrice(tickSpacing));
 185 |     |     }
 186 |     | 
 187 |     |     function minPrice(
 188 |     |         int16 tickSpacing
 189 |     |     ) internal pure returns (
 190 |     |         uint160 price
 191 |     |     ) {
 192 |     |         PoolsharkStructs.LimitImmutables  memory constants;
 193 |     |         constants.tickSpacing = tickSpacing;
 194 |     |         return getPriceAtTick(minTick(tickSpacing), constants);
 195 |     |     }
 196 |     | 
 197 |     |     function maxPrice(
 198 |     |         int16 tickSpacing
 199 |     |     ) internal pure returns (
 200 |     |         uint160 price
 201 |     |     ) {
 202 |     |         PoolsharkStructs.LimitImmutables  memory constants;
 203 |     |         constants.tickSpacing = tickSpacing;
 204 |     |         return getPriceAtTick(maxTick(tickSpacing), constants);
 205 |     |     }
 206 |     | 
 207 |     |     function checkTicks(
 208 |     |         int24 lower,
 209 |     |         int24 upper,
 210 |     |         int16 tickSpacing
 211 |     |     ) internal pure
 212 |     |     {
 213 |     |         if (lower < minTick(tickSpacing)) require (false, 'LowerTickOutOfBounds()');
 214 |     |         if (upper > maxTick(tickSpacing)) require (false, 'UpperTickOutOfBounds()');
 215 |     |         if (lower % tickSpacing != 0) require (false, 'LowerTickOutsideTickSpacing()');
 216 |     |         if (upper % tickSpacing != 0) require (false, 'UpperTickOutsideTickSpacing()');
 217 |     |         if (lower >= upper) require (false, 'LowerUpperTickOrderInvalid()');
 218 |     |     }
 219 |     | 
 220 |     |     function checkPrice(
 221 |     |         uint160 price,
 222 |     |         PriceBounds memory bounds
 223 |     |     ) internal pure {
 224 |     |         if (price < bounds.min || price >= bounds.max) require (false, 'PriceOutOfBounds()');
 225 |     |     }
 226 |     | 
 227 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96.
 228 |     |     /// @dev Throws if |tick| > max tick.
 229 |     |     /// @param tick The input tick for the above formula.
 230 |     |     /// @return price Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
 231 |     |     /// at the given tick.
 232 | *   |     function getPriceAtTick(
 233 |     |         int24 tick,
 234 |     |         PoolsharkStructs.LimitImmutables memory constants
 235 |     |     ) internal pure returns (
 236 | *   |         uint160 price
 237 | *   |     ) {
 238 | *   |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
 239 | *   |         if (absTick > uint256(uint24(maxTick(constants.tickSpacing)))) require (false, 'TickOutOfBounds()');
 240 | *   |         unchecked {
 241 | *   |             uint256 ratio = absTick & 0x1 != 0
 242 |     |                 ? 0xfffcb933bd6fad37aa2d162d1a594001
 243 | *   |                 : 0x100000000000000000000000000000000;
 244 | *   |             if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
 245 | *   |             if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
 246 | *   |             if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
 247 | *   |             if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
 248 | *   |             if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
 249 | *   |             if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
 250 | *   |             if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
 251 | *   |             if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
 252 | *   |             if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
 253 | *   |             if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
 254 | *   |             if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
 255 | *   |             if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
 256 | *   |             if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
 257 | *   |             if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
 258 | *   |             if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
 259 | *   |             if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
 260 | *   |             if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
 261 | *   |             if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
 262 | *   |             if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
 263 |     | 
 264 | *   |             if (tick > 0) ratio = type(uint256).max / ratio;
 265 |     |             // This divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
 266 |     |             // We then downcast because we know the result always fits within 160 bits due to our tick input constraint.
 267 |     |             // We round up in the division so getTickAtPrice of the output price is always consistent.
 268 | *   |             price = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
 269 |     |         }
 270 |     |     }
 271 |     | 
 272 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio.
 273 |     |     /// @param price The sqrt ratio for which to compute the tick as a Q64.96.
 274 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio.
 275 |     |     function getTickAtPrice(
 276 |     |         uint160 price,
 277 |     |         PoolsharkStructs.LimitImmutables  memory constants
 278 |     |     ) internal pure returns (int24 tick) {
 279 |     |         // Second inequality must be < because the price can never reach the price at the max tick.
 280 |     |         if (price < constants.bounds.min || price > constants.bounds.max)
 281 |     |             require (false, 'PriceOutOfBounds()');
 282 |     |         uint256 ratio = uint256(price) << 32;
 283 |     | 
 284 |     |         uint256 r = ratio;
 285 |     |         uint256 msb = 0;
 286 |     | 
 287 |     |         assembly {
 288 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
 289 |     |             msb := or(msb, f)
 290 |     |             r := shr(f, r)
 291 |     |         }
 292 |     |         assembly {
 293 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
 294 |     |             msb := or(msb, f)
 295 |     |             r := shr(f, r)
 296 |     |         }
 297 |     |         assembly {
 298 |     |             let f := shl(5, gt(r, 0xFFFFFFFF))
 299 |     |             msb := or(msb, f)
 300 |     |             r := shr(f, r)
 301 |     |         }
 302 |     |         assembly {
 303 |     |             let f := shl(4, gt(r, 0xFFFF))
 304 |     |             msb := or(msb, f)
 305 |     |             r := shr(f, r)
 306 |     |         }
 307 |     |         assembly {
 308 |     |             let f := shl(3, gt(r, 0xFF))
 309 |     |             msb := or(msb, f)
 310 |     |             r := shr(f, r)
 311 |     |         }
 312 |     |         assembly {
 313 |     |             let f := shl(2, gt(r, 0xF))
 314 |     |             msb := or(msb, f)
 315 |     |             r := shr(f, r)
 316 |     |         }
 317 |     |         assembly {
 318 |     |             let f := shl(1, gt(r, 0x3))
 319 |     |             msb := or(msb, f)
 320 |     |             r := shr(f, r)
 321 |     |         }
 322 |     |         assembly {
 323 |     |             let f := gt(r, 0x1)
 324 |     |             msb := or(msb, f)
 325 |     |         }
 326 |     | 
 327 |     |         if (msb >= 128) r = ratio >> (msb - 127);
 328 |     |         else r = ratio << (127 - msb);
 329 |     | 
 330 |     |         int256 log_2 = (int256(msb) - 128) << 64;
 331 |     | 
 332 |     |         assembly {
 333 |     |             r := shr(127, mul(r, r))
 334 |     |             let f := shr(128, r)
 335 |     |             log_2 := or(log_2, shl(63, f))
 336 |     |             r := shr(f, r)
 337 |     |         }
 338 |     |         assembly {
 339 |     |             r := shr(127, mul(r, r))
 340 |     |             let f := shr(128, r)
 341 |     |             log_2 := or(log_2, shl(62, f))
 342 |     |             r := shr(f, r)
 343 |     |         }
 344 |     |         assembly {
 345 |     |             r := shr(127, mul(r, r))
 346 |     |             let f := shr(128, r)
 347 |     |             log_2 := or(log_2, shl(61, f))
 348 |     |             r := shr(f, r)
 349 |     |         }
 350 |     |         assembly {
 351 |     |             r := shr(127, mul(r, r))
 352 |     |             let f := shr(128, r)
 353 |     |             log_2 := or(log_2, shl(60, f))
 354 |     |             r := shr(f, r)
 355 |     |         }
 356 |     |         assembly {
 357 |     |             r := shr(127, mul(r, r))
 358 |     |             let f := shr(128, r)
 359 |     |             log_2 := or(log_2, shl(59, f))
 360 |     |             r := shr(f, r)
 361 |     |         }
 362 |     |         assembly {
 363 |     |             r := shr(127, mul(r, r))
 364 |     |             let f := shr(128, r)
 365 |     |             log_2 := or(log_2, shl(58, f))
 366 |     |             r := shr(f, r)
 367 |     |         }
 368 |     |         assembly {
 369 |     |             r := shr(127, mul(r, r))
 370 |     |             let f := shr(128, r)
 371 |     |             log_2 := or(log_2, shl(57, f))
 372 |     |             r := shr(f, r)
 373 |     |         }
 374 |     |         assembly {
 375 |     |             r := shr(127, mul(r, r))
 376 |     |             let f := shr(128, r)
 377 |     |             log_2 := or(log_2, shl(56, f))
 378 |     |             r := shr(f, r)
 379 |     |         }
 380 |     |         assembly {
 381 |     |             r := shr(127, mul(r, r))
 382 |     |             let f := shr(128, r)
 383 |     |             log_2 := or(log_2, shl(55, f))
 384 |     |             r := shr(f, r)
 385 |     |         }
 386 |     |         assembly {
 387 |     |             r := shr(127, mul(r, r))
 388 |     |             let f := shr(128, r)
 389 |     |             log_2 := or(log_2, shl(54, f))
 390 |     |             r := shr(f, r)
 391 |     |         }
 392 |     |         assembly {
 393 |     |             r := shr(127, mul(r, r))
 394 |     |             let f := shr(128, r)
 395 |     |             log_2 := or(log_2, shl(53, f))
 396 |     |             r := shr(f, r)
 397 |     |         }
 398 |     |         assembly {
 399 |     |             r := shr(127, mul(r, r))
 400 |     |             let f := shr(128, r)
 401 |     |             log_2 := or(log_2, shl(52, f))
 402 |     |             r := shr(f, r)
 403 |     |         }
 404 |     |         assembly {
 405 |     |             r := shr(127, mul(r, r))
 406 |     |             let f := shr(128, r)
 407 |     |             log_2 := or(log_2, shl(51, f))
 408 |     |             r := shr(f, r)
 409 |     |         }
 410 |     |         assembly {
 411 |     |             r := shr(127, mul(r, r))
 412 |     |             let f := shr(128, r)
 413 |     |             log_2 := or(log_2, shl(50, f))
 414 |     |         }
 415 |     | 
 416 |     |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 417 |     | 
 418 |     |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 419 |     |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 420 |     | 
 421 |     |         tick = tickLow == tickHi ? tickLow : getPriceAtTick(tickHi, constants) <= price
 422 |     |             ? tickHi
 423 |     |             : tickLow;
 424 |     |     }
 425 |     | }

/root/git/limit/contracts/libraries/math/OverflowMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | /// @notice Math library that facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision.
   5 |     | library OverflowMath {
   6 |     | 
   7 |     |     // @dev no underflow or overflow checks
   8 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
   9 |     |         assembly {
  10 |     |             z := add(div(x, y), gt(mod(x, y), 0))
  11 |     |         }
  12 |     |     }
  13 |     | 
  14 |     |     /// @notice Calculates floor(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
  15 |     |     /// @param a The multiplicand.
  16 |     |     /// @param b The multiplier.
  17 |     |     /// @param denominator The divisor.
  18 |     |     /// @return result The 256-bit result.
  19 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.
  20 | *   |     function mulDiv(
  21 |     |         uint256 a,
  22 |     |         uint256 b,
  23 |     |         uint256 denominator
  24 | *   |     ) internal pure returns (uint256 result) {
  25 |     |         unchecked {
  26 |     |             // 512-bit multiply [prod1 prod0] = a * b.
  27 |     |             // Compute the product mod 2**256 and mod 2**256 - 1,
  28 |     |             // then use the Chinese Remainder Theorem to reconstruct
  29 |     |             // the 512 bit result. The result is stored in two 256
  30 |     |             // variables such that product = prod1 * 2**256 + prod0.
  31 | *   |             uint256 prod0; // Least significant 256 bits of the product.
  32 | *   |             uint256 prod1; // Most significant 256 bits of the product.
  33 | *   |             assembly {
  34 | *   |                 let mm := mulmod(a, b, not(0))
  35 | *   |                 prod0 := mul(a, b)
  36 | *   |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  37 |     |             }
  38 |     |             // Handle non-overflow cases, 256 by 256 division.
  39 | *   |             if (prod1 == 0) {
  40 | *   |                 require(denominator > 0);
  41 |     |                 assembly {
  42 | *   |                     result := div(prod0, denominator)
  43 |     |                 }
  44 | *   |                 return result;
  45 |     |             }
  46 |     |             // Make sure the result is less than 2**256 -
  47 |     |             // also prevents denominator == 0.
  48 | *   |             require(denominator > prod1);
  49 |     |             ///////////////////////////////////////////////
  50 |     |             // 512 by 256 division.
  51 |     |             ///////////////////////////////////////////////
  52 |     |             // Make division exact by subtracting the remainder from [prod1 prod0] -
  53 |     |             // compute remainder using mulmod.
  54 | *   |             uint256 remainder;
  55 |     |             assembly {
  56 | *   |                 remainder := mulmod(a, b, denominator)
  57 |     |             }
  58 |     |             // Subtract 256 bit number from 512 bit number.
  59 |     |             assembly {
  60 | *   |                 prod1 := sub(prod1, gt(remainder, prod0))
  61 | *   |                 prod0 := sub(prod0, remainder)
  62 |     |             }
  63 |     |             // Factor powers of two out of denominator -
  64 |     |             // compute largest power of two divisor of denominator
  65 |     |             // (always >= 1).
  66 | *   |             uint256 twos = uint256(-int256(denominator)) & denominator;
  67 |     |             // Divide denominator by power of two.
  68 |     |             assembly {
  69 | *   |                 denominator := div(denominator, twos)
  70 |     |             }
  71 |     |             // Divide [prod1 prod0] by the factors of two.
  72 |     |             assembly {
  73 | *   |                 prod0 := div(prod0, twos)
  74 |     |             }
  75 |     |             // Shift in bits from prod1 into prod0. For this we need
  76 |     |             // to flip `twos` such that it is 2**256 / twos -
  77 |     |             // if twos is zero, then it becomes one.
  78 |     |             assembly {
  79 | *   |                 twos := add(div(sub(0, twos), twos), 1)
  80 |     |             }
  81 | *   |             prod0 |= prod1 * twos;
  82 |     |             // Invert denominator mod 2**256 -
  83 |     |             // now that denominator is an odd number, it has an inverse
  84 |     |             // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  85 |     |             // Compute the inverse by starting with a seed that is correct
  86 |     |             // for four bits. That is, denominator * inv = 1 mod 2**4.
  87 | *   |             uint256 inv = (3 * denominator) ^ 2;
  88 |     |             // Now use Newton-Raphson iteration to improve the precision.
  89 |     |             // Thanks to Hensel's lifting lemma, this also works in modular
  90 |     |             // arithmetic, doubling the correct bits in each step.
  91 | *   |             inv *= 2 - denominator * inv; // Inverse mod 2**8.
  92 | *   |             inv *= 2 - denominator * inv; // Inverse mod 2**16.
  93 | *   |             inv *= 2 - denominator * inv; // Inverse mod 2**32.
  94 | *   |             inv *= 2 - denominator * inv; // Inverse mod 2**64.
  95 | *   |             inv *= 2 - denominator * inv; // Inverse mod 2**128.
  96 | *   |             inv *= 2 - denominator * inv; // Inverse mod 2**256.
  97 |     |             // Because the division is now exact we can divide by multiplying
  98 |     |             // with the modular inverse of denominator. This will give us the
  99 |     |             // correct result modulo 2**256. Since the precoditions guarantee
 100 |     |             // that the outcome is less than 2**256, this is the final result.
 101 |     |             // We don't need to compute the high bits of the result and prod1
 102 |     |             // is no longer required.
 103 | *   |             result = prod0 * inv;
 104 | *   |             return result;
 105 |     |         }
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice Calculates ceil(abdenominator) with full precision - throws if result overflows an uint256 or denominator == 0.
 109 |     |     /// @param a The multiplicand.
 110 |     |     /// @param b The multiplier.
 111 |     |     /// @param denominator The divisor.
 112 |     |     /// @return result The 256-bit result.
 113 |     |     function mulDivRoundingUp(
 114 |     |         uint256 a,
 115 |     |         uint256 b,
 116 |     |         uint256 denominator
 117 |     |     ) internal pure returns (uint256 result) {
 118 |     |         result = mulDiv(a, b, denominator);
 119 |     |         unchecked {
 120 |     |             if (mulmod(a, b, denominator) != 0) {
 121 |     |                 if (result >= type(uint256).max) require (false, 'MaxUintExceeded()');
 122 |     |                 result++;
 123 |     |             }
 124 |     |         }
 125 |     |     }
 126 |     | }
 127 |     | 

/root/git/limit/contracts/libraries/pool/FeesCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/IPositionERC1155.sol';
  5 |     | import '../../interfaces/structs/PoolsharkStructs.sol';
  6 |     | import '../../interfaces/limit/ILimitPoolManager.sol';
  7 |     | import '../utils/SafeTransfers.sol';
  8 |     | 
  9 |     | library FeesCall {
 10 |     | 
 11 |     |     // protocol fee ceilings
 12 |     |     uint16  public constant MAX_PROTOCOL_SWAP_FEE = 1e4; // max protocol swap fee of 100%
 13 |     |     uint16  public constant MAX_PROTOCOL_FILL_FEE = 1e2; // max protocol fill fee of 1%
 14 |     | 
 15 |     |     // protocol fee flags
 16 |     |     uint8 internal constant PROTOCOL_SWAP_FEE_0 = 2**0;
 17 |     |     uint8 internal constant PROTOCOL_SWAP_FEE_1 = 2**1;
 18 |     |     uint8 internal constant PROTOCOL_FILL_FEE_0 = 2**2;
 19 |     |     uint8 internal constant PROTOCOL_FILL_FEE_1 = 2**3;
 20 |     | 
 21 |     |     // eth address for safe withdrawal
 22 |     |     address public constant ethAddress = address(0);
 23 |     | 
 24 |     |     /// @dev - LimitPoolManager (i.e. constants.owner) emits events in aggregate
 25 |     | 
 26 |     |     function perform(
 27 |     |         PoolsharkStructs.GlobalState storage globalState,
 28 |     |         PoolsharkStructs.FeesParams memory params,
 29 |     |         PoolsharkStructs.LimitImmutables memory constants
 30 |     |     ) internal returns (
 31 |     |         uint128 token0Fees,
 32 |     |         uint128 token1Fees
 33 |     |     ) {
 34 |     |         // swap fee token0
 35 |     |         if ((params.setFeesFlags & PROTOCOL_SWAP_FEE_0) > 0) {
 36 |     |             if (params.protocolSwapFee0 > MAX_PROTOCOL_SWAP_FEE)
 37 |     |                 require(false, 'ProtocolSwapFeeCeilingExceeded()');
 38 |     |             globalState.pool.protocolSwapFee0 = params.protocolSwapFee0;
 39 |     |         }
 40 |     |         // swap fee token1
 41 |     |         if ((params.setFeesFlags & PROTOCOL_SWAP_FEE_1) > 0) {
 42 |     |             if (params.protocolSwapFee1 > MAX_PROTOCOL_SWAP_FEE)
 43 |     |                 require(false, 'ProtocolSwapFeeCeilingExceeded()');
 44 |     |             globalState.pool.protocolSwapFee1 = params.protocolSwapFee1;
 45 |     |         }
 46 |     |         // fill fee token0
 47 |     |         if ((params.setFeesFlags & PROTOCOL_FILL_FEE_0) > 0) {
 48 |     |             if (params.protocolFillFee0 > MAX_PROTOCOL_FILL_FEE)
 49 |     |                 require(false, 'ProtocolFillFeeCeilingExceeded()');
 50 |     |             globalState.pool1.protocolFillFee = params.protocolFillFee0;
 51 |     |         }
 52 |     |         // fill fee token1
 53 |     |         if ((params.setFeesFlags & PROTOCOL_FILL_FEE_1) > 0) {
 54 |     |             if (params.protocolFillFee1 > MAX_PROTOCOL_FILL_FEE)
 55 |     |                 require(false, 'ProtocolFillFeeCeilingExceeded()');
 56 |     |             globalState.pool0.protocolFillFee = params.protocolFillFee1;
 57 |     |         }
 58 |     |         address feeTo = ILimitPoolManager(constants.owner).feeTo();
 59 |     | 
 60 |     |         // token0 fees stored on pool1 for swaps and fills
 61 |     |         token0Fees = globalState.pool1.protocolFees;
 62 |     |         // token1 fees stored on pool0 for swaps and fills
 63 |     |         token1Fees = globalState.pool0.protocolFees;
 64 |     |         globalState.pool0.protocolFees = 0;
 65 |     |         globalState.pool1.protocolFees = 0;
 66 |     | 
 67 |     |         if (token0Fees > 0)
 68 |     |             SafeTransfers.transferOut(feeTo, constants.token0, token0Fees);
 69 |     |         if (token1Fees > 0)
 70 |     |             SafeTransfers.transferOut(feeTo, constants.token1, token1Fees);
 71 |     | 
 72 |     |         // withdraw errantly received ETH from pool
 73 |     |         if (address(this).balance > 0) {
 74 |     |             // send eth balance to feeTo
 75 |     |             SafeTransfers.transferOut(feeTo, ethAddress, address(this).balance);
 76 |     |         }
 77 |     | 
 78 |     |         // withdraw errantly received ETH from pool token
 79 |     |         if (address(constants.poolToken).balance > 0) {
 80 |     |             // send eth balance to feeTo
 81 |     |             IPositionERC1155(constants.poolToken).withdrawEth(feeTo, constants);
 82 |     |         }
 83 |     | 
 84 |     |         return (token0Fees, token1Fees);
 85 |     |     }
 86 |     | }
 87 |     | 

/root/git/limit/contracts/libraries/pool/QuoteCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
  5 |     | import '../Ticks.sol';
  6 |     | 
  7 |     | library QuoteCall {
  8 |     |     uint8 private constant _ENTERED = 2;
  9 |     | 
 10 |     |     event Swap(
 11 |     |         address indexed recipient,
 12 |     |         bool zeroForOne,
 13 |     |         uint256 amountIn,
 14 |     |         uint256 amountOut,
 15 |     |         uint160 price,
 16 |     |         uint128 liquidity,
 17 |     |         int24 tickAtPrice
 18 |     |     );
 19 |     | 
 20 |     |     function perform(
 21 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
 22 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
 23 |     |         PoolsharkStructs.TickMap storage limitTickMap,
 24 |     |         PoolsharkStructs.GlobalState storage globalState,
 25 |     |         PoolsharkStructs.QuoteParams memory params,
 26 |     |         PoolsharkStructs.SwapCache memory cache
 27 |     |     ) internal returns (
 28 |     |         uint256,
 29 |     |         uint256,
 30 |     |         uint160
 31 |     |     ) {
 32 |     |         if (cache.state.unlocked == _ENTERED)
 33 |     |             require(false, 'ReentrancyGuardReadOnlyReentrantCall()');
 34 |     |         cache.state = globalState;
 35 |     |         return Ticks.quote(
 36 |     |             ticks,
 37 |     |             rangeTickMap,
 38 |     |             limitTickMap,
 39 |     |             params,
 40 |     |             cache
 41 |     |         );
 42 |     |     }
 43 |     | }
 44 |     | 

/root/git/limit/contracts/libraries/pool/SampleCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/RangePoolStructs.sol';
  5 |     | import '../Samples.sol';
  6 |     | 
  7 |     | library SampleCall {
  8 |     |     uint8 private constant _ENTERED = 2;
  9 |     |     
 10 |     |     event SampleRecorded(
 11 |     |         int56 tickSecondsAccum,
 12 |     |         uint160 secondsPerLiquidityAccum
 13 |     |     );
 14 |     | 
 15 |     |     event SampleLengthIncreased(
 16 |     |         uint16 sampleLengthNext
 17 |     |     );
 18 |     | 
 19 |     |     function perform(
 20 |     |         PoolsharkStructs.GlobalState memory state,
 21 |     |         PoolsharkStructs.LimitImmutables memory constants,
 22 |     |         uint32[] memory secondsAgo
 23 |     |     ) internal view returns (
 24 |     |         int56[]   memory tickSecondsAccum,
 25 |     |         uint160[] memory secondsPerLiquidityAccum,
 26 |     |         uint160 averagePrice,
 27 |     |         uint128 averageLiquidity,
 28 |     |         int24 averageTick
 29 |     |     ) {
 30 |     |         if (state.unlocked == _ENTERED)
 31 |     |             require(false, 'ReentrancyGuardReadOnlyReentrantCall()');
 32 |     |         return Samples.get(
 33 |     |             address(this),
 34 |     |             RangePoolStructs.SampleParams(
 35 |     |                 state.pool.samples.index,
 36 |     |                 state.pool.samples.count,
 37 |     |                 uint32(block.timestamp),
 38 |     |                 secondsAgo,
 39 |     |                 state.pool.tickAtPrice,
 40 |     |                 state.pool.liquidity,
 41 |     |                 constants
 42 |     |             )
 43 |     |         );
 44 |     |     }
 45 |     | }
 46 |     | 

/root/git/limit/contracts/libraries/pool/SwapCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import '../../interfaces/callbacks/ILimitPoolCallback.sol';
   6 |     | import '../../interfaces/IERC20Minimal.sol';
   7 |     | import '../Ticks.sol';
   8 |     | import '../utils/Collect.sol';
   9 |     | import '../utils/SafeTransfers.sol';
  10 |     | 
  11 |     | library SwapCall {
  12 |     |     event Swap(
  13 |     |         address indexed recipient,
  14 |     |         bool zeroForOne,
  15 |     |         uint256 amountIn,
  16 |     |         uint256 amountOut,
  17 |     |         uint160 price,
  18 |     |         uint128 liquidity,
  19 |     |         uint128 feeAmount,
  20 |     |         int24 tickAtPrice
  21 |     |     );
  22 |     | 
  23 |     |     function perform(
  24 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  25 |     |         RangePoolStructs.Sample[65535] storage samples,
  26 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
  27 |     |         PoolsharkStructs.TickMap storage limitTickMap,
  28 |     |         PoolsharkStructs.GlobalState storage globalState,
  29 |     |         PoolsharkStructs.SwapParams memory params,
  30 |     |         PoolsharkStructs.SwapCache memory cache
  31 |     |     ) internal returns (
  32 |     |         int256,
  33 |     |         int256
  34 |     |     ) {
  35 |     |         // check for invalid receiver
  36 |     |         if (params.to == address(0))
  37 |     |             require(false, "CollectToZeroAddress()");
  38 |     |         
  39 |     |         // initialize state
  40 |     |         cache.state = globalState;
  41 |     |         
  42 |     |         // execute swap
  43 |     |         cache = Ticks.swap(
  44 |     |             ticks,
  45 |     |             samples,
  46 |     |             rangeTickMap,
  47 |     |             limitTickMap,
  48 |     |             params,
  49 |     |             cache
  50 |     |         );
  51 |     | 
  52 |     |         // save state for reentrancy protection
  53 |     |         save(cache, globalState, params.zeroForOne);
  54 |     |         EchidnaAssertions.assertPoolBalanceExceeded(
  55 |     |             (params.zeroForOne ? balance(cache.constants.token1) : balance(cache.constants.token0)),
  56 |     |             cache.output
  57 |     |         );
  58 |     |         // transfer output amount
  59 |     |         SafeTransfers.transferOut(
  60 |     |             params.to, 
  61 |     |             params.zeroForOne ? cache.constants.token1
  62 |     |                               : cache.constants.token0,
  63 |     |             cache.output
  64 |     |         );
  65 |     | 
  66 |     |         // check balance and execute callback
  67 |     |         uint256 balanceStart = balance(params, cache);
  68 |     |         ILimitPoolSwapCallback(msg.sender).limitPoolSwapCallback(
  69 |     |             params.zeroForOne ? -int256(cache.input) : int256(cache.output),
  70 |     |             params.zeroForOne ? int256(cache.output) : -int256(cache.input),
  71 |     |             params.callbackData
  72 |     |         );
  73 |     | 
  74 |     |         // check balance requirements after callback
  75 |     |         if (balance(params, cache) < balanceStart + cache.input) {
  76 |     |            require(false, 'SwapInputAmountTooLow()');
  77 |     |         }
  78 |     | 
  79 |     |         return (
  80 |     |             params.zeroForOne ? 
  81 |     |                 (
  82 |     |                     -int256(cache.input),
  83 |     |                      int256(cache.output)
  84 |     |                 )
  85 |     |               : (
  86 |     |                      int256(cache.output),
  87 |     |                     -int256(cache.input)
  88 |     |                 )
  89 |     |         );
  90 |     |     }
  91 |     | 
  92 |     |     function save(
  93 |     |         PoolsharkStructs.SwapCache memory cache,
  94 |     |         PoolsharkStructs.GlobalState storage globalState,
  95 |     |         bool zeroForOne
  96 |     |     ) internal {
  97 |     |         globalState.epoch = cache.state.epoch;
  98 |     |         globalState.pool = cache.state.pool;
  99 |     |         if (zeroForOne)
 100 |     |             globalState.pool1 = cache.state.pool1;
 101 |     |         else
 102 |     |             globalState.pool0 = cache.state.pool0;
 103 |     |     }
 104 |     | 
 105 |     |     function balance(
 106 |     |         PoolsharkStructs.SwapParams memory params,
 107 |     |         PoolsharkStructs.SwapCache memory cache
 108 |     |     ) private view returns (uint256) {
 109 |     |         (
 110 |     |             bool success,
 111 |     |             bytes memory data
 112 |     |         ) = (params.zeroForOne ? cache.constants.token0
 113 |     |                                : cache.constants.token1)
 114 |     |                                .staticcall(
 115 |     |                                     abi.encodeWithSelector(
 116 |     |                                         IERC20Minimal.balanceOf.selector,
 117 |     |                                         address(this)
 118 |     |                                     )
 119 |     |                                 );
 120 |     |         require(success && data.length >= 32);
 121 |     |         return abi.decode(data, (uint256));
 122 |     |     }
 123 |     | 
 124 |     |     function balance(
 125 |     |         address token
 126 |     |     ) private view returns (uint256) {
 127 |     |         (
 128 |     |             bool success,
 129 |     |             bytes memory data
 130 |     |         ) = token.staticcall(
 131 |     |                                     abi.encodeWithSelector(
 132 |     |                                         IERC20Minimal.balanceOf.selector,
 133 |     |                                         address(this)
 134 |     |                                     )
 135 |     |                                 );
 136 |     |         require(success && data.length >= 32);
 137 |     |         return abi.decode(data, (uint256));
 138 |     |     }
 139 |     | }
 140 |     | 

/root/git/limit/contracts/libraries/range/RangePositions.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/IPool.sol';
   5 |     | import '../../interfaces/IPositionERC1155.sol';
   6 |     | import '../../interfaces/structs/RangePoolStructs.sol';
   7 |     | import '../math/ConstantProduct.sol';
   8 |     | import './math/FeeMath.sol';
   9 |     | import '../math/OverflowMath.sol';
  10 |     | import '../utils/SafeCast.sol';
  11 |     | import './RangeTicks.sol';
  12 |     | import '../Samples.sol';
  13 |     | 
  14 |     | /// @notice Position management library for ranged liquidity.
  15 |     | library RangePositions {
  16 |     |     using SafeCast for uint256;
  17 |     |     using SafeCast for uint128;
  18 |     |     using SafeCast for int256;
  19 |     |     using SafeCast for int128;
  20 |     | 
  21 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  22 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
  23 |     | 
  24 |     |     event BurnRange(
  25 |     |         address indexed recipient,
  26 |     |         uint256 indexed positionId,
  27 |     |         uint128 liquidityBurned,
  28 |     |         int128 amount0,
  29 |     |         int128 amount1
  30 |     |     );
  31 |     | 
  32 |     |     event CompoundRange(
  33 |     |         uint32 indexed positionId,
  34 |     |         uint128 liquidityCompounded
  35 |     |     );
  36 |     | 
  37 |     |     function validate(
  38 |     |         RangePoolStructs.MintRangeParams memory params,
  39 |     |         RangePoolStructs.MintRangeCache memory cache
  40 |     |     ) internal pure returns (
  41 |     |         RangePoolStructs.MintRangeParams memory,
  42 |     |         RangePoolStructs.MintRangeCache memory
  43 |     |     ) {
  44 |     |         cache.liquidityMinted = ConstantProduct.getLiquidityForAmounts(
  45 |     |             cache.priceLower,
  46 |     |             cache.priceUpper,
  47 |     |             cache.state.pool.price,
  48 |     |             params.amount1,
  49 |     |             params.amount0
  50 |     |         );
  51 |     |         if (cache.liquidityMinted == 0) require(false, 'NoLiquidityBeingAdded()');
  52 |     |         (params.amount0, params.amount1) = ConstantProduct.getAmountsForLiquidity(
  53 |     |             cache.priceLower,
  54 |     |             cache.priceUpper,
  55 |     |             cache.state.pool.price,
  56 |     |             cache.liquidityMinted,
  57 |     |             true
  58 |     |         );
  59 |     |         if (cache.state.liquidityGlobal + cache.liquidityMinted > uint128(type(int128).max))
  60 |     |             require(false, 'LiquidityOverflow()');
  61 |     | 
  62 |     |         return (params, cache);
  63 |     |     }
  64 |     | 
  65 |     |     function add(
  66 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
  67 |     |         RangePoolStructs.Sample[65535] storage samples,
  68 |     |         PoolsharkStructs.TickMap storage tickMap,
  69 |     |         RangePoolStructs.MintRangeCache memory cache,
  70 |     |         RangePoolStructs.MintRangeParams memory params
  71 |     |     ) internal returns (
  72 |     |         RangePoolStructs.MintRangeCache memory
  73 |     |     ) {
  74 |     |         if (params.amount0 == 0 && params.amount1 == 0) return cache;
  75 |     | 
  76 |     |         cache.state = RangeTicks.insert(
  77 |     |             ticks,
  78 |     |             samples,
  79 |     |             tickMap,
  80 |     |             cache.state,
  81 |     |             cache.constants,
  82 |     |             cache.position.lower,
  83 |     |             cache.position.upper,
  84 |     |             cache.liquidityMinted.toUint128()
  85 |     |         );
  86 |     |         (
  87 |     |             cache.position.feeGrowthInside0Last,
  88 |     |             cache.position.feeGrowthInside1Last
  89 |     |         ) = rangeFeeGrowth(
  90 |     |             ticks[cache.position.lower].range,
  91 |     |             ticks[cache.position.upper].range,
  92 |     |             cache.state,
  93 |     |             cache.position.lower,
  94 |     |             cache.position.upper
  95 |     |         );
  96 |     |         if (cache.position.liquidity == 0) {
  97 |     |             IPositionERC1155(cache.constants.poolToken).mint(
  98 |     |                 params.to,
  99 |     |                 params.positionId,
 100 |     |                 1,
 101 |     |                 cache.constants
 102 |     |             );
 103 |     |         }
 104 |     |         cache.position.liquidity += uint128(cache.liquidityMinted);
 105 |     |         return cache;
 106 |     |     }
 107 |     | 
 108 |     |     function remove(
 109 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 110 |     |         RangePoolStructs.Sample[65535] storage samples,
 111 |     |         PoolsharkStructs.TickMap storage tickMap,
 112 |     |         RangePoolStructs.BurnRangeParams memory params,
 113 |     |         RangePoolStructs.BurnRangeCache memory cache
 114 |     |     ) internal returns (
 115 |     |         RangePoolStructs.BurnRangeCache memory
 116 |     |     ) {
 117 |     |         cache.priceLower = ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants);
 118 |     |         cache.priceUpper = ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants);
 119 |     |         cache.liquidityBurned = _convert(cache.position.liquidity, params.burnPercent);
 120 |     |         if (cache.liquidityBurned  == 0) {
 121 |     |             return cache;
 122 |     |         }
 123 |     |         if (cache.liquidityBurned > cache.position.liquidity) require(false, 'NotEnoughPositionLiquidity()');
 124 |     |         {
 125 |     |             uint128 amount0Removed; uint128 amount1Removed;
 126 |     |             (amount0Removed, amount1Removed) = ConstantProduct.getAmountsForLiquidity(
 127 |     |                 cache.priceLower,
 128 |     |                 cache.priceUpper,
 129 |     |                 cache.state.pool.price,
 130 |     |                 cache.liquidityBurned ,
 131 |     |                 false
 132 |     |             );
 133 |     |             cache.amount0 += amount0Removed.toInt128();
 134 |     |             cache.amount1 += amount1Removed.toInt128();
 135 |     |             cache.position.liquidity -= cache.liquidityBurned.toUint128();
 136 |     |         }
 137 |     |         cache.state = RangeTicks.remove(
 138 |     |             ticks,
 139 |     |             samples,
 140 |     |             tickMap,
 141 |     |             cache.state,
 142 |     |             cache.constants,
 143 |     |             cache.position.lower,
 144 |     |             cache.position.upper,
 145 |     |             uint128(cache.liquidityBurned)
 146 |     |         );
 147 |     |         emit BurnRange(
 148 |     |             params.to,
 149 |     |             params.positionId,
 150 |     |             uint128(cache.liquidityBurned),
 151 |     |             cache.amount0,
 152 |     |             cache.amount1
 153 |     |         );
 154 |     |         if (cache.position.liquidity == 0) {
 155 |     |             cache.position.lower = 0;
 156 |     |             cache.position.upper = 0;
 157 |     |         }
 158 |     |         return cache;
 159 |     |     }
 160 |     | 
 161 |     |     function compound(
 162 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 163 |     |         PoolsharkStructs.TickMap storage tickMap,
 164 |     |         RangePoolStructs.Sample[65535] storage samples,
 165 |     |         PoolsharkStructs.GlobalState memory state,
 166 |     |         PoolsharkStructs.LimitImmutables memory constants,
 167 |     |         RangePoolStructs.RangePosition memory position,
 168 |     |         RangePoolStructs.CompoundRangeParams memory params
 169 |     |     ) internal returns (
 170 |     |         RangePoolStructs.RangePosition memory,
 171 |     |         PoolsharkStructs.GlobalState memory,
 172 |     |         int128,
 173 |     |         int128
 174 |     |     ) {
 175 |     |         // price tells you the ratio so you need to swap into the correct ratio and add liquidity
 176 |     |         uint256 liquidityAmount = ConstantProduct.getLiquidityForAmounts(
 177 |     |             params.priceLower,
 178 |     |             params.priceUpper,
 179 |     |             state.pool.price,
 180 |     |             params.amount1,
 181 |     |             params.amount0
 182 |     |         );
 183 |     |         if (liquidityAmount > 0) {
 184 |     |             state = RangeTicks.insert(
 185 |     |                 ticks,
 186 |     |                 samples,
 187 |     |                 tickMap,
 188 |     |                 state,
 189 |     |                 constants,
 190 |     |                 position.lower,
 191 |     |                 position.upper,
 192 |     |                 uint128(liquidityAmount)
 193 |     |             );
 194 |     |             uint256 amount0; uint256 amount1;
 195 |     |             (amount0, amount1) = ConstantProduct.getAmountsForLiquidity(
 196 |     |                 params.priceLower,
 197 |     |                 params.priceUpper,
 198 |     |                 state.pool.price,
 199 |     |                 liquidityAmount,
 200 |     |                 true
 201 |     |             );
 202 |     |             params.amount0 -= (amount0 <= params.amount0) ? uint128(amount0) : params.amount0;
 203 |     |             params.amount1 -= (amount1 <= params.amount1) ? uint128(amount1) : params.amount1;
 204 |     |             position.liquidity += uint128(liquidityAmount);
 205 |     |         }
 206 |     |         emit CompoundRange(
 207 |     |             params.positionId,
 208 |     |             uint128(liquidityAmount)
 209 |     |         );
 210 |     |         return (position, state, params.amount0.toInt128(), params.amount1.toInt128());
 211 |     |     }
 212 |     | 
 213 |     |     function update(
 214 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 215 |     |         RangePoolStructs.RangePosition memory position,
 216 |     |         PoolsharkStructs.GlobalState memory state,
 217 |     |         PoolsharkStructs.LimitImmutables memory constants,
 218 |     |         RangePoolStructs.UpdateParams memory params
 219 |     |     ) internal returns (
 220 |     |         RangePoolStructs.RangePosition memory,
 221 |     |         int128,
 222 |     |         int128
 223 |     |     ) {
 224 |     |         RangePoolStructs.RangePositionCache memory cache;
 225 |     |         /// @dev - only true if burn call
 226 |     |         if (params.burnPercent > 0) {
 227 |     |             cache.liquidityAmount = _convert(position.liquidity, params.burnPercent);
 228 |     |             if (position.liquidity == cache.liquidityAmount)
 229 |     |                 IPositionERC1155(constants.poolToken).burn(msg.sender, params.positionId, 1, constants);
 230 |     |         }
 231 |     | 
 232 |     |         (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(
 233 |     |             ticks[position.lower].range,
 234 |     |             ticks[position.upper].range,
 235 |     |             state,
 236 |     |             position.lower,
 237 |     |             position.upper
 238 |     |         );
 239 |     | 
 240 |     |         EchidnaAssertions.assertFeeGrowthInsideUnderflows(rangeFeeGrowth0, position.feeGrowthInside0Last);
 241 |     | 
 242 |     |         int128 amount0Fees = OverflowMath.mulDiv(
 243 |     |             rangeFeeGrowth0 - position.feeGrowthInside0Last,
 244 |     |             uint256(position.liquidity),
 245 |     |             Q128
 246 |     |         ).toInt256().toInt128();
 247 |     | 
 248 |     |         EchidnaAssertions.assertFeeGrowthInsideUnderflows(rangeFeeGrowth1, position.feeGrowthInside1Last);
 249 |     | 
 250 |     |         int128 amount1Fees = OverflowMath.mulDiv(
 251 |     |             rangeFeeGrowth1 - position.feeGrowthInside1Last,
 252 |     |             position.liquidity,
 253 |     |             Q128
 254 |     |         ).toInt256().toInt128();
 255 |     | 
 256 |     |         position.feeGrowthInside0Last = rangeFeeGrowth0;
 257 |     |         position.feeGrowthInside1Last = rangeFeeGrowth1;
 258 |     | 
 259 |     |         return (position, amount0Fees, amount1Fees);
 260 |     |     }
 261 |     | 
 262 |     |     function rangeFeeGrowth(
 263 |     |         PoolsharkStructs.RangeTick memory lowerTick,
 264 |     |         PoolsharkStructs.RangeTick memory upperTick,
 265 |     |         PoolsharkStructs.GlobalState memory state,
 266 |     |         int24 lower,
 267 |     |         int24 upper
 268 |     |     ) internal pure returns (uint256 feeGrowthInside0, uint256 feeGrowthInside1) {
 269 |     | 
 270 |     |         uint256 feeGrowthGlobal0 = state.pool.feeGrowthGlobal0;
 271 |     |         uint256 feeGrowthGlobal1 = state.pool.feeGrowthGlobal1;
 272 |     | 
 273 |     |         uint256 feeGrowthBelow0;
 274 |     |         uint256 feeGrowthBelow1;
 275 |     |         if (state.pool.tickAtPrice >= lower) {
 276 |     |             feeGrowthBelow0 = lowerTick.feeGrowthOutside0;
 277 |     |             feeGrowthBelow1 = lowerTick.feeGrowthOutside1;
 278 |     |         } else {
 279 |     |             feeGrowthBelow0 = feeGrowthGlobal0 - lowerTick.feeGrowthOutside0;
 280 |     |             feeGrowthBelow1 = feeGrowthGlobal1 - lowerTick.feeGrowthOutside1;
 281 |     |         }
 282 |     | 
 283 |     |         uint256 feeGrowthAbove0;
 284 |     |         uint256 feeGrowthAbove1;
 285 |     |         if (state.pool.tickAtPrice < upper) {
 286 |     |             feeGrowthAbove0 = upperTick.feeGrowthOutside0;
 287 |     |             feeGrowthAbove1 = upperTick.feeGrowthOutside1;
 288 |     |         } else {
 289 |     |             feeGrowthAbove0 = feeGrowthGlobal0 - upperTick.feeGrowthOutside0;
 290 |     |             feeGrowthAbove1 = feeGrowthGlobal1 - upperTick.feeGrowthOutside1;
 291 |     |         }
 292 |     |         feeGrowthInside0 = feeGrowthGlobal0 - feeGrowthBelow0 - feeGrowthAbove0;
 293 |     |         feeGrowthInside1 = feeGrowthGlobal1 - feeGrowthBelow1 - feeGrowthAbove1;
 294 |     |     }
 295 |     | 
 296 |     |     function snapshot(
 297 |     |         mapping(uint256 => RangePoolStructs.RangePosition)
 298 |     |             storage positions,
 299 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 300 |     |         PoolsharkStructs.GlobalState memory state,
 301 |     |         PoolsharkStructs.LimitImmutables memory constants,
 302 |     |         uint32 positionId
 303 |     |     ) internal view returns (
 304 |     |         int56   tickSecondsAccum,
 305 |     |         uint160 secondsPerLiquidityAccum,
 306 |     |         uint128 feesOwed0,
 307 |     |         uint128 feesOwed1
 308 |     |     ) {
 309 |     |         RangePoolStructs.SnapshotRangeCache memory cache;
 310 |     |         cache.position = positions[positionId];
 311 |     | 
 312 |     |         // early return if position empty
 313 |     |         if (cache.position.liquidity == 0)
 314 |     |             return (0,0,0,0);
 315 |     | 
 316 |     |         cache.price = state.pool.price;
 317 |     |         cache.liquidity = state.pool.liquidity;
 318 |     |         cache.samples = state.pool.samples;
 319 |     | 
 320 |     |         // grab lower tick
 321 |     |         PoolsharkStructs.RangeTick memory tickLower = ticks[cache.position.lower].range;
 322 |     |         
 323 |     |         // grab upper tick
 324 |     |         PoolsharkStructs.RangeTick memory tickUpper = ticks[cache.position.upper].range;
 325 |     | 
 326 |     |         cache.tickSecondsAccumLower =  tickLower.tickSecondsAccumOutside;
 327 |     |         cache.secondsPerLiquidityAccumLower = tickLower.secondsPerLiquidityAccumOutside;
 328 |     | 
 329 |     |         // if both have never been crossed into return 0
 330 |     |         cache.tickSecondsAccumUpper = tickUpper.tickSecondsAccumOutside;
 331 |     |         cache.secondsPerLiquidityAccumUpper = tickUpper.secondsPerLiquidityAccumOutside;
 332 |     |         cache.constants = constants;
 333 |     | 
 334 |     |         (uint256 rangeFeeGrowth0, uint256 rangeFeeGrowth1) = rangeFeeGrowth(
 335 |     |             tickLower,
 336 |     |             tickUpper,
 337 |     |             state,
 338 |     |             cache.position.lower,
 339 |     |             cache.position.upper
 340 |     |         );
 341 |     | 
 342 |     |         // calcuate fees earned
 343 |     |         cache.amount0 += uint128(
 344 |     |             OverflowMath.mulDiv(
 345 |     |                 rangeFeeGrowth0 - cache.position.feeGrowthInside0Last,
 346 |     |                 cache.position.liquidity,
 347 |     |                 Q128
 348 |     |             )
 349 |     |         );
 350 |     |         cache.amount1 += uint128(
 351 |     |             OverflowMath.mulDiv(
 352 |     |                 rangeFeeGrowth1 - cache.position.feeGrowthInside1Last,
 353 |     |                 cache.position.liquidity,
 354 |     |                 Q128
 355 |     |             )
 356 |     |         );
 357 |     | 
 358 |     |         cache.tick = state.pool.tickAtPrice;
 359 |     | 
 360 |     |         if (cache.tick < cache.position.lower) {
 361 |     |             // lower accum values are greater
 362 |     |             return (
 363 |     |                 cache.tickSecondsAccumLower - cache.tickSecondsAccumUpper,
 364 |     |                 cache.secondsPerLiquidityAccumLower - cache.secondsPerLiquidityAccumUpper,
 365 |     |                 cache.amount0,
 366 |     |                 cache.amount1
 367 |     |             );
 368 |     |         } else if (cache.position.upper >= cache.tick) {
 369 |     |             // grab current sample
 370 |     |             cache.blockTimestamp = uint32(block.timestamp);
 371 |     |             (
 372 |     |                 cache.tickSecondsAccum,
 373 |     |                 cache.secondsPerLiquidityAccum
 374 |     |             ) = Samples.getSingle(
 375 |     |                 IRangePool(address(this)), 
 376 |     |                 RangePoolStructs.SampleParams(
 377 |     |                     cache.samples.index,
 378 |     |                     cache.samples.count,
 379 |     |                     uint32(block.timestamp),
 380 |     |                     new uint32[](2),
 381 |     |                     cache.tick,
 382 |     |                     cache.liquidity,
 383 |     |                     cache.constants
 384 |     |                 ),
 385 |     |                 0
 386 |     |             );
 387 |     |             return (
 388 |     |                 cache.tickSecondsAccum 
 389 |     |                   - cache.tickSecondsAccumLower 
 390 |     |                   - cache.tickSecondsAccumUpper,
 391 |     |                 cache.secondsPerLiquidityAccum
 392 |     |                   - cache.secondsPerLiquidityAccumLower
 393 |     |                   - cache.secondsPerLiquidityAccumUpper,
 394 |     |                 cache.amount0,
 395 |     |                 cache.amount1
 396 |     |             );
 397 |     |         } else {
 398 |     |             // upper accum values are greater
 399 |     |             return (
 400 |     |                 cache.tickSecondsAccumUpper - cache.tickSecondsAccumLower,
 401 |     |                 cache.secondsPerLiquidityAccumUpper - cache.secondsPerLiquidityAccumLower,
 402 |     |                 cache.amount0,
 403 |     |                 cache.amount1
 404 |     |             );
 405 |     |         }
 406 |     |     }
 407 |     | 
 408 |     |     function _convert(
 409 |     |         uint128 liquidity,
 410 |     |         uint128 percent
 411 |     |     ) internal pure returns (
 412 |     |         uint128
 413 |     |     ) {
 414 |     |         // convert percentage to liquidity amount
 415 |     |         if (percent > 1e38) percent = 1e38;
 416 |     |         if (liquidity == 0 && percent > 0) require (false, 'PositionNotFound()');
 417 |     |         return uint128(uint256(liquidity) * uint256(percent) / 1e38);
 418 |     |     }
 419 |     | }
 420 |     | 

/root/git/limit/contracts/libraries/range/RangeTicks.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/PoolsharkStructs.sol';
   5 |     | import '../../interfaces/structs/RangePoolStructs.sol';
   6 |     | import '../../interfaces/range/IRangePoolFactory.sol';
   7 |     | import '../../interfaces/range/IRangePool.sol';
   8 |     | import './math/FeeMath.sol';
   9 |     | import './RangePositions.sol';
  10 |     | import '../math/OverflowMath.sol';
  11 |     | import '../math/ConstantProduct.sol';
  12 |     | import '../TickMap.sol';
  13 |     | import '../Samples.sol';
  14 |     | import '../../test/echidna/EchidnaAssertions.sol';
  15 |     | 
  16 |     | /// @notice Tick management library for range pools
  17 |     | library RangeTicks {
  18 |     | 
  19 |     |     event SyncRangeTick(
  20 |     |         uint200 feeGrowthOutside0,
  21 |     |         uint200 feeGrowthOutside1,
  22 |     |         int24 tick
  23 |     |     );
  24 |     | 
  25 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
  26 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
  27 |     | 
  28 |     |     function validate(
  29 |     |         int24 lower,
  30 |     |         int24 upper,
  31 |     |         int16 tickSpacing
  32 |     |     ) internal pure {
  33 |     |         if (lower % tickSpacing != 0) require(false, 'InvalidLowerTick()');
  34 |     |         if (lower < ConstantProduct.minTick(tickSpacing)) require(false, 'InvalidLowerTick()');
  35 |     |         if (upper % tickSpacing != 0) require(false, 'InvalidUpperTick()');
  36 |     |         if (upper > ConstantProduct.maxTick(tickSpacing)) require(false, 'InvalidUpperTick()');
  37 |     |         if (lower >= upper) require(false, 'InvalidPositionBounds()');
  38 |     |     }
  39 |     | 
  40 |     |     function insert(
  41 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
  42 |     |         RangePoolStructs.Sample[65535] storage samples,
  43 |     |         PoolsharkStructs.TickMap storage tickMap,
  44 |     |         PoolsharkStructs.GlobalState memory state,
  45 |     |         PoolsharkStructs.LimitImmutables memory constants,
  46 |     |         int24 lower,
  47 |     |         int24 upper,
  48 |     |         uint128 amount
  49 |     |     ) internal returns (PoolsharkStructs.GlobalState memory) {
  50 |     | 
  51 |     |         // get tick at price
  52 |     |         int24 tickAtPrice = state.pool.tickAtPrice;
  53 |     | 
  54 |     |         if(TickMap.set(tickMap, lower, constants.tickSpacing)) {
  55 |     |             ticks[lower].range.liquidityDelta += int128(amount);
  56 |     |             ticks[lower].range.liquidityAbsolute += amount;
  57 |     |         } else {
  58 |     |             if (lower <= tickAtPrice) {
  59 |     |                 (
  60 |     |                     int56 tickSecondsAccum,
  61 |     |                     uint160 secondsPerLiquidityAccum
  62 |     |                 ) = Samples.getSingle(
  63 |     |                         IRangePool(address(this)), 
  64 |     |                         RangePoolStructs.SampleParams(
  65 |     |                             state.pool.samples.index,
  66 |     |                             state.pool.samples.count,
  67 |     |                             uint32(block.timestamp),
  68 |     |                             new uint32[](2),
  69 |     |                             state.pool.tickAtPrice,
  70 |     |                             state.pool.liquidity,
  71 |     |                             constants
  72 |     |                         ),
  73 |     |                         0
  74 |     |                 );
  75 |     |                 ticks[lower].range = PoolsharkStructs.RangeTick(
  76 |     |                     state.pool.feeGrowthGlobal0,
  77 |     |                     state.pool.feeGrowthGlobal1,
  78 |     |                     secondsPerLiquidityAccum,
  79 |     |                     tickSecondsAccum,
  80 |     |                     int128(amount),             // liquidityDelta
  81 |     |                     amount                      // liquidityAbsolute
  82 |     |                 );
  83 |     |                 emit SyncRangeTick(
  84 |     |                     state.pool.feeGrowthGlobal0,
  85 |     |                     state.pool.feeGrowthGlobal1,
  86 |     |                     lower
  87 |     |                 );
  88 |     |             } else {
  89 |     |                 ticks[lower].range.liquidityDelta = int128(amount);
  90 |     |                 ticks[lower].range.liquidityAbsolute += amount;
  91 |     |             }
  92 |     |         }
  93 |     |         if(TickMap.set(tickMap, upper, constants.tickSpacing)) {
  94 |     |             ticks[upper].range.liquidityDelta -= int128(amount);
  95 |     |             ticks[upper].range.liquidityAbsolute += amount;
  96 |     |         } else {
  97 |     |             if (upper <= tickAtPrice) {
  98 |     | 
  99 |     |                 (
 100 |     |                     int56 tickSecondsAccum,
 101 |     |                     uint160 secondsPerLiquidityAccum
 102 |     |                 ) = Samples.getSingle(
 103 |     |                         IRangePool(address(this)), 
 104 |     |                         RangePoolStructs.SampleParams(
 105 |     |                             state.pool.samples.index,
 106 |     |                             state.pool.samples.count,
 107 |     |                             uint32(block.timestamp),
 108 |     |                             new uint32[](2),
 109 |     |                             state.pool.tickAtPrice,
 110 |     |                             state.pool.liquidity,
 111 |     |                             constants
 112 |     |                         ),
 113 |     |                         0
 114 |     |                 );
 115 |     |                 ticks[upper].range = PoolsharkStructs.RangeTick(
 116 |     |                     state.pool.feeGrowthGlobal0,
 117 |     |                     state.pool.feeGrowthGlobal1,
 118 |     |                     secondsPerLiquidityAccum,
 119 |     |                     tickSecondsAccum,
 120 |     |                     -int128(amount),
 121 |     |                     amount
 122 |     |                 );
 123 |     |                 emit SyncRangeTick(
 124 |     |                     state.pool.feeGrowthGlobal0,
 125 |     |                     state.pool.feeGrowthGlobal1,
 126 |     |                     upper
 127 |     |                 );
 128 |     |             } else {
 129 |     |                 ticks[upper].range.liquidityDelta = -int128(amount);
 130 |     |                 ticks[upper].range.liquidityAbsolute = amount;
 131 |     |             }
 132 |     |         }
 133 |     |         if (tickAtPrice >= lower && tickAtPrice < upper) {
 134 |     |             // write an oracle entry
 135 |     |             (state.pool.samples.index, state.pool.samples.count) = Samples.save(
 136 |     |                 samples,
 137 |     |                 state.pool.samples,
 138 |     |                 state.pool.liquidity,
 139 |     |                 state.pool.tickAtPrice
 140 |     |             );
 141 |     |             // update pool liquidity
 142 |     |             state.pool.liquidity += amount;
 143 |     |         }
 144 |     |         // update global liquidity
 145 |     |         state.liquidityGlobal += amount;
 146 |     | 
 147 |     |         return state;
 148 |     |     }
 149 |     | 
 150 |     |     function remove(
 151 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 152 |     |         RangePoolStructs.Sample[65535] storage samples,
 153 |     |         PoolsharkStructs.TickMap storage tickMap,
 154 |     |         PoolsharkStructs.GlobalState memory state,
 155 |     |         PoolsharkStructs.LimitImmutables memory constants, 
 156 |     |         int24 lower,
 157 |     |         int24 upper,
 158 |     |         uint128 amount
 159 |     |     ) internal returns (PoolsharkStructs.GlobalState memory) {
 160 |     |         validate(lower, upper, constants.tickSpacing);
 161 |     |         //check for amount to overflow liquidity delta & global
 162 |     |         if (amount == 0) return state;
 163 |     |         if (amount > uint128(type(int128).max)) require(false, 'LiquidityUnderflow()');
 164 |     |         if (amount > state.liquidityGlobal) require(false, 'LiquidityUnderflow()');
 165 |     | 
 166 |     |         // get pool tick at price
 167 |     |         int24 tickAtPrice = state.pool.tickAtPrice;
 168 |     | 
 169 |     |         // update lower liquidity values
 170 |     |         PoolsharkStructs.RangeTick memory tickLower = ticks[lower].range;
 171 |     |         unchecked {
 172 |     |             tickLower.liquidityDelta -= int128(amount);
 173 |     |             EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, amount, 'RTKS-1');
 174 |     |             tickLower.liquidityAbsolute -= amount;
 175 |     |         }
 176 |     |         ticks[lower].range = tickLower;
 177 |     |         // try to clear tick if possible
 178 |     |         clear(ticks, constants, tickMap, lower);
 179 |     | 
 180 |     |         // update upper liquidity values
 181 |     |         PoolsharkStructs.RangeTick memory tickUpper = ticks[upper].range;
 182 |     |         unchecked {
 183 |     |             tickUpper.liquidityDelta += int128(amount);
 184 |     |             EchidnaAssertions.assertLiquidityAbsoluteUnderflows(tickLower.liquidityAbsolute, amount, 'RTKS-2');
 185 |     |             tickUpper.liquidityAbsolute -= amount;
 186 |     |         }
 187 |     |         ticks[upper].range = tickUpper;
 188 |     |         // try to clear tick if possible
 189 |     |         clear(ticks, constants, tickMap, upper);
 190 |     | 
 191 |     |         if (tickAtPrice >= lower && tickAtPrice < upper) {
 192 |     |             // write an oracle entry
 193 |     |             (state.pool.samples.index, state.pool.samples.count) = Samples.save(
 194 |     |                 samples,
 195 |     |                 state.pool.samples,
 196 |     |                 state.pool.liquidity,
 197 |     |                 tickAtPrice
 198 |     |             );
 199 |     |             EchidnaAssertions.assertLiquidityUnderflows(state.pool.liquidity, amount, 'RTKS-3');
 200 |     |             state.pool.liquidity -= amount;  
 201 |     |         }
 202 |     |         EchidnaAssertions.assertLiquidityGlobalUnderflows(state.liquidityGlobal, amount, 'RTKS-4');
 203 |     |         state.liquidityGlobal -= amount;
 204 |     | 
 205 |     |         return state;
 206 |     |     }
 207 |     | 
 208 |     |     function clear(
 209 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 210 |     |         PoolsharkStructs.LimitImmutables memory constants,
 211 |     |         PoolsharkStructs.TickMap storage tickMap,
 212 |     |         int24 tickToClear
 213 |     |     ) internal {
 214 |     |         if (_empty(ticks[tickToClear])) {
 215 |     |             if (tickToClear != ConstantProduct.maxTick(constants.tickSpacing) &&
 216 |     |                     tickToClear != ConstantProduct.minTick(constants.tickSpacing)) {
 217 |     |                 ticks[tickToClear].range = PoolsharkStructs.RangeTick(0,0,0,0,0,0);
 218 |     |                 TickMap.unset(tickMap, tickToClear, constants.tickSpacing);
 219 |     |             }
 220 |     |         }
 221 |     |     }
 222 |     | 
 223 |     |     function _empty(
 224 |     |         LimitPoolStructs.Tick memory tick
 225 |     |     ) internal pure returns (
 226 |     |         bool
 227 |     |     ) {
 228 |     |         return tick.range.liquidityAbsolute == 0;
 229 |     |     }
 230 |     | }
 231 |     | 

/root/git/limit/contracts/libraries/range/math/FeeMath.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../Samples.sol';
   5 |     | import '../../utils/SafeCast.sol';
   6 |     | import "../../math/OverflowMath.sol";
   7 |     | import '../../../interfaces/structs/PoolsharkStructs.sol';
   8 |     | import "../../../interfaces/structs/RangePoolStructs.sol";
   9 |     | 
  10 |     | /// @notice Math library that facilitates fee handling.
  11 |     | library FeeMath {
  12 |     |     using SafeCast for uint256;
  13 |     | 
  14 |     |     uint256 internal constant FEE_DELTA_CONST = 0;
  15 |     |     //TODO: change FEE_DELTA_CONST before launch
  16 |     |     // uint256 internal constant FEE_DELTA_CONST = 5000;
  17 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
  18 |     | 
  19 |     |     struct CalculateLocals {
  20 |     |         uint256 price;
  21 |     |         uint256 minPrice;
  22 |     |         uint256 lastPrice;
  23 |     |         uint256 swapFee;
  24 |     |         uint256 feeAmount;
  25 |     |         uint256 protocolFee;
  26 |     |         uint256 protocolFeesAccrued;
  27 |     |         uint256 amountRange;
  28 |     |         bool feeDirection;
  29 |     |     }
  30 |     | 
  31 |     |     function calculate(
  32 |     |         PoolsharkStructs.SwapCache memory cache,
  33 |     |         uint256 amountIn,
  34 |     |         uint256 amountOut,
  35 |     |         bool zeroForOne
  36 |     |     ) internal pure returns (
  37 |     |         PoolsharkStructs.SwapCache memory
  38 |     |     )
  39 |     |     {
  40 |     |         CalculateLocals memory locals;
  41 |     |         if (cache.state.pool.liquidity != 0) {
  42 |     |             // calculate dynamic fee
  43 |     |             {
  44 |     |                 locals.minPrice = ConstantProduct.getPrice(cache.constants.bounds.min);
  45 |     |                 // square prices to take delta
  46 |     |                 locals.price = ConstantProduct.getPrice(cache.price);
  47 |     |                 locals.lastPrice = ConstantProduct.getPrice(cache.averagePrice);
  48 |     |                 if (locals.price < locals.minPrice)
  49 |     |                     locals.price = locals.minPrice;
  50 |     |                 if (locals.lastPrice < locals.minPrice)
  51 |     |                     locals.lastPrice = locals.minPrice;
  52 |     |                 // delta is % modifier on the swapFee
  53 |     |                 uint256 delta = OverflowMath.mulDiv(
  54 |     |                         FEE_DELTA_CONST / uint16(cache.constants.tickSpacing), // higher FEE_DELTA_CONST means
  55 |     |                         (                                                      // more aggressive dynamic fee
  56 |     |                             locals.price > locals.lastPrice
  57 |     |                                 ? locals.price - locals.lastPrice
  58 |     |                                 : locals.lastPrice - locals.price
  59 |     |                         ) * 1_000_000,
  60 |     |                         locals.lastPrice 
  61 |     |                 );
  62 |     |                 // max fee increase at 5x
  63 |     |                 if (delta > 4_000_000) delta = 4_000_000;
  64 |     |                 // true means increased fee for zeroForOne = true
  65 |     |                 locals.feeDirection = locals.price < locals.lastPrice;
  66 |     |                 // adjust fee based on direction
  67 |     |                 if (zeroForOne == locals.feeDirection) {
  68 |     |                     // if swapping away from twap price, increase fee
  69 |     |                     locals.swapFee = cache.constants.swapFee + OverflowMath.mulDiv(delta,cache.constants.swapFee, 1e6);
  70 |     |                 } else if (delta < 1e6) {
  71 |     |                     // if swapping towards twap price, decrease fee
  72 |     |                     locals.swapFee = cache.constants.swapFee - OverflowMath.mulDiv(delta,cache.constants.swapFee, 1e6);
  73 |     |                 } else {
  74 |     |                     // if swapping towards twap price and delta > 100%, set fee to zero
  75 |     |                     locals.swapFee = 0;
  76 |     |                 }
  77 |     |                 // console.log('price movement', locals.lastPrice, locals.price);
  78 |     |                 // console.log('swap fee adjustment',cache.constants.swapFee + delta * cache.constants.swapFee / 1e6);
  79 |     |             }
  80 |     |             if (cache.exactIn) {
  81 |     |                 // calculate output from range liquidity
  82 |     |                 locals.amountRange = OverflowMath.mulDiv(amountOut, cache.state.pool.liquidity, cache.liquidity);
  83 |     |                 // take enough fees to cover fee growth
  84 |     |                 locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountRange, locals.swapFee, 1e6);
  85 |     |                 amountOut -= locals.feeAmount;
  86 |     |             } else {
  87 |     |                 // calculate input from range liquidity
  88 |     |                 locals.amountRange = OverflowMath.mulDiv(amountIn, cache.state.pool.liquidity, cache.liquidity);
  89 |     |                 // take enough fees to cover fee growth
  90 |     |                 locals.feeAmount = OverflowMath.mulDivRoundingUp(locals.amountRange, locals.swapFee, 1e6);
  91 |     |                 amountIn += locals.feeAmount;
  92 |     |             }
  93 |     |             // add to total fees paid for swap
  94 |     |             cache.feeAmount += locals.feeAmount.toUint128();
  95 |     |             // load protocol fee from cache
  96 |     |             // zeroForOne && exactIn   = fee on token1
  97 |     |             // zeroForOne && !exactIn  = fee on token0
  98 |     |             // !zeroForOne && !exactIn = fee on token1
  99 |     |             // !zeroForOne && exactIn  = fee on token0
 100 |     |             locals.protocolFee = (zeroForOne == cache.exactIn) ? cache.state.pool.protocolSwapFee1 
 101 |     |                                                                : cache.state.pool.protocolSwapFee0;
 102 |     |             // calculate fee
 103 |     |             locals.protocolFeesAccrued = OverflowMath.mulDiv(locals.feeAmount, locals.protocolFee, 1e4);
 104 |     |             // fees for this swap step
 105 |     |             locals.feeAmount -= locals.protocolFeesAccrued;
 106 |     |             // save fee growth and protocol fees
 107 |     |             if (zeroForOne == cache.exactIn) {
 108 |     |                 cache.state.pool0.protocolFees += uint128(locals.protocolFeesAccrued);
 109 |     |                 cache.state.pool.feeGrowthGlobal1 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));
 110 |     |             } else {
 111 |     |                 cache.state.pool1.protocolFees += uint128(locals.protocolFeesAccrued);
 112 |     |                 cache.state.pool.feeGrowthGlobal0 += uint200(OverflowMath.mulDiv(locals.feeAmount, Q128, cache.state.pool.liquidity));
 113 |     |             }
 114 |     |         }
 115 |     |         cache.input  += amountIn;
 116 |     |         cache.output += amountOut;
 117 |     | 
 118 |     |         return cache;
 119 |     |     }
 120 |     | }

/root/git/limit/contracts/libraries/range/pool/BurnRangeCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../../interfaces/structs/RangePoolStructs.sol';
   5 |     | import '../../utils/Collect.sol';
   6 |     | import '../../utils/PositionTokens.sol';
   7 |     | import '../RangePositions.sol';
   8 |     | 
   9 |     | library BurnRangeCall {
  10 |     |     using SafeCast for int128;
  11 |     | 
  12 |     |     event BurnRange(
  13 |     |         address indexed recipient,
  14 |     |         int24 lower,
  15 |     |         int24 upper,
  16 |     |         uint256 indexed tokenId,
  17 |     |         uint128 liquidityBurned,
  18 |     |         uint128 amount0,
  19 |     |         uint128 amount1
  20 |     |     );
  21 |     | 
  22 |     |     function perform(
  23 |     |         mapping(uint256 => RangePoolStructs.RangePosition)
  24 |     |             storage positions,
  25 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
  26 |     |         PoolsharkStructs.TickMap storage tickMap,
  27 |     |         RangePoolStructs.Sample[65535] storage samples,
  28 |     |         PoolsharkStructs.GlobalState storage globalState,
  29 |     |         RangePoolStructs.BurnRangeCache memory cache,
  30 |     |         RangePoolStructs.BurnRangeParams memory params
  31 |     |     ) internal {
  32 |     |         // check for invalid receiver
  33 |     |         if (params.to == address(0))
  34 |     |             require(false, "CollectToZeroAddress()");
  35 |     |         
  36 |     |         // initialize cache
  37 |     |         cache.state = globalState;
  38 |     |         cache.position = positions[params.positionId];
  39 |     | 
  40 |     |         if (cache.position.liquidity == 0)
  41 |     |             require(false, 'PositionNotFound()');
  42 |     |         if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
  43 |     |             require(false, 'PositionOwnerMismatch()');
  44 |     | 
  45 |     |         ( 
  46 |     |             cache.position,
  47 |     |             cache.amount0,
  48 |     |             cache.amount1
  49 |     |         ) = RangePositions.update(
  50 |     |                 ticks,
  51 |     |                 cache.position,
  52 |     |                 cache.state,
  53 |     |                 cache.constants,
  54 |     |                 RangePoolStructs.UpdateParams(
  55 |     |                     cache.position.lower,
  56 |     |                     cache.position.upper,
  57 |     |                     params.positionId,
  58 |     |                     params.burnPercent
  59 |     |                 )
  60 |     |         );
  61 |     |         cache = RangePositions.remove(
  62 |     |             ticks,
  63 |     |             samples,
  64 |     |             tickMap,
  65 |     |             params,
  66 |     |             cache
  67 |     |         );
  68 |     |         // only compound if burnPercent is zero
  69 |     |         if (params.burnPercent == 0)
  70 |     |             if (cache.amount0 > 0 || cache.amount1 > 0) {
  71 |     |                 (
  72 |     |                     cache.position,
  73 |     |                     cache.state,
  74 |     |                     cache.amount0,
  75 |     |                     cache.amount1
  76 |     |                 ) = RangePositions.compound(
  77 |     |                     ticks,
  78 |     |                     tickMap,
  79 |     |                     samples,
  80 |     |                     cache.state,
  81 |     |                     cache.constants,
  82 |     |                     cache.position,
  83 |     |                     RangePoolStructs.CompoundRangeParams(
  84 |     |                         cache.priceLower,
  85 |     |                         cache.priceUpper,
  86 |     |                         cache.amount0.toUint128(),
  87 |     |                         cache.amount1.toUint128(),
  88 |     |                         params.positionId
  89 |     |                     )
  90 |     |                 );
  91 |     |             }
  92 |     |         // save changes to storage
  93 |     |         save(positions, globalState, cache, params.positionId);
  94 |     | 
  95 |     |         // transfer amounts to user
  96 |     |         if (cache.amount0 > 0 || cache.amount1 > 0)
  97 |     |             Collect.range(
  98 |     |                 cache.constants,
  99 |     |                 params.to,
 100 |     |                 cache.amount0,
 101 |     |                 cache.amount1
 102 |     |             );
 103 |     |     }
 104 |     | 
 105 |     |     function save(
 106 |     |         mapping(uint256 => RangePoolStructs.RangePosition)
 107 |     |             storage positions,
 108 |     |         PoolsharkStructs.GlobalState storage globalState,
 109 |     |         RangePoolStructs.BurnRangeCache memory cache,
 110 |     |         uint32 positionId
 111 |     |     ) internal {
 112 |     |         positions[positionId] = cache.position;
 113 |     |         globalState.pool = cache.state.pool;
 114 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 115 |     |     }
 116 |     | }
 117 |     | 

/root/git/limit/contracts/libraries/range/pool/MintRangeCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../../interfaces/structs/RangePoolStructs.sol';
   5 |     | import '../../../interfaces/callbacks/ILimitPoolCallback.sol';
   6 |     | import '../../../interfaces/IERC20Minimal.sol';
   7 |     | import '../../utils/SafeTransfers.sol';
   8 |     | import '../../utils/Collect.sol';
   9 |     | import '../../utils/PositionTokens.sol';
  10 |     | import '../RangePositions.sol';
  11 |     | 
  12 |     | library MintRangeCall {
  13 |     |     using SafeCast for uint256;
  14 |     |     using SafeCast for int128;
  15 |     |     using SafeCast for uint128;
  16 |     | 
  17 |     |     event MintRange(
  18 |     |         address indexed recipient,
  19 |     |         int24 lower,
  20 |     |         int24 upper,
  21 |     |         uint32 indexed positionId,
  22 |     |         uint128 liquidityMinted,
  23 |     |         int128 amount0Delta,
  24 |     |         int128 amount1Delta
  25 |     |     );
  26 |     | 
  27 |     |     struct Balances {
  28 |     |         uint256 amount0;
  29 |     |         uint256 amount1;
  30 |     |     }
  31 |     | 
  32 |     |     function perform(
  33 |     |         mapping(uint256 => RangePoolStructs.RangePosition)
  34 |     |             storage positions,
  35 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
  36 |     |         PoolsharkStructs.TickMap storage tickMap,
  37 |     |         RangePoolStructs.Sample[65535] storage samples,
  38 |     |         PoolsharkStructs.GlobalState storage globalState,
  39 |     |         RangePoolStructs.MintRangeCache memory cache,
  40 |     |         RangePoolStructs.MintRangeParams memory params
  41 |     |     ) internal {
  42 |     |         // check for invalid receiver
  43 |     |         if (params.to == address(0))
  44 |     |             require(false, "CollectToZeroAddress()");
  45 |     | 
  46 |     |         // validate position ticks
  47 |     |         ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);
  48 |     | 
  49 |     |         cache.state = globalState;
  50 |     | 
  51 |     |         // id of 0 passed to create new position
  52 |     |         if (params.positionId > 0) {
  53 |     |             // require balance held
  54 |     |             cache.position = positions[params.positionId];
  55 |     |             if (cache.position.liquidity == 0)
  56 |     |                 require(false, 'PositionNotFound()');
  57 |     |             if (PositionTokens.balanceOf(cache.constants, params.to, params.positionId) == 0)
  58 |     |                 require(false, 'PositionOwnerMismatch()');
  59 |     |             // existing position
  60 |     |             cache.owner = params.to;
  61 |     |             // set bounds as defined by position
  62 |     |             params.lower = cache.position.lower;
  63 |     |             params.upper = cache.position.upper;
  64 |     |             // update existing position
  65 |     |             (
  66 |     |                 cache.position,
  67 |     |                 cache.feesAccrued0,
  68 |     |                 cache.feesAccrued1
  69 |     |             ) = RangePositions.update(
  70 |     |                     ticks,
  71 |     |                     cache.position,
  72 |     |                     cache.state,
  73 |     |                     cache.constants,
  74 |     |                     RangePoolStructs.UpdateParams(
  75 |     |                         params.lower,
  76 |     |                         params.upper,
  77 |     |                         params.positionId,
  78 |     |                         0
  79 |     |                     )
  80 |     |             );
  81 |     |         } else {
  82 |     |             // create a new position
  83 |     |             params.positionId = cache.state.positionIdNext;
  84 |     |             // increment for next position
  85 |     |             cache.state.positionIdNext += 1;
  86 |     |             // set tick bounds on position
  87 |     |             cache.position.lower = params.lower;
  88 |     |             cache.position.upper = params.upper;
  89 |     |             cache.owner = params.to;
  90 |     |         }
  91 |     |         // set cache based on bounds
  92 |     |         cache.priceLower = ConstantProduct.getPriceAtTick(cache.position.lower, cache.constants);
  93 |     |         cache.priceUpper = ConstantProduct.getPriceAtTick(cache.position.upper, cache.constants);
  94 |     | 
  95 |     |         // validate input amounts
  96 |     |         (params, cache) = RangePositions.validate(params, cache);
  97 |     | 
  98 |     |         // save changes to storage before transfer in
  99 |     |         save(positions, globalState, cache, params.positionId);
 100 |     |         cache.amount0 -= params.amount0.toInt128();
 101 |     |         cache.amount1 -= params.amount1.toInt128();
 102 |     | 
 103 |     |         emit MintRange(
 104 |     |             cache.owner,
 105 |     |             cache.position.lower,
 106 |     |             cache.position.upper,
 107 |     |             params.positionId,
 108 |     |             cache.liquidityMinted.toUint128(),
 109 |     |             -(cache.amount0 + cache.feesAccrued0), /// @dev - emit token0 balance delta
 110 |     |             -(cache.amount1 + cache.feesAccrued1)  /// @dev - emit token1 balance delta
 111 |     |         );
 112 |     | 
 113 |     |         // update position with latest fees accrued
 114 |     |         cache = RangePositions.add(
 115 |     |             ticks,
 116 |     |             samples,
 117 |     |             tickMap,
 118 |     |             cache,
 119 |     |             params
 120 |     |         );
 121 |     | 
 122 |     |         // save changes to storage before transfer out
 123 |     |         save(positions, globalState, cache, params.positionId);
 124 |     | 
 125 |     |         // transfer positive amounts back to user
 126 |     |         if (cache.feesAccrued0 > 0 || cache.feesAccrued1 > 0)
 127 |     |             Collect.range(
 128 |     |                 cache.constants,
 129 |     |                 cache.owner,
 130 |     |                 cache.feesAccrued0,
 131 |     |                 cache.feesAccrued1
 132 |     |             );
 133 |     | 
 134 |     |         // check starting balances
 135 |     |         Balances memory startBalance;
 136 |     |         if (cache.amount0 < 0) startBalance.amount0 = balance0(cache);
 137 |     |         if (cache.amount1 < 0) startBalance.amount1 = balance1(cache);
 138 |     | 
 139 |     |         // execute mint range callback
 140 |     |         ILimitPoolMintRangeCallback(msg.sender).limitPoolMintRangeCallback(
 141 |     |             cache.amount0,
 142 |     |             cache.amount1,
 143 |     |             params.callbackData
 144 |     |         );
 145 |     | 
 146 |     |         // check balance after callback
 147 |     |         if (cache.amount0 < 0)
 148 |     |             if (balance0(cache) < startBalance.amount0 + (-cache.amount0).toUint128())
 149 |     |                 require(false, 'MintInputAmount0TooLow()');
 150 |     |         if (cache.amount1 < 0)
 151 |     |             if (balance1(cache) < startBalance.amount1 + (-cache.amount1).toUint128())
 152 |     |                 require(false, 'MintInputAmount1TooLow()');
 153 |     |     }
 154 |     | 
 155 |     |     function save(
 156 |     |         mapping(uint256 => RangePoolStructs.RangePosition)
 157 |     |             storage positions,
 158 |     |         PoolsharkStructs.GlobalState storage globalState,
 159 |     |         RangePoolStructs.MintRangeCache memory cache,
 160 |     |         uint32 positionId
 161 |     |     ) internal {
 162 |     |         positions[positionId] = cache.position;
 163 |     |         globalState.pool = cache.state.pool;
 164 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
 165 |     |         globalState.positionIdNext = cache.state.positionIdNext;
 166 |     |     }
 167 |     | 
 168 |     |     function balance0(
 169 |     |         RangePoolStructs.MintRangeCache memory cache
 170 |     |     ) private view returns (uint256) {
 171 |     |         (
 172 |     |             bool success,
 173 |     |             bytes memory data
 174 |     |         ) = (cache.constants.token0)
 175 |     |                                .staticcall(
 176 |     |                                     abi.encodeWithSelector(
 177 |     |                                         IERC20Minimal.balanceOf.selector,
 178 |     |                                         address(this)
 179 |     |                                     )
 180 |     |                                 );
 181 |     |         require(success && data.length >= 32);
 182 |     |         return abi.decode(data, (uint256));
 183 |     |     }
 184 |     | 
 185 |     |     function balance1(
 186 |     |         RangePoolStructs.MintRangeCache memory cache
 187 |     |     ) private view returns (uint256) {
 188 |     |         (
 189 |     |             bool success,
 190 |     |             bytes memory data
 191 |     |         ) = (cache.constants.token1)
 192 |     |                                .staticcall(
 193 |     |                                     abi.encodeWithSelector(
 194 |     |                                         IERC20Minimal.balanceOf.selector,
 195 |     |                                         address(this)
 196 |     |                                     )
 197 |     |                                 );
 198 |     |         require(success && data.length >= 32);
 199 |     |         return abi.decode(data, (uint256));
 200 |     |     }
 201 |     | }
 202 |     | 

/root/git/limit/contracts/libraries/range/pool/SnapshotRangeCall.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../../interfaces/structs/LimitPoolStructs.sol';
  5 |     | import '../RangePositions.sol';
  6 |     | import '../../utils/Collect.sol';
  7 |     | 
  8 |     | library SnapshotRangeCall {
  9 |     |     uint8 private constant _ENTERED = 2;
 10 |     | 
 11 |     |     event Burn(
 12 |     |         address indexed recipient,
 13 |     |         int24 lower,
 14 |     |         int24 upper,
 15 |     |         uint256 indexed tokenId,
 16 |     |         uint128 liquidityBurned,
 17 |     |         uint128 amount0,
 18 |     |         uint128 amount1
 19 |     |     );
 20 |     | 
 21 |     |     function perform(
 22 |     |         mapping(uint256 => RangePoolStructs.RangePosition)
 23 |     |             storage positions,
 24 |     |         mapping(int24 => PoolsharkStructs.Tick) storage ticks,
 25 |     |         PoolsharkStructs.GlobalState memory state,
 26 |     |         PoolsharkStructs.LimitImmutables memory constants,
 27 |     |         uint32 positionId
 28 |     |     ) internal view returns (
 29 |     |         int56,
 30 |     |         uint160,
 31 |     |         uint128,
 32 |     |         uint128
 33 |     |     )
 34 |     |     {
 35 |     |         if (state.unlocked == _ENTERED)
 36 |     |             require(false, 'ReentrancyGuardReadOnlyReentrantCall()');
 37 |     |         return RangePositions.snapshot(
 38 |     |             positions,
 39 |     |             ticks,
 40 |     |             state,
 41 |     |             constants,
 42 |     |             positionId
 43 |     |         );
 44 |     |     }
 45 |     | }
 46 |     | 

/root/git/limit/contracts/libraries/utils/Bytes.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | library Bytes {
  5 |     |     bytes16 private constant alphabet = "0123456789abcdef";
  6 |     | 
  7 |     |     function from(string memory source) internal pure returns (bytes32 result) {
  8 |     |         bytes memory tempEmptyStringTest = bytes(source);
  9 |     |         if (tempEmptyStringTest.length == 0) {
 10 |     |             return 0x0;
 11 |     |         }
 12 |     | 
 13 |     |         assembly {
 14 |     |             result := mload(add(source, 32))
 15 |     |         }
 16 |     |     }
 17 |     | 
 18 |     |     function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {
 19 |     |         uint8 i = 0;
 20 |     |         while(i < 32 && _bytes32[i] != 0) {
 21 |     |             i++;
 22 |     |         }
 23 |     |         bytes memory bytesArray = new bytes(i);
 24 |     |         for (i = 0; i < 32 && _bytes32[i] != 0; i++) {
 25 |     |             bytesArray[i] = _bytes32[i];
 26 |     |         }
 27 |     |         return string(bytesArray);
 28 |     |     }
 29 |     | }

/root/git/limit/contracts/libraries/utils/Collect.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/IERC20Minimal.sol';
  5 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
  6 |     | import '../limit/LimitPositions.sol';
  7 |     | import '../utils/SafeTransfers.sol';
  8 |     | 
  9 |     | library Collect {
 10 |     |     using SafeCast for int128;
 11 |     | 
 12 |     |     event CollectRange0(
 13 |     |         uint128 amount0
 14 |     |     );
 15 |     | 
 16 |     |     event CollectRange1(
 17 |     |         uint128 amount1
 18 |     |     );
 19 |     | 
 20 |     |     function range(
 21 |     |         PoolsharkStructs.LimitImmutables memory constants,
 22 |     |         address recipient,
 23 |     |         int128 amount0,
 24 |     |         int128 amount1
 25 |     |     ) internal {
 26 |     |         /// @dev - negative balances will revert
 27 |     |         if (amount0 > 0) {
 28 |     |             EchidnaAssertions.assertPoolBalanceExceededRange(
 29 |     |                 balance(constants.token0),
 30 |     |                 amount0
 31 |     |             );
 32 |     |             /// @dev - cast to ensure user doesn't owe the pool balance
 33 |     |             SafeTransfers.transferOut(recipient, constants.token0, amount0.toUint128());
 34 |     |             emit CollectRange0(amount0.toUint128());
 35 |     |         }
 36 |     |         if (amount1 > 0) {
 37 |     |             EchidnaAssertions.assertPoolBalanceExceededRange(
 38 |     |                 balance(constants.token1),
 39 |     |                 amount1
 40 |     |             );
 41 |     |             /// @dev - cast to ensure user doesn't owe the pool balance
 42 |     |             SafeTransfers.transferOut(recipient, constants.token1, amount1.toUint128());
 43 |     |             emit CollectRange1(amount1.toUint128());
 44 |     |         }
 45 |     |     }
 46 |     | 
 47 |     |     function burnLimit(
 48 |     |         LimitPoolStructs.BurnLimitCache memory cache,
 49 |     |         PoolsharkStructs.BurnLimitParams memory params
 50 |     |     ) internal returns (
 51 |     |         LimitPoolStructs.BurnLimitCache memory
 52 |     |     )    
 53 |     |     {
 54 |     |         uint128 amount0 = params.zeroForOne ? cache.amountOut : cache.amountIn;
 55 |     |         uint128 amount1 = params.zeroForOne ? cache.amountIn : cache.amountOut;
 56 |     | 
 57 |     |         /// zero out balances and transfer out
 58 |     |         if (amount0 > 0) {
 59 |     |             cache.amountIn = 0;
 60 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
 61 |     |                 balance(cache.constants.token0),
 62 |     |                 amount0
 63 |     |             );
 64 |     |             SafeTransfers.transferOut(params.to, cache.constants.token0, amount0);
 65 |     |         }
 66 |     |         if (amount1 > 0) {
 67 |     |             cache.amountOut = 0;
 68 |     |             EchidnaAssertions.assertPoolBalanceExceeded(
 69 |     |                 balance(cache.constants.token1),
 70 |     |                 amount1
 71 |     |             );
 72 |     |             SafeTransfers.transferOut(params.to, cache.constants.token1, amount1);
 73 |     |         }
 74 |     |         return cache;
 75 |     |     }
 76 |     | 
 77 |     |     function balance(
 78 |     |         address token
 79 |     |     ) private view returns (uint256) {
 80 |     |         (
 81 |     |             bool success,
 82 |     |             bytes memory data
 83 |     |         ) = token.staticcall(
 84 |     |                                     abi.encodeWithSelector(
 85 |     |                                         IERC20Minimal.balanceOf.selector,
 86 |     |                                         address(this)
 87 |     |                                     )
 88 |     |                                 );
 89 |     |         require(success && data.length >= 32);
 90 |     |         return abi.decode(data, (uint256));
 91 |     |     }
 92 |     | }
 93 |     | 

/root/git/limit/contracts/libraries/utils/PositionTokens.sol
  1 |     | // SPDX-License-Identifier: GPLv3
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import './Bytes.sol';
  5 |     | import './String.sol';
  6 |     | import "../math/OverflowMath.sol";
  7 |     | import '../../interfaces/IPositionERC1155.sol';
  8 |     | import "../../interfaces/range/IRangePoolFactory.sol";
  9 |     | import "../../interfaces/structs/RangePoolStructs.sol";
 10 |     | import '../../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
 11 |     | 
 12 |     | /// @notice Token library for ERC-1155 calls.
 13 |     | library PositionTokens {
 14 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
 15 |     | 
 16 |     |     function balanceOf(
 17 |     |         PoolsharkStructs.LimitImmutables memory constants,
 18 |     |         address owner,
 19 |     |         uint32 positionId
 20 |     |     ) internal view returns (
 21 |     |         uint256
 22 |     |     )
 23 |     |     {
 24 |     |         return IPositionERC1155(constants.poolToken).balanceOf(owner, positionId);
 25 |     |     }
 26 |     | 
 27 |     |     function name(address token0, address token1) internal view returns (bytes32 result) {
 28 |     |         string memory nameString = string.concat(
 29 |     |             'Poolshark ',
 30 |     |             ERC20(token0).symbol(), '-',
 31 |     |             ERC20(token1).symbol()
 32 |     |         );
 33 |     | 
 34 |     |         result = Bytes.from(nameString);
 35 |     |     }
 36 |     | 
 37 |     |     function symbol(address token0, address token1) internal view returns (bytes32 result) {
 38 |     |         string memory symbolString = string.concat(
 39 |     |             'PSHARK-',
 40 |     |             ERC20(token0).symbol(), '-',
 41 |     |             ERC20(token1).symbol()
 42 |     |         );
 43 |     | 
 44 |     |         result = Bytes.from(symbolString);
 45 |     |     }
 46 |     | }

/root/git/limit/contracts/libraries/utils/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint128
 10 |     |     function toUint128(uint256 y) internal pure returns (uint128 z) {
 11 |     |         if((z = uint128(y)) != y) require(false, 'Uint256ToUint128:Overflow()');
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
 15 |     |     /// @param y The uint256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type uint128
 17 |     |     function toUint128(int128 y) internal pure returns (uint128 z) {
 18 |     |         if(y < 0) require(false, 'Int128ToUint128:Underflow()');
 19 |     |         z = uint128(y);
 20 |     |     }
 21 |     | 
 22 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 23 |     |     /// @param y The uint256 to be downcasted
 24 |     |     /// @return z The downcasted integer, now type uint160
 25 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 26 |     |         if((z = uint160(y)) != y) require(false, 'Uint256ToUint160:Overflow()');
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
 30 |     |     /// @param y The uint256 to be downcasted
 31 |     |     /// @return z The downcasted integer, now type uint160
 32 |     |     function toUint32(uint256 y) internal pure returns (uint32 z) {
 33 |     |         if((z = uint32(y)) != y) require(false, 'Uint256ToUint32:Overflow()');
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 37 |     |     /// @param y The int256 to be downcasted
 38 |     |     /// @return z The downcasted integer, now type int128
 39 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 40 |     |         if ((z = int128(y)) != y) require(false, 'Int256ToInt128:Overflow()');
 41 |     |     }
 42 |     | 
 43 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 44 |     |     /// @param y The int256 to be downcasted
 45 |     |     /// @return z The downcasted integer, now type int128
 46 |     |     function toInt128(uint128 y) internal pure returns (int128 z) {
 47 |     |         if(y > uint128(type(int128).max)) require(false, 'Uint128ToInt128:Overflow()');
 48 |     |         z = int128(y);
 49 |     |     }
 50 |     | 
 51 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 52 |     |     /// @param y The uint256 to be casted
 53 |     |     /// @return z The casted integer, now type int256
 54 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 55 |     |         if(y > uint256(type(int256).max)) require(false, 'Uint256ToInt256:Overflow()');
 56 |     |         z = int256(y);
 57 |     |     }
 58 |     | 
 59 |     |     /// @notice Cast a uint256 to a uint128, revert on overflow
 60 |     |     /// @param y The uint256 to be downcasted
 61 |     |     /// @return z The downcasted integer, now type uint128
 62 |     |     function toUint256(int256 y) internal pure returns (uint256 z) {
 63 |     |         if(y < 0) require(false, 'Int256ToUint256:Underflow()');
 64 |     |         z = uint256(y);
 65 |     |     }
 66 |     | 
 67 |     |     /// @notice Cast a uint256 to a uint16, revert on overflow
 68 |     |     /// @param y The uint256 to be downcasted
 69 |     |     /// @return z The downcasted integer, now type uint128
 70 |     |     function toUint16(uint256 y) internal pure returns (uint16 z) {
 71 |     |         if((z = uint16(y)) != y) require(false, 'Uint256ToUint16:Overflow()');
 72 |     |     }
 73 |     | }

/root/git/limit/contracts/libraries/utils/SafeTransfers.sol
   1 |     | //SPDX-License-Identifier: Unlicense
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
   5 |     | 
   6 |     | library SafeTransfers {
   7 |     |     event BalanceCheck(uint256 balance, uint256 amount);
   8 |     |     event AllowanceCheck(uint256 allowance, address owner, address spender, address msgSender);
   9 |     |     /**
  10 |     |      * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory
  11 |     |      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to
  12 |     |      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified
  13 |     |      *      it is >= amount, this should not revert in normal conditions.
  14 |     |      *
  15 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  16 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  17 |     |      */
  18 |     |     // slither-disable-next-line assembly
  19 | *   |     function transferOut(
  20 |     |         address to,
  21 |     |         address token,
  22 |     |         uint256 amount
  23 | *   |     ) internal {
  24 | *   |         bool success;
  25 | *   |         if (token == address(0)) {
  26 |     |             (success, ) = to.call{value: amount}("");
  27 |     |             if (!success) require(false, "SafeTransfers::EthTransferFailed()");
  28 |     |             return;
  29 |     |         }
  30 | *   |         if (amount == 0) return;
  31 | *   |         IERC20 erc20Token = IERC20(token);
  32 |     |         // ? We are checking the transfer, but since we are doing so in an assembly block
  33 |     |         // ? Slither does not pick up on that and results in a hit
  34 |     |         // slither-disable-next-line unchecked-transfer
  35 | *r  |         erc20Token.transfer(to, amount);
  36 |     | 
  37 | *   |         success = false;
  38 |     |         assembly {
  39 | *   |             switch returndatasize()
  40 | *   |             case 0 {
  41 |     |                 // This is a non-standard ERC-20
  42 |     |                 success := 1 // set success to true
  43 |     |             }
  44 | *   |             case 32 {
  45 |     |                 // This is a complaint ERC-20
  46 | *   |                 returndatacopy(0, 0, 32)
  47 | *   |                 success := mload(0) // Set `success = returndata` of external call
  48 |     |             }
  49 |     |             default {
  50 |     |                 // This is an excessively non-compliant ERC-20, revert.
  51 |     |                 success := 0
  52 |     |             }
  53 |     |         }
  54 | *   |         if (!success) require(false, 'TransferFailed(address(this), msg.sender');
  55 |     |     }
  56 |     | 
  57 |     |     /**
  58 |     |      * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.
  59 |     |      *      This will revert due to insufficient balance or insufficient allowance.
  60 |     |      *      This function returns the actual amount received,
  61 |     |      *      which may be less than `amount` if there is a fee attached to the transfer.
  62 |     |      *
  63 |     |      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.
  64 |     |      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca
  65 |     |      */
  66 |     |     // slither-disable-next-line assembly
  67 | *   |     function transferInto(address token, address sender, uint256 amount) internal {
  68 | *   |         if (token == address(0)) {
  69 |     |             if (msg.value < amount) require(false, 'SafeTransfers::LowEthAmountSent()');
  70 |     |             return;
  71 |     |         }
  72 | *   |         IERC20 erc20Token = IERC20(token);
  73 |     | 
  74 |     |         /// @dev - msg.sender here is the pool
  75 | *   |         emit BalanceCheck(erc20Token.balanceOf(sender), amount);
  76 | *   |         emit AllowanceCheck(erc20Token.allowance(sender, msg.sender), sender, address(this), msg.sender);
  77 | *   |         erc20Token.transferFrom(sender, msg.sender, amount);
  78 | *   |         emit BalanceCheck(erc20Token.balanceOf(sender), amount);
  79 |     | 
  80 | *   |         bool success;
  81 |     |         assembly {
  82 | *   |             switch returndatasize()
  83 | *   |             case 0 {
  84 |     |                 // This is a non-standard ERC-20
  85 |     |                 success := 1 // set success to true
  86 |     |             }
  87 | *   |             case 32 {
  88 |     |                 // This is a compliant ERC-20
  89 | *   |                 returndatacopy(0, 0, 32)
  90 | *   |                 success := mload(0) // Set `success = returndata` of external call
  91 |     |             }
  92 |     |             default {
  93 |     |                 // This is an excessively non-compliant ERC-20, revert.
  94 |     |                 success := 0
  95 |     |             }
  96 |     |         }
  97 | *   |         if (!success) require(false, 'TransferFailed(msg.sender, address(this)');
  98 |     | 
  99 | *   |         emit AllowanceCheck(erc20Token.allowance(sender, msg.sender), sender, address(this), msg.sender);
 100 |     |     }
 101 |     | }
 102 |     | 

/root/git/limit/contracts/libraries/utils/String.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | library String {
  5 |     |     bytes16 private constant alphabet = "0123456789abcdef";
  6 |     | 
  7 |     |     function from(bytes32 value) internal pure returns(string memory) {
  8 |     |         return toString(abi.encodePacked(value));
  9 |     |     }
 10 |     | 
 11 |     |     function from(address account) internal pure returns(string memory) {
 12 |     |         return toString(abi.encodePacked(account));
 13 |     |     }
 14 |     | 
 15 |     |     function from(uint256 value) internal pure returns(string memory) {
 16 |     |         unchecked {
 17 |     |             uint256 length = log10(value) + 1;
 18 |     |             string memory buffer = new string(length);
 19 |     |             uint256 ptr;
 20 |     |             /// @solidity memory-safe-assembly
 21 |     |             assembly {
 22 |     |                 ptr := add(buffer, add(32, length))
 23 |     |             }
 24 |     |             while (true) {
 25 |     |                 ptr--;
 26 |     |                 /// @solidity memory-safe-assembly
 27 |     |                 assembly {
 28 |     |                     mstore8(ptr, byte(mod(value, 10), alphabet))
 29 |     |                 }
 30 |     |                 value /= 10;
 31 |     |                 if (value == 0) break;
 32 |     |             }
 33 |     |             return buffer;
 34 |     |         }
 35 |     |     }
 36 |     | 
 37 |     |     function from(int256 value) internal pure returns (string memory) {
 38 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", from(abs(value))));
 39 |     |     }
 40 |     | 
 41 |     |     function abs(int256 n) internal pure returns (uint256) {
 42 |     |         unchecked {
 43 |     |             // must be unchecked in order to support `n = type(int256).min`
 44 |     |             return uint256(n >= 0 ? n : -n);
 45 |     |         }
 46 |     |     }
 47 |     | 
 48 |     |     function log10(uint256 value) internal pure returns (uint256) {
 49 |     |         uint256 result = 0;
 50 |     |         unchecked {
 51 |     |             if (value >= 10 ** 64) {
 52 |     |                 value /= 10 ** 64;
 53 |     |                 result += 64;
 54 |     |             }
 55 |     |             if (value >= 10 ** 32) {
 56 |     |                 value /= 10 ** 32;
 57 |     |                 result += 32;
 58 |     |             }
 59 |     |             if (value >= 10 ** 16) {
 60 |     |                 value /= 10 ** 16;
 61 |     |                 result += 16;
 62 |     |             }
 63 |     |             if (value >= 10 ** 8) {
 64 |     |                 value /= 10 ** 8;
 65 |     |                 result += 8;
 66 |     |             }
 67 |     |             if (value >= 10 ** 4) {
 68 |     |                 value /= 10 ** 4;
 69 |     |                 result += 4;
 70 |     |             }
 71 |     |             if (value >= 10 ** 2) {
 72 |     |                 value /= 10 ** 2;
 73 |     |                 result += 2;
 74 |     |             }
 75 |     |             if (value >= 10 ** 1) {
 76 |     |                 result += 1;
 77 |     |             }
 78 |     |         }
 79 |     |         return result;
 80 |     |     }
 81 |     | 
 82 |     |     function toString(bytes memory data) internal pure returns(string memory) {
 83 |     |         bytes memory str = new bytes(2 + data.length * 2);
 84 |     |         str[0] = "0";
 85 |     |         str[1] = "x";
 86 |     |         for (uint i = 0; i < data.length;) {
 87 |     |             str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];
 88 |     |             str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];
 89 |     |             unchecked {
 90 |     |                 ++i;
 91 |     |             }
 92 |     |         }
 93 |     |         return string(str);
 94 |     |     }
 95 |     | }

/root/git/limit/contracts/test/Token20.sol
  1 |     | //SPDX-License-Identifier: Unlicense
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../external/openzeppelin/contracts/token/ERC20/ERC20.sol';
  5 |     | import '../external/openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol';
  6 |     | 
  7 | *   | contract Token20 is ERC20, ERC20Burnable {
  8 |     |     uint8 _decimals;
  9 |     | 
 10 |     |     constructor(
 11 |     |         string memory tokenName,
 12 |     |         string memory tokenSymbol,
 13 |     |         uint8 decimals_
 14 |     |     ) ERC20(tokenName, tokenSymbol) {
 15 |     |         _decimals = decimals_;
 16 |     |     }
 17 |     | 
 18 | *   |     function mint(address to, uint256 amount) external {
 19 | *   |         _mint(to, amount);
 20 |     |     }
 21 |     | 
 22 |     |     function decimals() public view override returns (uint8) {
 23 |     |         return _decimals;
 24 |     |     }
 25 |     | }
 26 |     | 

/root/git/limit/contracts/test/echidna/EchidnaAssertions.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity 0.8.13;
  3 |     | 
  4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
  5 |     | import '../../libraries/math/ConstantProduct.sol';
  6 |     | 
  7 |     | library EchidnaAssertions {
  8 |     | 
  9 |     |     event LiquidityGlobalUnderflow(uint128 liquidityGlobal, uint128 amount, string location);
 10 |     |     event LiquidityUnderflow(uint128 liquidity, uint128 amount, string location);
 11 |     |     event LiquidityOverflow(uint128 liquidity, uint128 amount, string location);
 12 |     |     event LiquidityUnlock(int128 liquidity);
 13 |     |     event PoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount);
 14 |     |     event PoolBalanceExceededRange(uint256 poolBalance, int256 outputAmount);
 15 |     |     event LiquidityDelta(int128 liquidityDelta);
 16 |     |     event TickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing);
 17 |     |     event FeeGrowthInsideUnderflow(uint256 rangeFeeGrowth, uint256 positionFeeGrowthInsideLast);
 18 |     |     event FeeGrowthOutsideUnderflow(uint256 feeGrowthGlobal, uint256 tickFeeGrowthOutside);
 19 |     |     event TickSecondsAccumWithinBounds(int56 tickSecondsAccum, int56 tickTickSecondsAccum);
 20 |     |     event SecondsPerLiquidityAccumUnderflow(uint160 secondsPerLiquidityAccum, uint160 tickSecondsPerLiquidityAccum, int24 tick);
 21 |     | 
 22 |     |     function assertLiquidityGlobalUnderflows(uint128 liquidityGlobal, uint128 amount, string memory location) internal {
 23 |     |         emit LiquidityGlobalUnderflow(liquidityGlobal, amount, location);
 24 |     |         assert(liquidityGlobal >= amount);
 25 |     |     }
 26 |     | 
 27 |     |     function assertLiquidityUnderflows(uint128 liquidity, uint128 amount, string memory location) internal {
 28 |     |         emit LiquidityUnderflow(liquidity, amount, location);
 29 |     |         assert(liquidity >= amount);
 30 |     |     }
 31 |     | 
 32 |     |     function assertFeeGrowthInsideUnderflows(uint256 rangeFeeGrowth, uint256 positionFeeGrowthInsideLast) internal {
 33 |     |         emit FeeGrowthInsideUnderflow(rangeFeeGrowth, positionFeeGrowthInsideLast);
 34 |     |         assert(rangeFeeGrowth >= positionFeeGrowthInsideLast);
 35 |     |     }
 36 |     | 
 37 |     |     function assertFeeGrowthOutsideUnderflows(uint256 feeGrowthGlobal, uint256 tickFeeGrowthOutside) internal {
 38 |     |         emit FeeGrowthOutsideUnderflow(feeGrowthGlobal, tickFeeGrowthOutside);
 39 |     |         assert(feeGrowthGlobal >= tickFeeGrowthOutside);
 40 |     |     }
 41 |     | 
 42 |     |     function assertTickSecondsAccumWithinBounds(int56 tickSecondsAccum, int56 tickTickSecondsAccum) internal {
 43 |     |         emit TickSecondsAccumWithinBounds(tickSecondsAccum, tickTickSecondsAccum);
 44 |     |         assert(int256(tickSecondsAccum) - int256(tickTickSecondsAccum) <= type(int56).max);
 45 |     |         assert(int256(tickSecondsAccum) - int256(tickTickSecondsAccum) >= type(int56).min);
 46 |     |     }
 47 |     | 
 48 |     |     function assertSecondsPerLiquidityAccumUnderflows(uint160 secondsPerLiquidityAccum, uint160 tickSecondsPerLiquidityAccum, int24 tick) internal {
 49 |     |         emit SecondsPerLiquidityAccumUnderflow(secondsPerLiquidityAccum, tickSecondsPerLiquidityAccum, tick);
 50 |     |         assert(secondsPerLiquidityAccum >= tickSecondsPerLiquidityAccum);
 51 |     |     }
 52 |     | 
 53 |     |     function assertLiquidityOverflows(uint128 liquidity, uint128 amount, string memory location) internal {
 54 |     |         emit LiquidityUnderflow(liquidity, amount, location);
 55 |     |         assert(uint256(liquidity) + uint256(amount) <= uint128(type(int128).max));
 56 |     |     }
 57 |     | 
 58 |     |     function assertLiquidityAbsoluteUnderflows(uint128 liquidityAbs, uint128 amount, string memory location) internal {
 59 |     |         emit LiquidityUnderflow(liquidityAbs, amount, location);
 60 |     |         assert(liquidityAbs >= amount);
 61 |     |     }
 62 |     | 
 63 |     |     function assertPositiveLiquidityOnUnlock(int128 liquidity) internal {
 64 |     |         emit LiquidityUnlock(liquidity);
 65 |     |         assert(liquidity >= 0);
 66 |     |     }
 67 |     | 
 68 |     |     function assertPoolBalanceExceeded(uint256 poolBalance, uint256 outputAmount) internal {
 69 |     |         emit PoolBalanceExceeded(poolBalance, outputAmount);
 70 |     |         assert(poolBalance >= outputAmount);
 71 |     |     }
 72 |     | 
 73 |     |     function assertPoolBalanceExceededRange(uint256 poolBalance, int256 outputAmount) internal {
 74 |     |         emit PoolBalanceExceededRange(poolBalance, outputAmount);
 75 |     |         assert(outputAmount > 0);
 76 |     |         assert(int256(poolBalance) >= outputAmount);
 77 |     |     }
 78 |     | 
 79 |     |     function assertTickAtPriceDivisibleByTickSpacing(int24 tick, uint160 priceAt, int16 tickSpacing) internal {
 80 |     |         emit TickAtPriceDivisibleByTickSpacing(tick, priceAt, tickSpacing);
 81 |     |         if(tick % tickSpacing == 0) assert(priceAt == 0);
 82 |     |     }
 83 |     | }

/root/git/limit/contracts/test/echidna/EchidnaBurnLimitCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import '../../interfaces/IPositionERC1155.sol';
   6 |     | import '../../libraries/limit/LimitPositions.sol';
   7 |     | import '../../libraries/utils/Collect.sol';
   8 |     | import '../../libraries/utils/PositionTokens.sol';
   9 |     | 
  10 | *   | library EchidnaBurnLimitCall {
  11 |     |     event BurnLimit(
  12 |     |         address indexed to,
  13 |     |         uint32 positionId,
  14 |     |         int24 lower,
  15 |     |         int24 upper,
  16 |     |         int24 oldClaim,
  17 |     |         int24 newClaim,
  18 |     |         bool zeroForOne,
  19 |     |         uint128 liquidityBurned,
  20 |     |         uint128 tokenInClaimed,
  21 |     |         uint128 tokenOutBurned
  22 |     |     );
  23 |     | 
  24 |     |     error SimulateBurn(int24 lower, int24 upper, bool positionExists);
  25 |     | 
  26 |     |     // Echidna funcs
  27 | *   |     function getResizedTicks(
  28 |     |         mapping(uint256 => LimitPoolStructs.LimitPosition)
  29 |     |             storage positions,
  30 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  31 |     |         PoolsharkStructs.TickMap storage tickMap,
  32 |     |         PoolsharkStructs.GlobalState storage globalState,
  33 |     |         LimitPoolStructs.BurnLimitParams memory params,
  34 |     |         LimitPoolStructs.BurnLimitCache memory cache
  35 |     |     ) external {
  36 |     |         // check for invalid receiver
  37 | *   |         if (params.to == address(0))
  38 |     |             require(false, 'CollectToZeroAddress()');
  39 |     |         
  40 |     |         // initialize cache
  41 | *   |         cache.state = globalState;
  42 |     |         cache.position = positions[params.positionId];
  43 |     | 
  44 |     |         // check positionId owner
  45 |     |         if (PositionTokens.balanceOf(cache.constants, msg.sender, params.positionId) == 0)
  46 |     |             require(false, 'PositionNotFound()');
  47 |     | 
  48 |     |         // update position
  49 |     |         (
  50 |     |             params,
  51 |     |             cache
  52 |     |         ) = LimitPositions.update(
  53 |     |             ticks,
  54 |     |             tickMap,
  55 |     |             cache,
  56 |     |             params
  57 |     |         );
  58 |     | 
  59 |     |         int24 lower = cache.position.lower;
  60 |     |         int24 upper = cache.position.upper;
  61 |     |         bool positionExists = cache.position.liquidity != 0;
  62 |     | 
  63 |     |         // save position before transfer
  64 |     |         if ((params.zeroForOne ? params.claim != cache.position.upper
  65 |     |                                : params.claim != cache.position.lower)) {
  66 |     |             if (cache.position.liquidity > 0) {
  67 |     |                 if (params.zeroForOne) {
  68 |     |                     cache.position.lower = params.claim;
  69 |     |                 } else {
  70 |     |                     cache.position.upper = params.claim;
  71 |     |                 }
  72 |     |                 positions[params.positionId] = cache.position;
  73 |     |             } else {
  74 |     |                 IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);
  75 |     |                 delete positions[params.positionId];
  76 |     |             }
  77 |     |         } else {
  78 |     |             IPositionERC1155(cache.constants.poolToken).burn(msg.sender, params.positionId, 1, cache.constants);
  79 |     |             delete positions[params.positionId];
  80 |     |         }
  81 |     | 
  82 |     |         cache = Collect.burnLimit(
  83 |     |             cache,
  84 |     |             params
  85 |     |         );
  86 |     | 
  87 |     |         revert SimulateBurn(lower, upper, positionExists);
  88 |     |     }
  89 |     | 
  90 |     |     function save(
  91 |     |         LimitPoolStructs.BurnLimitCache memory cache,
  92 |     |         PoolsharkStructs.GlobalState storage globalState,
  93 |     |         bool zeroForOne
  94 |     |     ) internal {
  95 |     |         globalState.epoch = cache.state.epoch;
  96 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
  97 |     |         if (zeroForOne) {
  98 |     |             globalState.pool = cache.state.pool;
  99 |     |             globalState.pool0 = cache.state.pool0;
 100 |     |         } else {
 101 |     |             globalState.pool = cache.state.pool;
 102 |     |             globalState.pool1 = cache.state.pool1;
 103 |     |         }
 104 |     |     }
 105 |     | }
 106 |     | 

/root/git/limit/contracts/test/echidna/EchidnaMintLimitCall.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../../interfaces/structs/LimitPoolStructs.sol';
   5 |     | import '../../interfaces/callbacks/ILimitPoolCallback.sol';
   6 |     | import '../../libraries/limit/LimitPositions.sol';
   7 |     | import '../../libraries/utils/Collect.sol';
   8 |     | import '../../libraries/utils/PositionTokens.sol';
   9 |     | import './EchidnaAssertions.sol';
  10 |     | import '../../interfaces/IERC20Minimal.sol';
  11 |     | 
  12 | *   | library EchidnaMintLimitCall {
  13 |     | 
  14 |     |     error SimulateMint(int24 lower, int24 upper, bool positionCreated);
  15 |     | 
  16 |     |     event TestEvent();
  17 |     | 
  18 |     |     event MsgSender(address sender, address thisAddress);
  19 |     | 
  20 |     |     event MintLimit(
  21 |     |         address indexed to,
  22 |     |         int24 lower,
  23 |     |         int24 upper,
  24 |     |         bool zeroForOne,
  25 |     |         uint32 positionId,
  26 |     |         uint32 epochLast,
  27 |     |         uint128 amountIn,
  28 |     |         uint128 liquidityMinted
  29 |     |     );
  30 |     | 
  31 |     |     event SyncLimitPool(
  32 |     |         uint160 price,
  33 |     |         uint128 liquidity,
  34 |     |         uint32 epoch,
  35 |     |         int24 tickAtPrice,
  36 |     |         bool isPool0
  37 |     |     );
  38 |     | 
  39 |     |     function save(
  40 |     |         LimitPoolStructs.MintLimitCache memory cache,
  41 |     |         PoolsharkStructs.GlobalState storage globalState,
  42 |     |         bool zeroForOne
  43 |     |     ) internal {
  44 |     |         globalState.epoch = cache.state.epoch;
  45 |     |         globalState.liquidityGlobal = cache.state.liquidityGlobal;
  46 |     |         globalState.positionIdNext = cache.state.positionIdNext;
  47 |     |         if (zeroForOne) {
  48 |     |             globalState.pool = cache.state.pool;
  49 |     |             globalState.pool0 = cache.state.pool0;
  50 |     |         } else {
  51 |     |             globalState.pool = cache.state.pool;
  52 |     |             globalState.pool1 = cache.state.pool1;
  53 |     |         }
  54 |     |     }
  55 |     | 
  56 |     |     function balance(
  57 |     |         address token
  58 |     |     ) private view returns (uint256) {
  59 |     |         (
  60 |     |             bool success,
  61 |     |             bytes memory data
  62 |     |         ) = token.staticcall(
  63 |     |                                     abi.encodeWithSelector(
  64 |     |                                         IERC20Minimal.balanceOf.selector,
  65 |     |                                         address(this)
  66 |     |                                     )
  67 |     |                                 );
  68 |     |         require(success && data.length >= 32);
  69 |     |         return abi.decode(data, (uint256));
  70 |     |     }
  71 |     | 
  72 |     |     function balance(
  73 |     |         PoolsharkStructs.MintLimitParams memory params,
  74 |     |         LimitPoolStructs.MintLimitCache memory cache
  75 |     |     ) private view returns (uint256) {
  76 |     |         (
  77 |     |             bool success,
  78 |     |             bytes memory data
  79 |     |         ) = (params.zeroForOne ? cache.constants.token0
  80 |     |                                : cache.constants.token1)
  81 |     |                                .staticcall(
  82 |     |                                     abi.encodeWithSelector(
  83 |     |                                         IERC20Minimal.balanceOf.selector,
  84 |     |                                         address(this)
  85 |     |                                     )
  86 |     |                                 );
  87 |     |         require(success && data.length >= 32);
  88 |     |         return abi.decode(data, (uint256));
  89 |     |     }
  90 |     | 
  91 |     |         // Echidna funcs
  92 | *   |     function getResizedTicks(
  93 |     |         mapping(uint256 => LimitPoolStructs.LimitPosition)
  94 |     |             storage positions,
  95 |     |         mapping(int24 => LimitPoolStructs.Tick) storage ticks,
  96 |     |         RangePoolStructs.Sample[65535] storage samples,
  97 |     |         PoolsharkStructs.TickMap storage rangeTickMap,
  98 |     |         PoolsharkStructs.TickMap storage limitTickMap,
  99 |     |         PoolsharkStructs.GlobalState storage globalState,
 100 |     |         PoolsharkStructs.MintLimitParams memory params,
 101 |     |         LimitPoolStructs.MintLimitCache memory cache
 102 |     |     ) external {
 103 | *   |         bool positionCreated = false;
 104 |     | 
 105 | *   |         if (params.to == address(0))
 106 |     |             require(false, "CollectToZeroAddress()");
 107 |     | 
 108 | *   |         cache.state = globalState;
 109 |     | 
 110 |     |         // validate position ticks
 111 |     |         ConstantProduct.checkTicks(params.lower, params.upper, cache.constants.tickSpacing);
 112 |     | 
 113 |     |         if (params.positionId > 0) {
 114 |     |             cache.position = positions[params.positionId];
 115 |     |             if (cache.position.liquidity == 0) {
 116 |     |                 // position doesn't exist
 117 |     |                 require(false, 'PositionNotFound()');
 118 |     |             }
 119 |     |             if (PositionTokens.balanceOf(cache.constants, params.to, params.positionId) == 0)
 120 |     |                 require(false, 'PositionOwnerMismatch()');
 121 |     |         }
 122 |     | 
 123 |     |         // resize position if necessary
 124 |     |         (params, cache) = LimitPositions.resize(
 125 |     |             ticks,
 126 |     |             samples,
 127 |     |             rangeTickMap,
 128 |     |             limitTickMap,
 129 |     |             params,
 130 |     |             cache
 131 |     |         );
 132 |     | 
 133 |     |         // save state for reentrancy safety
 134 |     |         save(cache, globalState, !params.zeroForOne);
 135 |     | 
 136 |     |         // transfer out if swap output 
 137 |     |         if (cache.swapCache.output > 0) {
 138 |     |             SafeTransfers.transferOut(
 139 |     |                 params.to,
 140 |     |                 params.zeroForOne ? cache.constants.token1 
 141 |     |                                   : cache.constants.token0,
 142 |     |                 cache.swapCache.output
 143 |     |             );
 144 |     |         }
 145 |     | 
 146 |     |         emit TestEvent();
 147 |     | 
 148 |     |         // mint position if amount is left
 149 |     |         if (params.amount > 0 && cache.liquidityMinted > 0 && params.lower < params.upper) {
 150 |     |             // check if new position created
 151 |     |             if (params.positionId == 0 ||                       // new position
 152 |     |                     params.lower != cache.position.lower ||     // lower mismatch
 153 |     |                     params.upper != cache.position.upper) {     // upper mismatch
 154 |     |                 LimitPoolStructs.LimitPosition memory newPosition;
 155 |     |                 newPosition.lower = params.lower;
 156 |     |                 newPosition.upper = params.upper;
 157 |     |                 // use new position in cache
 158 |     |                 cache.position = newPosition;
 159 |     |                 params.positionId = cache.state.positionIdNext;
 160 |     |                 cache.state.positionIdNext += 1;
 161 |     |             }
 162 |     |             cache.pool = params.zeroForOne ? cache.state.pool0 : cache.state.pool1;
 163 |     |             // bump to the next tick if there is no liquidity
 164 |     |             if (cache.pool.liquidity == 0) {
 165 |     |                 /// @dev - this makes sure to have liquidity unlocked if undercutting
 166 |     |                 (cache, cache.pool) = LimitTicks.unlock(cache, cache.pool, ticks, limitTickMap, params.zeroForOne);
 167 |     |             }
 168 |     | 
 169 |     |             if (params.zeroForOne) {
 170 |     |                 uint160 priceLower = ConstantProduct.getPriceAtTick(params.lower, cache.constants);
 171 |     |                 if (priceLower <= cache.pool.price) {
 172 |     |                     // save liquidity if active
 173 |     |                     if (cache.pool.liquidity > 0) {
 174 |     |                         cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);
 175 |     |                     }
 176 |     |                     cache.pool.price = priceLower;
 177 |     |                     cache.pool.tickAtPrice = params.lower;
 178 |     |                     /// @auditor - double check liquidity is set correctly for this in insertSingle
 179 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 180 |     |                     cache.position.crossedInto = true;
 181 |     |                     // set epoch on start tick to signify position being crossed into
 182 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 183 |     |                     emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);
 184 |     |                 }
 185 |     |             } else {
 186 |     |                 uint160 priceUpper = ConstantProduct.getPriceAtTick(params.upper, cache.constants);
 187 |     |                 if (priceUpper >= cache.pool.price) {
 188 |     |                     if (cache.pool.liquidity > 0) {
 189 |     |                         cache.pool = LimitTicks.insertSingle(params, ticks, limitTickMap, cache, cache.pool, cache.constants);
 190 |     |                     }
 191 |     |                     cache.pool.price = priceUpper;
 192 |     |                     cache.pool.tickAtPrice = params.upper;
 193 |     |                     cache.pool.liquidity += uint128(cache.liquidityMinted);
 194 |     |                     cache.position.crossedInto = true;
 195 |     |                     // set epoch on start tick to signify position being crossed into
 196 |     |                     /// @auditor - this is safe assuming we have swapped at least this far on the other side
 197 |     |                     emit SyncLimitPool(cache.pool.price, cache.pool.liquidity, cache.state.epoch, cache.pool.tickAtPrice, params.zeroForOne);
 198 |     |                 }
 199 |     |             }
 200 |     |             (cache.pool, cache.position) = LimitPositions.add(
 201 |     |                 cache,
 202 |     |                 ticks,
 203 |     |                 limitTickMap,
 204 |     |                 params
 205 |     |             );
 206 |     | 
 207 |     |             positionCreated = true;
 208 |     | 
 209 |     |             // save position to storage
 210 |     |             positions[params.positionId] = cache.position;
 211 |     | 
 212 |     |             params.zeroForOne ? cache.state.pool0 = cache.pool 
 213 |     |                               : cache.state.pool1 = cache.pool;
 214 |     | 
 215 |     |             emit MintLimit(
 216 |     |                 params.to,
 217 |     |                 params.lower,
 218 |     |                 params.upper,
 219 |     |                 params.zeroForOne,
 220 |     |                 params.positionId,
 221 |     |                 cache.position.epochLast,
 222 |     |                 uint128(params.amount),
 223 |     |                 uint128(cache.liquidityMinted)
 224 |     |             );
 225 |     |         }
 226 |     |         // save lp side for safe reentrancy
 227 |     |         save(cache, globalState, params.zeroForOne);
 228 |     | 
 229 |     |         emit TestEvent();
 230 |     |         emit MsgSender(msg.sender, address(this));
 231 |     | 
 232 |     |         // check balance and execute callback
 233 |     |         uint256 balanceStart = balance(params, cache);
 234 |     |         ILimitPoolMintLimitCallback(msg.sender).limitPoolMintLimitCallback(
 235 |     |             params.zeroForOne ? -int256(params.amount + cache.swapCache.input) : int256(cache.swapCache.output),
 236 |     |             params.zeroForOne ? int256(cache.swapCache.output) : -int256(params.amount + cache.swapCache.input),
 237 |     |             params.callbackData
 238 |     |         );
 239 |     | 
 240 |     |         emit TestEvent();
 241 |     | 
 242 |     |         // check balance requirements after callback
 243 |     |         if (balance(params, cache) < balanceStart + params.amount + cache.swapCache.input)
 244 |     |             require(false, 'MintInputAmountTooLow()');
 245 |     | 
 246 |     |         emit TestEvent();
 247 |     |     
 248 |     |         revert SimulateMint(params.lower, params.upper, positionCreated);
 249 |     |     }
 250 |     | }
 251 |     | 

/root/git/limit/contracts/utils/LimitPoolManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/IPool.sol';
   5 |     | import '../interfaces/limit/ILimitPool.sol';
   6 |     | import '../interfaces/limit/ILimitPoolFactory.sol';
   7 |     | import '../interfaces/limit/ILimitPoolManager.sol';
   8 |     | import '../base/events/LimitPoolManagerEvents.sol';
   9 |     | import '../libraries/utils/SafeCast.sol';
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Defines the actions which can be executed by the factory admin.
  13 |     |  */
  14 |     | contract LimitPoolManager is ILimitPoolManager, LimitPoolManagerEvents {
  15 |     |     address public owner;
  16 |     |     address public feeTo;
  17 |     |     address public factory;
  18 |     |     uint16  public constant MAX_PROTOCOL_SWAP_FEE = 1e4; /// @dev - max protocol swap fee of 100%
  19 |     |     uint16  public constant MAX_PROTOCOL_FILL_FEE = 1e2; /// @dev - max protocol fill fee of 1%
  20 |     |     // impl name => impl address
  21 |     |     bytes32[] _poolTypeNames;
  22 |     |     mapping(uint256 => address) internal _poolImpls;
  23 |     |     mapping(uint256 => address) internal _tokenImpls;
  24 |     |     // swap fee => tick spacing
  25 |     |     mapping(uint16 => int16) internal _feeTiers;
  26 |     | 
  27 |     |     using SafeCast for uint256;
  28 |     | 
  29 |     |     error InvalidSwapFee();
  30 |     |     error InvalidTickSpacing();
  31 |     |     error InvalidPoolImplAddress();
  32 |     |     error InvalidTokenImplAddress();
  33 |     |     error InvalidImplAddresses();
  34 |     |     error FeeTierAlreadyEnabled();
  35 |     |     error PoolTypeAlreadyExists();
  36 |     |     error MaxPoolTypesCountExceeded();
  37 |     | 
  38 |     |     constructor() {
  39 |     |         owner = msg.sender;
  40 |     |         feeTo = msg.sender;
  41 |     |         emit OwnerTransfer(address(0), msg.sender);
  42 |     |         emit FeeToTransfer(address(0), msg.sender);
  43 |     | 
  44 |     |         // create initial fee tiers
  45 |     |         _feeTiers[1000] = 10;
  46 |     |         _feeTiers[3000] = 30;
  47 |     |         _feeTiers[10000] = 100;
  48 |     |         emit FeeTierEnabled(1000, 10);
  49 |     |         emit FeeTierEnabled(3000, 30);
  50 |     |         emit FeeTierEnabled(10000, 100);
  51 |     |     }
  52 |     | 
  53 |     |     /**
  54 |     |      * @dev Throws if called by any account other than the owner.
  55 |     |      */
  56 |     |     modifier onlyOwner() {
  57 |     |         _checkOwner();
  58 |     |         _;
  59 |     |     }
  60 |     | 
  61 |     |     modifier onlyOwnerOrFeeTo() {
  62 |     |         _checkFeeToAndOwner();
  63 |     |         _;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  68 |     |      * Can only be called by the current owner.
  69 |     |      */
  70 |     |     function transferOwner(address newOwner) public virtual onlyOwner {
  71 |     |         if(newOwner == address(0)) require (false, 'TransferredToZeroAddress()');
  72 |     |         _transferOwner(newOwner);
  73 |     |     }
  74 |     | 
  75 |     |     function transferFeeTo(address newFeeTo) public virtual onlyOwner {
  76 |     |         if(newFeeTo == address(0)) require (false, 'TransferredToZeroAddress()');
  77 |     |         _transferFeeTo(newFeeTo);
  78 |     |     }
  79 |     | 
  80 |     |     /**
  81 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
  82 |     |      * Internal function without access restriction.
  83 |     |      */
  84 |     |     function _transferOwner(address newOwner) internal virtual {
  85 |     |         address oldOwner = owner;
  86 |     |         owner = newOwner;
  87 |     |         emit OwnerTransfer(oldOwner, newOwner);
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Transfers fee collection to a new account (`newFeeTo`).
  92 |     |      * Internal function without access restriction.
  93 |     |      */
  94 |     |     function _transferFeeTo(address newFeeTo) internal virtual {
  95 |     |         address oldFeeTo = feeTo;
  96 |     |         feeTo = newFeeTo;
  97 |     |         emit FeeToTransfer(oldFeeTo, newFeeTo);
  98 |     |     }
  99 |     | 
 100 |     |     function enableFeeTier(
 101 |     |         uint16 swapFee,
 102 |     |         int16 tickSpacing
 103 |     |     ) external onlyOwner {
 104 |     |         if (_feeTiers[swapFee] != 0) revert FeeTierAlreadyEnabled();
 105 |     |         if (tickSpacing <= 0) revert InvalidTickSpacing();
 106 |     |         if (tickSpacing % 2 != 0) revert InvalidTickSpacing();
 107 |     |         if (swapFee == 0) revert InvalidSwapFee();
 108 |     |         if (swapFee > 10000) revert InvalidSwapFee();
 109 |     |         _feeTiers[swapFee] = tickSpacing;
 110 |     |         emit FeeTierEnabled(swapFee, tickSpacing);
 111 |     |     }
 112 |     | 
 113 |     |     function enablePoolType(
 114 |     |         address poolImpl_,
 115 |     |         address tokenImpl_,
 116 |     |         bytes32 poolTypeName_
 117 |     |     ) external onlyOwner {
 118 |     |         uint16 poolTypeId_ = _poolTypeNames.length.toUint16();
 119 |     |         if (poolTypeId_ > type(uint8).max) revert MaxPoolTypesCountExceeded();
 120 |     |         if (poolImpl_ == address(0)) revert InvalidPoolImplAddress();
 121 |     |         if (tokenImpl_ == address(0)) revert InvalidTokenImplAddress();
 122 |     |         /// @dev - prevent same addresses since factory does not support this
 123 |     |         if (poolImpl_ == tokenImpl_) revert InvalidImplAddresses();
 124 |     |         _poolImpls[poolTypeId_] = poolImpl_;
 125 |     |         _tokenImpls[poolTypeId_] = tokenImpl_;
 126 |     |         _poolTypeNames.push(poolTypeName_);
 127 |     |         emit PoolTypeEnabled(poolTypeName_, poolImpl_, tokenImpl_, poolTypeId_);
 128 |     |     }
 129 |     | 
 130 |     |     function setFactory(
 131 |     |         address factory_
 132 |     |     ) external onlyOwner {
 133 |     |         if (factory != address(0)) require (false, 'FactoryAlreadySet()');
 134 |     |         emit FactoryChanged(factory, factory_);
 135 |     |         factory = factory_;
 136 |     |     }
 137 |     | 
 138 |     |     function collectProtocolFees(
 139 |     |         address[] calldata pools
 140 |     |     ) external onlyOwnerOrFeeTo {
 141 |     |         if (pools.length == 0) require (false, 'EmptyPoolsArray()');
 142 |     |         uint128[] memory token0FeesCollected = new uint128[](pools.length);
 143 |     |         uint128[] memory token1FeesCollected = new uint128[](pools.length);
 144 |     |         // pass empty fees params
 145 |     |         FeesParams memory feesParams;
 146 |     |         for (uint i; i < pools.length;) {
 147 |     |             (
 148 |     |                 token0FeesCollected[i],
 149 |     |                 token1FeesCollected[i]
 150 |     |             ) = IPool(pools[i]).fees(feesParams);
 151 |     |             unchecked {
 152 |     |                 ++i;
 153 |     |             }
 154 |     |         }
 155 |     |         emit ProtocolFeesCollected(pools, token0FeesCollected, token1FeesCollected);
 156 |     |     }
 157 |     | 
 158 |     |     // protocol fee flags
 159 |     |     uint8 internal constant PROTOCOL_SWAP_FEE_0 = 2**0;
 160 |     |     uint8 internal constant PROTOCOL_SWAP_FEE_1 = 2**1;
 161 |     |     uint8 internal constant PROTOCOL_FILL_FEE_0 = 2**2;
 162 |     |     uint8 internal constant PROTOCOL_FILL_FEE_1 = 2**3;
 163 |     | 
 164 |     |     function modifyProtocolFees(
 165 |     |         address[] calldata pools,
 166 |     |         FeesParams[] calldata feesParams
 167 |     |     ) external onlyOwner {
 168 |     |         if (pools.length == 0) require (false, 'EmptyPoolsArray()');
 169 |     |         if (pools.length != feesParams.length) {
 170 |     |             require (false, 'MismatchedArrayLengths()');
 171 |     |         }
 172 |     |         uint128[] memory token0FeesCollected = new uint128[](pools.length);
 173 |     |         uint128[] memory token1FeesCollected = new uint128[](pools.length);
 174 |     |         int16[] memory protocolSwapFees0 = new int16[](pools.length);
 175 |     |         int16[] memory protocolSwapFees1 = new int16[](pools.length);
 176 |     |         int16[] memory protocolFillFees0 = new int16[](pools.length);
 177 |     |         int16[] memory protocolFillFees1 = new int16[](pools.length);
 178 |     |         for (uint i; i < pools.length;) {
 179 |     |             (
 180 |     |                 token0FeesCollected[i],
 181 |     |                 token1FeesCollected[i]
 182 |     |             ) = IPool(pools[i]).fees(
 183 |     |                 feesParams[i]
 184 |     |             );
 185 |     |             if ((feesParams[i].setFeesFlags & PROTOCOL_SWAP_FEE_0) > 0) {
 186 |     |                 protocolSwapFees0[i] = int16(feesParams[i].protocolSwapFee0);
 187 |     |             } else {
 188 |     |                 // no protocol fee change
 189 |     |                 protocolSwapFees0[i] = -1;
 190 |     |             }
 191 |     |             if ((feesParams[i].setFeesFlags & PROTOCOL_SWAP_FEE_1) > 0) {
 192 |     |                 protocolSwapFees1[i] = int16(feesParams[i].protocolSwapFee1);
 193 |     |             } else {
 194 |     |                 // no protocol fee change
 195 |     |                 protocolSwapFees1[i] = -1;
 196 |     |             }
 197 |     |             if ((feesParams[i].setFeesFlags & PROTOCOL_FILL_FEE_0) > 0) {
 198 |     |                 protocolFillFees0[i] = int16(feesParams[i].protocolFillFee0);
 199 |     |             } else {
 200 |     |                 // no protocol fee change
 201 |     |                 protocolFillFees0[i] = -1;
 202 |     |             }
 203 |     |             if ((feesParams[i].setFeesFlags & PROTOCOL_FILL_FEE_1) > 0) {
 204 |     |                 protocolFillFees1[i] = int16(feesParams[i].protocolFillFee1);
 205 |     |             } else {
 206 |     |                 // no protocol fee change
 207 |     |                 protocolFillFees1[i] = -1;
 208 |     |             }
 209 |     |             // else values will remain zero
 210 |     |             unchecked {
 211 |     |                 ++i;
 212 |     |             }
 213 |     |         }
 214 |     |         emit ProtocolSwapFeesModified(
 215 |     |             pools,
 216 |     |             protocolSwapFees0,
 217 |     |             protocolSwapFees1
 218 |     |         );
 219 |     |         emit ProtocolFillFeesModified(
 220 |     |             pools,
 221 |     |             protocolFillFees0,
 222 |     |             protocolFillFees1
 223 |     |         );
 224 |     |         emit ProtocolFeesCollected(
 225 |     |             pools,
 226 |     |             token0FeesCollected,
 227 |     |             token1FeesCollected
 228 |     |         );
 229 |     |     }
 230 |     | 
 231 |     |     function poolTypes(
 232 |     |         uint16 poolTypeId
 233 |     |     ) external view returns (
 234 |     |         address,
 235 |     |         address
 236 |     |     ) {
 237 |     |         return (_poolImpls[poolTypeId], _tokenImpls[poolTypeId]);
 238 |     |     }
 239 |     | 
 240 |     |     function feeTiers(
 241 |     |         uint16 swapFee
 242 |     |     ) external view returns (
 243 |     |         int16 tickSpacing
 244 |     |     ) {
 245 |     |         return _feeTiers[swapFee];
 246 |     |     }
 247 |     |     
 248 |     |     /**
 249 |     |      * @dev Throws if the sender is not the owner.
 250 |     |      */
 251 |     |     function _checkOwner() internal view {
 252 |     |         if (owner != msg.sender)
 253 |     |             require (false, 'OwnerOnly()');
 254 |     |     }
 255 |     | 
 256 |     |     /**
 257 |     |      * @dev Throws if the sender is not the feeTo.
 258 |     |      */
 259 |     |     function _checkFeeToAndOwner() internal view {
 260 |     |         if (feeTo != msg.sender && owner != msg.sender)
 261 |     |             require (false, 'OwnerOrFeeToOnly()');
 262 |     |     }
 263 |     | }

/root/git/limit/contracts/utils/PoolsharkRouter.sol
   1 |     | // SPDX-License-Identifier: GPLv3
   2 |     | pragma solidity 0.8.13;
   3 |     | 
   4 |     | import '../interfaces/IPool.sol';
   5 |     | import '../interfaces/staking/IRangeStaker.sol';
   6 |     | import '../interfaces/IWETH9.sol';
   7 |     | import '../interfaces/range/IRangePool.sol';
   8 |     | import '../interfaces/limit/ILimitPool.sol';
   9 |     | import '../interfaces/limit/ILimitPoolView.sol';
  10 |     | import '../interfaces/cover/ICoverPool.sol';
  11 |     | import '../interfaces/cover/ICoverPoolFactory.sol';
  12 |     | import '../interfaces/limit/ILimitPoolFactory.sol';
  13 |     | import '../interfaces/callbacks/ILimitPoolCallback.sol';
  14 |     | import '../interfaces/callbacks/ICoverPoolCallback.sol';
  15 |     | import '../libraries/utils/SafeTransfers.sol';
  16 |     | import '../libraries/utils/SafeCast.sol';
  17 |     | import '../interfaces/structs/PoolsharkStructs.sol';
  18 |     | import '../external/solady/LibClone.sol';
  19 |     | 
  20 | *   | contract PoolsharkRouter is
  21 |     |     PoolsharkStructs,
  22 |     |     ILimitPoolMintRangeCallback,
  23 |     |     ILimitPoolMintLimitCallback,
  24 |     |     ILimitPoolSwapCallback,
  25 |     |     ICoverPoolSwapCallback,
  26 |     |     ICoverPoolMintCallback
  27 |     | {
  28 |     |     using SafeCast for uint256;
  29 |     |     using SafeCast for int256;
  30 |     | 
  31 |     |     address public constant ethAddress = address(0);
  32 |     |     address public immutable wethAddress;
  33 |     |     address public immutable limitPoolFactory;
  34 |     |     address public immutable coverPoolFactory;
  35 |     | 
  36 |     |     event RouterContract(address router);
  37 |     | 
  38 |     |     event MintAmoutns(int256 amount0Delta, int256 amount1Delta);
  39 |     | 
  40 |     |     event RouterDeployed(
  41 |     |         address router,
  42 |     |         address limitPoolFactory,
  43 |     |         address coverPoolFactory
  44 |     |     );
  45 |     | 
  46 |     |     struct MintRangeInputData {
  47 |     |         address staker;
  48 |     |     }
  49 |     | 
  50 |     |     struct MintRangeCallbackData {
  51 |     |         address sender;
  52 |     |         address recipient;
  53 |     |         bool wrapped;
  54 |     |     }
  55 |     | 
  56 |     |     struct MintLimitCallbackData {
  57 |     |         address sender;
  58 |     |         bool wrapped;
  59 |     |     }
  60 |     | 
  61 |     |     struct MintCoverCallbackData {
  62 |     |         address sender;
  63 |     |         bool wrapped;
  64 |     |     }
  65 |     | 
  66 |     |     struct SwapCallbackData {
  67 |     |         address sender;
  68 |     |         address recipient;
  69 |     |         bool wrapped;
  70 |     |     }
  71 |     | 
  72 |     |     constructor(
  73 |     |         address limitPoolFactory_,
  74 |     |         address coverPoolFactory_,
  75 |     |         address wethAddress_
  76 |     |     ) {
  77 |     |         limitPoolFactory = limitPoolFactory_;
  78 |     |         coverPoolFactory = coverPoolFactory_;
  79 |     |         wethAddress = wethAddress_;
  80 |     |         emit RouterDeployed(
  81 |     |             address(this),
  82 |     |             limitPoolFactory,
  83 |     |             coverPoolFactory
  84 |     |         );
  85 |     |     }
  86 |     | 
  87 |     |     receive() external payable {}
  88 |     | 
  89 |     |     /// @inheritdoc ILimitPoolSwapCallback
  90 | *   |     function limitPoolSwapCallback(
  91 |     |         int256 amount0Delta,
  92 |     |         int256 amount1Delta,
  93 |     |         bytes calldata data
  94 | *   |     ) external override {
  95 | *   |         PoolsharkStructs.LimitImmutables memory constants = ILimitPoolView(msg.sender).immutables();
  96 |     | 
  97 |     |         // validate sender is a canonical limit pool
  98 | *   |         canonicalLimitPoolsOnly(constants);
  99 |     | 
 100 |     |         // decode original msg.sender
 101 | *   |         SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));
 102 |     | 
 103 |     |         // transfer from swap caller
 104 | *   |         if (amount0Delta < 0) {
 105 | *   |             if (constants.token0 == wethAddress && _data.wrapped) {
 106 |     |                 wrapEth(uint256(-amount0Delta));
 107 |     |             } else {
 108 | *   |                 SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   
 109 |     |             }
 110 |     |         }
 111 | *   |         if (amount1Delta < 0) {
 112 | *   |             if (constants.token1 == wethAddress && _data.wrapped) {
 113 |     |                 wrapEth(uint256(-amount1Delta));
 114 |     |             } else {
 115 | *   |                 SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));
 116 |     |             }
 117 |     |         }
 118 |     |         // transfer to swap caller
 119 | *   |         if (amount0Delta > 0) {
 120 | *   |             if (constants.token0 == wethAddress && _data.wrapped) {
 121 |     |                 // unwrap WETH and send to recipient
 122 |     |                 unwrapEth(_data.recipient, uint256(amount0Delta));
 123 |     |             }
 124 |     |         }
 125 | *   |         if (amount1Delta > 0) {
 126 | *   |             if (constants.token1 == wethAddress && _data.wrapped) {
 127 |     |                 // unwrap WETH and send to recipient
 128 |     |                 unwrapEth(_data.recipient, uint256(amount1Delta));
 129 |     |             }
 130 |     |         }
 131 |     |     }
 132 |     | 
 133 |     |     /// @inheritdoc ICoverPoolSwapCallback
 134 |     |     function coverPoolSwapCallback(
 135 |     |         int256 amount0Delta,
 136 |     |         int256 amount1Delta,
 137 |     |         bytes calldata data
 138 |     |     ) external override {
 139 |     |         PoolsharkStructs.CoverImmutables memory constants = ICoverPool(msg.sender).immutables();
 140 |     | 
 141 |     |         // validate sender is a canonical cover pool
 142 |     |         canonicalCoverPoolsOnly(constants);
 143 |     | 
 144 |     |         // decode original sender
 145 |     |         SwapCallbackData memory _data = abi.decode(data, (SwapCallbackData));
 146 |     |         
 147 |     |         // transfer from swap caller
 148 |     |         if (amount0Delta < 0) {
 149 |     |             if (constants.token0 == wethAddress && _data.wrapped) {
 150 |     |                 wrapEth(uint256(-amount0Delta));
 151 |     |             } else {
 152 |     |                 SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   
 153 |     |             }
 154 |     |         }
 155 |     |         if (amount1Delta < 0) {
 156 |     |             if (constants.token1 == wethAddress && _data.wrapped) {
 157 |     |                 wrapEth(uint256(-amount1Delta));
 158 |     |             } else {
 159 |     |                 SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));
 160 |     |             }
 161 |     |         }
 162 |     |         if (amount0Delta > 0) {
 163 |     |             if (constants.token0 == wethAddress && _data.wrapped) {
 164 |     |                 // unwrap WETH and send to recipient
 165 |     |                 unwrapEth(_data.recipient, uint256(amount0Delta));
 166 |     |             }
 167 |     |         }
 168 |     |         if (amount1Delta > 0) {
 169 |     |             if (constants.token1 == wethAddress && _data.wrapped) {
 170 |     |                 // unwrap WETH and send to recipient
 171 |     |                 unwrapEth(_data.recipient, uint256(amount1Delta));
 172 |     |             }
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /// @inheritdoc ILimitPoolMintRangeCallback
 177 |     |     function limitPoolMintRangeCallback(
 178 |     |         int256 amount0Delta,
 179 |     |         int256 amount1Delta,
 180 |     |         bytes calldata data
 181 |     |     ) external override {
 182 |     |         PoolsharkStructs.LimitImmutables memory constants = ILimitPoolView(msg.sender).immutables();
 183 |     | 
 184 |     |         // validate sender is a canonical limit pool
 185 |     |         canonicalLimitPoolsOnly(constants);
 186 |     | 
 187 |     |         // decode original sender
 188 |     |         MintRangeCallbackData memory _data = abi.decode(data, (MintRangeCallbackData));
 189 |     | 
 190 |     |         // transfer from swap caller
 191 |     |         if (amount0Delta < 0) {
 192 |     |             if (constants.token0 == wethAddress && _data.wrapped) {
 193 |     |                 wrapEth(uint256(-amount0Delta));
 194 |     |             } else {
 195 |     |                 SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   
 196 |     |             }
 197 |     |         }
 198 |     |         if (amount1Delta < 0) {
 199 |     |             if (constants.token1 == wethAddress && _data.wrapped) {
 200 |     |                 wrapEth(uint256(-amount1Delta));
 201 |     |             } else {
 202 |     |                 SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));
 203 |     |             }
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     /// @inheritdoc ILimitPoolMintLimitCallback
 208 | *   |     function limitPoolMintLimitCallback(
 209 |     |         int256 amount0Delta,
 210 |     |         int256 amount1Delta,
 211 |     |         bytes calldata data
 212 | *   |     ) external override {
 213 | *   |         PoolsharkStructs.LimitImmutables memory constants = ILimitPoolView(msg.sender).immutables();
 214 |     | 
 215 |     |         // validate sender is a canonical limit pool
 216 | *   |         canonicalLimitPoolsOnly(constants);
 217 |     | 
 218 |     |         // decode original sender
 219 | *   |         MintLimitCallbackData memory _data = abi.decode(data, (MintLimitCallbackData));
 220 |     |         
 221 |     |         // transfer from swap caller
 222 | *   |         if (amount0Delta < 0) {
 223 | *   |             if (constants.token0 == wethAddress && _data.wrapped) {
 224 |     |                 wrapEth(uint256(-amount0Delta));
 225 |     |             } else {
 226 | *   |                 SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   
 227 |     |             }
 228 |     |         }
 229 | *   |         if (amount1Delta < 0) {
 230 | *   |             if (constants.token1 == wethAddress && _data.wrapped) {
 231 |     |                 wrapEth(uint256(-amount1Delta));
 232 |     |             } else {
 233 | *   |                 SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));
 234 |     |             }
 235 |     |         }
 236 |     |     }
 237 |     | 
 238 |     |     /// @inheritdoc ICoverPoolMintCallback
 239 |     |     function coverPoolMintCallback(
 240 |     |         int256 amount0Delta,
 241 |     |         int256 amount1Delta,
 242 |     |         bytes calldata data
 243 |     |     ) external override {
 244 |     |         PoolsharkStructs.CoverImmutables memory constants = ICoverPool(msg.sender).immutables();
 245 |     | 
 246 |     |         // validate sender is a canonical cover pool
 247 |     |         canonicalCoverPoolsOnly(constants);
 248 |     | 
 249 |     |         // decode original sender
 250 |     |         MintCoverCallbackData memory _data = abi.decode(data, (MintCoverCallbackData));
 251 |     | 
 252 |     |         // transfer from swap caller
 253 |     |         if (amount0Delta < 0) {
 254 |     |             if (constants.token0 == wethAddress && _data.wrapped) {
 255 |     |                 wrapEth(uint256(-amount0Delta));
 256 |     |             } else {
 257 |     |                 SafeTransfers.transferInto(constants.token0, _data.sender, uint256(-amount0Delta));   
 258 |     |             }
 259 |     |         }
 260 |     |         if (amount1Delta < 0) {
 261 |     |             if (constants.token1 == wethAddress && _data.wrapped) {
 262 |     |                 wrapEth(uint256(-amount1Delta));
 263 |     |             } else {
 264 |     |                 SafeTransfers.transferInto(constants.token1, _data.sender, uint256(-amount1Delta));
 265 |     |             }
 266 |     |         }
 267 |     |     }
 268 |     | 
 269 | *   |     function multiMintLimit(
 270 |     |         address[] memory pools,
 271 |     |         MintLimitParams[] memory params
 272 |     |     ) external payable {
 273 | *   |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 274 | *   |         for (uint i = 0; i < pools.length;) {
 275 | *   |             params[i].callbackData = abi.encode(MintLimitCallbackData({
 276 | *   |                 sender: msg.sender,
 277 | *   |                 wrapped: msg.value > 0
 278 |     |             }));
 279 | *   |             ILimitPool(pools[i]).mintLimit(params[i]);
 280 |     |             unchecked {
 281 | *   |                 ++i;
 282 |     |             }
 283 |     |         }
 284 | *   |         if (address(this).balance > 0) {
 285 |     |             // return eth balance to msg.sender
 286 |     |             SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 | *   |     function multiMintRange(
 291 |     |         address[] memory pools,
 292 |     |         MintRangeParams[] memory params
 293 |     |     ) external payable {
 294 | *   |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 295 | *   |         for (uint i = 0; i < pools.length;) {
 296 | *   |             address staker;
 297 |     |             {
 298 | *   |                 MintRangeCallbackData memory callbackData = MintRangeCallbackData({
 299 | *   |                     sender: msg.sender,
 300 | *   |                     recipient: params[i].to,
 301 | *   |                     wrapped: msg.value > 0
 302 |     |                 });
 303 | *   |                 staker = abi.decode(params[i].callbackData, (MintRangeInputData)).staker; 
 304 |     |                 if (staker != address(0)) {
 305 |     |                     params[i].to = staker;
 306 |     |                 }
 307 |     |                 params[i].callbackData = abi.encode(callbackData);
 308 |     |             }
 309 |     |             IRangePool(pools[i]).mintRange(params[i]);
 310 |     |             if (staker != address(0)) {
 311 |     |                 IRangeStaker(staker).stakeRange(StakeRangeParams({
 312 |     |                     to: abi.decode(params[i].callbackData, (MintRangeCallbackData)).recipient,
 313 |     |                     pool: pools[i],
 314 |     |                     positionId: params[i].positionId
 315 |     |                 }));
 316 |     |             }
 317 |     |             // call to staking contract using positionId returned from mintRange
 318 |     |             // fees and staked position will go to params.to
 319 |     |             unchecked {
 320 |     |                 ++i;
 321 |     |             }
 322 |     |         }
 323 |     |         if (address(this).balance > 0) {
 324 |     |             // return eth balance to msg.sender
 325 |     |             SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);
 326 |     |         }
 327 |     |     }
 328 |     | 
 329 |     |     function multiMintCover(
 330 |     |         address[] memory pools,
 331 |     |         PoolsharkStructs.MintCoverParams[] memory params
 332 |     |     ) external payable {
 333 |     |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 334 |     |         for (uint i = 0; i < pools.length;) {
 335 |     |             params[i].callbackData = abi.encode(MintCoverCallbackData({
 336 |     |                 sender: msg.sender,
 337 |     |                 wrapped: msg.value > 0
 338 |     |             }));
 339 |     |             try ICoverPool(pools[i]).mint(params[i]) {
 340 |     |             } catch {}
 341 |     |             unchecked {
 342 |     |                 ++i;
 343 |     |             }
 344 |     |         }
 345 |     |         if (address(this).balance > 0) {
 346 |     |             // return eth balance to msg.sender
 347 |     |             SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);
 348 |     |         }
 349 |     |     }
 350 |     | 
 351 |     |     function multiQuote(
 352 |     |         address[] memory pools,
 353 |     |         QuoteParams[] memory params,
 354 |     |         bool sortResults 
 355 |     |     ) external view returns (
 356 |     |         QuoteResults[] memory results
 357 |     |     )
 358 |     |     {
 359 |     |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 360 |     |         if (sortResults) {
 361 |     |             // if sorting results check for matching params
 362 |     |             for (uint i = 0; i < pools.length;) {
 363 |     |                 if (i > 0) {
 364 |     |                     if (params[i].zeroForOne != params[0].zeroForOne) require (false, 'ZeroForOneParamMismatch()');
 365 |     |                     if (params[i].exactIn != params[0].exactIn) require(false, 'ExactInParamMismatch()');
 366 |     |                     /// @dev - amount and priceLimit values are allowed to be different
 367 |     |                 }
 368 |     |                 unchecked {
 369 |     |                     ++i;
 370 |     |                 }
 371 |     |             }
 372 |     |         }
 373 |     |         results = new QuoteResults[](pools.length);
 374 |     |         for (uint i = 0; i < pools.length;) {
 375 |     |             results[i].pool = pools[i];
 376 |     |             (
 377 |     |                 results[i].amountIn,
 378 |     |                 results[i].amountOut,
 379 |     |                 results[i].priceAfter
 380 |     |             ) = IPool(pools[i]).quote(params[i]);
 381 |     |             unchecked {
 382 |     |                 ++i;
 383 |     |             }
 384 |     |         }
 385 |     |         // sort if true
 386 |     |         if (sortResults) {
 387 |     |             results = sortQuoteResults(params, results);
 388 |     |         }
 389 |     |     }
 390 |     | 
 391 | *   |     function multiSwapSplit(
 392 |     |         address[] memory pools,
 393 |     |         SwapParams[] memory params 
 394 |     |     ) external payable {
 395 | *   |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 396 | *   |         for (uint i = 0; i < pools.length;) {
 397 | *   |             if (i > 0) {
 398 |     |                 if (params[i].zeroForOne != params[0].zeroForOne) require (false, 'ZeroForOneParamMismatch()');
 399 |     |                 if (params[i].exactIn != params[0].exactIn) require(false, 'ExactInParamMismatch()');
 400 |     |                 if (params[i].amount != params[0].amount) require(false, 'AmountParamMisMatch()');
 401 |     |             }
 402 |     |             unchecked {
 403 | *   |                 ++i;
 404 |     |             }
 405 |     |         }
 406 | *   |         for (uint i = 0; i < pools.length && params[0].amount > 0;) {
 407 |     |             // if msg.value > 0 we either need to wrap or unwrap the native gas token
 408 | *   |             params[i].callbackData = abi.encode(SwapCallbackData({
 409 | *   |                 sender: msg.sender,
 410 | *   |                 recipient: params[i].to,
 411 | *   |                 wrapped: msg.value > 0
 412 |     |             }));
 413 | *   |             if (msg.value > 0) {
 414 |     |                 IPool pool = IPool(pools[i]);
 415 |     |                 address tokenIn = params[i].zeroForOne ? pool.token0() : pool.token1();
 416 |     |                 address tokenOut = params[i].zeroForOne ? pool.token1() : pool.token0();
 417 |     |                 if (tokenOut == wethAddress) {
 418 |     |                     // send weth to router for unwrapping
 419 |     |                     params[i].to = address(this);
 420 |     |                 } else if (tokenIn != wethAddress) {
 421 |     |                     require (false, "NonNativeTokenPair()");
 422 |     |                 }
 423 |     |             }
 424 | *   |             (
 425 | *   |                 int256 amount0Delta,
 426 | *   |                 int256 amount1Delta
 427 | *   |             ) = IPool(pools[i]).swap(params[i]);
 428 |     |             // if there is another pool to swap against
 429 | *   |             if ((i + 1) < pools.length) {
 430 |     |                 // calculate amount left and set for next call
 431 |     |                 if (params[0].zeroForOne && params[0].exactIn) {
 432 |     |                     params[0].amount -= (-amount0Delta).toUint256().toUint128();
 433 |     |                 } else if (params[0].zeroForOne && !params[0].exactIn) {
 434 |     |                     params[0].amount -= (amount1Delta).toUint256().toUint128();
 435 |     |                 } else if (!params[0].zeroForOne && !params[0].exactIn) {
 436 |     |                     params[0].amount -= (amount0Delta).toUint256().toUint128();
 437 |     |                 } else if (!params[0].zeroForOne && params[0].exactIn) {
 438 |     |                     params[0].amount -= (-amount1Delta).toUint256().toUint128();
 439 |     |                 }
 440 |     |                 params[i+1].amount = params[0].amount;
 441 |     |             }
 442 |     |             unchecked {
 443 | *   |                 ++i;
 444 |     |             }
 445 |     |         }
 446 | *   |         if (address(this).balance > 0) {
 447 |     |             // return eth balance to msg.sender
 448 |     |             SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);
 449 |     |         }
 450 |     |     }
 451 |     | 
 452 |     |     function multiSnapshotLimit(
 453 |     |         address[] memory pools,
 454 |     |         SnapshotLimitParams[] memory params 
 455 |     |     ) external view returns(
 456 |     |         uint128[] memory amountIns,
 457 |     |         uint128[] memory amountOuts
 458 |     |     ) {
 459 |     |         amountIns = new uint128[](pools.length);
 460 |     |         amountOuts = new uint128[](pools.length);
 461 |     |         for (uint i = 0; i < pools.length;) {
 462 |     |             if (pools[i] == address(0)) require(false, "InvalidPoolAddress()");
 463 |     |             (amountIns[i], amountOuts[i]) = ILimitPoolView(pools[i]).snapshotLimit(params[i]);
 464 |     |             unchecked {
 465 |     |                 ++i;
 466 |     |             }
 467 |     |         }
 468 |     |     }
 469 |     | 
 470 |     |     function createLimitPoolAndMint(
 471 |     |         ILimitPoolFactory.LimitPoolParams memory params,
 472 |     |         MintRangeParams[] memory mintRangeParams,
 473 |     |         MintLimitParams[] memory mintLimitParams
 474 |     |     ) external payable returns (
 475 |     |         address pool,
 476 |     |         address poolToken 
 477 |     |     ) {
 478 |     |         // check if pool exists
 479 |     |         (
 480 |     |             pool,
 481 |     |             poolToken
 482 |     |         ) = ILimitPoolFactory(limitPoolFactory).getLimitPool(
 483 |     |             params.tokenIn,
 484 |     |             params.tokenOut,
 485 |     |             params.swapFee,
 486 |     |             params.poolTypeId
 487 |     |         );
 488 |     |         // create if pool doesn't exist
 489 |     |         if (pool == address(0)) {
 490 |     |             (
 491 |     |                 pool,
 492 |     |                 poolToken
 493 |     |             ) = ILimitPoolFactory(limitPoolFactory).createLimitPool(
 494 |     |                 params
 495 |     |             );
 496 |     |         }
 497 |     |         // mint initial range positions
 498 |     |         for (uint i = 0; i < mintRangeParams.length;) {
 499 |     |             address staker;
 500 |     |             {
 501 |     |                 mintRangeParams[i].positionId = 0;
 502 |     |                 MintRangeCallbackData memory callbackData = MintRangeCallbackData({
 503 |     |                     sender: msg.sender,
 504 |     |                     recipient: mintRangeParams[i].to,
 505 |     |                     wrapped: msg.value > 0
 506 |     |                 });
 507 |     |                 staker = abi.decode(mintRangeParams[i].callbackData, (MintRangeInputData)).staker; 
 508 |     |                 if (staker != address(0)) {
 509 |     |                     mintRangeParams[i].to = staker;
 510 |     |                 }
 511 |     |                 mintRangeParams[i].callbackData = abi.encode(callbackData);
 512 |     |             }
 513 |     |             try IRangePool(pool).mintRange(mintRangeParams[i]) {
 514 |     |             } catch {}
 515 |     |             if (staker != address(0)) {
 516 |     |                 IRangeStaker(staker).stakeRange(StakeRangeParams({
 517 |     |                     to: abi.decode(mintRangeParams[i].callbackData, (MintRangeCallbackData)).recipient,
 518 |     |                     pool: pool,
 519 |     |                     positionId: 0
 520 |     |                 }));
 521 |     |             }
 522 |     |             unchecked {
 523 |     |                 ++i;
 524 |     |             }
 525 |     |         }
 526 |     |         // mint initial limit positions
 527 |     |         for (uint i = 0; i < mintLimitParams.length;) {
 528 |     |             mintLimitParams[i].positionId = 0;
 529 |     |             mintLimitParams[i].callbackData = abi.encode(MintLimitCallbackData({
 530 |     |                 sender: msg.sender,
 531 |     |                 wrapped: msg.value > 0
 532 |     |             }));
 533 |     |             ILimitPool(pool).mintLimit(mintLimitParams[i]);
 534 |     |             unchecked {
 535 |     |                 ++i;
 536 |     |             }
 537 |     |         }
 538 |     |         if (address(this).balance > 0) {
 539 |     |             // send remaining eth to msg.sender
 540 |     |             SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);
 541 |     |         }
 542 |     |     }
 543 |     | 
 544 |     |     function createCoverPoolAndMint(
 545 |     |         ICoverPoolFactory.CoverPoolParams memory params,
 546 |     |         MintCoverParams[] memory mintCoverParams
 547 |     |     ) external payable returns (
 548 |     |         address pool,
 549 |     |         address poolToken 
 550 |     |     ) {
 551 |     |         // check if pool exists
 552 |     |         (
 553 |     |             pool,
 554 |     |             poolToken
 555 |     |         ) = ICoverPoolFactory(coverPoolFactory).getCoverPool(
 556 |     |             params
 557 |     |         );
 558 |     |         // create if pool doesn't exist
 559 |     |         if (pool == address(0)) {
 560 |     |             (
 561 |     |                 pool,
 562 |     |                 poolToken
 563 |     |             ) = ICoverPoolFactory(coverPoolFactory).createCoverPool(
 564 |     |                 params
 565 |     |             );
 566 |     |         }
 567 |     |         // mint initial cover positions
 568 |     |         for (uint i = 0; i < mintCoverParams.length;) {
 569 |     |             mintCoverParams[i].positionId = 0;
 570 |     |             mintCoverParams[i].callbackData = abi.encode(MintCoverCallbackData({
 571 |     |                 sender: msg.sender,
 572 |     |                 wrapped: msg.value > 0
 573 |     |             }));
 574 |     |             try ICoverPool(pool).mint(mintCoverParams[i]) {
 575 |     |             } catch {}
 576 |     |             unchecked {
 577 |     |                 ++i;
 578 |     |             }
 579 |     |         }
 580 |     |         if (address(this).balance > 0) {
 581 |     |             // send remaining eth to msg.sender
 582 |     |             SafeTransfers.transferOut(msg.sender, ethAddress, address(this).balance);
 583 |     |         }
 584 |     |     }
 585 |     | 
 586 |     |     struct SortQuoteResultsLocals {
 587 |     |         QuoteResults[] sortedResults;
 588 |     |         QuoteResults[] prunedResults;
 589 |     |         bool[] sortedFlags;
 590 |     |         uint256 emptyResults;
 591 |     |         int256 sortAmount;
 592 |     |         uint256 sortIndex;
 593 |     |         uint256 prunedIndex;
 594 |     |     }
 595 |     | 
 596 |     |     function sortQuoteResults(
 597 |     |         QuoteParams[] memory params,
 598 |     |         QuoteResults[] memory results
 599 |     |     ) internal pure returns (
 600 |     |         QuoteResults[] memory
 601 |     |     ) {
 602 |     |         SortQuoteResultsLocals memory locals;
 603 |     |         locals.sortedResults = new QuoteResults[](results.length);
 604 |     |         locals.sortedFlags = new bool[](results.length);
 605 |     |         locals.emptyResults = 0;
 606 |     |         for (uint sorted = 0; sorted < results.length;) {
 607 |     |             // if exactIn, sort by most output
 608 |     |             // if exactOut, sort by most output then least input
 609 |     |             locals.sortAmount = params[0].exactIn ? int256(0) : type(int256).max;
 610 |     |             locals.sortIndex = type(uint256).max;
 611 |     |             for (uint index = 0; index < results.length;) {
 612 |     |                 // check if result already sorted
 613 |     |                 if (!locals.sortedFlags[index]) {
 614 |     |                     if (params[0].exactIn) {
 615 |     |                         if (results[index].amountOut > 0 && results[index].amountOut >= locals.sortAmount) {
 616 |     |                             locals.sortIndex = index;
 617 |     |                             locals.sortAmount = results[index].amountOut;
 618 |     |                         }
 619 |     |                     } else {
 620 |     |                         if (results[index].amountIn > 0 && results[index].amountIn <= locals.sortAmount) {
 621 |     |                             locals.sortIndex = index;
 622 |     |                             locals.sortAmount = results[index].amountIn;
 623 |     |                         }
 624 |     |                     }
 625 |     |                 }
 626 |     |                 // continue finding nth element
 627 |     |                 unchecked {
 628 |     |                     ++index;
 629 |     |                 }
 630 |     |             }
 631 |     |             if (locals.sortIndex != type(uint256).max) {
 632 |     |                 // add the sorted result
 633 |     |                 locals.sortedResults[sorted].pool = results[locals.sortIndex].pool;
 634 |     |                 locals.sortedResults[sorted].amountIn = results[locals.sortIndex].amountIn;
 635 |     |                 locals.sortedResults[sorted].amountOut = results[locals.sortIndex].amountOut;
 636 |     |                 locals.sortedResults[sorted].priceAfter = results[locals.sortIndex].priceAfter;
 637 |     | 
 638 |     |                 // indicate this result was already sorted
 639 |     |                 locals.sortedFlags[locals.sortIndex] = true;
 640 |     |             } else {
 641 |     |                 ++locals.emptyResults;
 642 |     |             }
 643 |     |             // find next sorted element
 644 |     |             unchecked {
 645 |     |                 ++sorted;
 646 |     |             }
 647 |     |         }
 648 |     |         // if any results were empty, prune them
 649 |     |         if (locals.emptyResults > 0) {
 650 |     |             locals.prunedResults = new QuoteResults[](results.length - locals.emptyResults);
 651 |     |             locals.prunedIndex = 0;
 652 |     |             for (uint sorted = 0; sorted < results.length;) {
 653 |     |                 // empty results are omitted
 654 |     |                 if (locals.sortedResults[sorted].pool != address(0)) {
 655 |     |                     locals.prunedResults[locals.prunedIndex] = locals.sortedResults[sorted];
 656 |     |                     unchecked {
 657 |     |                         ++locals.prunedIndex;
 658 |     |                     }
 659 |     |                 }
 660 |     |                 unchecked {
 661 |     |                     ++sorted;
 662 |     |                 }
 663 |     |             }
 664 |     |         } else {
 665 |     |             locals.prunedResults = locals.sortedResults;
 666 |     |         }
 667 |     |         return locals.prunedResults;
 668 |     |     }
 669 |     | 
 670 |     |     function multiCall(
 671 |     |         address[] memory pools,
 672 |     |         SwapParams[] memory params 
 673 |     |     ) external {
 674 |     |         if (pools.length != params.length) require(false, 'InputArrayLengthsMismatch()');
 675 |     |         for (uint i = 0; i < pools.length;) {
 676 |     |             params[i].callbackData = abi.encode(SwapCallbackData({sender: msg.sender, recipient: params[i].to, wrapped: true}));
 677 |     |             ICoverPool(pools[i]).swap(params[i]);
 678 |     |             unchecked {
 679 |     |                 ++i;
 680 |     |             }
 681 |     |         }
 682 |     |     }
 683 |     | 
 684 | *   |     function canonicalLimitPoolsOnly(
 685 |     |         PoolsharkStructs.LimitImmutables memory constants
 686 | *   |     ) private view {
 687 |     |         // generate key for pool
 688 | *   |         bytes32 key = keccak256(abi.encode(
 689 | *   |             constants.poolImpl,
 690 | *   |             constants.token0,
 691 | *   |             constants.token1,
 692 | *   |             constants.swapFee
 693 |     |         ));
 694 |     | 
 695 |     |         // compute address
 696 | *   |         address predictedAddress = LibClone.predictDeterministicAddress(
 697 | *   |             constants.poolImpl,
 698 | *   |             encodeLimit(constants),
 699 | *   |             key,
 700 | *   |             limitPoolFactory
 701 |     |         );
 702 |     | 
 703 |     |         // revert on sender mismatch
 704 | *   |         if (msg.sender != predictedAddress) require(false, 'InvalidCallerAddress()');
 705 |     |     }
 706 |     | 
 707 |     |     function canonicalCoverPoolsOnly(
 708 |     |         PoolsharkStructs.CoverImmutables memory constants
 709 |     |     ) private view {
 710 |     |         // generate key for pool
 711 |     |         bytes32 key = keccak256(abi.encode(
 712 |     |             constants.token0,
 713 |     |             constants.token1,
 714 |     |             constants.source,
 715 |     |             constants.inputPool,
 716 |     |             constants.tickSpread,
 717 |     |             constants.twapLength
 718 |     |         ));
 719 |     | 
 720 |     |         // compute address
 721 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 722 |     |             constants.poolImpl,
 723 |     |             encodeCover(constants),
 724 |     |             key,
 725 |     |             coverPoolFactory
 726 |     |         );
 727 |     | 
 728 |     |         // revert on sender mismatch
 729 |     |         if (msg.sender != predictedAddress) require(false, 'InvalidCallerAddress()');
 730 |     |     }
 731 |     | 
 732 | *   |     function encodeLimit(
 733 |     |         LimitImmutables memory constants
 734 | *   |     ) private pure returns (bytes memory) {
 735 | *   |         return abi.encodePacked(
 736 | *   |                 constants.owner,
 737 | *   |                 constants.token0,
 738 | *   |                 constants.token1,
 739 | *   |                 constants.poolToken,
 740 | *   |                 constants.bounds.min,
 741 | *   |                 constants.bounds.max,
 742 | *   |                 constants.genesisTime,
 743 | *   |                 constants.tickSpacing,
 744 | *   |                 constants.swapFee
 745 |     |         );
 746 |     |     }
 747 |     | 
 748 |     |     function encodeCover(
 749 |     |         CoverImmutables memory constants
 750 |     |     ) private pure returns (bytes memory) {
 751 |     |         bytes memory value1 = abi.encodePacked(
 752 |     |             constants.owner,
 753 |     |             constants.token0,
 754 |     |             constants.token1,
 755 |     |             constants.source,
 756 |     |             constants.poolToken,
 757 |     |             constants.inputPool,
 758 |     |             constants.bounds.min,
 759 |     |             constants.bounds.max
 760 |     |         );
 761 |     |         bytes memory value2 = abi.encodePacked(
 762 |     |             constants.minAmountPerAuction,
 763 |     |             constants.genesisTime,
 764 |     |             constants.minPositionWidth,
 765 |     |             constants.tickSpread,
 766 |     |             constants.twapLength,
 767 |     |             constants.auctionLength
 768 |     |         );
 769 |     |         bytes memory value3 = abi.encodePacked(
 770 |     |             constants.sampleInterval,
 771 |     |             constants.token0Decimals,
 772 |     |             constants.token1Decimals,
 773 |     |             constants.minAmountLowerPriced
 774 |     |         );
 775 |     |         return abi.encodePacked(value1, value2, value3);
 776 |     |     }
 777 |     | 
 778 |     |     function wrapEth(uint256 amount) private {
 779 |     |         // wrap necessary amount of WETH
 780 |     |         IWETH9 weth = IWETH9(wethAddress);
 781 |     |         if (amount > address(this).balance) require(false, 'WrapEth::LowEthBalance()');
 782 |     |         weth.deposit{value: amount}();
 783 |     |         // transfer weth into pool
 784 |     |         SafeTransfers.transferOut(msg.sender, wethAddress, amount);
 785 |     |     }
 786 |     | 
 787 |     |     function unwrapEth(address recipient, uint256 amount) private {
 788 |     |         IWETH9 weth = IWETH9(wethAddress);
 789 |     |         // unwrap WETH and send to recipient
 790 |     |         weth.withdraw(amount);
 791 |     |         // send balance to recipient
 792 |     |         SafeTransfers.transferOut(recipient, ethAddress, amount);
 793 |     |     }
 794 |     | }

/root/git/limit/contracts/utils/PositionERC1155.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | 
   3 |     | pragma solidity 0.8.13;
   4 |     | 
   5 |     | import '../interfaces/IPool.sol';
   6 |     | import '../base/storage/PositionERC1155Immutables.sol';
   7 |     | import "../interfaces/IPositionERC1155.sol";
   8 |     | import '../external/solady/LibClone.sol';
   9 |     | import '../libraries/utils/String.sol';
  10 |     | import '../libraries/utils/SafeTransfers.sol';
  11 |     | import '../libraries/utils/PositionTokens.sol';
  12 |     | 
  13 | *   | contract PositionERC1155 is
  14 |     |     IPositionERC1155,
  15 |     |     PositionERC1155Immutables
  16 |     | {
  17 |     |     address public immutable factory;
  18 |     |     address public immutable original;
  19 |     | 
  20 |     |     constructor(
  21 |     |         address factory_
  22 |     |     ) {
  23 |     |         factory = factory_;
  24 |     |         original = address(this);
  25 |     |     }
  26 |     | 
  27 |     |     /// @dev token id => owner => balance
  28 |     |     mapping(uint256 => mapping(address => uint256)) private _tokenBalances;
  29 |     | 
  30 |     |     /// @dev owner => spender => approved
  31 |     |     mapping(address => mapping(address => bool)) private _spenderApprovals;
  32 |     | 
  33 |     |     /// @dev token id => total supply
  34 |     |     mapping(uint256 => uint256) private _totalSupplyById;
  35 |     | 
  36 |     |     // eth address for safe withdrawal
  37 |     |     address public constant ethAddress = address(0);
  38 |     | 
  39 |     |     modifier onlyCanonicalClones(
  40 |     |         PoolsharkStructs.LimitImmutables memory constants
  41 |     |     ) {
  42 |     |         if(!_onlyCanonicalPools(constants)) require (false, 'CanoncialPoolsOnly()');
  43 |     |         if(!_onlyCanonicalPoolTokens(constants)) require (false, 'CanoncialPoolTokensOnly()');
  44 |     |         _;
  45 |     |     }
  46 |     | 
  47 |     |     modifier checkApproval(address _from, address _spender) {
  48 |     |         if (_from != _spender)
  49 |     |             if(!_isApprovedForAll(_from, _spender)) 
  50 |     |                 require(false, string.concat('SpenderNotApproved(', String.from(_from), ', ', String.from(_spender), ')'));
  51 |     |         _;
  52 |     |     }
  53 |     | 
  54 |     |     modifier checkAddresses(address _from, address _to) {
  55 |     |         if (_from == address(0) || _to == address(0)) require(false, 'TransferFromOrToAddress0()');
  56 |     |         if (_from == _to) require(false, 'TransferToSelf()');
  57 |     |         _;
  58 |     |     }
  59 |     | 
  60 |     |     modifier checkLength(uint256 _lengthA, uint256 _lengthB) {
  61 |     |         if (_lengthA != _lengthB) require(false, string.concat('LengthMismatch(', String.from(_lengthA), ', ',  String.from(_lengthB), ')'));
  62 |     |         _;
  63 |     |     }
  64 |     | 
  65 |     |     modifier checkERC1155Support(address recipient) {
  66 |     |         if (!_verifyERC1155Support(recipient)) require(false, 'ERC1155NotSupported()');
  67 |     |         _;
  68 |     |     }
  69 |     | 
  70 |     |     function mint(
  71 |     |         address _account,
  72 |     |         uint256 _id,
  73 |     |         uint256 _amount,
  74 |     |         PoolsharkStructs.LimitImmutables memory constants
  75 |     |     ) external 
  76 |     |         onlyCanonicalClones(constants)
  77 |     |         checkERC1155Support(_account)
  78 |     |     {
  79 |     |         _mint(_account, _id, _amount);
  80 |     |     }
  81 |     | 
  82 |     |     function burn(
  83 |     |         address _account,
  84 |     |         uint256 _id,
  85 |     |         uint256 _amount,
  86 |     |         PoolsharkStructs.LimitImmutables memory constants
  87 |     |     ) external
  88 |     |         onlyCanonicalClones(constants)
  89 |     |     {
  90 |     |         _burn(_account, _id, _amount);
  91 |     |     }
  92 |     | 
  93 |     |     function setApprovalForAll(address _spender, bool _approved) public virtual override {
  94 |     |         _setApprovalForAll(msg.sender, _spender, _approved);
  95 |     |     }
  96 |     | 
  97 |     |     function safeTransferFrom(
  98 |     |         address _from,
  99 |     |         address _to,
 100 |     |         uint256 _id,
 101 |     |         uint256 _amount
 102 |     |     ) public virtual override
 103 |     |         checkAddresses(_from, _to)
 104 |     |         checkApproval(_from, msg.sender)
 105 |     |         checkERC1155Support(_to)
 106 |     |     {
 107 |     |         address _spender = msg.sender;
 108 |     |         _transfer(_from, _to, _id, _amount);
 109 |     |         emit TransferSingle(_spender, _from, _to, _id, _amount);
 110 |     |     }
 111 |     | 
 112 |     |     function safeBatchTransferFrom(
 113 |     |         address _from,
 114 |     |         address _to,
 115 |     |         uint256[] calldata _ids,
 116 |     |         uint256[] calldata _amounts
 117 |     |     ) public virtual override
 118 |     |         checkLength(_ids.length, _amounts.length)
 119 |     |         checkAddresses(_from, _to)
 120 |     |         checkApproval(_from, msg.sender)
 121 |     |         checkERC1155Support(_to)
 122 |     |     {
 123 |     |         unchecked {
 124 |     |             for (uint256 i; i < _ids.length; ++i) {
 125 |     |                 _transfer(_from, _to, _ids[i], _amounts[i]);
 126 |     |             }
 127 |     |         }
 128 |     |         emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);
 129 |     |     }
 130 |     | 
 131 |     |     function withdrawEth(
 132 |     |         address recipient,
 133 |     |         PoolsharkStructs.LimitImmutables memory constants
 134 |     |     ) external
 135 |     |         onlyCanonicalClones(constants)
 136 |     |     {
 137 |     |         SafeTransfers.transferOut(recipient, ethAddress, address(this).balance);
 138 |     |     }
 139 |     | 
 140 |     |     function isApprovedForAll(address _owner, address _spender) public view virtual override returns (bool) {
 141 |     |         return _isApprovedForAll(_owner, _spender);
 142 |     |     }
 143 |     | 
 144 |     |     function supportsInterface(bytes4 interfaceID) external pure returns (bool) {
 145 |     |       return  interfaceID == 0x01ffc9a7 ||    // ERC-165 support
 146 |     |               interfaceID == 0xd9b67a26;      // ERC-1155 support
 147 |     |     }
 148 |     | 
 149 |     |     function name() public pure virtual override returns (string memory) {
 150 |     |         return Bytes.bytes32ToString(tokenName());
 151 |     |     }
 152 |     | 
 153 |     |     function symbol() public pure virtual override returns (string memory) {
 154 |     |         return Bytes.bytes32ToString(tokenSymbol());
 155 |     |     }
 156 |     | 
 157 |     |     function totalSupply(uint256 _id) public view virtual override returns (uint256) {
 158 |     |         return _totalSupplyById[_id];
 159 |     |     }
 160 |     | 
 161 |     |     function balanceOf(address _account, uint256 _id) public view virtual override returns (uint256) {
 162 |     |         return _tokenBalances[_id][_account];
 163 |     |     }
 164 |     | 
 165 |     |     function balanceOfBatch(
 166 |     |         address[] calldata _accounts,
 167 |     |         uint256[] calldata _ids
 168 |     |     ) public view virtual override
 169 |     |         checkLength(_accounts.length, _ids.length)
 170 |     |         returns (uint256[] memory batchBalances)
 171 |     |     {
 172 |     |         batchBalances = new uint256[](_accounts.length);
 173 |     |         unchecked {
 174 |     |             for (uint256 i; i < _accounts.length; ++i) {
 175 |     |                 batchBalances[i] = balanceOf(_accounts[i], _ids[i]);
 176 |     |             }
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     function _mint(
 181 |     |         address _account,
 182 |     |         uint256 _id,
 183 |     |         uint256 _amount
 184 |     |     ) internal virtual {
 185 |     |         if (_account == address(0)) require(false, 'MintToAddress0()');
 186 |     |         _beforeTokenTransfer(address(0), _account, _id, _amount);
 187 |     |         _totalSupplyById[_id] += _amount;
 188 |     |         uint256 _accountBalance = _tokenBalances[_id][_account];
 189 |     |         unchecked {
 190 |     |             _tokenBalances[_id][_account] = _accountBalance + _amount;
 191 |     |         }
 192 |     |         emit TransferSingle(msg.sender, address(0), _account, _id, _amount);
 193 |     |     }
 194 |     | 
 195 |     |     function _burn(
 196 |     |         address _account,
 197 |     |         uint256 _id,
 198 |     |         uint256 _amount
 199 |     |     ) internal virtual {
 200 |     |         if (_account == address(0)) require(false, 'BurnFromAddress0()');
 201 |     |         uint256 _accountBalance = _tokenBalances[_id][_account];
 202 |     |         if (_accountBalance < _amount) require(false, string.concat('BurnExceedsBalance(', String.from(_account), ', ', String.from(_id), ', ', String.from(_amount), ')'));
 203 |     |         _beforeTokenTransfer(_account, address(0), _id, _amount);
 204 |     |         unchecked {
 205 |     |             _tokenBalances[_id][_account] = _accountBalance - _amount;
 206 |     |             _totalSupplyById[_id] -= _amount;
 207 |     |         }
 208 |     |         emit TransferSingle(msg.sender, _account, address(0), _id, _amount);
 209 |     |     }
 210 |     | 
 211 |     |     function _transfer(
 212 |     |         address _from,
 213 |     |         address _to,
 214 |     |         uint256 _id,
 215 |     |         uint256 _amount
 216 |     |     ) internal virtual {
 217 |     |         uint256 _fromBalance = _tokenBalances[_id][_from];
 218 |     |         if (_fromBalance < _amount) require(false, string.concat('TransferExceedsBalance(', String.from(_from), ', ', String.from(_id), ', ', String.from(_amount), ')'));
 219 |     |         _beforeTokenTransfer(_from, _to, _id, _amount);
 220 |     |         unchecked {
 221 |     |             _tokenBalances[_id][_from] = _fromBalance - _amount;
 222 |     |         }
 223 |     |         uint256 _toBalance = _tokenBalances[_id][_to];
 224 |     |         unchecked {
 225 |     |             _tokenBalances[_id][_to] = _toBalance + _amount;
 226 |     |         }
 227 |     |     }
 228 |     | 
 229 |     |     function _setApprovalForAll(
 230 |     |         address _owner,
 231 |     |         address _spender,
 232 |     |         bool _approved
 233 |     |     ) internal virtual {
 234 |     |         if (_owner == _spender) require(false, string.concat('SelfApproval(', String.from(_owner), ')'));
 235 |     |         _spenderApprovals[_owner][_spender] = _approved;
 236 |     |         emit ApprovalForAll(_owner, _spender, _approved);
 237 |     |     }
 238 |     | 
 239 |     |     function _isApprovedForAll(address _owner, address _spender) internal view virtual returns (bool) {
 240 |     |         return _owner == _spender || _spenderApprovals[_owner][_spender];
 241 |     |     }
 242 |     | 
 243 |     |     /// @notice Hook that is called before any token transfer.
 244 |     |     function _beforeTokenTransfer(
 245 |     |         address from,
 246 |     |         address to,
 247 |     |         uint256 id,
 248 |     |         uint256 amount
 249 |     |     ) internal virtual {}
 250 |     | 
 251 |     |     function _onlyCanonicalPoolTokens(
 252 |     |         PoolsharkStructs.LimitImmutables memory constants
 253 |     |     ) private view returns (bool) {
 254 |     |         // generate key for pool
 255 |     |         bytes32 key = keccak256(abi.encode(
 256 |     |             constants.poolImpl,
 257 |     |             constants.token0,
 258 |     |             constants.token1,
 259 |     |             constants.swapFee
 260 |     |         ));
 261 |     | 
 262 |     |         // compute address
 263 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 264 |     |             original,
 265 |     |             abi.encodePacked(
 266 |     |                 tokenName(),
 267 |     |                 tokenSymbol()
 268 |     |             ),
 269 |     |             key,
 270 |     |             factory
 271 |     |         );
 272 |     | 
 273 |     |         if (predictedAddress != address(this)) return false;
 274 |     | 
 275 |     |         return true;
 276 |     |     }
 277 |     | 
 278 |     |     function _onlyCanonicalPools(
 279 |     |         PoolsharkStructs.LimitImmutables memory constants
 280 |     |     ) private view returns (bool) {
 281 |     |         // generate key for pool
 282 |     |         bytes32 key = keccak256(abi.encode(
 283 |     |             constants.poolImpl,
 284 |     |             constants.token0,
 285 |     |             constants.token1,
 286 |     |             constants.swapFee
 287 |     |         ));
 288 |     | 
 289 |     |         // compute address
 290 |     |         address predictedAddress = LibClone.predictDeterministicAddress(
 291 |     |             constants.poolImpl,
 292 |     |             abi.encodePacked(
 293 |     |                 constants.owner,
 294 |     |                 constants.token0,
 295 |     |                 constants.token1,
 296 |     |                 constants.poolToken,
 297 |     |                 constants.bounds.min,
 298 |     |                 constants.bounds.max,
 299 |     |                 constants.genesisTime,
 300 |     |                 constants.tickSpacing,
 301 |     |                 constants.swapFee
 302 |     |             ),
 303 |     |             key,
 304 |     |             factory
 305 |     |         );
 306 |     | 
 307 |     |         if (predictedAddress != msg.sender) return false;
 308 |     | 
 309 |     |         return true;
 310 |     |     }
 311 |     | 
 312 |     |     /// @notice Return if the `_target` contract supports ERC-1155 interface
 313 |     |     /// @param _target The address of the contract
 314 |     |     /// @return supported Whether the contract is supported (true) or not (false)
 315 |     |     function _verifyERC1155Support(address _target) private view returns (bool supported) {
 316 |     |         if (_target.code.length == 0) return true;
 317 |     |         bytes memory encodedParams = abi.encodeWithSelector(
 318 |     |             IERC165.supportsInterface.selector,
 319 |     |             bytes4(0xd9b67a26) // ERC-1155 support
 320 |     |         );
 321 |     |         (bool success, bytes memory result) = _target.staticcall{gas: 30_000}(encodedParams);
 322 |     |         if (result.length < 32) return false;
 323 |     |         return success && abi.decode(result, (bool));
 324 |     |     }
 325 |     | }

